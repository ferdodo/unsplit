(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from3, except, desc) => {
    if (from3 && typeof from3 === "object" || typeof from3 === "function") {
      for (let key of __getOwnPropNames(from3))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc(from3, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // ../core/node_modules/pixi.js/lib/extensions/Extensions.mjs
  var ExtensionType, normalizeExtension, normalizeExtensionPriority, extensions;
  var init_Extensions = __esm({
    "../core/node_modules/pixi.js/lib/extensions/Extensions.mjs"() {
      "use strict";
      ExtensionType = /* @__PURE__ */ ((ExtensionType2) => {
        ExtensionType2["Application"] = "application";
        ExtensionType2["WebGLPipes"] = "webgl-pipes";
        ExtensionType2["WebGLPipesAdaptor"] = "webgl-pipes-adaptor";
        ExtensionType2["WebGLSystem"] = "webgl-system";
        ExtensionType2["WebGPUPipes"] = "webgpu-pipes";
        ExtensionType2["WebGPUPipesAdaptor"] = "webgpu-pipes-adaptor";
        ExtensionType2["WebGPUSystem"] = "webgpu-system";
        ExtensionType2["CanvasSystem"] = "canvas-system";
        ExtensionType2["CanvasPipesAdaptor"] = "canvas-pipes-adaptor";
        ExtensionType2["CanvasPipes"] = "canvas-pipes";
        ExtensionType2["Asset"] = "asset";
        ExtensionType2["LoadParser"] = "load-parser";
        ExtensionType2["ResolveParser"] = "resolve-parser";
        ExtensionType2["CacheParser"] = "cache-parser";
        ExtensionType2["DetectionParser"] = "detection-parser";
        ExtensionType2["MaskEffect"] = "mask-effect";
        ExtensionType2["BlendMode"] = "blend-mode";
        ExtensionType2["TextureSource"] = "texture-source";
        ExtensionType2["Environment"] = "environment";
        return ExtensionType2;
      })(ExtensionType || {});
      normalizeExtension = (ext) => {
        if (typeof ext === "function" || typeof ext === "object" && ext.extension) {
          if (!ext.extension) {
            throw new Error("Extension class must have an extension object");
          }
          const metadata = typeof ext.extension !== "object" ? { type: ext.extension } : ext.extension;
          ext = { ...metadata, ref: ext };
        }
        if (typeof ext === "object") {
          ext = { ...ext };
        } else {
          throw new Error("Invalid extension type");
        }
        if (typeof ext.type === "string") {
          ext.type = [ext.type];
        }
        return ext;
      };
      normalizeExtensionPriority = (ext, defaultPriority) => normalizeExtension(ext).priority ?? defaultPriority;
      extensions = {
        /** @ignore */
        _addHandlers: {},
        /** @ignore */
        _removeHandlers: {},
        /** @ignore */
        _queue: {},
        /**
         * Remove extensions from PixiJS.
         * @param extensions - Extensions to be removed.
         * @returns {extensions} For chaining.
         */
        remove(...extensions2) {
          extensions2.map(normalizeExtension).forEach((ext) => {
            ext.type.forEach((type) => this._removeHandlers[type]?.(ext));
          });
          return this;
        },
        /**
         * Register new extensions with PixiJS.
         * @param extensions - The spread of extensions to add to PixiJS.
         * @returns {extensions} For chaining.
         */
        add(...extensions2) {
          extensions2.map(normalizeExtension).forEach((ext) => {
            ext.type.forEach((type) => {
              const handlers = this._addHandlers;
              const queue = this._queue;
              if (!handlers[type]) {
                queue[type] = queue[type] || [];
                queue[type]?.push(ext);
              } else {
                handlers[type]?.(ext);
              }
            });
          });
          return this;
        },
        /**
         * Internal method to handle extensions by name.
         * @param type - The extension type.
         * @param onAdd  - Function handler when extensions are added/registered {@link StrictExtensionFormat}.
         * @param onRemove  - Function handler when extensions are removed/unregistered {@link StrictExtensionFormat}.
         * @returns {extensions} For chaining.
         */
        handle(type, onAdd, onRemove) {
          const addHandlers = this._addHandlers;
          const removeHandlers = this._removeHandlers;
          if (addHandlers[type] || removeHandlers[type]) {
            throw new Error(`Extension type ${type} already has a handler`);
          }
          addHandlers[type] = onAdd;
          removeHandlers[type] = onRemove;
          const queue = this._queue;
          if (queue[type]) {
            queue[type]?.forEach((ext) => onAdd(ext));
            delete queue[type];
          }
          return this;
        },
        /**
         * Handle a type, but using a map by `name` property.
         * @param type - Type of extension to handle.
         * @param map - The object map of named extensions.
         * @returns {extensions} For chaining.
         */
        handleByMap(type, map3) {
          return this.handle(
            type,
            (extension) => {
              if (extension.name) {
                map3[extension.name] = extension.ref;
              }
            },
            (extension) => {
              if (extension.name) {
                delete map3[extension.name];
              }
            }
          );
        },
        /**
         * Handle a type, but using a list of extensions with a `name` property.
         * @param type - Type of extension to handle.
         * @param map - The array of named extensions.
         * @param defaultPriority - Fallback priority if none is defined.
         * @returns {extensions} For chaining.
         */
        handleByNamedList(type, map3, defaultPriority = -1) {
          return this.handle(
            type,
            (extension) => {
              const index = map3.findIndex((item) => item.name === extension.name);
              if (index >= 0)
                return;
              map3.push({ name: extension.name, value: extension.ref });
              map3.sort((a2, b2) => normalizeExtensionPriority(b2.value, defaultPriority) - normalizeExtensionPriority(a2.value, defaultPriority));
            },
            (extension) => {
              const index = map3.findIndex((item) => item.name === extension.name);
              if (index !== -1) {
                map3.splice(index, 1);
              }
            }
          );
        },
        /**
         * Handle a type, but using a list of extensions.
         * @param type - Type of extension to handle.
         * @param list - The list of extensions.
         * @param defaultPriority - The default priority to use if none is specified.
         * @returns {extensions} For chaining.
         */
        handleByList(type, list, defaultPriority = -1) {
          return this.handle(
            type,
            (extension) => {
              if (list.includes(extension.ref)) {
                return;
              }
              list.push(extension.ref);
              list.sort((a2, b2) => normalizeExtensionPriority(b2, defaultPriority) - normalizeExtensionPriority(a2, defaultPriority));
            },
            (extension) => {
              const index = list.indexOf(extension.ref);
              if (index !== -1) {
                list.splice(index, 1);
              }
            }
          );
        }
      };
    }
  });

  // ../core/node_modules/eventemitter3/index.js
  var require_eventemitter3 = __commonJS({
    "../core/node_modules/eventemitter3/index.js"(exports, module) {
      "use strict";
      var has = Object.prototype.hasOwnProperty;
      var prefix = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events().__proto__)
          prefix = false;
      }
      function EE(fn, context4, once) {
        this.fn = fn;
        this.context = context4;
        this.once = once || false;
      }
      function addListener(emitter, event, fn, context4, once) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn, context4 || emitter, once), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt])
          emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn)
          emitter._events[evt].push(listener);
        else
          emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0)
          emitter._events = new Events();
        else
          delete emitter._events[evt];
      }
      function EventEmitter2() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter2.prototype.eventNames = function eventNames() {
        var names = [], events, name;
        if (this._eventsCount === 0)
          return names;
        for (name in events = this._events) {
          if (has.call(events, name))
            names.push(prefix ? name.slice(1) : name);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events));
        }
        return names;
      };
      EventEmitter2.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers)
          return [];
        if (handlers.fn)
          return [handlers.fn];
        for (var i2 = 0, l2 = handlers.length, ee = new Array(l2); i2 < l2; i2++) {
          ee[i2] = handlers[i2].fn;
        }
        return ee;
      };
      EventEmitter2.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners)
          return 0;
        if (listeners.fn)
          return 1;
        return listeners.length;
      };
      EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return false;
        var listeners = this._events[evt], len = arguments.length, args, i2;
        if (listeners.fn) {
          if (listeners.once)
            this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }
          for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
            args[i2 - 1] = arguments[i2];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length = listeners.length, j2;
          for (i2 = 0; i2 < length; i2++) {
            if (listeners[i2].once)
              this.removeListener(event, listeners[i2].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i2].fn.call(listeners[i2].context);
                break;
              case 2:
                listeners[i2].fn.call(listeners[i2].context, a1);
                break;
              case 3:
                listeners[i2].fn.call(listeners[i2].context, a1, a2);
                break;
              case 4:
                listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
                break;
              default:
                if (!args)
                  for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                    args[j2 - 1] = arguments[j2];
                  }
                listeners[i2].fn.apply(listeners[i2].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter2.prototype.on = function on(event, fn, context4) {
        return addListener(this, event, fn, context4, false);
      };
      EventEmitter2.prototype.once = function once(event, fn, context4) {
        return addListener(this, event, fn, context4, true);
      };
      EventEmitter2.prototype.removeListener = function removeListener(event, fn, context4, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn && (!once || listeners.once) && (!context4 || listeners.context === context4)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i2 = 0, events = [], length = listeners.length; i2 < length; i2++) {
            if (listeners[i2].fn !== fn || once && !listeners[i2].once || context4 && listeners[i2].context !== context4) {
              events.push(listeners[i2]);
            }
          }
          if (events.length)
            this._events[evt] = events.length === 1 ? events[0] : events;
          else
            clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt])
            clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
      EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
      EventEmitter2.prefixed = prefix;
      EventEmitter2.EventEmitter = EventEmitter2;
      if ("undefined" !== typeof module) {
        module.exports = EventEmitter2;
      }
    }
  });

  // ../core/node_modules/eventemitter3/index.mjs
  var import_index, eventemitter3_default;
  var init_eventemitter3 = __esm({
    "../core/node_modules/eventemitter3/index.mjs"() {
      import_index = __toESM(require_eventemitter3(), 1);
      eventemitter3_default = import_index.default;
    }
  });

  // ../core/node_modules/@pixi/colord/index.mjs
  var r, t, n, e, u, a, o, i, s, h, b, g, d, f, c, l, p, v, m, y, N, x, M, H, $, j, w, S, k;
  var init_colord = __esm({
    "../core/node_modules/@pixi/colord/index.mjs"() {
      r = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) };
      t = function(r2) {
        return "string" == typeof r2 ? r2.length > 0 : "number" == typeof r2;
      };
      n = function(r2, t2, n2) {
        return void 0 === t2 && (t2 = 0), void 0 === n2 && (n2 = Math.pow(10, t2)), Math.round(n2 * r2) / n2 + 0;
      };
      e = function(r2, t2, n2) {
        return void 0 === t2 && (t2 = 0), void 0 === n2 && (n2 = 1), r2 > n2 ? n2 : r2 > t2 ? r2 : t2;
      };
      u = function(r2) {
        return (r2 = isFinite(r2) ? r2 % 360 : 0) > 0 ? r2 : r2 + 360;
      };
      a = function(r2) {
        return { r: e(r2.r, 0, 255), g: e(r2.g, 0, 255), b: e(r2.b, 0, 255), a: e(r2.a) };
      };
      o = function(r2) {
        return { r: n(r2.r), g: n(r2.g), b: n(r2.b), a: n(r2.a, 3) };
      };
      i = /^#([0-9a-f]{3,8})$/i;
      s = function(r2) {
        var t2 = r2.toString(16);
        return t2.length < 2 ? "0" + t2 : t2;
      };
      h = function(r2) {
        var t2 = r2.r, n2 = r2.g, e2 = r2.b, u2 = r2.a, a2 = Math.max(t2, n2, e2), o2 = a2 - Math.min(t2, n2, e2), i2 = o2 ? a2 === t2 ? (n2 - e2) / o2 : a2 === n2 ? 2 + (e2 - t2) / o2 : 4 + (t2 - n2) / o2 : 0;
        return { h: 60 * (i2 < 0 ? i2 + 6 : i2), s: a2 ? o2 / a2 * 100 : 0, v: a2 / 255 * 100, a: u2 };
      };
      b = function(r2) {
        var t2 = r2.h, n2 = r2.s, e2 = r2.v, u2 = r2.a;
        t2 = t2 / 360 * 6, n2 /= 100, e2 /= 100;
        var a2 = Math.floor(t2), o2 = e2 * (1 - n2), i2 = e2 * (1 - (t2 - a2) * n2), s2 = e2 * (1 - (1 - t2 + a2) * n2), h2 = a2 % 6;
        return { r: 255 * [e2, i2, o2, o2, s2, e2][h2], g: 255 * [s2, e2, e2, i2, o2, o2][h2], b: 255 * [o2, o2, s2, e2, e2, i2][h2], a: u2 };
      };
      g = function(r2) {
        return { h: u(r2.h), s: e(r2.s, 0, 100), l: e(r2.l, 0, 100), a: e(r2.a) };
      };
      d = function(r2) {
        return { h: n(r2.h), s: n(r2.s), l: n(r2.l), a: n(r2.a, 3) };
      };
      f = function(r2) {
        return b((n2 = (t2 = r2).s, { h: t2.h, s: (n2 *= ((e2 = t2.l) < 50 ? e2 : 100 - e2) / 100) > 0 ? 2 * n2 / (e2 + n2) * 100 : 0, v: e2 + n2, a: t2.a }));
        var t2, n2, e2;
      };
      c = function(r2) {
        return { h: (t2 = h(r2)).h, s: (u2 = (200 - (n2 = t2.s)) * (e2 = t2.v) / 100) > 0 && u2 < 200 ? n2 * e2 / 100 / (u2 <= 100 ? u2 : 200 - u2) * 100 : 0, l: u2 / 2, a: t2.a };
        var t2, n2, e2, u2;
      };
      l = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
      p = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
      v = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
      m = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
      y = { string: [[function(r2) {
        var t2 = i.exec(r2);
        return t2 ? (r2 = t2[1]).length <= 4 ? { r: parseInt(r2[0] + r2[0], 16), g: parseInt(r2[1] + r2[1], 16), b: parseInt(r2[2] + r2[2], 16), a: 4 === r2.length ? n(parseInt(r2[3] + r2[3], 16) / 255, 2) : 1 } : 6 === r2.length || 8 === r2.length ? { r: parseInt(r2.substr(0, 2), 16), g: parseInt(r2.substr(2, 2), 16), b: parseInt(r2.substr(4, 2), 16), a: 8 === r2.length ? n(parseInt(r2.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
      }, "hex"], [function(r2) {
        var t2 = v.exec(r2) || m.exec(r2);
        return t2 ? t2[2] !== t2[4] || t2[4] !== t2[6] ? null : a({ r: Number(t2[1]) / (t2[2] ? 100 / 255 : 1), g: Number(t2[3]) / (t2[4] ? 100 / 255 : 1), b: Number(t2[5]) / (t2[6] ? 100 / 255 : 1), a: void 0 === t2[7] ? 1 : Number(t2[7]) / (t2[8] ? 100 : 1) }) : null;
      }, "rgb"], [function(t2) {
        var n2 = l.exec(t2) || p.exec(t2);
        if (!n2)
          return null;
        var e2, u2, a2 = g({ h: (e2 = n2[1], u2 = n2[2], void 0 === u2 && (u2 = "deg"), Number(e2) * (r[u2] || 1)), s: Number(n2[3]), l: Number(n2[4]), a: void 0 === n2[5] ? 1 : Number(n2[5]) / (n2[6] ? 100 : 1) });
        return f(a2);
      }, "hsl"]], object: [[function(r2) {
        var n2 = r2.r, e2 = r2.g, u2 = r2.b, o2 = r2.a, i2 = void 0 === o2 ? 1 : o2;
        return t(n2) && t(e2) && t(u2) ? a({ r: Number(n2), g: Number(e2), b: Number(u2), a: Number(i2) }) : null;
      }, "rgb"], [function(r2) {
        var n2 = r2.h, e2 = r2.s, u2 = r2.l, a2 = r2.a, o2 = void 0 === a2 ? 1 : a2;
        if (!t(n2) || !t(e2) || !t(u2))
          return null;
        var i2 = g({ h: Number(n2), s: Number(e2), l: Number(u2), a: Number(o2) });
        return f(i2);
      }, "hsl"], [function(r2) {
        var n2 = r2.h, a2 = r2.s, o2 = r2.v, i2 = r2.a, s2 = void 0 === i2 ? 1 : i2;
        if (!t(n2) || !t(a2) || !t(o2))
          return null;
        var h2 = function(r3) {
          return { h: u(r3.h), s: e(r3.s, 0, 100), v: e(r3.v, 0, 100), a: e(r3.a) };
        }({ h: Number(n2), s: Number(a2), v: Number(o2), a: Number(s2) });
        return b(h2);
      }, "hsv"]] };
      N = function(r2, t2) {
        for (var n2 = 0; n2 < t2.length; n2++) {
          var e2 = t2[n2][0](r2);
          if (e2)
            return [e2, t2[n2][1]];
        }
        return [null, void 0];
      };
      x = function(r2) {
        return "string" == typeof r2 ? N(r2.trim(), y.string) : "object" == typeof r2 && null !== r2 ? N(r2, y.object) : [null, void 0];
      };
      M = function(r2, t2) {
        var n2 = c(r2);
        return { h: n2.h, s: e(n2.s + 100 * t2, 0, 100), l: n2.l, a: n2.a };
      };
      H = function(r2) {
        return (299 * r2.r + 587 * r2.g + 114 * r2.b) / 1e3 / 255;
      };
      $ = function(r2, t2) {
        var n2 = c(r2);
        return { h: n2.h, s: n2.s, l: e(n2.l + 100 * t2, 0, 100), a: n2.a };
      };
      j = function() {
        function r2(r3) {
          this.parsed = x(r3)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
        }
        return r2.prototype.isValid = function() {
          return null !== this.parsed;
        }, r2.prototype.brightness = function() {
          return n(H(this.rgba), 2);
        }, r2.prototype.isDark = function() {
          return H(this.rgba) < 0.5;
        }, r2.prototype.isLight = function() {
          return H(this.rgba) >= 0.5;
        }, r2.prototype.toHex = function() {
          return r3 = o(this.rgba), t2 = r3.r, e2 = r3.g, u2 = r3.b, i2 = (a2 = r3.a) < 1 ? s(n(255 * a2)) : "", "#" + s(t2) + s(e2) + s(u2) + i2;
          var r3, t2, e2, u2, a2, i2;
        }, r2.prototype.toRgb = function() {
          return o(this.rgba);
        }, r2.prototype.toRgbString = function() {
          return r3 = o(this.rgba), t2 = r3.r, n2 = r3.g, e2 = r3.b, (u2 = r3.a) < 1 ? "rgba(" + t2 + ", " + n2 + ", " + e2 + ", " + u2 + ")" : "rgb(" + t2 + ", " + n2 + ", " + e2 + ")";
          var r3, t2, n2, e2, u2;
        }, r2.prototype.toHsl = function() {
          return d(c(this.rgba));
        }, r2.prototype.toHslString = function() {
          return r3 = d(c(this.rgba)), t2 = r3.h, n2 = r3.s, e2 = r3.l, (u2 = r3.a) < 1 ? "hsla(" + t2 + ", " + n2 + "%, " + e2 + "%, " + u2 + ")" : "hsl(" + t2 + ", " + n2 + "%, " + e2 + "%)";
          var r3, t2, n2, e2, u2;
        }, r2.prototype.toHsv = function() {
          return r3 = h(this.rgba), { h: n(r3.h), s: n(r3.s), v: n(r3.v), a: n(r3.a, 3) };
          var r3;
        }, r2.prototype.invert = function() {
          return w({ r: 255 - (r3 = this.rgba).r, g: 255 - r3.g, b: 255 - r3.b, a: r3.a });
          var r3;
        }, r2.prototype.saturate = function(r3) {
          return void 0 === r3 && (r3 = 0.1), w(M(this.rgba, r3));
        }, r2.prototype.desaturate = function(r3) {
          return void 0 === r3 && (r3 = 0.1), w(M(this.rgba, -r3));
        }, r2.prototype.grayscale = function() {
          return w(M(this.rgba, -1));
        }, r2.prototype.lighten = function(r3) {
          return void 0 === r3 && (r3 = 0.1), w($(this.rgba, r3));
        }, r2.prototype.darken = function(r3) {
          return void 0 === r3 && (r3 = 0.1), w($(this.rgba, -r3));
        }, r2.prototype.rotate = function(r3) {
          return void 0 === r3 && (r3 = 15), this.hue(this.hue() + r3);
        }, r2.prototype.alpha = function(r3) {
          return "number" == typeof r3 ? w({ r: (t2 = this.rgba).r, g: t2.g, b: t2.b, a: r3 }) : n(this.rgba.a, 3);
          var t2;
        }, r2.prototype.hue = function(r3) {
          var t2 = c(this.rgba);
          return "number" == typeof r3 ? w({ h: r3, s: t2.s, l: t2.l, a: t2.a }) : n(t2.h);
        }, r2.prototype.isEqual = function(r3) {
          return this.toHex() === w(r3).toHex();
        }, r2;
      }();
      w = function(r2) {
        return r2 instanceof j ? r2 : new j(r2);
      };
      S = [];
      k = function(r2) {
        r2.forEach(function(r3) {
          S.indexOf(r3) < 0 && (r3(j, y), S.push(r3));
        });
      };
    }
  });

  // ../core/node_modules/@pixi/colord/plugins/names.mjs
  function names_default(e2, f2) {
    var a2 = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" }, r2 = {};
    for (var d2 in a2)
      r2[a2[d2]] = d2;
    var l2 = {};
    e2.prototype.toName = function(f3) {
      if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b))
        return "transparent";
      var d3, i2, n2 = r2[this.toHex()];
      if (n2)
        return n2;
      if (null == f3 ? void 0 : f3.closest) {
        var o2 = this.toRgb(), t2 = 1 / 0, b2 = "black";
        if (!l2.length)
          for (var c2 in a2)
            l2[c2] = new e2(a2[c2]).toRgb();
        for (var g2 in a2) {
          var u2 = (d3 = o2, i2 = l2[g2], Math.pow(d3.r - i2.r, 2) + Math.pow(d3.g - i2.g, 2) + Math.pow(d3.b - i2.b, 2));
          u2 < t2 && (t2 = u2, b2 = g2);
        }
        return b2;
      }
    };
    f2.string.push([function(f3) {
      var r3 = f3.toLowerCase(), d3 = "transparent" === r3 ? "#0000" : a2[r3];
      return d3 ? new e2(d3).toRgb() : null;
    }, "name"]);
  }
  var init_names = __esm({
    "../core/node_modules/@pixi/colord/plugins/names.mjs"() {
    }
  });

  // ../core/node_modules/pixi.js/lib/color/Color.mjs
  var _Color, Color;
  var init_Color = __esm({
    "../core/node_modules/pixi.js/lib/color/Color.mjs"() {
      init_colord();
      init_names();
      k([names_default]);
      _Color = class _Color2 {
        /**
         * @param {ColorSource} value - Optional value to use, if not provided, white is used.
         */
        constructor(value = 16777215) {
          this._value = null;
          this._components = new Float32Array(4);
          this._components.fill(1);
          this._int = 16777215;
          this.value = value;
        }
        /** Get red component (0 - 1) */
        get red() {
          return this._components[0];
        }
        /** Get green component (0 - 1) */
        get green() {
          return this._components[1];
        }
        /** Get blue component (0 - 1) */
        get blue() {
          return this._components[2];
        }
        /** Get alpha component (0 - 1) */
        get alpha() {
          return this._components[3];
        }
        /**
         * Set the value, suitable for chaining
         * @param value
         * @see Color.value
         */
        setValue(value) {
          this.value = value;
          return this;
        }
        /**
         * The current color source.
         *
         * When setting:
         * - Setting to an instance of `Color` will copy its color source and components.
         * - Otherwise, `Color` will try to normalize the color source and set the components.
         *   If the color source is invalid, an `Error` will be thrown and the `Color` will left unchanged.
         *
         * Note: The `null` in the setter's parameter type is added to match the TypeScript rule: return type of getter
         * must be assignable to its setter's parameter type. Setting `value` to `null` will throw an `Error`.
         *
         * When getting:
         * - A return value of `null` means the previous value was overridden (e.g., {@link Color.multiply multiply},
         *   {@link Color.premultiply premultiply} or {@link Color.round round}).
         * - Otherwise, the color source used when setting is returned.
         */
        set value(value) {
          if (value instanceof _Color2) {
            this._value = this._cloneSource(value._value);
            this._int = value._int;
            this._components.set(value._components);
          } else if (value === null) {
            throw new Error("Cannot set Color#value to null");
          } else if (this._value === null || !this._isSourceEqual(this._value, value)) {
            this._normalize(value);
            this._value = this._cloneSource(value);
          }
        }
        get value() {
          return this._value;
        }
        /**
         * Copy a color source internally.
         * @param value - Color source
         */
        _cloneSource(value) {
          if (typeof value === "string" || typeof value === "number" || value instanceof Number || value === null) {
            return value;
          } else if (Array.isArray(value) || ArrayBuffer.isView(value)) {
            return value.slice(0);
          } else if (typeof value === "object" && value !== null) {
            return { ...value };
          }
          return value;
        }
        /**
         * Equality check for color sources.
         * @param value1 - First color source
         * @param value2 - Second color source
         * @returns `true` if the color sources are equal, `false` otherwise.
         */
        _isSourceEqual(value1, value2) {
          const type1 = typeof value1;
          const type2 = typeof value2;
          if (type1 !== type2) {
            return false;
          } else if (type1 === "number" || type1 === "string" || value1 instanceof Number) {
            return value1 === value2;
          } else if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {
            if (value1.length !== value2.length) {
              return false;
            }
            return value1.every((v2, i2) => v2 === value2[i2]);
          } else if (value1 !== null && value2 !== null) {
            const keys1 = Object.keys(value1);
            const keys2 = Object.keys(value2);
            if (keys1.length !== keys2.length) {
              return false;
            }
            return keys1.every((key) => value1[key] === value2[key]);
          }
          return value1 === value2;
        }
        /**
         * Convert to a RGBA color object.
         * @example
         * import { Color } from 'pixi.js';
         * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1, a: 1 }
         */
        toRgba() {
          const [r2, g2, b2, a2] = this._components;
          return { r: r2, g: g2, b: b2, a: a2 };
        }
        /**
         * Convert to a RGB color object.
         * @example
         * import { Color } from 'pixi.js';
         * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1 }
         */
        toRgb() {
          const [r2, g2, b2] = this._components;
          return { r: r2, g: g2, b: b2 };
        }
        /** Convert to a CSS-style rgba string: `rgba(255,255,255,1.0)`. */
        toRgbaString() {
          const [r2, g2, b2] = this.toUint8RgbArray();
          return `rgba(${r2},${g2},${b2},${this.alpha})`;
        }
        toUint8RgbArray(out2) {
          const [r2, g2, b2] = this._components;
          if (!this._arrayRgb) {
            this._arrayRgb = [];
          }
          out2 = out2 || this._arrayRgb;
          out2[0] = Math.round(r2 * 255);
          out2[1] = Math.round(g2 * 255);
          out2[2] = Math.round(b2 * 255);
          return out2;
        }
        toArray(out2) {
          if (!this._arrayRgba) {
            this._arrayRgba = [];
          }
          out2 = out2 || this._arrayRgba;
          const [r2, g2, b2, a2] = this._components;
          out2[0] = r2;
          out2[1] = g2;
          out2[2] = b2;
          out2[3] = a2;
          return out2;
        }
        toRgbArray(out2) {
          if (!this._arrayRgb) {
            this._arrayRgb = [];
          }
          out2 = out2 || this._arrayRgb;
          const [r2, g2, b2] = this._components;
          out2[0] = r2;
          out2[1] = g2;
          out2[2] = b2;
          return out2;
        }
        /**
         * Convert to a hexadecimal number.
         * @example
         * import { Color } from 'pixi.js';
         * new Color('white').toNumber(); // returns 16777215
         */
        toNumber() {
          return this._int;
        }
        /**
         * Convert to a BGR number
         * @example
         * import { Color } from 'pixi.js';
         * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff
         */
        toBgrNumber() {
          const [r2, g2, b2] = this.toUint8RgbArray();
          return (b2 << 16) + (g2 << 8) + r2;
        }
        /**
         * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).
         * @example
         * import { Color } from 'pixi.js';
         * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff
         * @returns {number} - The color as a number in little endian format.
         */
        toLittleEndianNumber() {
          const value = this._int;
          return (value >> 16) + (value & 65280) + ((value & 255) << 16);
        }
        /**
         * Multiply with another color. This action is destructive, and will
         * override the previous `value` property to be `null`.
         * @param {ColorSource} value - The color to multiply by.
         */
        multiply(value) {
          const [r2, g2, b2, a2] = _Color2._temp.setValue(value)._components;
          this._components[0] *= r2;
          this._components[1] *= g2;
          this._components[2] *= b2;
          this._components[3] *= a2;
          this._refreshInt();
          this._value = null;
          return this;
        }
        /**
         * Converts color to a premultiplied alpha format. This action is destructive, and will
         * override the previous `value` property to be `null`.
         * @param alpha - The alpha to multiply by.
         * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.
         * @returns {Color} - Itself.
         */
        premultiply(alpha, applyToRGB = true) {
          if (applyToRGB) {
            this._components[0] *= alpha;
            this._components[1] *= alpha;
            this._components[2] *= alpha;
          }
          this._components[3] = alpha;
          this._refreshInt();
          this._value = null;
          return this;
        }
        /**
         * Premultiplies alpha with current color.
         * @param {number} alpha - The alpha to multiply by.
         * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.
         * @returns {number} tint multiplied by alpha
         */
        toPremultiplied(alpha, applyToRGB = true) {
          if (alpha === 1) {
            return (255 << 24) + this._int;
          }
          if (alpha === 0) {
            return applyToRGB ? 0 : this._int;
          }
          let r2 = this._int >> 16 & 255;
          let g2 = this._int >> 8 & 255;
          let b2 = this._int & 255;
          if (applyToRGB) {
            r2 = r2 * alpha + 0.5 | 0;
            g2 = g2 * alpha + 0.5 | 0;
            b2 = b2 * alpha + 0.5 | 0;
          }
          return (alpha * 255 << 24) + (r2 << 16) + (g2 << 8) + b2;
        }
        /**
         * Convert to a hexidecimal string.
         * @example
         * import { Color } from 'pixi.js';
         * new Color('white').toHex(); // returns "#ffffff"
         */
        toHex() {
          const hexString = this._int.toString(16);
          return `#${"000000".substring(0, 6 - hexString.length) + hexString}`;
        }
        /**
         * Convert to a hexidecimal string with alpha.
         * @example
         * import { Color } from 'pixi.js';
         * new Color('white').toHexa(); // returns "#ffffffff"
         */
        toHexa() {
          const alphaValue = Math.round(this._components[3] * 255);
          const alphaString = alphaValue.toString(16);
          return this.toHex() + "00".substring(0, 2 - alphaString.length) + alphaString;
        }
        /**
         * Set alpha, suitable for chaining.
         * @param alpha
         */
        setAlpha(alpha) {
          this._components[3] = this._clamp(alpha);
          return this;
        }
        /**
         * Normalize the input value into rgba
         * @param value - Input value
         */
        _normalize(value) {
          let r2;
          let g2;
          let b2;
          let a2;
          if ((typeof value === "number" || value instanceof Number) && value >= 0 && value <= 16777215) {
            const int = value;
            r2 = (int >> 16 & 255) / 255;
            g2 = (int >> 8 & 255) / 255;
            b2 = (int & 255) / 255;
            a2 = 1;
          } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4) {
            value = this._clamp(value);
            [r2, g2, b2, a2 = 1] = value;
          } else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4) {
            value = this._clamp(value, 0, 255);
            [r2, g2, b2, a2 = 255] = value;
            r2 /= 255;
            g2 /= 255;
            b2 /= 255;
            a2 /= 255;
          } else if (typeof value === "string" || typeof value === "object") {
            if (typeof value === "string") {
              const match = _Color2.HEX_PATTERN.exec(value);
              if (match) {
                value = `#${match[2]}`;
              }
            }
            const color3 = w(value);
            if (color3.isValid()) {
              ({ r: r2, g: g2, b: b2, a: a2 } = color3.rgba);
              r2 /= 255;
              g2 /= 255;
              b2 /= 255;
            }
          }
          if (r2 !== void 0) {
            this._components[0] = r2;
            this._components[1] = g2;
            this._components[2] = b2;
            this._components[3] = a2;
            this._refreshInt();
          } else {
            throw new Error(`Unable to convert color ${value}`);
          }
        }
        /** Refresh the internal color rgb number */
        _refreshInt() {
          this._clamp(this._components);
          const [r2, g2, b2] = this._components;
          this._int = (r2 * 255 << 16) + (g2 * 255 << 8) + (b2 * 255 | 0);
        }
        /**
         * Clamps values to a range. Will override original values
         * @param value - Value(s) to clamp
         * @param min - Minimum value
         * @param max - Maximum value
         */
        _clamp(value, min = 0, max = 1) {
          if (typeof value === "number") {
            return Math.min(Math.max(value, min), max);
          }
          value.forEach((v2, i2) => {
            value[i2] = Math.min(Math.max(v2, min), max);
          });
          return value;
        }
        /**
         * Check if the value is a color-like object
         * @param value - Value to check
         * @returns True if the value is a color-like object
         * @static
         * @example
         * import { Color } from 'pixi.js';
         * Color.isColorLike('white'); // returns true
         * Color.isColorLike(0xffffff); // returns true
         * Color.isColorLike([1, 1, 1]); // returns true
         */
        static isColorLike(value) {
          return typeof value === "number" || typeof value === "string" || value instanceof Number || value instanceof _Color2 || Array.isArray(value) || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Float32Array || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 && value.a !== void 0;
        }
      };
      _Color.shared = new _Color();
      _Color._temp = new _Color();
      _Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
      Color = _Color;
    }
  });

  // ../core/node_modules/pixi.js/lib/culling/cullingMixin.mjs
  var cullingMixin;
  var init_cullingMixin = __esm({
    "../core/node_modules/pixi.js/lib/culling/cullingMixin.mjs"() {
      "use strict";
      cullingMixin = {
        cullArea: null,
        cullable: false,
        cullableChildren: true
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/maths/misc/const.mjs
  var PI_2, RAD_TO_DEG, DEG_TO_RAD;
  var init_const = __esm({
    "../core/node_modules/pixi.js/lib/maths/misc/const.mjs"() {
      "use strict";
      PI_2 = Math.PI * 2;
      RAD_TO_DEG = 180 / Math.PI;
      DEG_TO_RAD = Math.PI / 180;
    }
  });

  // ../core/node_modules/pixi.js/lib/maths/point/Point.mjs
  var Point, tempPoint;
  var init_Point = __esm({
    "../core/node_modules/pixi.js/lib/maths/point/Point.mjs"() {
      "use strict";
      Point = class {
        /**
         * Creates a new `Point`
         * @param {number} [x=0] - position of the point on the x axis
         * @param {number} [y=0] - position of the point on the y axis
         */
        constructor(x2 = 0, y2 = 0) {
          this.x = 0;
          this.y = 0;
          this.x = x2;
          this.y = y2;
        }
        /**
         * Creates a clone of this point
         * @returns A clone of this point
         */
        clone() {
          return new Point(this.x, this.y);
        }
        /**
         * Copies `x` and `y` from the given point into this point
         * @param p - The point to copy from
         * @returns The point instance itself
         */
        copyFrom(p2) {
          this.set(p2.x, p2.y);
          return this;
        }
        /**
         * Copies this point's x and y into the given point (`p`).
         * @param p - The point to copy to. Can be any of type that is or extends `PointData`
         * @returns The point (`p`) with values updated
         */
        copyTo(p2) {
          p2.set(this.x, this.y);
          return p2;
        }
        /**
         * Accepts another point (`p`) and returns `true` if the given point is equal to this point
         * @param p - The point to check
         * @returns Returns `true` if both `x` and `y` are equal
         */
        equals(p2) {
          return p2.x === this.x && p2.y === this.y;
        }
        /**
         * Sets the point to a new `x` and `y` position.
         * If `y` is omitted, both `x` and `y` will be set to `x`.
         * @param {number} [x=0] - position of the point on the `x` axis
         * @param {number} [y=x] - position of the point on the `y` axis
         * @returns The point instance itself
         */
        set(x2 = 0, y2 = x2) {
          this.x = x2;
          this.y = y2;
          return this;
        }
        toString() {
          return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;
        }
        /**
         * A static Point object with `x` and `y` values of `0`. Can be used to avoid creating new objects multiple times.
         * @readonly
         */
        static get shared() {
          tempPoint.x = 0;
          tempPoint.y = 0;
          return tempPoint;
        }
      };
      tempPoint = new Point();
    }
  });

  // ../core/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs
  var Matrix, tempMatrix, identityMatrix;
  var init_Matrix = __esm({
    "../core/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs"() {
      init_const();
      init_Point();
      Matrix = class {
        /**
         * @param a - x scale
         * @param b - y skew
         * @param c - x skew
         * @param d - y scale
         * @param tx - x translation
         * @param ty - y translation
         */
        constructor(a2 = 1, b2 = 0, c2 = 0, d2 = 1, tx = 0, ty = 0) {
          this.array = null;
          this.a = a2;
          this.b = b2;
          this.c = c2;
          this.d = d2;
          this.tx = tx;
          this.ty = ty;
        }
        /**
         * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
         *
         * a = array[0]
         * b = array[1]
         * c = array[3]
         * d = array[4]
         * tx = array[2]
         * ty = array[5]
         * @param array - The array that the matrix will be populated from.
         */
        fromArray(array) {
          this.a = array[0];
          this.b = array[1];
          this.c = array[3];
          this.d = array[4];
          this.tx = array[2];
          this.ty = array[5];
        }
        /**
         * Sets the matrix properties.
         * @param a - Matrix component
         * @param b - Matrix component
         * @param c - Matrix component
         * @param d - Matrix component
         * @param tx - Matrix component
         * @param ty - Matrix component
         * @returns This matrix. Good for chaining method calls.
         */
        set(a2, b2, c2, d2, tx, ty) {
          this.a = a2;
          this.b = b2;
          this.c = c2;
          this.d = d2;
          this.tx = tx;
          this.ty = ty;
          return this;
        }
        /**
         * Creates an array from the current Matrix object.
         * @param transpose - Whether we need to transpose the matrix or not
         * @param [out=new Float32Array(9)] - If provided the array will be assigned to out
         * @returns The newly created array which contains the matrix
         */
        toArray(transpose, out2) {
          if (!this.array) {
            this.array = new Float32Array(9);
          }
          const array = out2 || this.array;
          if (transpose) {
            array[0] = this.a;
            array[1] = this.b;
            array[2] = 0;
            array[3] = this.c;
            array[4] = this.d;
            array[5] = 0;
            array[6] = this.tx;
            array[7] = this.ty;
            array[8] = 1;
          } else {
            array[0] = this.a;
            array[1] = this.c;
            array[2] = this.tx;
            array[3] = this.b;
            array[4] = this.d;
            array[5] = this.ty;
            array[6] = 0;
            array[7] = 0;
            array[8] = 1;
          }
          return array;
        }
        /**
         * Get a new position with the current transformation applied.
         * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
         * @param pos - The origin
         * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
         * @returns {Point} The new point, transformed through this matrix
         */
        apply(pos, newPos) {
          newPos = newPos || new Point();
          const x2 = pos.x;
          const y2 = pos.y;
          newPos.x = this.a * x2 + this.c * y2 + this.tx;
          newPos.y = this.b * x2 + this.d * y2 + this.ty;
          return newPos;
        }
        /**
         * Get a new position with the inverse of the current transformation applied.
         * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
         * @param pos - The origin
         * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
         * @returns {Point} The new point, inverse-transformed through this matrix
         */
        applyInverse(pos, newPos) {
          newPos = newPos || new Point();
          const a2 = this.a;
          const b2 = this.b;
          const c2 = this.c;
          const d2 = this.d;
          const tx = this.tx;
          const ty = this.ty;
          const id = 1 / (a2 * d2 + c2 * -b2);
          const x2 = pos.x;
          const y2 = pos.y;
          newPos.x = d2 * id * x2 + -c2 * id * y2 + (ty * c2 - tx * d2) * id;
          newPos.y = a2 * id * y2 + -b2 * id * x2 + (-ty * a2 + tx * b2) * id;
          return newPos;
        }
        /**
         * Translates the matrix on the x and y.
         * @param x - How much to translate x by
         * @param y - How much to translate y by
         * @returns This matrix. Good for chaining method calls.
         */
        translate(x2, y2) {
          this.tx += x2;
          this.ty += y2;
          return this;
        }
        /**
         * Applies a scale transformation to the matrix.
         * @param x - The amount to scale horizontally
         * @param y - The amount to scale vertically
         * @returns This matrix. Good for chaining method calls.
         */
        scale(x2, y2) {
          this.a *= x2;
          this.d *= y2;
          this.c *= x2;
          this.b *= y2;
          this.tx *= x2;
          this.ty *= y2;
          return this;
        }
        /**
         * Applies a rotation transformation to the matrix.
         * @param angle - The angle in radians.
         * @returns This matrix. Good for chaining method calls.
         */
        rotate(angle) {
          const cos = Math.cos(angle);
          const sin = Math.sin(angle);
          const a1 = this.a;
          const c1 = this.c;
          const tx1 = this.tx;
          this.a = a1 * cos - this.b * sin;
          this.b = a1 * sin + this.b * cos;
          this.c = c1 * cos - this.d * sin;
          this.d = c1 * sin + this.d * cos;
          this.tx = tx1 * cos - this.ty * sin;
          this.ty = tx1 * sin + this.ty * cos;
          return this;
        }
        /**
         * Appends the given Matrix to this Matrix.
         * @param matrix - The matrix to append.
         * @returns This matrix. Good for chaining method calls.
         */
        append(matrix) {
          const a1 = this.a;
          const b1 = this.b;
          const c1 = this.c;
          const d1 = this.d;
          this.a = matrix.a * a1 + matrix.b * c1;
          this.b = matrix.a * b1 + matrix.b * d1;
          this.c = matrix.c * a1 + matrix.d * c1;
          this.d = matrix.c * b1 + matrix.d * d1;
          this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
          this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
          return this;
        }
        /**
         * Appends two matrix's and sets the result to this matrix. AB = A * B
         * @param a - The matrix to append.
         * @param b - The matrix to append.
         * @returns This matrix. Good for chaining method calls.
         */
        appendFrom(a2, b2) {
          const a1 = a2.a;
          const b1 = a2.b;
          const c1 = a2.c;
          const d1 = a2.d;
          const tx = a2.tx;
          const ty = a2.ty;
          const a22 = b2.a;
          const b22 = b2.b;
          const c2 = b2.c;
          const d2 = b2.d;
          this.a = a1 * a22 + b1 * c2;
          this.b = a1 * b22 + b1 * d2;
          this.c = c1 * a22 + d1 * c2;
          this.d = c1 * b22 + d1 * d2;
          this.tx = tx * a22 + ty * c2 + b2.tx;
          this.ty = tx * b22 + ty * d2 + b2.ty;
          return this;
        }
        /**
         * Sets the matrix based on all the available properties
         * @param x - Position on the x axis
         * @param y - Position on the y axis
         * @param pivotX - Pivot on the x axis
         * @param pivotY - Pivot on the y axis
         * @param scaleX - Scale on the x axis
         * @param scaleY - Scale on the y axis
         * @param rotation - Rotation in radians
         * @param skewX - Skew on the x axis
         * @param skewY - Skew on the y axis
         * @returns This matrix. Good for chaining method calls.
         */
        setTransform(x2, y2, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
          this.a = Math.cos(rotation + skewY) * scaleX;
          this.b = Math.sin(rotation + skewY) * scaleX;
          this.c = -Math.sin(rotation - skewX) * scaleY;
          this.d = Math.cos(rotation - skewX) * scaleY;
          this.tx = x2 - (pivotX * this.a + pivotY * this.c);
          this.ty = y2 - (pivotX * this.b + pivotY * this.d);
          return this;
        }
        /**
         * Prepends the given Matrix to this Matrix.
         * @param matrix - The matrix to prepend
         * @returns This matrix. Good for chaining method calls.
         */
        prepend(matrix) {
          const tx1 = this.tx;
          if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
            const a1 = this.a;
            const c1 = this.c;
            this.a = a1 * matrix.a + this.b * matrix.c;
            this.b = a1 * matrix.b + this.b * matrix.d;
            this.c = c1 * matrix.a + this.d * matrix.c;
            this.d = c1 * matrix.b + this.d * matrix.d;
          }
          this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
          this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
          return this;
        }
        /**
         * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.
         * @param transform - The transform to apply the properties to.
         * @returns The transform with the newly applied properties
         */
        decompose(transform2) {
          const a2 = this.a;
          const b2 = this.b;
          const c2 = this.c;
          const d2 = this.d;
          const pivot = transform2.pivot;
          const skewX = -Math.atan2(-c2, d2);
          const skewY = Math.atan2(b2, a2);
          const delta = Math.abs(skewX + skewY);
          if (delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5) {
            transform2.rotation = skewY;
            transform2.skew.x = transform2.skew.y = 0;
          } else {
            transform2.rotation = 0;
            transform2.skew.x = skewX;
            transform2.skew.y = skewY;
          }
          transform2.scale.x = Math.sqrt(a2 * a2 + b2 * b2);
          transform2.scale.y = Math.sqrt(c2 * c2 + d2 * d2);
          transform2.position.x = this.tx + (pivot.x * a2 + pivot.y * c2);
          transform2.position.y = this.ty + (pivot.x * b2 + pivot.y * d2);
          return transform2;
        }
        /**
         * Inverts this matrix
         * @returns This matrix. Good for chaining method calls.
         */
        invert() {
          const a1 = this.a;
          const b1 = this.b;
          const c1 = this.c;
          const d1 = this.d;
          const tx1 = this.tx;
          const n2 = a1 * d1 - b1 * c1;
          this.a = d1 / n2;
          this.b = -b1 / n2;
          this.c = -c1 / n2;
          this.d = a1 / n2;
          this.tx = (c1 * this.ty - d1 * tx1) / n2;
          this.ty = -(a1 * this.ty - b1 * tx1) / n2;
          return this;
        }
        /** Checks if this matrix is an identity matrix */
        isIdentity() {
          return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;
        }
        /**
         * Resets this Matrix to an identity (default) matrix.
         * @returns This matrix. Good for chaining method calls.
         */
        identity() {
          this.a = 1;
          this.b = 0;
          this.c = 0;
          this.d = 1;
          this.tx = 0;
          this.ty = 0;
          return this;
        }
        /**
         * Creates a new Matrix object with the same values as this one.
         * @returns A copy of this matrix. Good for chaining method calls.
         */
        clone() {
          const matrix = new Matrix();
          matrix.a = this.a;
          matrix.b = this.b;
          matrix.c = this.c;
          matrix.d = this.d;
          matrix.tx = this.tx;
          matrix.ty = this.ty;
          return matrix;
        }
        /**
         * Changes the values of the given matrix to be the same as the ones in this matrix
         * @param matrix - The matrix to copy to.
         * @returns The matrix given in parameter with its values updated.
         */
        copyTo(matrix) {
          matrix.a = this.a;
          matrix.b = this.b;
          matrix.c = this.c;
          matrix.d = this.d;
          matrix.tx = this.tx;
          matrix.ty = this.ty;
          return matrix;
        }
        /**
         * Changes the values of the matrix to be the same as the ones in given matrix
         * @param matrix - The matrix to copy from.
         * @returns this
         */
        copyFrom(matrix) {
          this.a = matrix.a;
          this.b = matrix.b;
          this.c = matrix.c;
          this.d = matrix.d;
          this.tx = matrix.tx;
          this.ty = matrix.ty;
          return this;
        }
        /**
         * check to see if two matrices are the same
         * @param matrix - The matrix to compare to.
         */
        equals(matrix) {
          return matrix.a === this.a && matrix.b === this.b && matrix.c === this.c && matrix.d === this.d && matrix.tx === this.tx && matrix.ty === this.ty;
        }
        toString() {
          return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
        }
        /**
         * A default (identity) matrix.
         *
         * This is a shared object, if you want to modify it consider creating a new `Matrix`
         * @readonly
         */
        static get IDENTITY() {
          return identityMatrix.identity();
        }
        /**
         * A static Matrix that can be used to avoid creating new objects.
         * Will always ensure the matrix is reset to identity when requested.
         * Use this object for fast but temporary calculations, as it may be mutated later on.
         * This is a different object to the `IDENTITY` object and so can be modified without changing `IDENTITY`.
         * @readonly
         */
        static get shared() {
          return tempMatrix.identity();
        }
      };
      tempMatrix = new Matrix();
      identityMatrix = new Matrix();
    }
  });

  // ../core/node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs
  var ObservablePoint;
  var init_ObservablePoint = __esm({
    "../core/node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs"() {
      "use strict";
      ObservablePoint = class {
        /**
         * Creates a new `ObservablePoint`
         * @param observer - Observer to pass to listen for change events.
         * @param {number} [x=0] - position of the point on the x axis
         * @param {number} [y=0] - position of the point on the y axis
         */
        constructor(observer, x2, y2) {
          this._x = x2 || 0;
          this._y = y2 || 0;
          this._observer = observer;
        }
        /**
         * Creates a clone of this point.
         * @param observer - Optional observer to pass to the new observable point.
         * @returns a copy of this observable point
         */
        clone(observer) {
          return new ObservablePoint(observer ?? this._observer, this._x, this._y);
        }
        /**
         * Sets the point to a new `x` and `y` position.
         * If `y` is omitted, both `x` and `y` will be set to `x`.
         * @param {number} [x=0] - position of the point on the x axis
         * @param {number} [y=x] - position of the point on the y axis
         * @returns The observable point instance itself
         */
        set(x2 = 0, y2 = x2) {
          if (this._x !== x2 || this._y !== y2) {
            this._x = x2;
            this._y = y2;
            this._observer._onUpdate(this);
          }
          return this;
        }
        /**
         * Copies x and y from the given point (`p`)
         * @param p - The point to copy from. Can be any of type that is or extends `PointData`
         * @returns The observable point instance itself
         */
        copyFrom(p2) {
          if (this._x !== p2.x || this._y !== p2.y) {
            this._x = p2.x;
            this._y = p2.y;
            this._observer._onUpdate(this);
          }
          return this;
        }
        /**
         * Copies this point's x and y into that of the given point (`p`)
         * @param p - The point to copy to. Can be any of type that is or extends `PointData`
         * @returns The point (`p`) with values updated
         */
        copyTo(p2) {
          p2.set(this._x, this._y);
          return p2;
        }
        /**
         * Accepts another point (`p`) and returns `true` if the given point is equal to this point
         * @param p - The point to check
         * @returns Returns `true` if both `x` and `y` are equal
         */
        equals(p2) {
          return p2.x === this._x && p2.y === this._y;
        }
        toString() {
          return `[pixi.js/math:ObservablePoint x=${0} y=${0} scope=${this._observer}]`;
        }
        /** Position of the observable point on the x axis. */
        get x() {
          return this._x;
        }
        set x(value) {
          if (this._x !== value) {
            this._x = value;
            this._observer._onUpdate(this);
          }
        }
        /** Position of the observable point on the y axis. */
        get y() {
          return this._y;
        }
        set y(value) {
          if (this._y !== value) {
            this._y = value;
            this._observer._onUpdate(this);
          }
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/utils/data/uid.mjs
  function uid(name = "default") {
    if (uidCache[name] === void 0) {
      uidCache[name] = -1;
    }
    return ++uidCache[name];
  }
  var uidCache;
  var init_uid = __esm({
    "../core/node_modules/pixi.js/lib/utils/data/uid.mjs"() {
      "use strict";
      uidCache = {
        default: -1
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/utils/logging/deprecation.mjs
  function deprecation(version, message, ignoreDepth = 3) {
    if (warnings[message]) {
      return;
    }
    let stack = new Error().stack;
    if (typeof stack === "undefined") {
      console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`);
    } else {
      stack = stack.split("\n").splice(ignoreDepth).join("\n");
      if (console.groupCollapsed) {
        console.groupCollapsed(
          "%cPixiJS Deprecation Warning: %c%s",
          "color:#614108;background:#fffbe6",
          "font-weight:normal;color:#614108;background:#fffbe6",
          `${message}
Deprecated since v${version}`
        );
        console.warn(stack);
        console.groupEnd();
      } else {
        console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`);
        console.warn(stack);
      }
    }
    warnings[message] = true;
  }
  var warnings, v8_0_0;
  var init_deprecation = __esm({
    "../core/node_modules/pixi.js/lib/utils/logging/deprecation.mjs"() {
      "use strict";
      warnings = {};
      v8_0_0 = "8.0.0";
    }
  });

  // ../core/node_modules/pixi.js/lib/utils/data/removeItems.mjs
  function removeItems(arr, startIdx, removeCount) {
    const length = arr.length;
    let i2;
    if (startIdx >= length || removeCount === 0) {
      return;
    }
    removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
    const len = length - removeCount;
    for (i2 = startIdx; i2 < len; ++i2) {
      arr[i2] = arr[i2 + removeCount];
    }
    arr.length = len;
  }
  var init_removeItems = __esm({
    "../core/node_modules/pixi.js/lib/utils/data/removeItems.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.mjs
  var childrenHelperMixin;
  var init_childrenHelperMixin = __esm({
    "../core/node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.mjs"() {
      init_removeItems();
      init_deprecation();
      childrenHelperMixin = {
        allowChildren: true,
        /**
         * Removes all children from this container that are within the begin and end indexes.
         * @param beginIndex - The beginning position.
         * @param endIndex - The ending position. Default value is size of the container.
         * @returns - List of removed children
         * @memberof scene.Container#
         */
        removeChildren(beginIndex = 0, endIndex) {
          const end = endIndex ?? this.children.length;
          const range = end - beginIndex;
          const removed = [];
          if (range > 0 && range <= end) {
            for (let i2 = end - 1; i2 >= beginIndex; i2--) {
              const child = this.children[i2];
              if (!child)
                continue;
              removed.push(child);
              child.parent = null;
            }
            removeItems(this.children, beginIndex, end);
            const renderGroup = this.renderGroup || this.parentRenderGroup;
            if (renderGroup) {
              renderGroup.removeChildren(removed);
            }
            for (let i2 = 0; i2 < removed.length; ++i2) {
              this.emit("childRemoved", removed[i2], this, i2);
              removed[i2].emit("removed", this);
            }
            return removed;
          } else if (range === 0 && this.children.length === 0) {
            return removed;
          }
          throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
        },
        /**
         * Removes a child from the specified index position.
         * @param index - The index to get the child from
         * @returns The child that was removed.
         * @memberof scene.Container#
         */
        removeChildAt(index) {
          const child = this.getChildAt(index);
          return this.removeChild(child);
        },
        /**
         * Returns the child at the specified index
         * @param index - The index to get the child at
         * @returns - The child at the given index, if any.
         * @memberof scene.Container#
         */
        getChildAt(index) {
          if (index < 0 || index >= this.children.length) {
            throw new Error(`getChildAt: Index (${index}) does not exist.`);
          }
          return this.children[index];
        },
        /**
         * Changes the position of an existing child in the container container
         * @param child - The child Container instance for which you want to change the index number
         * @param index - The resulting index number for the child container
         * @memberof scene.Container#
         */
        setChildIndex(child, index) {
          if (index < 0 || index >= this.children.length) {
            throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);
          }
          this.getChildIndex(child);
          this.addChildAt(child, index);
        },
        /**
         * Returns the index position of a child Container instance
         * @param child - The Container instance to identify
         * @returns - The index position of the child container to identify
         * @memberof scene.Container#
         */
        getChildIndex(child) {
          const index = this.children.indexOf(child);
          if (index === -1) {
            throw new Error("The supplied Container must be a child of the caller");
          }
          return index;
        },
        /**
         * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown.
         * If the child is already in this container, it will be moved to the specified index.
         * @param {Container} child - The child to add.
         * @param {number} index - The absolute index where the child will be positioned at the end of the operation.
         * @returns {Container} The child that was added.
         * @memberof scene.Container#
         */
        addChildAt(child, index) {
          if (!this.allowChildren) {
            deprecation(v8_0_0, "addChildAt: Only Containers will be allowed to add children in v8.0.0");
          }
          const { children: children2 } = this;
          if (index < 0 || index > children2.length) {
            throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children2.length}`);
          }
          if (child.parent) {
            const currentIndex = child.parent.children.indexOf(child);
            if (child.parent === this && currentIndex === index) {
              return child;
            }
            if (currentIndex !== -1) {
              child.parent.children.splice(currentIndex, 1);
            }
          }
          if (index === children2.length) {
            children2.push(child);
          } else {
            children2.splice(index, 0, child);
          }
          child.parent = this;
          child.didChange = true;
          child.didViewUpdate = false;
          child._updateFlags = 15;
          const renderGroup = this.renderGroup || this.parentRenderGroup;
          if (renderGroup) {
            renderGroup.addChild(child);
          }
          if (this.sortableChildren)
            this.sortDirty = true;
          this.emit("childAdded", child, this, index);
          child.emit("added", this);
          return child;
        },
        /**
         * Swaps the position of 2 Containers within this container.
         * @param child - First container to swap
         * @param child2 - Second container to swap
         */
        swapChildren(child, child2) {
          if (child === child2) {
            return;
          }
          const index1 = this.getChildIndex(child);
          const index2 = this.getChildIndex(child2);
          this.children[index1] = child2;
          this.children[index2] = child;
        },
        /**
         * Remove the Container from its parent Container. If the Container has no parent, do nothing.
         * @memberof scene.Container#
         */
        removeFromParent() {
          this.parent?.removeChild(this);
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/filters/FilterEffect.mjs
  var FilterEffect;
  var init_FilterEffect = __esm({
    "../core/node_modules/pixi.js/lib/filters/FilterEffect.mjs"() {
      "use strict";
      FilterEffect = class {
        constructor() {
          this.pipe = "filter";
          this.priority = 1;
        }
        destroy() {
          for (let i2 = 0; i2 < this.filters.length; i2++) {
            this.filters[i2].destroy();
          }
          this.filters = null;
          this.filterArea = null;
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/utils/pool/Pool.mjs
  var Pool;
  var init_Pool = __esm({
    "../core/node_modules/pixi.js/lib/utils/pool/Pool.mjs"() {
      "use strict";
      Pool = class {
        /**
         * Constructs a new Pool.
         * @param ClassType - The constructor of the items in the pool.
         * @param {number} [initialSize] - The initial size of the pool.
         */
        constructor(ClassType, initialSize) {
          this._pool = [];
          this._count = 0;
          this._index = 0;
          this._classType = ClassType;
          if (initialSize) {
            this.prepopulate(initialSize);
          }
        }
        /**
         * Prepopulates the pool with a given number of items.
         * @param total - The number of items to add to the pool.
         */
        prepopulate(total) {
          for (let i2 = 0; i2 < total; i2++) {
            this._pool[this._index++] = new this._classType();
          }
          this._count += total;
        }
        /**
         * Gets an item from the pool. Calls the item's `init` method if it exists.
         * If there are no items left in the pool, a new one will be created.
         * @param {unknown} [data] - Optional data to pass to the item's constructor.
         * @returns {T} The item from the pool.
         */
        get(data) {
          let item;
          if (this._index > 0) {
            item = this._pool[--this._index];
          } else {
            item = new this._classType();
          }
          item.init?.(data);
          return item;
        }
        /**
         * Returns an item to the pool. Calls the item's `reset` method if it exists.
         * @param {T} item - The item to return to the pool.
         */
        return(item) {
          item.reset?.();
          this._pool[this._index++] = item;
        }
        /**
         * Gets the number of items in the pool.
         * @readonly
         * @member {number}
         */
        get totalSize() {
          return this._count;
        }
        /**
         * Gets the number of items in the pool that are free to use without needing to create more.
         * @readonly
         * @member {number}
         */
        get totalFree() {
          return this._index;
        }
        /**
         * Gets the number of items in the pool that are currently in use.
         * @readonly
         * @member {number}
         */
        get totalUsed() {
          return this._count - this._index;
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs
  var PoolGroupClass, BigPool;
  var init_PoolGroup = __esm({
    "../core/node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs"() {
      init_Pool();
      PoolGroupClass = class {
        constructor() {
          this._poolsByClass = /* @__PURE__ */ new Map();
        }
        /**
         * Prepopulates a specific pool with a given number of items.
         * @template T The type of items in the pool. Must extend PoolItem.
         * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.
         * @param {number} total - The number of items to add to the pool.
         */
        prepopulate(Class, total) {
          const classPool = this.getPool(Class);
          classPool.prepopulate(total);
        }
        /**
         * Gets an item from a specific pool.
         * @template T The type of items in the pool. Must extend PoolItem.
         * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.
         * @param {unknown} [data] - Optional data to pass to the item's constructor.
         * @returns {T} The item from the pool.
         */
        get(Class, data) {
          const pool = this.getPool(Class);
          return pool.get(data);
        }
        /**
         * Returns an item to its respective pool.
         * @param {PoolItem} item - The item to return to the pool.
         */
        return(item) {
          const pool = this.getPool(item.constructor);
          pool.return(item);
        }
        /**
         * Gets a specific pool based on the class type.
         * @template T The type of items in the pool. Must extend PoolItem.
         * @param {PoolItemConstructor<T>} ClassType - The constructor of the items in the pool.
         * @returns {Pool<T>} The pool of the given class type.
         */
        getPool(ClassType) {
          if (!this._poolsByClass.has(ClassType)) {
            this._poolsByClass.set(ClassType, new Pool(ClassType));
          }
          return this._poolsByClass.get(ClassType);
        }
        /** gets the usage stats of each pool in the system */
        stats() {
          const stats = {};
          this._poolsByClass.forEach((pool) => {
            const name = stats[pool._classType.name] ? pool._classType.name + pool._classType.ID : pool._classType.name;
            stats[name] = {
              free: pool.totalFree,
              used: pool.totalUsed,
              size: pool.totalSize
            };
          });
          return stats;
        }
      };
      BigPool = new PoolGroupClass();
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.mjs
  var MaskEffectManagerClass, MaskEffectManager;
  var init_MaskEffectManager = __esm({
    "../core/node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.mjs"() {
      init_Extensions();
      init_PoolGroup();
      MaskEffectManagerClass = class {
        constructor() {
          this._effectClasses = [];
          this._tests = [];
          this._initialized = false;
        }
        init() {
          if (this._initialized)
            return;
          this._initialized = true;
          this._effectClasses.forEach((test) => {
            this.add({
              test: test.test,
              maskClass: test
            });
          });
        }
        add(test) {
          this._tests.push(test);
        }
        getMaskEffect(item) {
          if (!this._initialized)
            this.init();
          for (let i2 = 0; i2 < this._tests.length; i2++) {
            const test = this._tests[i2];
            if (test.test(item)) {
              return BigPool.get(test.maskClass, item);
            }
          }
          return item;
        }
        returnMaskEffect(effect) {
          BigPool.return(effect);
        }
      };
      MaskEffectManager = new MaskEffectManagerClass();
      extensions.handleByList(ExtensionType.MaskEffect, MaskEffectManager._effectClasses);
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.mjs
  var effectsMixin;
  var init_effectsMixin = __esm({
    "../core/node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.mjs"() {
      init_FilterEffect();
      init_MaskEffectManager();
      effectsMixin = {
        _maskEffect: null,
        _filterEffect: null,
        /**
         * @todo Needs docs.
         * @memberof scene.Container#
         * @type {Array<Effect>}
         */
        effects: [],
        /**
         * @todo Needs docs.
         * @param effect - The effect to add.
         * @memberof scene.Container#
         * @ignore
         */
        addEffect(effect) {
          const index = this.effects.indexOf(effect);
          if (index !== -1)
            return;
          this.effects.push(effect);
          this.effects.sort((a2, b2) => a2.priority - b2.priority);
          const renderGroup = this.renderGroup || this.parentRenderGroup;
          if (renderGroup) {
            renderGroup.structureDidChange = true;
          }
          this._updateIsSimple();
        },
        /**
         * @todo Needs docs.
         * @param effect - The effect to remove.
         * @memberof scene.Container#
         * @ignore
         */
        removeEffect(effect) {
          const index = this.effects.indexOf(effect);
          if (index === -1)
            return;
          this.effects.splice(index, 1);
          if (this.parentRenderGroup) {
            this.parentRenderGroup.structureDidChange = true;
          }
          this._updateIsSimple();
        },
        set mask(value) {
          const effect = this._maskEffect;
          if (effect?.mask === value)
            return;
          if (effect) {
            this.removeEffect(effect);
            MaskEffectManager.returnMaskEffect(effect);
            this._maskEffect = null;
          }
          if (value === null || value === void 0)
            return;
          this._maskEffect = MaskEffectManager.getMaskEffect(value);
          this.addEffect(this._maskEffect);
        },
        /**
         * Sets a mask for the displayObject. A mask is an object that limits the visibility of an
         * object to the shape of the mask applied to it. In PixiJS a regular mask must be a
         * {@link Graphics} or a {@link Sprite} object. This allows for much faster masking in canvas as it
         * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.
         * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.
         * To remove a mask, set this property to `null`.
         *
         * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.
         * @example
         * import { Graphics, Sprite } from 'pixi.js';
         *
         * const graphics = new Graphics();
         * graphics.beginFill(0xFF3300);
         * graphics.drawRect(50, 250, 100, 100);
         * graphics.endFill();
         *
         * const sprite = new Sprite(texture);
         * sprite.mask = graphics;
         * @memberof scene.Container#
         */
        get mask() {
          return this._maskEffect?.mask;
        },
        set filters(value) {
          if (!Array.isArray(value) && value)
            value = [value];
          const effect = this._filterEffect || (this._filterEffect = new FilterEffect());
          value = value;
          const hasFilters = value?.length > 0;
          const hadFilters = effect.filters?.length > 0;
          const didChange = hasFilters !== hadFilters;
          value = Array.isArray(value) ? value.slice(0) : value;
          effect.filters = Object.freeze(value);
          if (didChange) {
            if (hasFilters) {
              this.addEffect(effect);
            } else {
              this.removeEffect(effect);
              effect.filters = value ?? null;
            }
          }
        },
        /**
         * Sets the filters for the displayObject.
         * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.
         * To remove filters simply set this property to `'null'`.
         * @memberof scene.Container#
         */
        get filters() {
          return this._filterEffect?.filters;
        },
        set filterArea(value) {
          this._filterEffect || (this._filterEffect = new FilterEffect());
          this._filterEffect.filterArea = value;
        },
        /**
         * The area the filter is applied to. This is used as more of an optimization
         * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.
         *
         * Also works as an interaction mask.
         * @memberof scene.Container#
         */
        get filterArea() {
          return this._filterEffect?.filterArea;
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.mjs
  var findMixin;
  var init_findMixin = __esm({
    "../core/node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.mjs"() {
      init_deprecation();
      findMixin = {
        /**
         * The instance label of the object.
         * @memberof scene.Container#
         * @member {string} label
         */
        label: null,
        /**
         * The instance name of the object.
         * @deprecated since 8.0.0
         * @see scene.Container#label
         * @member {string} name
         * @memberof scene.Container#
         */
        get name() {
          deprecation(v8_0_0, "Container.name property has been removed, use Container.label instead");
          return this.label;
        },
        set name(value) {
          deprecation(v8_0_0, "Container.name property has been removed, use Container.label instead");
          this.label = value;
        },
        /**
         * @method getChildByName
         * @deprecated since 8.0.0
         * @param {string} name - Instance name.
         * @param {boolean}[deep=false] - Whether to search recursively
         * @returns {Container} The child with the specified name.
         * @see scene.Container#getChildByLabel
         * @memberof scene.Container#
         */
        getChildByName(name, deep = false) {
          return this.getChildByLabel(name, deep);
        },
        /**
         * Returns the first child in the container with the specified label.
         *
         * Recursive searches are done in a pre-order traversal.
         * @memberof scene.Container#
         * @param {string|RegExp} label - Instance label.
         * @param {boolean}[deep=false] - Whether to search recursively
         * @returns {Container} The child with the specified label.
         */
        getChildByLabel(label, deep = false) {
          const children2 = this.children;
          for (let i2 = 0; i2 < children2.length; i2++) {
            const child = children2[i2];
            if (child.label === label || label instanceof RegExp && label.test(child.label))
              return child;
          }
          if (deep) {
            for (let i2 = 0; i2 < children2.length; i2++) {
              const child = children2[i2];
              const found = child.getChildByLabel(label, true);
              if (found) {
                return found;
              }
            }
          }
          return null;
        },
        /**
         * Returns all children in the container with the specified label.
         * @memberof scene.Container#
         * @param {string|RegExp} label - Instance label.
         * @param {boolean}[deep=false] - Whether to search recursively
         * @param {Container[]} [out=[]] - The array to store matching children in.
         * @returns {Container[]} An array of children with the specified label.
         */
        getChildrenByLabel(label, deep = false, out2 = []) {
          const children2 = this.children;
          for (let i2 = 0; i2 < children2.length; i2++) {
            const child = children2[i2];
            if (child.label === label || label instanceof RegExp && label.test(child.label)) {
              out2.push(child);
            }
          }
          if (deep) {
            for (let i2 = 0; i2 < children2.length; i2++) {
              children2[i2].getChildrenByLabel(label, true, out2);
            }
          }
          return out2;
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs
  var tempPoints, Rectangle;
  var init_Rectangle = __esm({
    "../core/node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs"() {
      init_Point();
      tempPoints = [new Point(), new Point(), new Point(), new Point()];
      Rectangle = class {
        /**
         * @param x - The X coordinate of the upper-left corner of the rectangle
         * @param y - The Y coordinate of the upper-left corner of the rectangle
         * @param width - The overall width of the rectangle
         * @param height - The overall height of the rectangle
         */
        constructor(x2 = 0, y2 = 0, width = 0, height = 0) {
          this.type = "rectangle";
          this.x = Number(x2);
          this.y = Number(y2);
          this.width = Number(width);
          this.height = Number(height);
        }
        /** Returns the left edge of the rectangle. */
        get left() {
          return this.x;
        }
        /** Returns the right edge of the rectangle. */
        get right() {
          return this.x + this.width;
        }
        /** Returns the top edge of the rectangle. */
        get top() {
          return this.y;
        }
        /** Returns the bottom edge of the rectangle. */
        get bottom() {
          return this.y + this.height;
        }
        /** Determines whether the Rectangle is empty. */
        isEmpty() {
          return this.left === this.right || this.top === this.bottom;
        }
        /** A constant empty rectangle. This is a new object every time the property is accessed */
        static get EMPTY() {
          return new Rectangle(0, 0, 0, 0);
        }
        /**
         * Creates a clone of this Rectangle
         * @returns a copy of the rectangle
         */
        clone() {
          return new Rectangle(this.x, this.y, this.width, this.height);
        }
        /**
         * Converts a Bounds object to a Rectangle object.
         * @param bounds - The bounds to copy and convert to a rectangle.
         * @returns Returns itself.
         */
        copyFromBounds(bounds) {
          this.x = bounds.minX;
          this.y = bounds.minY;
          this.width = bounds.maxX - bounds.minX;
          this.height = bounds.maxY - bounds.minY;
          return this;
        }
        /**
         * Copies another rectangle to this one.
         * @param rectangle - The rectangle to copy from.
         * @returns Returns itself.
         */
        copyFrom(rectangle) {
          this.x = rectangle.x;
          this.y = rectangle.y;
          this.width = rectangle.width;
          this.height = rectangle.height;
          return this;
        }
        /**
         * Copies this rectangle to another one.
         * @param rectangle - The rectangle to copy to.
         * @returns Returns given parameter.
         */
        copyTo(rectangle) {
          rectangle.copyFrom(this);
          return rectangle;
        }
        /**
         * Checks whether the x and y coordinates given are contained within this Rectangle
         * @param x - The X coordinate of the point to test
         * @param y - The Y coordinate of the point to test
         * @returns Whether the x/y coordinates are within this Rectangle
         */
        contains(x2, y2) {
          if (this.width <= 0 || this.height <= 0) {
            return false;
          }
          if (x2 >= this.x && x2 < this.x + this.width) {
            if (y2 >= this.y && y2 < this.y + this.height) {
              return true;
            }
          }
          return false;
        }
        /**
         * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.
         * @param x - The X coordinate of the point to test
         * @param y - The Y coordinate of the point to test
         * @param strokeWidth - The width of the line to check
         * @returns Whether the x/y coordinates are within this rectangle
         */
        strokeContains(x2, y2, strokeWidth) {
          const { width, height } = this;
          if (width <= 0 || height <= 0)
            return false;
          const _x = this.x;
          const _y = this.y;
          const outerLeft = _x - strokeWidth / 2;
          const outerRight = _x + width + strokeWidth / 2;
          const outerTop = _y - strokeWidth / 2;
          const outerBottom = _y + height + strokeWidth / 2;
          const innerLeft = _x + strokeWidth / 2;
          const innerRight = _x + width - strokeWidth / 2;
          const innerTop = _y + strokeWidth / 2;
          const innerBottom = _y + height - strokeWidth / 2;
          return x2 >= outerLeft && x2 <= outerRight && y2 >= outerTop && y2 <= outerBottom && !(x2 > innerLeft && x2 < innerRight && y2 > innerTop && y2 < innerBottom);
        }
        /**
         * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.
         * Returns true only if the area of the intersection is >0, this means that Rectangles
         * sharing a side are not overlapping. Another side effect is that an arealess rectangle
         * (width or height equal to zero) can't intersect any other rectangle.
         * @param {Rectangle} other - The Rectangle to intersect with `this`.
         * @param {Matrix} transform - The transformation matrix of `other`.
         * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.
         */
        intersects(other, transform2) {
          if (!transform2) {
            const x02 = this.x < other.x ? other.x : this.x;
            const x12 = this.right > other.right ? other.right : this.right;
            if (x12 <= x02) {
              return false;
            }
            const y02 = this.y < other.y ? other.y : this.y;
            const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;
            return y12 > y02;
          }
          const x0 = this.left;
          const x1 = this.right;
          const y0 = this.top;
          const y1 = this.bottom;
          if (x1 <= x0 || y1 <= y0) {
            return false;
          }
          const lt = tempPoints[0].set(other.left, other.top);
          const lb = tempPoints[1].set(other.left, other.bottom);
          const rt = tempPoints[2].set(other.right, other.top);
          const rb = tempPoints[3].set(other.right, other.bottom);
          if (rt.x <= lt.x || lb.y <= lt.y) {
            return false;
          }
          const s2 = Math.sign(transform2.a * transform2.d - transform2.b * transform2.c);
          if (s2 === 0) {
            return false;
          }
          transform2.apply(lt, lt);
          transform2.apply(lb, lb);
          transform2.apply(rt, rt);
          transform2.apply(rb, rb);
          if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {
            return false;
          }
          const nx = s2 * (lb.y - lt.y);
          const ny = s2 * (lt.x - lb.x);
          const n00 = nx * x0 + ny * y0;
          const n10 = nx * x1 + ny * y0;
          const n01 = nx * x0 + ny * y1;
          const n11 = nx * x1 + ny * y1;
          if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {
            return false;
          }
          const mx = s2 * (lt.y - rt.y);
          const my = s2 * (rt.x - lt.x);
          const m00 = mx * x0 + my * y0;
          const m10 = mx * x1 + my * y0;
          const m01 = mx * x0 + my * y1;
          const m11 = mx * x1 + my * y1;
          if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {
            return false;
          }
          return true;
        }
        /**
         * Pads the rectangle making it grow in all directions.
         * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
         * @param paddingX - The horizontal padding amount.
         * @param paddingY - The vertical padding amount.
         * @returns Returns itself.
         */
        pad(paddingX = 0, paddingY = paddingX) {
          this.x -= paddingX;
          this.y -= paddingY;
          this.width += paddingX * 2;
          this.height += paddingY * 2;
          return this;
        }
        /**
         * Fits this rectangle around the passed one.
         * @param rectangle - The rectangle to fit.
         * @returns Returns itself.
         */
        fit(rectangle) {
          const x1 = Math.max(this.x, rectangle.x);
          const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
          const y1 = Math.max(this.y, rectangle.y);
          const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
          this.x = x1;
          this.width = Math.max(x2 - x1, 0);
          this.y = y1;
          this.height = Math.max(y2 - y1, 0);
          return this;
        }
        /**
         * Enlarges rectangle that way its corners lie on grid
         * @param resolution - resolution
         * @param eps - precision
         * @returns Returns itself.
         */
        ceil(resolution = 1, eps = 1e-3) {
          const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
          const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
          this.x = Math.floor((this.x + eps) * resolution) / resolution;
          this.y = Math.floor((this.y + eps) * resolution) / resolution;
          this.width = x2 - this.x;
          this.height = y2 - this.y;
          return this;
        }
        /**
         * Enlarges this rectangle to include the passed rectangle.
         * @param rectangle - The rectangle to include.
         * @returns Returns itself.
         */
        enlarge(rectangle) {
          const x1 = Math.min(this.x, rectangle.x);
          const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
          const y1 = Math.min(this.y, rectangle.y);
          const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
          this.x = x1;
          this.width = x2 - x1;
          this.y = y1;
          this.height = y2 - y1;
          return this;
        }
        /**
         * Returns the framing rectangle of the rectangle as a Rectangle object
         * @param out - optional rectangle to store the result
         * @returns The framing rectangle
         */
        getBounds(out2) {
          out2 = out2 || new Rectangle();
          out2.copyFrom(this);
          return out2;
        }
        toString() {
          return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs
  var defaultMatrix, Bounds;
  var init_Bounds = __esm({
    "../core/node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs"() {
      init_Matrix();
      init_Rectangle();
      defaultMatrix = new Matrix();
      Bounds = class {
        constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {
          this.minX = Infinity;
          this.minY = Infinity;
          this.maxX = -Infinity;
          this.maxY = -Infinity;
          this.matrix = defaultMatrix;
          this.minX = minX;
          this.minY = minY;
          this.maxX = maxX;
          this.maxY = maxY;
        }
        /**
         * Checks if bounds are empty.
         * @returns - True if empty.
         */
        isEmpty() {
          return this.minX > this.maxX || this.minY > this.maxY;
        }
        /** The bounding rectangle of the bounds. */
        get rectangle() {
          if (!this._rectangle) {
            this._rectangle = new Rectangle();
          }
          const rectangle = this._rectangle;
          if (this.minX > this.maxX || this.minY > this.maxY) {
            rectangle.x = 0;
            rectangle.y = 0;
            rectangle.width = 0;
            rectangle.height = 0;
          } else {
            rectangle.copyFromBounds(this);
          }
          return rectangle;
        }
        /** Clears the bounds and resets. */
        clear() {
          this.minX = Infinity;
          this.minY = Infinity;
          this.maxX = -Infinity;
          this.maxY = -Infinity;
          this.matrix = defaultMatrix;
          return this;
        }
        /**
         * Sets the bounds.
         * @param x0 - left X of frame
         * @param y0 - top Y of frame
         * @param x1 - right X of frame
         * @param y1 - bottom Y of frame
         */
        set(x0, y0, x1, y1) {
          this.minX = x0;
          this.minY = y0;
          this.maxX = x1;
          this.maxY = y1;
        }
        /**
         * Adds sprite frame
         * @param x0 - left X of frame
         * @param y0 - top Y of frame
         * @param x1 - right X of frame
         * @param y1 - bottom Y of frame
         * @param matrix
         */
        addFrame(x0, y0, x1, y1, matrix) {
          matrix || (matrix = this.matrix);
          const a2 = matrix.a;
          const b2 = matrix.b;
          const c2 = matrix.c;
          const d2 = matrix.d;
          const tx = matrix.tx;
          const ty = matrix.ty;
          let minX = this.minX;
          let minY = this.minY;
          let maxX = this.maxX;
          let maxY = this.maxY;
          let x2 = a2 * x0 + c2 * y0 + tx;
          let y2 = b2 * x0 + d2 * y0 + ty;
          if (x2 < minX)
            minX = x2;
          if (y2 < minY)
            minY = y2;
          if (x2 > maxX)
            maxX = x2;
          if (y2 > maxY)
            maxY = y2;
          x2 = a2 * x1 + c2 * y0 + tx;
          y2 = b2 * x1 + d2 * y0 + ty;
          if (x2 < minX)
            minX = x2;
          if (y2 < minY)
            minY = y2;
          if (x2 > maxX)
            maxX = x2;
          if (y2 > maxY)
            maxY = y2;
          x2 = a2 * x0 + c2 * y1 + tx;
          y2 = b2 * x0 + d2 * y1 + ty;
          if (x2 < minX)
            minX = x2;
          if (y2 < minY)
            minY = y2;
          if (x2 > maxX)
            maxX = x2;
          if (y2 > maxY)
            maxY = y2;
          x2 = a2 * x1 + c2 * y1 + tx;
          y2 = b2 * x1 + d2 * y1 + ty;
          if (x2 < minX)
            minX = x2;
          if (y2 < minY)
            minY = y2;
          if (x2 > maxX)
            maxX = x2;
          if (y2 > maxY)
            maxY = y2;
          this.minX = minX;
          this.minY = minY;
          this.maxX = maxX;
          this.maxY = maxY;
        }
        /**
         * Adds a rectangle to the bounds.
         * @param rect - The rectangle to be added.
         * @param matrix - The matrix to apply to the bounds.
         */
        addRect(rect, matrix) {
          this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, matrix);
        }
        /**
         * Adds other {@link Bounds}.
         * @param bounds - The Bounds to be added
         * @param matrix
         */
        addBounds(bounds, matrix) {
          this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY, matrix);
        }
        /**
         * Adds other Bounds, masked with Bounds.
         * @param mask - The Bounds to be added.
         */
        addBoundsMask(mask) {
          this.minX = this.minX > mask.minX ? this.minX : mask.minX;
          this.minY = this.minY > mask.minY ? this.minY : mask.minY;
          this.maxX = this.maxX < mask.maxX ? this.maxX : mask.maxX;
          this.maxY = this.maxY < mask.maxY ? this.maxY : mask.maxY;
        }
        /**
         * Adds other Bounds, multiplied with matrix.
         * @param matrix - The matrix to apply to the bounds.
         */
        applyMatrix(matrix) {
          const minX = this.minX;
          const minY = this.minY;
          const maxX = this.maxX;
          const maxY = this.maxY;
          const { a: a2, b: b2, c: c2, d: d2, tx, ty } = matrix;
          let x2 = a2 * minX + c2 * minY + tx;
          let y2 = b2 * minX + d2 * minY + ty;
          this.minX = x2;
          this.minY = y2;
          this.maxX = x2;
          this.maxY = y2;
          x2 = a2 * maxX + c2 * minY + tx;
          y2 = b2 * maxX + d2 * minY + ty;
          this.minX = x2 < this.minX ? x2 : this.minX;
          this.minY = y2 < this.minY ? y2 : this.minY;
          this.maxX = x2 > this.maxX ? x2 : this.maxX;
          this.maxY = y2 > this.maxY ? y2 : this.maxY;
          x2 = a2 * minX + c2 * maxY + tx;
          y2 = b2 * minX + d2 * maxY + ty;
          this.minX = x2 < this.minX ? x2 : this.minX;
          this.minY = y2 < this.minY ? y2 : this.minY;
          this.maxX = x2 > this.maxX ? x2 : this.maxX;
          this.maxY = y2 > this.maxY ? y2 : this.maxY;
          x2 = a2 * maxX + c2 * maxY + tx;
          y2 = b2 * maxX + d2 * maxY + ty;
          this.minX = x2 < this.minX ? x2 : this.minX;
          this.minY = y2 < this.minY ? y2 : this.minY;
          this.maxX = x2 > this.maxX ? x2 : this.maxX;
          this.maxY = y2 > this.maxY ? y2 : this.maxY;
        }
        /**
         * Resizes the bounds object to include the given rectangle.
         * @param rect - The rectangle to be included.
         */
        fit(rect) {
          if (this.minX < rect.left)
            this.minX = rect.left;
          if (this.maxX > rect.right)
            this.maxX = rect.right;
          if (this.minY < rect.top)
            this.minY = rect.top;
          if (this.maxY > rect.bottom)
            this.maxY = rect.bottom;
          return this;
        }
        /**
         * Resizes the bounds object to include the given bounds.
         * @param left - The left value of the bounds.
         * @param right - The right value of the bounds.
         * @param top - The top value of the bounds.
         * @param bottom - The bottom value of the bounds.
         */
        fitBounds(left, right, top, bottom) {
          if (this.minX < left)
            this.minX = left;
          if (this.maxX > right)
            this.maxX = right;
          if (this.minY < top)
            this.minY = top;
          if (this.maxY > bottom)
            this.maxY = bottom;
          return this;
        }
        /**
         * Pads bounds object, making it grow in all directions.
         * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
         * @param paddingX - The horizontal padding amount.
         * @param paddingY - The vertical padding amount.
         */
        pad(paddingX, paddingY = paddingX) {
          this.minX -= paddingX;
          this.maxX += paddingX;
          this.minY -= paddingY;
          this.maxY += paddingY;
          return this;
        }
        /** Ceils the bounds. */
        ceil() {
          this.minX = Math.floor(this.minX);
          this.minY = Math.floor(this.minY);
          this.maxX = Math.ceil(this.maxX);
          this.maxY = Math.ceil(this.maxY);
          return this;
        }
        /** Clones the bounds. */
        clone() {
          return new Bounds(this.minX, this.minY, this.maxX, this.maxY);
        }
        /**
         * Scales the bounds by the given values
         * @param x - The X value to scale by.
         * @param y - The Y value to scale by.
         */
        scale(x2, y2 = x2) {
          this.minX *= x2;
          this.minY *= y2;
          this.maxX *= x2;
          this.maxY *= y2;
          return this;
        }
        /** the x value of the bounds. */
        get x() {
          return this.minX;
        }
        set x(value) {
          const width = this.maxX - this.minX;
          this.minX = value;
          this.maxX = value + width;
        }
        /** the y value of the bounds. */
        get y() {
          return this.minY;
        }
        set y(value) {
          const height = this.maxY - this.minY;
          this.minY = value;
          this.maxY = value + height;
        }
        /** the width value of the bounds. */
        get width() {
          return this.maxX - this.minX;
        }
        set width(value) {
          this.maxX = this.minX + value;
        }
        /** the height value of the bounds. */
        get height() {
          return this.maxY - this.minY;
        }
        set height(value) {
          this.maxY = this.minY + value;
        }
        /** the left value of the bounds. */
        get left() {
          return this.minX;
        }
        /** the right value of the bounds. */
        get right() {
          return this.maxX;
        }
        /** the top value of the bounds. */
        get top() {
          return this.minY;
        }
        /** the bottom value of the bounds. */
        get bottom() {
          return this.maxY;
        }
        /** Is the bounds positive. */
        get isPositive() {
          return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;
        }
        get isValid() {
          return this.minX + this.minY !== Infinity;
        }
        /**
         * Adds screen vertices from array
         * @param vertexData - calculated vertices
         * @param beginOffset - begin offset
         * @param endOffset - end offset, excluded
         * @param matrix
         */
        addVertexData(vertexData, beginOffset, endOffset, matrix) {
          let minX = this.minX;
          let minY = this.minY;
          let maxX = this.maxX;
          let maxY = this.maxY;
          matrix || (matrix = this.matrix);
          const a2 = matrix.a;
          const b2 = matrix.b;
          const c2 = matrix.c;
          const d2 = matrix.d;
          const tx = matrix.tx;
          const ty = matrix.ty;
          for (let i2 = beginOffset; i2 < endOffset; i2 += 2) {
            const localX = vertexData[i2];
            const localY = vertexData[i2 + 1];
            const x2 = a2 * localX + c2 * localY + tx;
            const y2 = b2 * localX + d2 * localY + ty;
            minX = x2 < minX ? x2 : minX;
            minY = y2 < minY ? y2 : minY;
            maxX = x2 > maxX ? x2 : maxX;
            maxY = y2 > maxY ? y2 : maxY;
          }
          this.minX = minX;
          this.minY = minY;
          this.maxX = maxX;
          this.maxY = maxY;
        }
        /**
         * Checks if the point is contained within the bounds.
         * @param x - x coordinate
         * @param y - y coordinate
         */
        containsPoint(x2, y2) {
          if (this.minX <= x2 && this.minY <= y2 && this.maxX >= x2 && this.maxY >= y2) {
            return true;
          }
          return false;
        }
        toString() {
          return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs
  var matrixPool, boundsPool;
  var init_matrixAndBoundsPool = __esm({
    "../core/node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs"() {
      init_Matrix();
      init_Pool();
      init_Bounds();
      matrixPool = new Pool(Matrix);
      boundsPool = new Pool(Bounds);
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs
  function getGlobalBounds(target, skipUpdateTransform, bounds) {
    bounds.clear();
    let parentTransform;
    let pooledMatrix;
    if (target.parent) {
      if (!skipUpdateTransform) {
        pooledMatrix = matrixPool.get().identity();
        parentTransform = updateTransformBackwards(target, pooledMatrix);
      } else {
        parentTransform = target.parent.worldTransform;
      }
    } else {
      parentTransform = Matrix.IDENTITY;
    }
    _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform);
    if (pooledMatrix) {
      matrixPool.return(pooledMatrix);
    }
    if (!bounds.isValid) {
      bounds.set(0, 0, 0, 0);
    }
    return bounds;
  }
  function _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform) {
    if (!target.visible || !target.measurable)
      return;
    let worldTransform;
    if (!skipUpdateTransform) {
      target.updateLocalTransform();
      worldTransform = matrixPool.get();
      worldTransform.appendFrom(target.localTransform, parentTransform);
    } else {
      worldTransform = target.worldTransform;
    }
    const parentBounds = bounds;
    const preserveBounds = !!target.effects.length;
    if (preserveBounds) {
      bounds = boundsPool.get().clear();
    }
    if (target.boundsArea) {
      bounds.addRect(target.boundsArea, worldTransform);
    } else {
      if (target.addBounds) {
        bounds.matrix = worldTransform;
        target.addBounds(bounds);
      }
      for (let i2 = 0; i2 < target.children.length; i2++) {
        _getGlobalBounds(target.children[i2], bounds, worldTransform, skipUpdateTransform);
      }
    }
    if (preserveBounds) {
      for (let i2 = 0; i2 < target.effects.length; i2++) {
        target.effects[i2].addBounds?.(bounds);
      }
      parentBounds.addBounds(bounds, Matrix.IDENTITY);
      boundsPool.return(bounds);
    }
    if (!skipUpdateTransform) {
      matrixPool.return(worldTransform);
    }
  }
  function updateTransformBackwards(target, parentTransform) {
    const parent = target.parent;
    if (parent) {
      updateTransformBackwards(parent, parentTransform);
      parent.updateLocalTransform();
      parentTransform.append(parent.localTransform);
    }
    return parentTransform;
  }
  var init_getGlobalBounds = __esm({
    "../core/node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs"() {
      init_Matrix();
      init_matrixAndBoundsPool();
    }
  });

  // ../core/node_modules/pixi.js/lib/utils/logging/warn.mjs
  function warn(...args) {
    if (warnCount === maxWarnings)
      return;
    warnCount++;
    if (warnCount === maxWarnings) {
      console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.");
    } else {
      console.warn("PixiJS Warning: ", ...args);
    }
  }
  var warnCount, maxWarnings;
  var init_warn = __esm({
    "../core/node_modules/pixi.js/lib/utils/logging/warn.mjs"() {
      "use strict";
      warnCount = 0;
      maxWarnings = 500;
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs
  function getLocalBounds(target, bounds, relativeMatrix) {
    bounds.clear();
    relativeMatrix || (relativeMatrix = Matrix.IDENTITY);
    _getLocalBounds(target, bounds, relativeMatrix, target, true);
    if (!bounds.isValid) {
      bounds.set(0, 0, 0, 0);
    }
    return bounds;
  }
  function _getLocalBounds(target, bounds, parentTransform, rootContainer, isRoot) {
    let relativeTransform;
    if (!isRoot) {
      if (!target.visible || !target.measurable)
        return;
      target.updateLocalTransform();
      const localTransform = target.localTransform;
      relativeTransform = matrixPool.get();
      relativeTransform.appendFrom(localTransform, parentTransform);
    } else {
      relativeTransform = matrixPool.get();
      relativeTransform = parentTransform.copyTo(relativeTransform);
    }
    const parentBounds = bounds;
    const preserveBounds = !!target.effects.length;
    if (preserveBounds) {
      bounds = boundsPool.get().clear();
    }
    if (target.boundsArea) {
      bounds.addRect(target.boundsArea, relativeTransform);
    } else {
      if (target.renderPipeId) {
        bounds.matrix = relativeTransform;
        target.addBounds(bounds);
      }
      const children2 = target.children;
      for (let i2 = 0; i2 < children2.length; i2++) {
        _getLocalBounds(children2[i2], bounds, relativeTransform, rootContainer, false);
      }
    }
    if (preserveBounds) {
      for (let i2 = 0; i2 < target.effects.length; i2++) {
        target.effects[i2].addLocalBounds?.(bounds, rootContainer);
      }
      parentBounds.addBounds(bounds, Matrix.IDENTITY);
      boundsPool.return(bounds);
    }
    matrixPool.return(relativeTransform);
  }
  var init_getLocalBounds = __esm({
    "../core/node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs"() {
      init_Matrix();
      init_matrixAndBoundsPool();
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/container/utils/checkChildrenDidChange.mjs
  function checkChildrenDidChange(container, previousData) {
    const children2 = container.children;
    for (let i2 = 0; i2 < children2.length; i2++) {
      const child = children2[i2];
      const changeId = (child.uid & 255) << 24 | child._didChangeId & 16777215;
      if (previousData.data[previousData.index] !== changeId) {
        previousData.data[previousData.index] = changeId;
        previousData.didChange = true;
      }
      previousData.index++;
      if (child.children.length) {
        checkChildrenDidChange(child, previousData);
      }
    }
    return previousData.didChange;
  }
  var init_checkChildrenDidChange = __esm({
    "../core/node_modules/pixi.js/lib/scene/container/utils/checkChildrenDidChange.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.mjs
  var tempMatrix2, measureMixin;
  var init_measureMixin = __esm({
    "../core/node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.mjs"() {
      init_Matrix();
      init_Bounds();
      init_getGlobalBounds();
      init_getLocalBounds();
      init_checkChildrenDidChange();
      tempMatrix2 = new Matrix();
      measureMixin = {
        _localBoundsCacheId: -1,
        _localBoundsCacheData: null,
        _setWidth(value, localWidth) {
          const sign = Math.sign(this.scale.x) || 1;
          if (localWidth !== 0) {
            this.scale.x = value / localWidth * sign;
          } else {
            this.scale.x = sign;
          }
        },
        _setHeight(value, localHeight) {
          const sign = Math.sign(this.scale.y) || 1;
          if (localHeight !== 0) {
            this.scale.y = value / localHeight * sign;
          } else {
            this.scale.y = sign;
          }
        },
        /**
         * Retrieves the local bounds of the container as a Bounds object.
         * @returns - The bounding area.
         * @memberof scene.Container#
         */
        getLocalBounds() {
          if (!this._localBoundsCacheData) {
            this._localBoundsCacheData = {
              data: [],
              index: 1,
              didChange: false,
              localBounds: new Bounds()
            };
          }
          const localBoundsCacheData = this._localBoundsCacheData;
          localBoundsCacheData.index = 1;
          localBoundsCacheData.didChange = false;
          if (localBoundsCacheData.data[0] !== this._didChangeId >> 12) {
            localBoundsCacheData.didChange = true;
            localBoundsCacheData.data[0] = this._didChangeId >> 12;
          }
          checkChildrenDidChange(this, localBoundsCacheData);
          if (localBoundsCacheData.didChange) {
            getLocalBounds(this, localBoundsCacheData.localBounds, tempMatrix2);
          }
          return localBoundsCacheData.localBounds;
        },
        /**
         * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link Rectangle}.
         * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from
         *  being updated. This means the calculation returned MAY be out of date BUT will give you a
         *  nice performance boost.
         * @param bounds - Optional bounds to store the result of the bounds calculation.
         * @returns - The minimum axis-aligned rectangle in world space that fits around this object.
         * @memberof scene.Container#
         */
        getBounds(skipUpdate, bounds) {
          return getGlobalBounds(this, skipUpdate, bounds || new Bounds());
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.mjs
  var onRenderMixin;
  var init_onRenderMixin = __esm({
    "../core/node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.mjs"() {
      "use strict";
      onRenderMixin = {
        _onRender: null,
        set onRender(func) {
          const renderGroup = this.renderGroup || this.parentRenderGroup;
          if (!func) {
            if (this._onRender) {
              renderGroup?.removeOnRender(this);
            }
            this._onRender = null;
            return;
          }
          if (!this._onRender) {
            renderGroup?.addOnRender(this);
          }
          this._onRender = func;
        },
        /**
         * This callback is used when the container is rendered. This is where you should add your custom
         * logic that is needed to be run every frame.
         *
         * In v7 many users used `updateTransform` for this, however the way v8 renders objects is different
         * and "updateTransform" is no longer called every frame
         * @example
         * const container = new Container();
         * container.onRender = () => {
         *    container.rotation += 0.01;
         * };
         * @memberof scene.Container#
         */
        get onRender() {
          return this._onRender;
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.mjs
  function sortChildren(a2, b2) {
    return a2._zIndex - b2._zIndex;
  }
  var sortMixin;
  var init_sortMixin = __esm({
    "../core/node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.mjs"() {
      "use strict";
      sortMixin = {
        _zIndex: 0,
        /**
         * Should children be sorted by zIndex at the next render call.
         *
         * Will get automatically set to true if a new child is added, or if a child's zIndex changes.
         * @type {boolean}
         * @memberof scene.Container#
         */
        sortDirty: false,
        /**
         * If set to true, the container will sort its children by `zIndex` value
         * when the next render is called, or manually if `sortChildren()` is called.
         *
         * This actually changes the order of elements in the array, so should be treated
         * as a basic solution that is not performant compared to other solutions,
         * such as {@link https://github.com/pixijs/layers PixiJS Layers}
         *
         * Also be aware of that this may not work nicely with the `addChildAt()` function,
         * as the `zIndex` sorting may cause the child to automatically sorted to another position.
         * @type {boolean}
         * @memberof scene.Container#
         */
        sortableChildren: false,
        /**
         * The zIndex of the container.
         *
         * Setting this value, will automatically set the parent to be sortable. Children will be automatically
         * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,
         * and thus rendered on top of other display objects within the same container.
         * @see scene.Container#sortableChildren
         * @memberof scene.Container#
         */
        get zIndex() {
          return this._zIndex;
        },
        set zIndex(value) {
          if (this._zIndex === value)
            return;
          this._zIndex = value;
          this.depthOfChildModified();
        },
        depthOfChildModified() {
          if (this.parent) {
            this.parent.sortableChildren = true;
            this.parent.sortDirty = true;
          }
          if (this.parentRenderGroup) {
            this.parentRenderGroup.structureDidChange = true;
          }
        },
        /**
         * Sorts children by zIndex.
         * @memberof scene.Container#
         */
        sortChildren() {
          if (!this.sortDirty)
            return;
          this.sortDirty = false;
          this.children.sort(sortChildren);
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs
  var toLocalGlobalMixin;
  var init_toLocalGlobalMixin = __esm({
    "../core/node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs"() {
      init_Matrix();
      init_Point();
      init_getGlobalBounds();
      toLocalGlobalMixin = {
        /**
         * Returns the global position of the container.
         * @param point - The optional point to write the global value to.
         * @param skipUpdate - Should we skip the update transform.
         * @returns - The updated point.
         * @memberof scene.Container#
         */
        getGlobalPosition(point = new Point(), skipUpdate = false) {
          if (this.parent) {
            this.parent.toGlobal(this._position, point, skipUpdate);
          } else {
            point.x = this._position.x;
            point.y = this._position.y;
          }
          return point;
        },
        /**
         * Calculates the global position of the container.
         * @param position - The world origin to calculate from.
         * @param point - A Point object in which to store the value, optional
         *  (otherwise will create a new Point).
         * @param skipUpdate - Should we skip the update transform.
         * @returns - A point object representing the position of this object.
         * @memberof scene.Container#
         */
        toGlobal(position, point, skipUpdate = false) {
          if (!skipUpdate) {
            this.updateLocalTransform();
            const globalMatrix = updateTransformBackwards(this, new Matrix());
            globalMatrix.append(this.localTransform);
            return globalMatrix.apply(position, point);
          }
          return this.worldTransform.apply(position, point);
        },
        /**
         * Calculates the local position of the container relative to another point.
         * @param position - The world origin to calculate from.
         * @param from - The Container to calculate the global position from.
         * @param point - A Point object in which to store the value, optional
         *  (otherwise will create a new Point).
         * @param skipUpdate - Should we skip the update transform
         * @returns - A point object representing the position of this object
         * @memberof scene.Container#
         */
        toLocal(position, from3, point, skipUpdate) {
          if (from3) {
            position = from3.toGlobal(position, point, skipUpdate);
          }
          if (!skipUpdate) {
            this.updateLocalTransform();
            const globalMatrix = updateTransformBackwards(this, new Matrix());
            globalMatrix.append(this.localTransform);
            return globalMatrix.applyInverse(position, point);
          }
          return this.worldTransform.applyInverse(position, point);
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs
  var InstructionSet;
  var init_InstructionSet = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs"() {
      init_uid();
      InstructionSet = class {
        constructor() {
          this.uid = uid("instructionSet");
          this.instructions = [];
          this.instructionSize = 0;
        }
        /** reset the instruction set so it can be reused set size back to 0 */
        reset() {
          this.instructionSize = 0;
        }
        /**
         * Add an instruction to the set
         * @param instruction - add an instruction to the set
         */
        add(instruction) {
          this.instructions[this.instructionSize++] = instruction;
        }
        /**
         * Log the instructions to the console (for debugging)
         * @internal
         * @ignore
         */
        log() {
          this.instructions.length = this.instructionSize;
          console.table(this.instructions, ["type", "action"]);
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/container/RenderGroup.mjs
  var RenderGroup;
  var init_RenderGroup = __esm({
    "../core/node_modules/pixi.js/lib/scene/container/RenderGroup.mjs"() {
      init_Matrix();
      init_InstructionSet();
      RenderGroup = class {
        constructor(root) {
          this.renderPipeId = "renderGroup";
          this.root = null;
          this.canBundle = false;
          this.renderGroupParent = null;
          this.renderGroupChildren = [];
          this.worldTransform = new Matrix();
          this.worldColorAlpha = 4294967295;
          this.worldColor = 16777215;
          this.worldAlpha = 1;
          this.childrenToUpdate = /* @__PURE__ */ Object.create(null);
          this.updateTick = 0;
          this.childrenRenderablesToUpdate = { list: [], index: 0 };
          this.structureDidChange = true;
          this.instructionSet = new InstructionSet();
          this._onRenderContainers = [];
          this.root = root;
          if (root._onRender)
            this.addOnRender(root);
          root.didChange = true;
          const children2 = root.children;
          for (let i2 = 0; i2 < children2.length; i2++) {
            this.addChild(children2[i2]);
          }
        }
        get localTransform() {
          return this.root.localTransform;
        }
        addRenderGroupChild(renderGroupChild) {
          if (renderGroupChild.renderGroupParent) {
            renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);
          }
          renderGroupChild.renderGroupParent = this;
          this.renderGroupChildren.push(renderGroupChild);
        }
        _removeRenderGroupChild(renderGroupChild) {
          const index = this.renderGroupChildren.indexOf(renderGroupChild);
          if (index > -1) {
            this.renderGroupChildren.splice(index, 1);
          }
          renderGroupChild.renderGroupParent = null;
        }
        addChild(child) {
          this.structureDidChange = true;
          child.parentRenderGroup = this;
          child.updateTick = -1;
          if (child.parent === this.root) {
            child.relativeRenderGroupDepth = 1;
          } else {
            child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;
          }
          child.didChange = true;
          this.onChildUpdate(child);
          if (child.renderGroup) {
            this.addRenderGroupChild(child.renderGroup);
            return;
          }
          if (child._onRender)
            this.addOnRender(child);
          const children2 = child.children;
          for (let i2 = 0; i2 < children2.length; i2++) {
            this.addChild(children2[i2]);
          }
        }
        removeChild(child) {
          this.structureDidChange = true;
          if (child._onRender) {
            if (!child.renderGroup) {
              this.removeOnRender(child);
            }
          }
          child.parentRenderGroup = null;
          if (child.renderGroup) {
            this._removeRenderGroupChild(child.renderGroup);
            return;
          }
          const children2 = child.children;
          for (let i2 = 0; i2 < children2.length; i2++) {
            this.removeChild(children2[i2]);
          }
        }
        removeChildren(children2) {
          for (let i2 = 0; i2 < children2.length; i2++) {
            this.removeChild(children2[i2]);
          }
        }
        onChildUpdate(child) {
          let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];
          if (!childrenToUpdate) {
            childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {
              index: 0,
              list: []
            };
          }
          childrenToUpdate.list[childrenToUpdate.index++] = child;
        }
        // SHOULD THIS BE HERE?
        updateRenderable(container) {
          if (container.globalDisplayStatus < 7)
            return;
          container.didViewUpdate = false;
          this.instructionSet.renderPipes[container.renderPipeId].updateRenderable(container);
        }
        onChildViewUpdate(child) {
          this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;
        }
        get isRenderable() {
          return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;
        }
        /**
         * adding a container to the onRender list will make sure the user function
         * passed in to the user defined 'onRender` callBack
         * @param container - the container to add to the onRender list
         */
        addOnRender(container) {
          this._onRenderContainers.push(container);
        }
        removeOnRender(container) {
          this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);
        }
        runOnRender() {
          for (let i2 = 0; i2 < this._onRenderContainers.length; i2++) {
            this._onRenderContainers[i2]._onRender();
          }
        }
        getChildren(out2 = []) {
          const children2 = this.root.children;
          for (let i2 = 0; i2 < children2.length; i2++) {
            this._getChildren(children2[i2], out2);
          }
          return out2;
        }
        _getChildren(container, out2 = []) {
          out2.push(container);
          if (container.renderGroup)
            return out2;
          const children2 = container.children;
          for (let i2 = 0; i2 < children2.length; i2++) {
            this._getChildren(children2[i2], out2);
          }
          return out2;
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/container/utils/assignWithIgnore.mjs
  function assignWithIgnore(target, options, ignore = {}) {
    for (const key in options) {
      if (!ignore[key] && options[key] !== void 0) {
        target[key] = options[key];
      }
    }
  }
  var init_assignWithIgnore = __esm({
    "../core/node_modules/pixi.js/lib/scene/container/utils/assignWithIgnore.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/container/Container.mjs
  var defaultSkew, defaultPivot, defaultScale, UPDATE_COLOR, UPDATE_BLEND, UPDATE_VISIBLE, Container;
  var init_Container = __esm({
    "../core/node_modules/pixi.js/lib/scene/container/Container.mjs"() {
      init_eventemitter3();
      init_Color();
      init_cullingMixin();
      init_Matrix();
      init_const();
      init_ObservablePoint();
      init_uid();
      init_deprecation();
      init_childrenHelperMixin();
      init_effectsMixin();
      init_findMixin();
      init_measureMixin();
      init_onRenderMixin();
      init_sortMixin();
      init_toLocalGlobalMixin();
      init_RenderGroup();
      init_assignWithIgnore();
      defaultSkew = new ObservablePoint(null);
      defaultPivot = new ObservablePoint(null);
      defaultScale = new ObservablePoint(null, 1, 1);
      UPDATE_COLOR = 1;
      UPDATE_BLEND = 2;
      UPDATE_VISIBLE = 4;
      Container = class extends eventemitter3_default {
        constructor(options = {}) {
          super();
          this.uid = uid("renderable");
          this._updateFlags = 15;
          this.renderGroup = null;
          this.parentRenderGroup = null;
          this.parentRenderGroupIndex = 0;
          this.didChange = false;
          this.didViewUpdate = false;
          this.relativeRenderGroupDepth = 0;
          this.children = [];
          this.parent = null;
          this.includeInBuild = true;
          this.measurable = true;
          this.isSimple = true;
          this.updateTick = -1;
          this.localTransform = new Matrix();
          this.relativeGroupTransform = new Matrix();
          this.groupTransform = this.relativeGroupTransform;
          this.destroyed = false;
          this._position = new ObservablePoint(this, 0, 0);
          this._scale = defaultScale;
          this._pivot = defaultPivot;
          this._skew = defaultSkew;
          this._cx = 1;
          this._sx = 0;
          this._cy = 0;
          this._sy = 1;
          this._rotation = 0;
          this.localColor = 16777215;
          this.localAlpha = 1;
          this.groupAlpha = 1;
          this.groupColor = 16777215;
          this.groupColorAlpha = 4294967295;
          this.localBlendMode = "inherit";
          this.groupBlendMode = "normal";
          this.localDisplayStatus = 7;
          this.globalDisplayStatus = 7;
          this._didChangeId = 0;
          this._didLocalTransformChangeId = -1;
          assignWithIgnore(this, options, {
            children: true,
            parent: true,
            effects: true
          });
          options.children?.forEach((child) => this.addChild(child));
          this.effects = [];
          options.parent?.addChild(this);
        }
        /**
         * Mixes all enumerable properties and methods from a source object to Container.
         * @param source - The source of properties and methods to mix in.
         */
        static mixin(source2) {
          Object.defineProperties(Container.prototype, Object.getOwnPropertyDescriptors(source2));
        }
        /**
         * Adds one or more children to the container.
         *
         * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`
         * @param {...Container} children - The Container(s) to add to the container
         * @returns {Container} - The first child that was added.
         */
        addChild(...children2) {
          if (!this.allowChildren) {
            deprecation(v8_0_0, "addChild: Only Containers will be allowed to add children in v8.0.0");
          }
          if (children2.length > 1) {
            for (let i2 = 0; i2 < children2.length; i2++) {
              this.addChild(children2[i2]);
            }
            return children2[0];
          }
          const child = children2[0];
          if (child.parent === this) {
            this.children.splice(this.children.indexOf(child), 1);
            this.children.push(child);
            if (this.parentRenderGroup) {
              this.parentRenderGroup.structureDidChange = true;
            }
            return child;
          }
          if (child.parent) {
            child.parent.removeChild(child);
          }
          this.children.push(child);
          if (this.sortableChildren)
            this.sortDirty = true;
          child.parent = this;
          child.didChange = true;
          child.didViewUpdate = false;
          child._updateFlags = 15;
          const renderGroup = this.renderGroup || this.parentRenderGroup;
          if (renderGroup) {
            renderGroup.addChild(child);
          }
          this.emit("childAdded", child, this, this.children.length - 1);
          child.emit("added", this);
          this._didChangeId += 1 << 12;
          if (child._zIndex !== 0) {
            child.depthOfChildModified();
          }
          return child;
        }
        /**
         * Removes one or more children from the container.
         * @param {...Container} children - The Container(s) to remove
         * @returns {Container} The first child that was removed.
         */
        removeChild(...children2) {
          if (children2.length > 1) {
            for (let i2 = 0; i2 < children2.length; i2++) {
              this.removeChild(children2[i2]);
            }
            return children2[0];
          }
          const child = children2[0];
          const index = this.children.indexOf(child);
          if (index > -1) {
            this._didChangeId += 1 << 12;
            this.children.splice(index, 1);
            if (this.renderGroup) {
              this.renderGroup.removeChild(child);
            } else if (this.parentRenderGroup) {
              this.parentRenderGroup.removeChild(child);
            }
            child.parent = null;
            this.emit("childRemoved", child, this, index);
            child.emit("removed", this);
          }
          return child;
        }
        /** @ignore */
        _onUpdate(point) {
          if (point) {
            if (point === this._skew) {
              this._updateSkew();
            }
          }
          this._didChangeId++;
          if (this.didChange)
            return;
          this.didChange = true;
          if (this.parentRenderGroup) {
            this.parentRenderGroup.onChildUpdate(this);
          }
        }
        set isRenderGroup(value) {
          if (this.renderGroup && value === false) {
            throw new Error("[Pixi] cannot undo a render group just yet");
          }
          if (value) {
            this.enableRenderGroup();
          }
        }
        /**
         * Returns true if this container is a render group.
         * This means that it will be rendered as a separate pass, with its own set of instructions
         */
        get isRenderGroup() {
          return !!this.renderGroup;
        }
        /** This enables the container to be rendered as a render group. */
        enableRenderGroup() {
          if (this.renderGroup)
            return;
          const parentRenderGroup = this.parentRenderGroup;
          if (parentRenderGroup) {
            parentRenderGroup.removeChild(this);
          }
          this.renderGroup = new RenderGroup(this);
          if (parentRenderGroup) {
            parentRenderGroup.addChild(this);
          }
          this._updateIsSimple();
          this.groupTransform = Matrix.IDENTITY;
        }
        /** @ignore */
        _updateIsSimple() {
          this.isSimple = !this.renderGroup && this.effects.length === 0;
        }
        /**
         * Current transform of the object based on world (parent) factors.
         * @readonly
         */
        get worldTransform() {
          this._worldTransform || (this._worldTransform = new Matrix());
          if (this.renderGroup) {
            this._worldTransform.copyFrom(this.renderGroup.worldTransform);
          } else if (this.parentRenderGroup) {
            this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform);
          }
          return this._worldTransform;
        }
        // / ////// transform related stuff
        /**
         * The position of the container on the x axis relative to the local coordinates of the parent.
         * An alias to position.x
         */
        get x() {
          return this._position.x;
        }
        set x(value) {
          this._position.x = value;
        }
        /**
         * The position of the container on the y axis relative to the local coordinates of the parent.
         * An alias to position.y
         */
        get y() {
          return this._position.y;
        }
        set y(value) {
          this._position.y = value;
        }
        /**
         * The coordinate of the object relative to the local coordinates of the parent.
         * @since 4.0.0
         */
        get position() {
          return this._position;
        }
        set position(value) {
          this._position.copyFrom(value);
        }
        /**
         * The rotation of the object in radians.
         * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
         */
        get rotation() {
          return this._rotation;
        }
        set rotation(value) {
          if (this._rotation !== value) {
            this._rotation = value;
            this._onUpdate(this._skew);
          }
        }
        /**
         * The angle of the object in degrees.
         * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
         */
        get angle() {
          return this.rotation * RAD_TO_DEG;
        }
        set angle(value) {
          this.rotation = value * DEG_TO_RAD;
        }
        /**
         * The center of rotation, scaling, and skewing for this display object in its local space. The `position`
         * is the projection of `pivot` in the parent's local space.
         *
         * By default, the pivot is the origin (0, 0).
         * @since 4.0.0
         */
        get pivot() {
          if (this._pivot === defaultPivot) {
            this._pivot = new ObservablePoint(this, 0, 0);
          }
          return this._pivot;
        }
        set pivot(value) {
          if (this._pivot === defaultPivot) {
            this._pivot = new ObservablePoint(this, 0, 0);
          }
          typeof value === "number" ? this._pivot.set(value) : this._pivot.copyFrom(value);
        }
        /**
         * The skew factor for the object in radians.
         * @since 4.0.0
         */
        get skew() {
          if (this._skew === defaultSkew) {
            this._skew = new ObservablePoint(this, 0, 0);
          }
          return this._skew;
        }
        set skew(value) {
          if (this._skew === defaultSkew) {
            this._skew = new ObservablePoint(this, 0, 0);
          }
          this._skew.copyFrom(value);
        }
        /**
         * The scale factors of this object along the local coordinate axes.
         *
         * The default scale is (1, 1).
         * @since 4.0.0
         */
        get scale() {
          if (this._scale === defaultScale) {
            this._scale = new ObservablePoint(this, 1, 1);
          }
          return this._scale;
        }
        set scale(value) {
          if (this._scale === defaultScale) {
            this._scale = new ObservablePoint(this, 0, 0);
          }
          typeof value === "number" ? this._scale.set(value) : this._scale.copyFrom(value);
        }
        /**
         * The width of the Container, setting this will actually modify the scale to achieve the value set.
         * @memberof scene.Container#
         */
        get width() {
          return Math.abs(this.scale.x * this.getLocalBounds().width);
        }
        set width(value) {
          const localWidth = this.getLocalBounds().width;
          this._setWidth(value, localWidth);
        }
        /**
         * The height of the Container, setting this will actually modify the scale to achieve the value set.
         * @memberof scene.Container#
         */
        get height() {
          return Math.abs(this.scale.y * this.getLocalBounds().height);
        }
        set height(value) {
          const localHeight = this.getLocalBounds().height;
          this._setHeight(value, localHeight);
        }
        /**
         * Retrieves the size of the container as a [Size]{@link Size} object.
         * This is faster than get the width and height separately.
         * @param out - Optional object to store the size in.
         * @returns - The size of the container.
         * @memberof scene.Container#
         */
        getSize(out2) {
          if (!out2) {
            out2 = {};
          }
          const bounds = this.getLocalBounds();
          out2.width = Math.abs(this.scale.x * bounds.width);
          out2.height = Math.abs(this.scale.y * bounds.height);
          return out2;
        }
        /**
         * Sets the size of the container to the specified width and height.
         * This is faster than setting the width and height separately.
         * @param value - This can be either a number or a [Size]{@link Size} object.
         * @param height - The height to set. Defaults to the value of `width` if not provided.
         * @memberof scene.Container#
         */
        setSize(value, height) {
          const size = this.getLocalBounds();
          let convertedWidth;
          let convertedHeight;
          if (typeof value !== "object") {
            convertedWidth = value;
            convertedHeight = height ?? value;
          } else {
            convertedWidth = value.width;
            convertedHeight = value.height ?? value.width;
          }
          if (convertedWidth !== void 0) {
            this._setWidth(convertedWidth, size.width);
          }
          if (convertedHeight !== void 0) {
            this._setHeight(convertedHeight, size.height);
          }
        }
        /** Called when the skew or the rotation changes. */
        _updateSkew() {
          const rotation = this._rotation;
          const skew = this._skew;
          this._cx = Math.cos(rotation + skew._y);
          this._sx = Math.sin(rotation + skew._y);
          this._cy = -Math.sin(rotation - skew._x);
          this._sy = Math.cos(rotation - skew._x);
        }
        /**
         * Updates the transform properties of the container (accepts partial values).
         * @param {object} opts - The options for updating the transform.
         * @param {number} opts.x - The x position of the container.
         * @param {number} opts.y - The y position of the container.
         * @param {number} opts.scaleX - The scale factor on the x-axis.
         * @param {number} opts.scaleY - The scale factor on the y-axis.
         * @param {number} opts.rotation - The rotation of the container, in radians.
         * @param {number} opts.skewX - The skew factor on the x-axis.
         * @param {number} opts.skewY - The skew factor on the y-axis.
         * @param {number} opts.pivotX - The x coordinate of the pivot point.
         * @param {number} opts.pivotY - The y coordinate of the pivot point.
         */
        updateTransform(opts) {
          this.position.set(
            typeof opts.x === "number" ? opts.x : this.position.x,
            typeof opts.y === "number" ? opts.y : this.position.y
          );
          this.scale.set(
            typeof opts.scaleX === "number" ? opts.scaleX || 1 : this.scale.x,
            typeof opts.scaleY === "number" ? opts.scaleY || 1 : this.scale.y
          );
          this.rotation = typeof opts.rotation === "number" ? opts.rotation : this.rotation;
          this.skew.set(
            typeof opts.skewX === "number" ? opts.skewX : this.skew.x,
            typeof opts.skewY === "number" ? opts.skewY : this.skew.y
          );
          this.pivot.set(
            typeof opts.pivotX === "number" ? opts.pivotX : this.pivot.x,
            typeof opts.pivotY === "number" ? opts.pivotY : this.pivot.y
          );
          return this;
        }
        /**
         * Updates the local transform using the given matrix.
         * @param matrix - The matrix to use for updating the transform.
         */
        setFromMatrix(matrix) {
          matrix.decompose(this);
        }
        /** Updates the local transform. */
        updateLocalTransform() {
          if ((this._didLocalTransformChangeId & 15) === this._didChangeId)
            return;
          this._didLocalTransformChangeId = this._didChangeId;
          const lt = this.localTransform;
          const scale = this._scale;
          const pivot = this._pivot;
          const position = this._position;
          const sx = scale._x;
          const sy = scale._y;
          const px = pivot._x;
          const py = pivot._y;
          lt.a = this._cx * sx;
          lt.b = this._sx * sx;
          lt.c = this._cy * sy;
          lt.d = this._sy * sy;
          lt.tx = position._x - (px * lt.a + py * lt.c);
          lt.ty = position._y - (px * lt.b + py * lt.d);
        }
        // / ///// color related stuff
        set alpha(value) {
          if (value === this.localAlpha)
            return;
          this.localAlpha = value;
          this._updateFlags |= UPDATE_COLOR;
          this._onUpdate();
        }
        /** The opacity of the object. */
        get alpha() {
          return this.localAlpha;
        }
        set tint(value) {
          const tempColor = Color.shared.setValue(value ?? 16777215);
          const bgr = tempColor.toBgrNumber();
          if (bgr === this.localColor)
            return;
          this.localColor = bgr;
          this._updateFlags |= UPDATE_COLOR;
          this._onUpdate();
        }
        /**
         * The tint applied to the sprite. This is a hex value.
         *
         * A value of 0xFFFFFF will remove any tint effect.
         * @default 0xFFFFFF
         */
        get tint() {
          const bgr = this.localColor;
          return ((bgr & 255) << 16) + (bgr & 65280) + (bgr >> 16 & 255);
        }
        // / //////////////// blend related stuff
        set blendMode(value) {
          if (this.localBlendMode === value)
            return;
          if (this.parentRenderGroup) {
            this.parentRenderGroup.structureDidChange = true;
          }
          this._updateFlags |= UPDATE_BLEND;
          this.localBlendMode = value;
          this._onUpdate();
        }
        /**
         * The blend mode to be applied to the sprite. Apply a value of `'normal'` to reset the blend mode.
         * @default 'normal'
         */
        get blendMode() {
          return this.localBlendMode;
        }
        // / ///////// VISIBILITY / RENDERABLE /////////////////
        /** The visibility of the object. If false the object will not be drawn, and the transform will not be updated. */
        get visible() {
          return !!(this.localDisplayStatus & 2);
        }
        set visible(value) {
          const valueNumber = value ? 1 : 0;
          if ((this.localDisplayStatus & 2) >> 1 === valueNumber)
            return;
          if (this.parentRenderGroup) {
            this.parentRenderGroup.structureDidChange = true;
          }
          this._updateFlags |= UPDATE_VISIBLE;
          this.localDisplayStatus ^= 2;
          this._onUpdate();
        }
        /** @ignore */
        get culled() {
          return !(this.localDisplayStatus & 4);
        }
        /** @ignore */
        set culled(value) {
          const valueNumber = value ? 1 : 0;
          if ((this.localDisplayStatus & 4) >> 2 === valueNumber)
            return;
          if (this.parentRenderGroup) {
            this.parentRenderGroup.structureDidChange = true;
          }
          this._updateFlags |= UPDATE_VISIBLE;
          this.localDisplayStatus ^= 4;
          this._onUpdate();
        }
        /** Can this object be rendered, if false the object will not be drawn but the transform will still be updated. */
        get renderable() {
          return !!(this.localDisplayStatus & 1);
        }
        set renderable(value) {
          const valueNumber = value ? 1 : 0;
          if ((this.localDisplayStatus & 1) === valueNumber)
            return;
          this._updateFlags |= UPDATE_VISIBLE;
          this.localDisplayStatus ^= 1;
          if (this.parentRenderGroup) {
            this.parentRenderGroup.structureDidChange = true;
          }
          this._onUpdate();
        }
        /** Whether or not the object should be rendered. */
        get isRenderable() {
          return this.localDisplayStatus === 7 && this.groupAlpha > 0;
        }
        /**
         * Removes all internal references and listeners as well as removes children from the display list.
         * Do not use a Container after calling `destroy`.
         * @param options - Options parameter. A boolean will act as if all options
         *  have been set to that value
         * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
         *  method called as well. 'options' will be passed on to those calls.
         * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites. If options.children
         * is set to true it should destroy the texture of the child sprite
         * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.
         * If options.children is set to true it should destroy the texture source of the child sprite
         * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.
         * If options.children is set to true it should destroy the context of the child graphics
         */
        destroy(options = false) {
          if (this.destroyed)
            return;
          this.destroyed = true;
          const oldChildren = this.removeChildren(0, this.children.length);
          this.removeFromParent();
          this.parent = null;
          this._maskEffect = null;
          this._filterEffect = null;
          this.effects = null;
          this._position = null;
          this._scale = null;
          this._pivot = null;
          this._skew = null;
          this.emit("destroyed", this);
          this.removeAllListeners();
          const destroyChildren = typeof options === "boolean" ? options : options?.children;
          if (destroyChildren) {
            for (let i2 = 0; i2 < oldChildren.length; ++i2) {
              oldChildren[i2].destroy(options);
            }
          }
        }
      };
      Container.mixin(childrenHelperMixin);
      Container.mixin(toLocalGlobalMixin);
      Container.mixin(onRenderMixin);
      Container.mixin(measureMixin);
      Container.mixin(effectsMixin);
      Container.mixin(findMixin);
      Container.mixin(sortMixin);
      Container.mixin(cullingMixin);
    }
  });

  // ../core/node_modules/pixi.js/lib/events/FederatedEvent.mjs
  var FederatedEvent;
  var init_FederatedEvent = __esm({
    "../core/node_modules/pixi.js/lib/events/FederatedEvent.mjs"() {
      init_Point();
      FederatedEvent = class {
        /**
         * @param manager - The event boundary which manages this event. Propagation can only occur
         *  within the boundary's jurisdiction.
         */
        constructor(manager) {
          this.bubbles = true;
          this.cancelBubble = true;
          this.cancelable = false;
          this.composed = false;
          this.defaultPrevented = false;
          this.eventPhase = FederatedEvent.prototype.NONE;
          this.propagationStopped = false;
          this.propagationImmediatelyStopped = false;
          this.layer = new Point();
          this.page = new Point();
          this.NONE = 0;
          this.CAPTURING_PHASE = 1;
          this.AT_TARGET = 2;
          this.BUBBLING_PHASE = 3;
          this.manager = manager;
        }
        /** @readonly */
        get layerX() {
          return this.layer.x;
        }
        /** @readonly */
        get layerY() {
          return this.layer.y;
        }
        /** @readonly */
        get pageX() {
          return this.page.x;
        }
        /** @readonly */
        get pageY() {
          return this.page.y;
        }
        /**
         * Fallback for the deprecated @code{InteractionEvent.data}.
         * @deprecated since 7.0.0
         */
        get data() {
          return this;
        }
        /** The propagation path for this event. Alias for {@link EventBoundary.propagationPath}. */
        composedPath() {
          if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target)) {
            this.path = this.target ? this.manager.propagationPath(this.target) : [];
          }
          return this.path;
        }
        /**
         * Unimplemented method included for implementing the DOM interface {@code Event}. It will throw an {@code Error}.
         * @deprecated
         * @param _type
         * @param _bubbles
         * @param _cancelable
         */
        initEvent(_type, _bubbles, _cancelable) {
          throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
        }
        /**
         * Unimplemented method included for implementing the DOM interface {@code UIEvent}. It will throw an {@code Error}.
         * @deprecated
         * @param _typeArg
         * @param _bubblesArg
         * @param _cancelableArg
         * @param _viewArg
         * @param _detailArg
         */
        initUIEvent(_typeArg, _bubblesArg, _cancelableArg, _viewArg, _detailArg) {
          throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
        }
        /** Prevent default behavior of PixiJS and the user agent. */
        preventDefault() {
          if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
            this.nativeEvent.preventDefault();
          }
          this.defaultPrevented = true;
        }
        /**
         * Stop this event from propagating to any addition listeners, including on the
         * {@link FederatedEventTarget.currentTarget currentTarget} and also the following
         * event targets on the propagation path.
         */
        stopImmediatePropagation() {
          this.propagationImmediatelyStopped = true;
        }
        /**
         * Stop this event from propagating to the next {@link FederatedEventTarget}. The rest of the listeners
         * on the {@link FederatedEventTarget.currentTarget currentTarget} will still be notified.
         */
        stopPropagation() {
          this.propagationStopped = true;
        }
      };
    }
  });

  // ../core/node_modules/ismobilejs/esm/isMobile.js
  function createMatch(userAgent) {
    return function(regex) {
      return regex.test(userAgent);
    };
  }
  function isMobile(param) {
    var nav = {
      userAgent: "",
      platform: "",
      maxTouchPoints: 0
    };
    if (!param && typeof navigator !== "undefined") {
      nav = {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        maxTouchPoints: navigator.maxTouchPoints || 0
      };
    } else if (typeof param === "string") {
      nav.userAgent = param;
    } else if (param && param.userAgent) {
      nav = {
        userAgent: param.userAgent,
        platform: param.platform,
        maxTouchPoints: param.maxTouchPoints || 0
      };
    }
    var userAgent = nav.userAgent;
    var tmp = userAgent.split("[FBAN");
    if (typeof tmp[1] !== "undefined") {
      userAgent = tmp[0];
    }
    tmp = userAgent.split("Twitter");
    if (typeof tmp[1] !== "undefined") {
      userAgent = tmp[0];
    }
    var match = createMatch(userAgent);
    var result = {
      apple: {
        phone: match(appleIphone) && !match(windowsPhone),
        ipod: match(appleIpod),
        tablet: !match(appleIphone) && (match(appleTablet) || isAppleTabletOnIos13(nav)) && !match(windowsPhone),
        universal: match(appleUniversal),
        device: (match(appleIphone) || match(appleIpod) || match(appleTablet) || match(appleUniversal) || isAppleTabletOnIos13(nav)) && !match(windowsPhone)
      },
      amazon: {
        phone: match(amazonPhone),
        tablet: !match(amazonPhone) && match(amazonTablet),
        device: match(amazonPhone) || match(amazonTablet)
      },
      android: {
        phone: !match(windowsPhone) && match(amazonPhone) || !match(windowsPhone) && match(androidPhone),
        tablet: !match(windowsPhone) && !match(amazonPhone) && !match(androidPhone) && (match(amazonTablet) || match(androidTablet)),
        device: !match(windowsPhone) && (match(amazonPhone) || match(amazonTablet) || match(androidPhone) || match(androidTablet)) || match(/\bokhttp\b/i)
      },
      windows: {
        phone: match(windowsPhone),
        tablet: match(windowsTablet),
        device: match(windowsPhone) || match(windowsTablet)
      },
      other: {
        blackberry: match(otherBlackBerry),
        blackberry10: match(otherBlackBerry10),
        opera: match(otherOpera),
        firefox: match(otherFirefox),
        chrome: match(otherChrome),
        device: match(otherBlackBerry) || match(otherBlackBerry10) || match(otherOpera) || match(otherFirefox) || match(otherChrome)
      },
      any: false,
      phone: false,
      tablet: false
    };
    result.any = result.apple.device || result.android.device || result.windows.device || result.other.device;
    result.phone = result.apple.phone || result.android.phone || result.windows.phone;
    result.tablet = result.apple.tablet || result.android.tablet || result.windows.tablet;
    return result;
  }
  var appleIphone, appleIpod, appleTablet, appleUniversal, androidPhone, androidTablet, amazonPhone, amazonTablet, windowsPhone, windowsTablet, otherBlackBerry, otherBlackBerry10, otherOpera, otherChrome, otherFirefox, isAppleTabletOnIos13;
  var init_isMobile = __esm({
    "../core/node_modules/ismobilejs/esm/isMobile.js"() {
      appleIphone = /iPhone/i;
      appleIpod = /iPod/i;
      appleTablet = /iPad/i;
      appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
      androidPhone = /\bAndroid(?:.+)Mobile\b/i;
      androidTablet = /Android/i;
      amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
      amazonTablet = /Silk/i;
      windowsPhone = /Windows Phone/i;
      windowsTablet = /\bWindows(?:.+)ARM\b/i;
      otherBlackBerry = /BlackBerry/i;
      otherBlackBerry10 = /BB10/i;
      otherOpera = /Opera Mini/i;
      otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
      otherFirefox = /Mobile(?:.+)Firefox\b/i;
      isAppleTabletOnIos13 = function(navigator2) {
        return typeof navigator2 !== "undefined" && navigator2.platform === "MacIntel" && typeof navigator2.maxTouchPoints === "number" && navigator2.maxTouchPoints > 1 && typeof MSStream === "undefined";
      };
    }
  });

  // ../core/node_modules/ismobilejs/esm/index.js
  var init_esm = __esm({
    "../core/node_modules/ismobilejs/esm/index.js"() {
      init_isMobile();
      init_isMobile();
    }
  });

  // ../core/node_modules/pixi.js/lib/utils/browser/isMobile.mjs
  var isMobileCall, isMobile2;
  var init_isMobile2 = __esm({
    "../core/node_modules/pixi.js/lib/utils/browser/isMobile.mjs"() {
      init_esm();
      isMobileCall = isMobile.default ?? isMobile;
      isMobile2 = isMobileCall(globalThis.navigator);
    }
  });

  // ../core/node_modules/pixi.js/lib/accessibility/AccessibilitySystem.mjs
  var KEY_CODE_TAB, DIV_TOUCH_SIZE, DIV_TOUCH_POS_X, DIV_TOUCH_POS_Y, DIV_TOUCH_ZINDEX, DIV_HOOK_SIZE, DIV_HOOK_POS_X, DIV_HOOK_POS_Y, DIV_HOOK_ZINDEX, AccessibilitySystem;
  var init_AccessibilitySystem = __esm({
    "../core/node_modules/pixi.js/lib/accessibility/AccessibilitySystem.mjs"() {
      init_FederatedEvent();
      init_Extensions();
      init_isMobile2();
      init_removeItems();
      KEY_CODE_TAB = 9;
      DIV_TOUCH_SIZE = 100;
      DIV_TOUCH_POS_X = 0;
      DIV_TOUCH_POS_Y = 0;
      DIV_TOUCH_ZINDEX = 2;
      DIV_HOOK_SIZE = 1;
      DIV_HOOK_POS_X = -1e3;
      DIV_HOOK_POS_Y = -1e3;
      DIV_HOOK_ZINDEX = 2;
      AccessibilitySystem = class {
        // 2fps
        // eslint-disable-next-line jsdoc/require-param
        /**
         * @param {WebGLRenderer|WebGPURenderer} renderer - A reference to the current renderer
         */
        constructor(renderer, _mobileInfo = isMobile2) {
          this._mobileInfo = _mobileInfo;
          this.debug = false;
          this._isActive = false;
          this._isMobileAccessibility = false;
          this._pool = [];
          this._renderId = 0;
          this._children = [];
          this._androidUpdateCount = 0;
          this._androidUpdateFrequency = 500;
          this._hookDiv = null;
          if (_mobileInfo.tablet || _mobileInfo.phone) {
            this._createTouchHook();
          }
          const div = document.createElement("div");
          div.style.width = `${DIV_TOUCH_SIZE}px`;
          div.style.height = `${DIV_TOUCH_SIZE}px`;
          div.style.position = "absolute";
          div.style.top = `${DIV_TOUCH_POS_X}px`;
          div.style.left = `${DIV_TOUCH_POS_Y}px`;
          div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
          this._div = div;
          this._renderer = renderer;
          this._onKeyDown = this._onKeyDown.bind(this);
          this._onMouseMove = this._onMouseMove.bind(this);
          globalThis.addEventListener("keydown", this._onKeyDown, false);
        }
        /**
         * Value of `true` if accessibility is currently active and accessibility layers are showing.
         * @member {boolean}
         * @readonly
         */
        get isActive() {
          return this._isActive;
        }
        /**
         * Value of `true` if accessibility is enabled for touch devices.
         * @member {boolean}
         * @readonly
         */
        get isMobileAccessibility() {
          return this._isMobileAccessibility;
        }
        get hookDiv() {
          return this._hookDiv;
        }
        /**
         * Creates the touch hooks.
         * @private
         */
        _createTouchHook() {
          const hookDiv = document.createElement("button");
          hookDiv.style.width = `${DIV_HOOK_SIZE}px`;
          hookDiv.style.height = `${DIV_HOOK_SIZE}px`;
          hookDiv.style.position = "absolute";
          hookDiv.style.top = `${DIV_HOOK_POS_X}px`;
          hookDiv.style.left = `${DIV_HOOK_POS_Y}px`;
          hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();
          hookDiv.style.backgroundColor = "#FF0000";
          hookDiv.title = "select to enable accessibility for this content";
          hookDiv.addEventListener("focus", () => {
            this._isMobileAccessibility = true;
            this._activate();
            this._destroyTouchHook();
          });
          document.body.appendChild(hookDiv);
          this._hookDiv = hookDiv;
        }
        /**
         * Destroys the touch hooks.
         * @private
         */
        _destroyTouchHook() {
          if (!this._hookDiv) {
            return;
          }
          document.body.removeChild(this._hookDiv);
          this._hookDiv = null;
        }
        /**
         * Activating will cause the Accessibility layer to be shown.
         * This is called when a user presses the tab key.
         * @private
         */
        _activate() {
          if (this._isActive) {
            return;
          }
          this._isActive = true;
          globalThis.document.addEventListener("mousemove", this._onMouseMove, true);
          globalThis.removeEventListener("keydown", this._onKeyDown, false);
          this._renderer.runners.postrender.add(this);
          this._renderer.view.canvas.parentNode?.appendChild(this._div);
        }
        /**
         * Deactivating will cause the Accessibility layer to be hidden.
         * This is called when a user moves the mouse.
         * @private
         */
        _deactivate() {
          if (!this._isActive || this._isMobileAccessibility) {
            return;
          }
          this._isActive = false;
          globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
          globalThis.addEventListener("keydown", this._onKeyDown, false);
          this._renderer.runners.postrender.remove(this);
          this._div.parentNode?.removeChild(this._div);
        }
        /**
         * This recursive function will run through the scene graph and add any new accessible objects to the DOM layer.
         * @private
         * @param {Container} container - The Container to check.
         */
        _updateAccessibleObjects(container) {
          if (!container.visible || !container.accessibleChildren) {
            return;
          }
          if (container.accessible && container.isInteractive()) {
            if (!container._accessibleActive) {
              this._addChild(container);
            }
            container._renderId = this._renderId;
          }
          const children2 = container.children;
          if (children2) {
            for (let i2 = 0; i2 < children2.length; i2++) {
              this._updateAccessibleObjects(children2[i2]);
            }
          }
        }
        /**
         * Runner init called, view is available at this point.
         * @ignore
         */
        init(options) {
          this.debug = options?.debug ?? this.debug;
          this._renderer.runners.postrender.remove(this);
        }
        /**
         * Runner postrender was called, ensure that all divs are mapped correctly to their Containers.
         * Only fires while active.
         * @ignore
         */
        postrender() {
          const now2 = performance.now();
          if (this._mobileInfo.android.device && now2 < this._androidUpdateCount) {
            return;
          }
          this._androidUpdateCount = now2 + this._androidUpdateFrequency;
          if (!this._renderer.renderingToScreen || !this._renderer.view.canvas) {
            return;
          }
          if (this._renderer.lastObjectRendered) {
            this._updateAccessibleObjects(this._renderer.lastObjectRendered);
          }
          const { x: x2, y: y2, width, height } = this._renderer.view.canvas.getBoundingClientRect();
          const { width: viewWidth, height: viewHeight, resolution } = this._renderer;
          const sx = width / viewWidth * resolution;
          const sy = height / viewHeight * resolution;
          let div = this._div;
          div.style.left = `${x2}px`;
          div.style.top = `${y2}px`;
          div.style.width = `${viewWidth}px`;
          div.style.height = `${viewHeight}px`;
          for (let i2 = 0; i2 < this._children.length; i2++) {
            const child = this._children[i2];
            if (child._renderId !== this._renderId) {
              child._accessibleActive = false;
              removeItems(this._children, i2, 1);
              this._div.removeChild(child._accessibleDiv);
              this._pool.push(child._accessibleDiv);
              child._accessibleDiv = null;
              i2--;
            } else {
              div = child._accessibleDiv;
              let hitArea = child.hitArea;
              const wt = child.worldTransform;
              if (child.hitArea) {
                div.style.left = `${(wt.tx + hitArea.x * wt.a) * sx}px`;
                div.style.top = `${(wt.ty + hitArea.y * wt.d) * sy}px`;
                div.style.width = `${hitArea.width * wt.a * sx}px`;
                div.style.height = `${hitArea.height * wt.d * sy}px`;
              } else {
                hitArea = child.getBounds().rectangle;
                this._capHitArea(hitArea);
                div.style.left = `${hitArea.x * sx}px`;
                div.style.top = `${hitArea.y * sy}px`;
                div.style.width = `${hitArea.width * sx}px`;
                div.style.height = `${hitArea.height * sy}px`;
                if (div.title !== child.accessibleTitle && child.accessibleTitle !== null) {
                  div.title = child.accessibleTitle || "";
                }
                if (div.getAttribute("aria-label") !== child.accessibleHint && child.accessibleHint !== null) {
                  div.setAttribute("aria-label", child.accessibleHint || "");
                }
              }
              if (child.accessibleTitle !== div.title || child.tabIndex !== div.tabIndex) {
                div.title = child.accessibleTitle || "";
                div.tabIndex = child.tabIndex;
                if (this.debug) {
                  this._updateDebugHTML(div);
                }
              }
            }
          }
          this._renderId++;
        }
        /**
         * private function that will visually add the information to the
         * accessibility div
         * @param {HTMLElement} div -
         */
        _updateDebugHTML(div) {
          div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;
        }
        /**
         * Adjust the hit area based on the bounds of a display object
         * @param {Rectangle} hitArea - Bounds of the child
         */
        _capHitArea(hitArea) {
          if (hitArea.x < 0) {
            hitArea.width += hitArea.x;
            hitArea.x = 0;
          }
          if (hitArea.y < 0) {
            hitArea.height += hitArea.y;
            hitArea.y = 0;
          }
          const { width: viewWidth, height: viewHeight } = this._renderer;
          if (hitArea.x + hitArea.width > viewWidth) {
            hitArea.width = viewWidth - hitArea.x;
          }
          if (hitArea.y + hitArea.height > viewHeight) {
            hitArea.height = viewHeight - hitArea.y;
          }
        }
        /**
         * Adds a Container to the accessibility manager
         * @private
         * @param {Container} container - The child to make accessible.
         */
        _addChild(container) {
          let div = this._pool.pop();
          if (!div) {
            div = document.createElement("button");
            div.style.width = `${DIV_TOUCH_SIZE}px`;
            div.style.height = `${DIV_TOUCH_SIZE}px`;
            div.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent";
            div.style.position = "absolute";
            div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
            div.style.borderStyle = "none";
            if (navigator.userAgent.toLowerCase().includes("chrome")) {
              div.setAttribute("aria-live", "off");
            } else {
              div.setAttribute("aria-live", "polite");
            }
            if (navigator.userAgent.match(/rv:.*Gecko\//)) {
              div.setAttribute("aria-relevant", "additions");
            } else {
              div.setAttribute("aria-relevant", "text");
            }
            div.addEventListener("click", this._onClick.bind(this));
            div.addEventListener("focus", this._onFocus.bind(this));
            div.addEventListener("focusout", this._onFocusOut.bind(this));
          }
          div.style.pointerEvents = container.accessiblePointerEvents;
          div.type = container.accessibleType;
          if (container.accessibleTitle && container.accessibleTitle !== null) {
            div.title = container.accessibleTitle;
          } else if (!container.accessibleHint || container.accessibleHint === null) {
            div.title = `container ${container.tabIndex}`;
          }
          if (container.accessibleHint && container.accessibleHint !== null) {
            div.setAttribute("aria-label", container.accessibleHint);
          }
          if (this.debug) {
            this._updateDebugHTML(div);
          }
          container._accessibleActive = true;
          container._accessibleDiv = div;
          div.container = container;
          this._children.push(container);
          this._div.appendChild(container._accessibleDiv);
          container._accessibleDiv.tabIndex = container.tabIndex;
        }
        /**
         * Dispatch events with the EventSystem.
         * @param e
         * @param type
         * @private
         */
        _dispatchEvent(e2, type) {
          const { container: target } = e2.target;
          const boundary = this._renderer.events.rootBoundary;
          const event = Object.assign(new FederatedEvent(boundary), { target });
          boundary.rootTarget = this._renderer.lastObjectRendered;
          type.forEach((type2) => boundary.dispatchEvent(event, type2));
        }
        /**
         * Maps the div button press to pixi's EventSystem (click)
         * @private
         * @param {MouseEvent} e - The click event.
         */
        _onClick(e2) {
          this._dispatchEvent(e2, ["click", "pointertap", "tap"]);
        }
        /**
         * Maps the div focus events to pixi's EventSystem (mouseover)
         * @private
         * @param {FocusEvent} e - The focus event.
         */
        _onFocus(e2) {
          if (!e2.target.getAttribute("aria-live")) {
            e2.target.setAttribute("aria-live", "assertive");
          }
          this._dispatchEvent(e2, ["mouseover"]);
        }
        /**
         * Maps the div focus events to pixi's EventSystem (mouseout)
         * @private
         * @param {FocusEvent} e - The focusout event.
         */
        _onFocusOut(e2) {
          if (!e2.target.getAttribute("aria-live")) {
            e2.target.setAttribute("aria-live", "polite");
          }
          this._dispatchEvent(e2, ["mouseout"]);
        }
        /**
         * Is called when a key is pressed
         * @private
         * @param {KeyboardEvent} e - The keydown event.
         */
        _onKeyDown(e2) {
          if (e2.keyCode !== KEY_CODE_TAB) {
            return;
          }
          this._activate();
        }
        /**
         * Is called when the mouse moves across the renderer element
         * @private
         * @param {MouseEvent} e - The mouse event.
         */
        _onMouseMove(e2) {
          if (e2.movementX === 0 && e2.movementY === 0) {
            return;
          }
          this._deactivate();
        }
        /** Destroys the accessibility manager */
        destroy() {
          this._destroyTouchHook();
          this._div = null;
          globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
          globalThis.removeEventListener("keydown", this._onKeyDown);
          this._pool = null;
          this._children = null;
          this._renderer = null;
        }
      };
      AccessibilitySystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem
        ],
        name: "accessibility"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/accessibility/accessibilityTarget.mjs
  var accessibilityTarget;
  var init_accessibilityTarget = __esm({
    "../core/node_modules/pixi.js/lib/accessibility/accessibilityTarget.mjs"() {
      "use strict";
      accessibilityTarget = {
        /**
         * Flag for if the object is accessible. If true AccessibilityManager will overlay a
         * shadow div with attributes set
         * @member {boolean}
         * @memberof scene.Container#
         */
        accessible: false,
        /**
         * Sets the title attribute of the shadow div
         * If accessibleTitle AND accessibleHint has not been this will default to 'container [tabIndex]'
         * @member {string}
         * @memberof scene.Container#
         */
        accessibleTitle: null,
        /**
         * Sets the aria-label attribute of the shadow div
         * @member {string}
         * @memberof scene.Container#
         */
        accessibleHint: null,
        /**
         * @member {number}
         * @memberof scene.Container#
         * @todo Needs docs.
         */
        tabIndex: 0,
        /**
         * @member {boolean}
         * @memberof scene.Container#
         * @private
         */
        _accessibleActive: false,
        /**
         * @memberof scene.Container#
         * @private
         */
        _accessibleDiv: null,
        /**
         * Specify the type of div the accessible layer is. Screen readers treat the element differently
         * depending on this type. Defaults to button.
         * @member {string}
         * @memberof scene.Container#
         * @default 'button'
         */
        accessibleType: "button",
        /**
         * Specify the pointer-events the accessible div will use
         * Defaults to auto.
         * @type {PointerEvents}
         * @memberof scene.Container#
         * @default 'auto'
         */
        accessiblePointerEvents: "auto",
        /**
         * Setting to false will prevent any children inside this container to
         * be accessible. Defaults to true.
         * @member {boolean}
         * @memberof scene.Container#
         * @default true
         */
        accessibleChildren: true,
        /**
         * @member {number}
         * @memberof scene.Container#
         * @private
         */
        _renderId: -1
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/accessibility/init.mjs
  var init_init = __esm({
    "../core/node_modules/pixi.js/lib/accessibility/init.mjs"() {
      init_Extensions();
      init_Container();
      init_AccessibilitySystem();
      init_accessibilityTarget();
      extensions.add(AccessibilitySystem);
      Container.mixin(accessibilityTarget);
    }
  });

  // ../core/node_modules/pixi.js/lib/app/ResizePlugin.mjs
  var ResizePlugin;
  var init_ResizePlugin = __esm({
    "../core/node_modules/pixi.js/lib/app/ResizePlugin.mjs"() {
      init_Extensions();
      ResizePlugin = class {
        /**
         * Initialize the plugin with scope of application instance
         * @static
         * @private
         * @param {object} [options] - See application options
         */
        static init(options) {
          Object.defineProperty(
            this,
            "resizeTo",
            /**
             * The HTML element or window to automatically resize the
             * renderer's view element to match width and height.
             * @member {Window|HTMLElement}
             * @name resizeTo
             * @memberof app.Application#
             */
            {
              set(dom) {
                globalThis.removeEventListener("resize", this.queueResize);
                this._resizeTo = dom;
                if (dom) {
                  globalThis.addEventListener("resize", this.queueResize);
                  this.resize();
                }
              },
              get() {
                return this._resizeTo;
              }
            }
          );
          this.queueResize = () => {
            if (!this._resizeTo) {
              return;
            }
            this._cancelResize();
            this._resizeId = requestAnimationFrame(() => this.resize());
          };
          this._cancelResize = () => {
            if (this._resizeId) {
              cancelAnimationFrame(this._resizeId);
              this._resizeId = null;
            }
          };
          this.resize = () => {
            if (!this._resizeTo) {
              return;
            }
            this._cancelResize();
            let width;
            let height;
            if (this._resizeTo === globalThis.window) {
              width = globalThis.innerWidth;
              height = globalThis.innerHeight;
            } else {
              const { clientWidth, clientHeight } = this._resizeTo;
              width = clientWidth;
              height = clientHeight;
            }
            this.renderer.resize(width, height);
            this.render();
          };
          this._resizeId = null;
          this._resizeTo = null;
          this.resizeTo = options.resizeTo || null;
        }
        /**
         * Clean up the ticker, scoped to application
         * @static
         * @private
         */
        static destroy() {
          globalThis.removeEventListener("resize", this.queueResize);
          this._cancelResize();
          this._cancelResize = null;
          this.queueResize = null;
          this.resizeTo = null;
          this.resize = null;
        }
      };
      ResizePlugin.extension = ExtensionType.Application;
    }
  });

  // ../core/node_modules/pixi.js/lib/ticker/const.mjs
  var UPDATE_PRIORITY;
  var init_const2 = __esm({
    "../core/node_modules/pixi.js/lib/ticker/const.mjs"() {
      "use strict";
      UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY2) => {
        UPDATE_PRIORITY2[UPDATE_PRIORITY2["INTERACTION"] = 50] = "INTERACTION";
        UPDATE_PRIORITY2[UPDATE_PRIORITY2["HIGH"] = 25] = "HIGH";
        UPDATE_PRIORITY2[UPDATE_PRIORITY2["NORMAL"] = 0] = "NORMAL";
        UPDATE_PRIORITY2[UPDATE_PRIORITY2["LOW"] = -25] = "LOW";
        UPDATE_PRIORITY2[UPDATE_PRIORITY2["UTILITY"] = -50] = "UTILITY";
        return UPDATE_PRIORITY2;
      })(UPDATE_PRIORITY || {});
    }
  });

  // ../core/node_modules/pixi.js/lib/ticker/TickerListener.mjs
  var TickerListener;
  var init_TickerListener = __esm({
    "../core/node_modules/pixi.js/lib/ticker/TickerListener.mjs"() {
      "use strict";
      TickerListener = class {
        /**
         * Constructor
         * @private
         * @param fn - The listener function to be added for one update
         * @param context - The listener context
         * @param priority - The priority for emitting
         * @param once - If the handler should fire once
         */
        constructor(fn, context4 = null, priority = 0, once = false) {
          this.next = null;
          this.previous = null;
          this._destroyed = false;
          this._fn = fn;
          this._context = context4;
          this.priority = priority;
          this._once = once;
        }
        /**
         * Simple compare function to figure out if a function and context match.
         * @param fn - The listener function to be added for one update
         * @param context - The listener context
         * @returns `true` if the listener match the arguments
         */
        match(fn, context4 = null) {
          return this._fn === fn && this._context === context4;
        }
        /**
         * Emit by calling the current function.
         * @param ticker - The ticker emitting.
         * @returns Next ticker
         */
        emit(ticker) {
          if (this._fn) {
            if (this._context) {
              this._fn.call(this._context, ticker);
            } else {
              this._fn(ticker);
            }
          }
          const redirect = this.next;
          if (this._once) {
            this.destroy(true);
          }
          if (this._destroyed) {
            this.next = null;
          }
          return redirect;
        }
        /**
         * Connect to the list.
         * @param previous - Input node, previous listener
         */
        connect(previous) {
          this.previous = previous;
          if (previous.next) {
            previous.next.previous = this;
          }
          this.next = previous.next;
          previous.next = this;
        }
        /**
         * Destroy and don't use after this.
         * @param hard - `true` to remove the `next` reference, this
         *        is considered a hard destroy. Soft destroy maintains the next reference.
         * @returns The listener to redirect while emitting or removing.
         */
        destroy(hard = false) {
          this._destroyed = true;
          this._fn = null;
          this._context = null;
          if (this.previous) {
            this.previous.next = this.next;
          }
          if (this.next) {
            this.next.previous = this.previous;
          }
          const redirect = this.next;
          this.next = hard ? null : redirect;
          this.previous = null;
          return redirect;
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/ticker/Ticker.mjs
  var _Ticker, Ticker;
  var init_Ticker = __esm({
    "../core/node_modules/pixi.js/lib/ticker/Ticker.mjs"() {
      init_const2();
      init_TickerListener();
      _Ticker = class _Ticker2 {
        constructor() {
          this.autoStart = false;
          this.deltaTime = 1;
          this.lastTime = -1;
          this.speed = 1;
          this.started = false;
          this._requestId = null;
          this._maxElapsedMS = 100;
          this._minElapsedMS = 0;
          this._protected = false;
          this._lastFrame = -1;
          this._head = new TickerListener(null, null, Infinity);
          this.deltaMS = 1 / _Ticker2.targetFPMS;
          this.elapsedMS = 1 / _Ticker2.targetFPMS;
          this._tick = (time) => {
            this._requestId = null;
            if (this.started) {
              this.update(time);
              if (this.started && this._requestId === null && this._head.next) {
                this._requestId = requestAnimationFrame(this._tick);
              }
            }
          };
        }
        /**
         * Conditionally requests a new animation frame.
         * If a frame has not already been requested, and if the internal
         * emitter has listeners, a new frame is requested.
         * @private
         */
        _requestIfNeeded() {
          if (this._requestId === null && this._head.next) {
            this.lastTime = performance.now();
            this._lastFrame = this.lastTime;
            this._requestId = requestAnimationFrame(this._tick);
          }
        }
        /**
         * Conditionally cancels a pending animation frame.
         * @private
         */
        _cancelIfNeeded() {
          if (this._requestId !== null) {
            cancelAnimationFrame(this._requestId);
            this._requestId = null;
          }
        }
        /**
         * Conditionally requests a new animation frame.
         * If the ticker has been started it checks if a frame has not already
         * been requested, and if the internal emitter has listeners. If these
         * conditions are met, a new frame is requested. If the ticker has not
         * been started, but autoStart is `true`, then the ticker starts now,
         * and continues with the previous conditions to request a new frame.
         * @private
         */
        _startIfPossible() {
          if (this.started) {
            this._requestIfNeeded();
          } else if (this.autoStart) {
            this.start();
          }
        }
        /**
         * Register a handler for tick events. Calls continuously unless
         * it is removed or the ticker is stopped.
         * @param fn - The listener function to be added for updates
         * @param context - The listener context
         * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting
         * @returns This instance of a ticker
         */
        add(fn, context4, priority = UPDATE_PRIORITY.NORMAL) {
          return this._addListener(new TickerListener(fn, context4, priority));
        }
        /**
         * Add a handler for the tick event which is only execute once.
         * @param fn - The listener function to be added for one update
         * @param context - The listener context
         * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting
         * @returns This instance of a ticker
         */
        addOnce(fn, context4, priority = UPDATE_PRIORITY.NORMAL) {
          return this._addListener(new TickerListener(fn, context4, priority, true));
        }
        /**
         * Internally adds the event handler so that it can be sorted by priority.
         * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run
         * before the rendering.
         * @private
         * @param listener - Current listener being added.
         * @returns This instance of a ticker
         */
        _addListener(listener) {
          let current = this._head.next;
          let previous = this._head;
          if (!current) {
            listener.connect(previous);
          } else {
            while (current) {
              if (listener.priority > current.priority) {
                listener.connect(previous);
                break;
              }
              previous = current;
              current = current.next;
            }
            if (!listener.previous) {
              listener.connect(previous);
            }
          }
          this._startIfPossible();
          return this;
        }
        /**
         * Removes any handlers matching the function and context parameters.
         * If no handlers are left after removing, then it cancels the animation frame.
         * @param fn - The listener function to be removed
         * @param context - The listener context to be removed
         * @returns This instance of a ticker
         */
        remove(fn, context4) {
          let listener = this._head.next;
          while (listener) {
            if (listener.match(fn, context4)) {
              listener = listener.destroy();
            } else {
              listener = listener.next;
            }
          }
          if (!this._head.next) {
            this._cancelIfNeeded();
          }
          return this;
        }
        /**
         * The number of listeners on this ticker, calculated by walking through linked list
         * @readonly
         * @member {number}
         */
        get count() {
          if (!this._head) {
            return 0;
          }
          let count2 = 0;
          let current = this._head;
          while (current = current.next) {
            count2++;
          }
          return count2;
        }
        /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */
        start() {
          if (!this.started) {
            this.started = true;
            this._requestIfNeeded();
          }
        }
        /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */
        stop() {
          if (this.started) {
            this.started = false;
            this._cancelIfNeeded();
          }
        }
        /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */
        destroy() {
          if (!this._protected) {
            this.stop();
            let listener = this._head.next;
            while (listener) {
              listener = listener.destroy(true);
            }
            this._head.destroy();
            this._head = null;
          }
        }
        /**
         * Triggers an update. An update entails setting the
         * current {@link ticker.Ticker#elapsedMS|elapsedMS},
         * the current {@link ticker.Ticker#deltaTime|deltaTime},
         * invoking all listeners with current deltaTime,
         * and then finally setting {@link ticker.Ticker#lastTime|lastTime}
         * with the value of currentTime that was provided.
         * This method will be called automatically by animation
         * frame callbacks if the ticker instance has been started
         * and listeners are added.
         * @param {number} [currentTime=performance.now()] - the current time of execution
         */
        update(currentTime = performance.now()) {
          let elapsedMS;
          if (currentTime > this.lastTime) {
            elapsedMS = this.elapsedMS = currentTime - this.lastTime;
            if (elapsedMS > this._maxElapsedMS) {
              elapsedMS = this._maxElapsedMS;
            }
            elapsedMS *= this.speed;
            if (this._minElapsedMS) {
              const delta = currentTime - this._lastFrame | 0;
              if (delta < this._minElapsedMS) {
                return;
              }
              this._lastFrame = currentTime - delta % this._minElapsedMS;
            }
            this.deltaMS = elapsedMS;
            this.deltaTime = this.deltaMS * _Ticker2.targetFPMS;
            const head = this._head;
            let listener = head.next;
            while (listener) {
              listener = listener.emit(this);
            }
            if (!head.next) {
              this._cancelIfNeeded();
            }
          } else {
            this.deltaTime = this.deltaMS = this.elapsedMS = 0;
          }
          this.lastTime = currentTime;
        }
        /**
         * The frames per second at which this ticker is running.
         * The default is approximately 60 in most modern browsers.
         * **Note:** This does not factor in the value of
         * {@link ticker.Ticker#speed|speed}, which is specific
         * to scaling {@link ticker.Ticker#deltaTime|deltaTime}.
         * @member {number}
         * @readonly
         */
        get FPS() {
          return 1e3 / this.elapsedMS;
        }
        /**
         * Manages the maximum amount of milliseconds allowed to
         * elapse between invoking {@link ticker.Ticker#update|update}.
         * This value is used to cap {@link ticker.Ticker#deltaTime|deltaTime},
         * but does not effect the measured value of {@link ticker.Ticker#FPS|FPS}.
         * When setting this property it is clamped to a value between
         * `0` and `Ticker.targetFPMS * 1000`.
         * @member {number}
         * @default 10
         */
        get minFPS() {
          return 1e3 / this._maxElapsedMS;
        }
        set minFPS(fps) {
          const minFPS = Math.min(this.maxFPS, fps);
          const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker2.targetFPMS);
          this._maxElapsedMS = 1 / minFPMS;
        }
        /**
         * Manages the minimum amount of milliseconds required to
         * elapse between invoking {@link ticker.Ticker#update|update}.
         * This will effect the measured value of {@link ticker.Ticker#FPS|FPS}.
         * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.
         * Otherwise it will be at least `minFPS`
         * @member {number}
         * @default 0
         */
        get maxFPS() {
          if (this._minElapsedMS) {
            return Math.round(1e3 / this._minElapsedMS);
          }
          return 0;
        }
        set maxFPS(fps) {
          if (fps === 0) {
            this._minElapsedMS = 0;
          } else {
            const maxFPS = Math.max(this.minFPS, fps);
            this._minElapsedMS = 1 / (maxFPS / 1e3);
          }
        }
        /**
         * The shared ticker instance used by {@link AnimatedSprite} and by
         * {@link VideoResource} to update animation frames / video textures.
         *
         * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.
         *
         * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.
         * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
         * @example
         * import { Ticker } from 'pixi.js';
         *
         * const ticker = Ticker.shared;
         * // Set this to prevent starting this ticker when listeners are added.
         * // By default this is true only for the Ticker.shared instance.
         * ticker.autoStart = false;
         *
         * // FYI, call this to ensure the ticker is stopped. It should be stopped
         * // if you have not attempted to render anything yet.
         * ticker.stop();
         *
         * // Call this when you are ready for a running shared ticker.
         * ticker.start();
         * @example
         * import { autoDetectRenderer, Container } from 'pixi.js';
         *
         * // You may use the shared ticker to render...
         * const renderer = autoDetectRenderer();
         * const stage = new Container();
         * document.body.appendChild(renderer.view);
         * ticker.add((time) => renderer.render(stage));
         *
         * // Or you can just update it manually.
         * ticker.autoStart = false;
         * ticker.stop();
         * const animate = (time) => {
         *     ticker.update(time);
         *     renderer.render(stage);
         *     requestAnimationFrame(animate);
         * };
         * animate(performance.now());
         * @member {ticker.Ticker}
         * @readonly
         * @static
         */
        static get shared() {
          if (!_Ticker2._shared) {
            const shared = _Ticker2._shared = new _Ticker2();
            shared.autoStart = true;
            shared._protected = true;
          }
          return _Ticker2._shared;
        }
        /**
         * The system ticker instance used by {@link BasePrepare} for core timing
         * functionality that shouldn't usually need to be paused, unlike the `shared`
         * ticker which drives visual animations and rendering which may want to be paused.
         *
         * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.
         * @member {ticker.Ticker}
         * @readonly
         * @static
         */
        static get system() {
          if (!_Ticker2._system) {
            const system = _Ticker2._system = new _Ticker2();
            system.autoStart = true;
            system._protected = true;
          }
          return _Ticker2._system;
        }
      };
      _Ticker.targetFPMS = 0.06;
      Ticker = _Ticker;
    }
  });

  // ../core/node_modules/pixi.js/lib/app/TickerPlugin.mjs
  var TickerPlugin;
  var init_TickerPlugin = __esm({
    "../core/node_modules/pixi.js/lib/app/TickerPlugin.mjs"() {
      init_Extensions();
      init_const2();
      init_Ticker();
      TickerPlugin = class {
        /**
         * Initialize the plugin with scope of application instance
         * @static
         * @private
         * @param {object} [options] - See application options
         */
        static init(options) {
          options = Object.assign({
            autoStart: true,
            sharedTicker: false
          }, options);
          Object.defineProperty(
            this,
            "ticker",
            {
              set(ticker) {
                if (this._ticker) {
                  this._ticker.remove(this.render, this);
                }
                this._ticker = ticker;
                if (ticker) {
                  ticker.add(this.render, this, UPDATE_PRIORITY.LOW);
                }
              },
              get() {
                return this._ticker;
              }
            }
          );
          this.stop = () => {
            this._ticker.stop();
          };
          this.start = () => {
            this._ticker.start();
          };
          this._ticker = null;
          this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();
          if (options.autoStart) {
            this.start();
          }
        }
        /**
         * Clean up the ticker, scoped to application.
         * @static
         * @private
         */
        static destroy() {
          if (this._ticker) {
            const oldTicker = this._ticker;
            this.ticker = null;
            oldTicker.destroy();
          }
        }
      };
      TickerPlugin.extension = ExtensionType.Application;
    }
  });

  // ../core/node_modules/pixi.js/lib/app/init.mjs
  var init_init2 = __esm({
    "../core/node_modules/pixi.js/lib/app/init.mjs"() {
      init_Extensions();
      init_ResizePlugin();
      init_TickerPlugin();
      extensions.add(ResizePlugin);
      extensions.add(TickerPlugin);
    }
  });

  // ../core/node_modules/pixi.js/lib/events/EventTicker.mjs
  var EventsTickerClass, EventsTicker;
  var init_EventTicker = __esm({
    "../core/node_modules/pixi.js/lib/events/EventTicker.mjs"() {
      init_const2();
      init_Ticker();
      EventsTickerClass = class {
        constructor() {
          this.interactionFrequency = 10;
          this._deltaTime = 0;
          this._didMove = false;
          this._tickerAdded = false;
          this._pauseUpdate = true;
        }
        /**
         * Initializes the event ticker.
         * @param events - The event system.
         */
        init(events) {
          this.removeTickerListener();
          this.events = events;
          this.interactionFrequency = 10;
          this._deltaTime = 0;
          this._didMove = false;
          this._tickerAdded = false;
          this._pauseUpdate = true;
        }
        /** Whether to pause the update checks or not. */
        get pauseUpdate() {
          return this._pauseUpdate;
        }
        set pauseUpdate(paused) {
          this._pauseUpdate = paused;
        }
        /** Adds the ticker listener. */
        addTickerListener() {
          if (this._tickerAdded || !this.domElement) {
            return;
          }
          Ticker.system.add(this._tickerUpdate, this, UPDATE_PRIORITY.INTERACTION);
          this._tickerAdded = true;
        }
        /** Removes the ticker listener. */
        removeTickerListener() {
          if (!this._tickerAdded) {
            return;
          }
          Ticker.system.remove(this._tickerUpdate, this);
          this._tickerAdded = false;
        }
        /** Sets flag to not fire extra events when the user has already moved there mouse */
        pointerMoved() {
          this._didMove = true;
        }
        /** Updates the state of interactive objects. */
        _update() {
          if (!this.domElement || this._pauseUpdate) {
            return;
          }
          if (this._didMove) {
            this._didMove = false;
            return;
          }
          const rootPointerEvent = this.events["_rootPointerEvent"];
          if (this.events.supportsTouchEvents && rootPointerEvent.pointerType === "touch") {
            return;
          }
          globalThis.document.dispatchEvent(new PointerEvent("pointermove", {
            clientX: rootPointerEvent.clientX,
            clientY: rootPointerEvent.clientY
          }));
        }
        /**
         * Updates the state of interactive objects if at least {@link interactionFrequency}
         * milliseconds have passed since the last invocation.
         *
         * Invoked by a throttled ticker update from {@link Ticker.system}.
         * @param ticker - The throttled ticker.
         */
        _tickerUpdate(ticker) {
          this._deltaTime += ticker.deltaTime;
          if (this._deltaTime < this.interactionFrequency) {
            return;
          }
          this._deltaTime = 0;
          this._update();
        }
      };
      EventsTicker = new EventsTickerClass();
    }
  });

  // ../core/node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs
  var FederatedMouseEvent;
  var init_FederatedMouseEvent = __esm({
    "../core/node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs"() {
      init_Point();
      init_FederatedEvent();
      FederatedMouseEvent = class extends FederatedEvent {
        constructor() {
          super(...arguments);
          this.client = new Point();
          this.movement = new Point();
          this.offset = new Point();
          this.global = new Point();
          this.screen = new Point();
        }
        /** @readonly */
        get clientX() {
          return this.client.x;
        }
        /** @readonly */
        get clientY() {
          return this.client.y;
        }
        /**
         * Alias for {@link FederatedMouseEvent.clientX this.clientX}.
         * @readonly
         */
        get x() {
          return this.clientX;
        }
        /**
         * Alias for {@link FederatedMouseEvent.clientY this.clientY}.
         * @readonly
         */
        get y() {
          return this.clientY;
        }
        /** @readonly */
        get movementX() {
          return this.movement.x;
        }
        /** @readonly */
        get movementY() {
          return this.movement.y;
        }
        /** @readonly */
        get offsetX() {
          return this.offset.x;
        }
        /** @readonly */
        get offsetY() {
          return this.offset.y;
        }
        /** @readonly */
        get globalX() {
          return this.global.x;
        }
        /** @readonly */
        get globalY() {
          return this.global.y;
        }
        /**
         * The pointer coordinates in the renderer's screen. Alias for {@code screen.x}.
         * @readonly
         */
        get screenX() {
          return this.screen.x;
        }
        /**
         * The pointer coordinates in the renderer's screen. Alias for {@code screen.y}.
         * @readonly
         */
        get screenY() {
          return this.screen.y;
        }
        /**
         * This will return the local coordinates of the specified container for this InteractionData
         * @param {Container} container - The Container that you would like the local
         *  coords off
         * @param {PointData} point - A Point object in which to store the value, optional (otherwise
         *  will create a new point)
         * @param {PointData} globalPos - A Point object containing your custom global coords, optional
         *  (otherwise will use the current global coords)
         * @returns - A point containing the coordinates of the InteractionData position relative
         *  to the Container
         */
        getLocalPosition(container, point, globalPos) {
          return container.worldTransform.applyInverse(globalPos || this.global, point);
        }
        /**
         * Whether the modifier key was pressed when this event natively occurred.
         * @param key - The modifier key.
         */
        getModifierState(key) {
          return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
        }
        /**
         * Not supported.
         * @param _typeArg
         * @param _canBubbleArg
         * @param _cancelableArg
         * @param _viewArg
         * @param _detailArg
         * @param _screenXArg
         * @param _screenYArg
         * @param _clientXArg
         * @param _clientYArg
         * @param _ctrlKeyArg
         * @param _altKeyArg
         * @param _shiftKeyArg
         * @param _metaKeyArg
         * @param _buttonArg
         * @param _relatedTargetArg
         * @deprecated since 7.0.0
         */
        // eslint-disable-next-line max-params
        initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {
          throw new Error("Method not implemented.");
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/events/FederatedPointerEvent.mjs
  var FederatedPointerEvent;
  var init_FederatedPointerEvent = __esm({
    "../core/node_modules/pixi.js/lib/events/FederatedPointerEvent.mjs"() {
      init_FederatedMouseEvent();
      FederatedPointerEvent = class extends FederatedMouseEvent {
        constructor() {
          super(...arguments);
          this.width = 0;
          this.height = 0;
          this.isPrimary = false;
        }
        // Only included for completeness for now
        getCoalescedEvents() {
          if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {
            return [this];
          }
          return [];
        }
        // Only included for completeness for now
        getPredictedEvents() {
          throw new Error("getPredictedEvents is not supported!");
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/events/FederatedWheelEvent.mjs
  var FederatedWheelEvent;
  var init_FederatedWheelEvent = __esm({
    "../core/node_modules/pixi.js/lib/events/FederatedWheelEvent.mjs"() {
      init_FederatedMouseEvent();
      FederatedWheelEvent = class extends FederatedMouseEvent {
        constructor() {
          super(...arguments);
          this.DOM_DELTA_PIXEL = 0;
          this.DOM_DELTA_LINE = 1;
          this.DOM_DELTA_PAGE = 2;
        }
      };
      FederatedWheelEvent.DOM_DELTA_PIXEL = 0;
      FederatedWheelEvent.DOM_DELTA_LINE = 1;
      FederatedWheelEvent.DOM_DELTA_PAGE = 2;
    }
  });

  // ../core/node_modules/pixi.js/lib/events/EventBoundary.mjs
  var PROPAGATION_LIMIT, tempHitLocation, tempLocalMapping, EventBoundary;
  var init_EventBoundary = __esm({
    "../core/node_modules/pixi.js/lib/events/EventBoundary.mjs"() {
      init_eventemitter3();
      init_Point();
      init_warn();
      init_EventTicker();
      init_FederatedMouseEvent();
      init_FederatedPointerEvent();
      init_FederatedWheelEvent();
      PROPAGATION_LIMIT = 2048;
      tempHitLocation = new Point();
      tempLocalMapping = new Point();
      EventBoundary = class {
        /**
         * @param rootTarget - The holder of the event boundary.
         */
        constructor(rootTarget) {
          this.dispatch = new eventemitter3_default();
          this.moveOnAll = false;
          this.enableGlobalMoveEvents = true;
          this.mappingState = {
            trackingData: {}
          };
          this.eventPool = /* @__PURE__ */ new Map();
          this._allInteractiveElements = [];
          this._hitElements = [];
          this._isPointerMoveEvent = false;
          this.rootTarget = rootTarget;
          this.hitPruneFn = this.hitPruneFn.bind(this);
          this.hitTestFn = this.hitTestFn.bind(this);
          this.mapPointerDown = this.mapPointerDown.bind(this);
          this.mapPointerMove = this.mapPointerMove.bind(this);
          this.mapPointerOut = this.mapPointerOut.bind(this);
          this.mapPointerOver = this.mapPointerOver.bind(this);
          this.mapPointerUp = this.mapPointerUp.bind(this);
          this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);
          this.mapWheel = this.mapWheel.bind(this);
          this.mappingTable = {};
          this.addEventMapping("pointerdown", this.mapPointerDown);
          this.addEventMapping("pointermove", this.mapPointerMove);
          this.addEventMapping("pointerout", this.mapPointerOut);
          this.addEventMapping("pointerleave", this.mapPointerOut);
          this.addEventMapping("pointerover", this.mapPointerOver);
          this.addEventMapping("pointerup", this.mapPointerUp);
          this.addEventMapping("pointerupoutside", this.mapPointerUpOutside);
          this.addEventMapping("wheel", this.mapWheel);
        }
        /**
         * Adds an event mapping for the event `type` handled by `fn`.
         *
         * Event mappings can be used to implement additional or custom events. They take an event
         * coming from the upstream scene (or directly from the {@link EventSystem}) and dispatch new downstream events
         * generally trickling down and bubbling up to {@link EventBoundary.rootTarget this.rootTarget}.
         *
         * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden
         * instead.
         * @param type - The type of upstream event to map.
         * @param fn - The mapping method. The context of this function must be bound manually, if desired.
         */
        addEventMapping(type, fn) {
          if (!this.mappingTable[type]) {
            this.mappingTable[type] = [];
          }
          this.mappingTable[type].push({
            fn,
            priority: 0
          });
          this.mappingTable[type].sort((a2, b2) => a2.priority - b2.priority);
        }
        /**
         * Dispatches the given event
         * @param e - The event to dispatch.
         * @param type - The type of event to dispatch. Defaults to `e.type`.
         */
        dispatchEvent(e2, type) {
          e2.propagationStopped = false;
          e2.propagationImmediatelyStopped = false;
          this.propagate(e2, type);
          this.dispatch.emit(type || e2.type, e2);
        }
        /**
         * Maps the given upstream event through the event boundary and propagates it downstream.
         * @param e - The event to map.
         */
        mapEvent(e2) {
          if (!this.rootTarget) {
            return;
          }
          const mappers = this.mappingTable[e2.type];
          if (mappers) {
            for (let i2 = 0, j2 = mappers.length; i2 < j2; i2++) {
              mappers[i2].fn(e2);
            }
          } else {
            warn(`[EventBoundary]: Event mapping not defined for ${e2.type}`);
          }
        }
        /**
         * Finds the Container that is the target of a event at the given coordinates.
         *
         * The passed (x,y) coordinates are in the world space above this event boundary.
         * @param x - The x coordinate of the event.
         * @param y - The y coordinate of the event.
         */
        hitTest(x2, y2) {
          EventsTicker.pauseUpdate = true;
          const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;
          const fn = useMove ? "hitTestMoveRecursive" : "hitTestRecursive";
          const invertedPath = this[fn](
            this.rootTarget,
            this.rootTarget.eventMode,
            tempHitLocation.set(x2, y2),
            this.hitTestFn,
            this.hitPruneFn
          );
          return invertedPath && invertedPath[0];
        }
        /**
         * Propagate the passed event from from {@link EventBoundary.rootTarget this.rootTarget} to its
         * target {@code e.target}.
         * @param e - The event to propagate.
         * @param type - The type of event to propagate. Defaults to `e.type`.
         */
        propagate(e2, type) {
          if (!e2.target) {
            return;
          }
          const composedPath = e2.composedPath();
          e2.eventPhase = e2.CAPTURING_PHASE;
          for (let i2 = 0, j2 = composedPath.length - 1; i2 < j2; i2++) {
            e2.currentTarget = composedPath[i2];
            this.notifyTarget(e2, type);
            if (e2.propagationStopped || e2.propagationImmediatelyStopped)
              return;
          }
          e2.eventPhase = e2.AT_TARGET;
          e2.currentTarget = e2.target;
          this.notifyTarget(e2, type);
          if (e2.propagationStopped || e2.propagationImmediatelyStopped)
            return;
          e2.eventPhase = e2.BUBBLING_PHASE;
          for (let i2 = composedPath.length - 2; i2 >= 0; i2--) {
            e2.currentTarget = composedPath[i2];
            this.notifyTarget(e2, type);
            if (e2.propagationStopped || e2.propagationImmediatelyStopped)
              return;
          }
        }
        /**
         * Emits the event {@code e} to all interactive containers. The event is propagated in the bubbling phase always.
         *
         * This is used in the `globalpointermove` event.
         * @param e - The emitted event.
         * @param type - The listeners to notify.
         * @param targets - The targets to notify.
         */
        all(e2, type, targets = this._allInteractiveElements) {
          if (targets.length === 0)
            return;
          e2.eventPhase = e2.BUBBLING_PHASE;
          const events = Array.isArray(type) ? type : [type];
          for (let i2 = targets.length - 1; i2 >= 0; i2--) {
            events.forEach((event) => {
              e2.currentTarget = targets[i2];
              this.notifyTarget(e2, event);
            });
          }
        }
        /**
         * Finds the propagation path from {@link EventBoundary.rootTarget rootTarget} to the passed
         * {@code target}. The last element in the path is {@code target}.
         * @param target - The target to find the propagation path to.
         */
        propagationPath(target) {
          const propagationPath = [target];
          for (let i2 = 0; i2 < PROPAGATION_LIMIT && (target !== this.rootTarget && target.parent); i2++) {
            if (!target.parent) {
              throw new Error("Cannot find propagation path to disconnected target");
            }
            propagationPath.push(target.parent);
            target = target.parent;
          }
          propagationPath.reverse();
          return propagationPath;
        }
        hitTestMoveRecursive(currentTarget, eventMode, location, testFn, pruneFn, ignore = false) {
          let shouldReturn = false;
          if (this._interactivePrune(currentTarget))
            return null;
          if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
            EventsTicker.pauseUpdate = false;
          }
          if (currentTarget.interactiveChildren && currentTarget.children) {
            const children2 = currentTarget.children;
            for (let i2 = children2.length - 1; i2 >= 0; i2--) {
              const child = children2[i2];
              const nestedHit = this.hitTestMoveRecursive(
                child,
                this._isInteractive(eventMode) ? eventMode : child.eventMode,
                location,
                testFn,
                pruneFn,
                ignore || pruneFn(currentTarget, location)
              );
              if (nestedHit) {
                if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
                  continue;
                }
                const isInteractive = currentTarget.isInteractive();
                if (nestedHit.length > 0 || isInteractive) {
                  if (isInteractive)
                    this._allInteractiveElements.push(currentTarget);
                  nestedHit.push(currentTarget);
                }
                if (this._hitElements.length === 0)
                  this._hitElements = nestedHit;
                shouldReturn = true;
              }
            }
          }
          const isInteractiveMode = this._isInteractive(eventMode);
          const isInteractiveTarget = currentTarget.isInteractive();
          if (isInteractiveTarget && isInteractiveTarget)
            this._allInteractiveElements.push(currentTarget);
          if (ignore || this._hitElements.length > 0)
            return null;
          if (shouldReturn)
            return this._hitElements;
          if (isInteractiveMode && (!pruneFn(currentTarget, location) && testFn(currentTarget, location))) {
            return isInteractiveTarget ? [currentTarget] : [];
          }
          return null;
        }
        /**
         * Recursive implementation for {@link EventBoundary.hitTest hitTest}.
         * @param currentTarget - The Container that is to be hit tested.
         * @param eventMode - The event mode for the `currentTarget` or one of its parents.
         * @param location - The location that is being tested for overlap.
         * @param testFn - Callback that determines whether the target passes hit testing. This callback
         *  can assume that `pruneFn` failed to prune the container.
         * @param pruneFn - Callback that determiness whether the target and all of its children
         *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees
         *  of the scene graph.
         * @returns An array holding the hit testing target and all its ancestors in order. The first element
         *  is the target itself and the last is {@link EventBoundary.rootTarget rootTarget}. This is the opposite
         *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.
         */
        hitTestRecursive(currentTarget, eventMode, location, testFn, pruneFn) {
          if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location)) {
            return null;
          }
          if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
            EventsTicker.pauseUpdate = false;
          }
          if (currentTarget.interactiveChildren && currentTarget.children) {
            const children2 = currentTarget.children;
            const relativeLocation = location;
            for (let i2 = children2.length - 1; i2 >= 0; i2--) {
              const child = children2[i2];
              const nestedHit = this.hitTestRecursive(
                child,
                this._isInteractive(eventMode) ? eventMode : child.eventMode,
                relativeLocation,
                testFn,
                pruneFn
              );
              if (nestedHit) {
                if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
                  continue;
                }
                const isInteractive = currentTarget.isInteractive();
                if (nestedHit.length > 0 || isInteractive)
                  nestedHit.push(currentTarget);
                return nestedHit;
              }
            }
          }
          const isInteractiveMode = this._isInteractive(eventMode);
          const isInteractiveTarget = currentTarget.isInteractive();
          if (isInteractiveMode && testFn(currentTarget, location)) {
            return isInteractiveTarget ? [currentTarget] : [];
          }
          return null;
        }
        _isInteractive(int) {
          return int === "static" || int === "dynamic";
        }
        _interactivePrune(container) {
          if (!container || !container.visible || !container.renderable) {
            return true;
          }
          if (container.eventMode === "none") {
            return true;
          }
          if (container.eventMode === "passive" && !container.interactiveChildren) {
            return true;
          }
          return false;
        }
        /**
         * Checks whether the container or any of its children cannot pass the hit test at all.
         *
         * {@link EventBoundary}'s implementation uses the {@link Container.hitArea hitArea}
         * and {@link Container._maskEffect} for pruning.
         * @param container - The container to prune.
         * @param location - The location to test for overlap.
         */
        hitPruneFn(container, location) {
          if (container.hitArea) {
            container.worldTransform.applyInverse(location, tempLocalMapping);
            if (!container.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)) {
              return true;
            }
          }
          if (container.effects && container.effects.length) {
            for (let i2 = 0; i2 < container.effects.length; i2++) {
              const effect = container.effects[i2];
              if (effect.containsPoint) {
                const effectContainsPoint = effect.containsPoint(location, this.hitTestFn);
                if (!effectContainsPoint) {
                  return true;
                }
              }
            }
          }
          return false;
        }
        /**
         * Checks whether the container passes hit testing for the given location.
         * @param container - The container to test.
         * @param location - The location to test for overlap.
         * @returns - Whether `container` passes hit testing for `location`.
         */
        hitTestFn(container, location) {
          if (container.hitArea) {
            return true;
          }
          if (container?.containsPoint) {
            container.worldTransform.applyInverse(location, tempLocalMapping);
            return container.containsPoint(tempLocalMapping);
          }
          return false;
        }
        /**
         * Notify all the listeners to the event's `currentTarget`.
         *
         * If the `currentTarget` contains the property `on<type>`, then it is called here,
         * simulating the behavior from version 6.x and prior.
         * @param e - The event passed to the target.
         * @param type - The type of event to notify. Defaults to `e.type`.
         */
        notifyTarget(e2, type) {
          type = type ?? e2.type;
          const handlerKey = `on${type}`;
          e2.currentTarget[handlerKey]?.(e2);
          const key = e2.eventPhase === e2.CAPTURING_PHASE || e2.eventPhase === e2.AT_TARGET ? `${type}capture` : type;
          this._notifyListeners(e2, key);
          if (e2.eventPhase === e2.AT_TARGET) {
            this._notifyListeners(e2, type);
          }
        }
        /**
         * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.
         *
         * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.
         * @param from - The upstream `pointerdown` event.
         */
        mapPointerDown(from3) {
          if (!(from3 instanceof FederatedPointerEvent)) {
            warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          const e2 = this.createPointerEvent(from3);
          this.dispatchEvent(e2, "pointerdown");
          if (e2.pointerType === "touch") {
            this.dispatchEvent(e2, "touchstart");
          } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
            const isRightButton = e2.button === 2;
            this.dispatchEvent(e2, isRightButton ? "rightdown" : "mousedown");
          }
          const trackingData = this.trackingData(from3.pointerId);
          trackingData.pressTargetsByButton[from3.button] = e2.composedPath();
          this.freeEvent(e2);
        }
        /**
         * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.
         *
         * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,
         * `mousemove`, and `touchmove` events are fired as well for specific pointer types.
         * @param from - The upstream `pointermove` event.
         */
        mapPointerMove(from3) {
          if (!(from3 instanceof FederatedPointerEvent)) {
            warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          this._allInteractiveElements.length = 0;
          this._hitElements.length = 0;
          this._isPointerMoveEvent = true;
          const e2 = this.createPointerEvent(from3);
          this._isPointerMoveEvent = false;
          const isMouse = e2.pointerType === "mouse" || e2.pointerType === "pen";
          const trackingData = this.trackingData(from3.pointerId);
          const outTarget = this.findMountedTarget(trackingData.overTargets);
          if (trackingData.overTargets?.length > 0 && outTarget !== e2.target) {
            const outType = from3.type === "mousemove" ? "mouseout" : "pointerout";
            const outEvent = this.createPointerEvent(from3, outType, outTarget);
            this.dispatchEvent(outEvent, "pointerout");
            if (isMouse)
              this.dispatchEvent(outEvent, "mouseout");
            if (!e2.composedPath().includes(outTarget)) {
              const leaveEvent = this.createPointerEvent(from3, "pointerleave", outTarget);
              leaveEvent.eventPhase = leaveEvent.AT_TARGET;
              while (leaveEvent.target && !e2.composedPath().includes(leaveEvent.target)) {
                leaveEvent.currentTarget = leaveEvent.target;
                this.notifyTarget(leaveEvent);
                if (isMouse)
                  this.notifyTarget(leaveEvent, "mouseleave");
                leaveEvent.target = leaveEvent.target.parent;
              }
              this.freeEvent(leaveEvent);
            }
            this.freeEvent(outEvent);
          }
          if (outTarget !== e2.target) {
            const overType = from3.type === "mousemove" ? "mouseover" : "pointerover";
            const overEvent = this.clonePointerEvent(e2, overType);
            this.dispatchEvent(overEvent, "pointerover");
            if (isMouse)
              this.dispatchEvent(overEvent, "mouseover");
            let overTargetAncestor = outTarget?.parent;
            while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent) {
              if (overTargetAncestor === e2.target)
                break;
              overTargetAncestor = overTargetAncestor.parent;
            }
            const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;
            if (didPointerEnter) {
              const enterEvent = this.clonePointerEvent(e2, "pointerenter");
              enterEvent.eventPhase = enterEvent.AT_TARGET;
              while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent) {
                enterEvent.currentTarget = enterEvent.target;
                this.notifyTarget(enterEvent);
                if (isMouse)
                  this.notifyTarget(enterEvent, "mouseenter");
                enterEvent.target = enterEvent.target.parent;
              }
              this.freeEvent(enterEvent);
            }
            this.freeEvent(overEvent);
          }
          const allMethods = [];
          const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;
          this.moveOnAll ? allMethods.push("pointermove") : this.dispatchEvent(e2, "pointermove");
          allowGlobalPointerEvents && allMethods.push("globalpointermove");
          if (e2.pointerType === "touch") {
            this.moveOnAll ? allMethods.splice(1, 0, "touchmove") : this.dispatchEvent(e2, "touchmove");
            allowGlobalPointerEvents && allMethods.push("globaltouchmove");
          }
          if (isMouse) {
            this.moveOnAll ? allMethods.splice(1, 0, "mousemove") : this.dispatchEvent(e2, "mousemove");
            allowGlobalPointerEvents && allMethods.push("globalmousemove");
            this.cursor = e2.target?.cursor;
          }
          if (allMethods.length > 0) {
            this.all(e2, allMethods);
          }
          this._allInteractiveElements.length = 0;
          this._hitElements.length = 0;
          trackingData.overTargets = e2.composedPath();
          this.freeEvent(e2);
        }
        /**
         * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.
         *
         * The tracking data for the specific pointer gets a new `overTarget`.
         * @param from - The upstream `pointerover` event.
         */
        mapPointerOver(from3) {
          if (!(from3 instanceof FederatedPointerEvent)) {
            warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          const trackingData = this.trackingData(from3.pointerId);
          const e2 = this.createPointerEvent(from3);
          const isMouse = e2.pointerType === "mouse" || e2.pointerType === "pen";
          this.dispatchEvent(e2, "pointerover");
          if (isMouse)
            this.dispatchEvent(e2, "mouseover");
          if (e2.pointerType === "mouse")
            this.cursor = e2.target?.cursor;
          const enterEvent = this.clonePointerEvent(e2, "pointerenter");
          enterEvent.eventPhase = enterEvent.AT_TARGET;
          while (enterEvent.target && enterEvent.target !== this.rootTarget.parent) {
            enterEvent.currentTarget = enterEvent.target;
            this.notifyTarget(enterEvent);
            if (isMouse)
              this.notifyTarget(enterEvent, "mouseenter");
            enterEvent.target = enterEvent.target.parent;
          }
          trackingData.overTargets = e2.composedPath();
          this.freeEvent(e2);
          this.freeEvent(enterEvent);
        }
        /**
         * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.
         *
         * The tracking data for the specific pointer is cleared of a `overTarget`.
         * @param from - The upstream `pointerout` event.
         */
        mapPointerOut(from3) {
          if (!(from3 instanceof FederatedPointerEvent)) {
            warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          const trackingData = this.trackingData(from3.pointerId);
          if (trackingData.overTargets) {
            const isMouse = from3.pointerType === "mouse" || from3.pointerType === "pen";
            const outTarget = this.findMountedTarget(trackingData.overTargets);
            const outEvent = this.createPointerEvent(from3, "pointerout", outTarget);
            this.dispatchEvent(outEvent);
            if (isMouse)
              this.dispatchEvent(outEvent, "mouseout");
            const leaveEvent = this.createPointerEvent(from3, "pointerleave", outTarget);
            leaveEvent.eventPhase = leaveEvent.AT_TARGET;
            while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent) {
              leaveEvent.currentTarget = leaveEvent.target;
              this.notifyTarget(leaveEvent);
              if (isMouse)
                this.notifyTarget(leaveEvent, "mouseleave");
              leaveEvent.target = leaveEvent.target.parent;
            }
            trackingData.overTargets = null;
            this.freeEvent(outEvent);
            this.freeEvent(leaveEvent);
          }
          this.cursor = null;
        }
        /**
         * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`,
         * and `click`/`rightclick`/`pointertap` events, in that order.
         *
         * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific
         * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event's target. `touchend`,
         * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for
         * specific pointer types.
         * @param from - The upstream `pointerup` event.
         */
        mapPointerUp(from3) {
          if (!(from3 instanceof FederatedPointerEvent)) {
            warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          const now2 = performance.now();
          const e2 = this.createPointerEvent(from3);
          this.dispatchEvent(e2, "pointerup");
          if (e2.pointerType === "touch") {
            this.dispatchEvent(e2, "touchend");
          } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
            const isRightButton = e2.button === 2;
            this.dispatchEvent(e2, isRightButton ? "rightup" : "mouseup");
          }
          const trackingData = this.trackingData(from3.pointerId);
          const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from3.button]);
          let clickTarget = pressTarget;
          if (pressTarget && !e2.composedPath().includes(pressTarget)) {
            let currentTarget = pressTarget;
            while (currentTarget && !e2.composedPath().includes(currentTarget)) {
              e2.currentTarget = currentTarget;
              this.notifyTarget(e2, "pointerupoutside");
              if (e2.pointerType === "touch") {
                this.notifyTarget(e2, "touchendoutside");
              } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
                const isRightButton = e2.button === 2;
                this.notifyTarget(e2, isRightButton ? "rightupoutside" : "mouseupoutside");
              }
              currentTarget = currentTarget.parent;
            }
            delete trackingData.pressTargetsByButton[from3.button];
            clickTarget = currentTarget;
          }
          if (clickTarget) {
            const clickEvent = this.clonePointerEvent(e2, "click");
            clickEvent.target = clickTarget;
            clickEvent.path = null;
            if (!trackingData.clicksByButton[from3.button]) {
              trackingData.clicksByButton[from3.button] = {
                clickCount: 0,
                target: clickEvent.target,
                timeStamp: now2
              };
            }
            const clickHistory = trackingData.clicksByButton[from3.button];
            if (clickHistory.target === clickEvent.target && now2 - clickHistory.timeStamp < 200) {
              ++clickHistory.clickCount;
            } else {
              clickHistory.clickCount = 1;
            }
            clickHistory.target = clickEvent.target;
            clickHistory.timeStamp = now2;
            clickEvent.detail = clickHistory.clickCount;
            if (clickEvent.pointerType === "mouse") {
              const isRightButton = clickEvent.button === 2;
              this.dispatchEvent(clickEvent, isRightButton ? "rightclick" : "click");
            } else if (clickEvent.pointerType === "touch") {
              this.dispatchEvent(clickEvent, "tap");
            }
            this.dispatchEvent(clickEvent, "pointertap");
            this.freeEvent(clickEvent);
          }
          this.freeEvent(e2);
        }
        /**
         * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original
         * `pointerdown` target to `rootTarget`.
         *
         * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the
         * `{@link EventBoundary}'s root because the `pointerup` event occurred outside of the boundary.)
         *
         * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer
         * types. The tracking data for the specific pointer is cleared of a `pressTarget`.
         * @param from - The upstream `pointerupoutside` event.
         */
        mapPointerUpOutside(from3) {
          if (!(from3 instanceof FederatedPointerEvent)) {
            warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          const trackingData = this.trackingData(from3.pointerId);
          const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from3.button]);
          const e2 = this.createPointerEvent(from3);
          if (pressTarget) {
            let currentTarget = pressTarget;
            while (currentTarget) {
              e2.currentTarget = currentTarget;
              this.notifyTarget(e2, "pointerupoutside");
              if (e2.pointerType === "touch") {
                this.notifyTarget(e2, "touchendoutside");
              } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
                this.notifyTarget(e2, e2.button === 2 ? "rightupoutside" : "mouseupoutside");
              }
              currentTarget = currentTarget.parent;
            }
            delete trackingData.pressTargetsByButton[from3.button];
          }
          this.freeEvent(e2);
        }
        /**
         * Maps the upstream `wheel` event to a downstream `wheel` event.
         * @param from - The upstream `wheel` event.
         */
        mapWheel(from3) {
          if (!(from3 instanceof FederatedWheelEvent)) {
            warn("EventBoundary cannot map a non-wheel event as a wheel event");
            return;
          }
          const wheelEvent = this.createWheelEvent(from3);
          this.dispatchEvent(wheelEvent);
          this.freeEvent(wheelEvent);
        }
        /**
         * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.
         *
         * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`
         * or `pointerover` target was unmounted from the scene graph.
         * @param propagationPath - The propagation path was valid in the past.
         * @returns - The most specific event-target still mounted at the same location in the scene graph.
         */
        findMountedTarget(propagationPath) {
          if (!propagationPath) {
            return null;
          }
          let currentTarget = propagationPath[0];
          for (let i2 = 1; i2 < propagationPath.length; i2++) {
            if (propagationPath[i2].parent === currentTarget) {
              currentTarget = propagationPath[i2];
            } else {
              break;
            }
          }
          return currentTarget;
        }
        /**
         * Creates an event whose {@code originalEvent} is {@code from}, with an optional `type` and `target` override.
         *
         * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
         * @param from - The {@code originalEvent} for the returned event.
         * @param [type=from.type] - The type of the returned event.
         * @param target - The target of the returned event.
         */
        createPointerEvent(from3, type, target) {
          const event = this.allocateEvent(FederatedPointerEvent);
          this.copyPointerData(from3, event);
          this.copyMouseData(from3, event);
          this.copyData(from3, event);
          event.nativeEvent = from3.nativeEvent;
          event.originalEvent = from3;
          event.target = target ?? this.hitTest(event.global.x, event.global.y) ?? this._hitElements[0];
          if (typeof type === "string") {
            event.type = type;
          }
          return event;
        }
        /**
         * Creates a wheel event whose {@code originalEvent} is {@code from}.
         *
         * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
         * @param from - The upstream wheel event.
         */
        createWheelEvent(from3) {
          const event = this.allocateEvent(FederatedWheelEvent);
          this.copyWheelData(from3, event);
          this.copyMouseData(from3, event);
          this.copyData(from3, event);
          event.nativeEvent = from3.nativeEvent;
          event.originalEvent = from3;
          event.target = this.hitTest(event.global.x, event.global.y);
          return event;
        }
        /**
         * Clones the event {@code from}, with an optional {@code type} override.
         *
         * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
         * @param from - The event to clone.
         * @param [type=from.type] - The type of the returned event.
         */
        clonePointerEvent(from3, type) {
          const event = this.allocateEvent(FederatedPointerEvent);
          event.nativeEvent = from3.nativeEvent;
          event.originalEvent = from3.originalEvent;
          this.copyPointerData(from3, event);
          this.copyMouseData(from3, event);
          this.copyData(from3, event);
          event.target = from3.target;
          event.path = from3.composedPath().slice();
          event.type = type ?? event.type;
          return event;
        }
        /**
         * Copies wheel {@link FederatedWheelEvent} data from {@code from} into {@code to}.
         *
         * The following properties are copied:
         * + deltaMode
         * + deltaX
         * + deltaY
         * + deltaZ
         * @param from - The event to copy data from.
         * @param to - The event to copy data into.
         */
        copyWheelData(from3, to) {
          to.deltaMode = from3.deltaMode;
          to.deltaX = from3.deltaX;
          to.deltaY = from3.deltaY;
          to.deltaZ = from3.deltaZ;
        }
        /**
         * Copies pointer {@link FederatedPointerEvent} data from {@code from} into {@code to}.
         *
         * The following properties are copied:
         * + pointerId
         * + width
         * + height
         * + isPrimary
         * + pointerType
         * + pressure
         * + tangentialPressure
         * + tiltX
         * + tiltY
         * @param from - The event to copy data from.
         * @param to - The event to copy data into.
         */
        copyPointerData(from3, to) {
          if (!(from3 instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent))
            return;
          to.pointerId = from3.pointerId;
          to.width = from3.width;
          to.height = from3.height;
          to.isPrimary = from3.isPrimary;
          to.pointerType = from3.pointerType;
          to.pressure = from3.pressure;
          to.tangentialPressure = from3.tangentialPressure;
          to.tiltX = from3.tiltX;
          to.tiltY = from3.tiltY;
          to.twist = from3.twist;
        }
        /**
         * Copies mouse {@link FederatedMouseEvent} data from {@code from} to {@code to}.
         *
         * The following properties are copied:
         * + altKey
         * + button
         * + buttons
         * + clientX
         * + clientY
         * + metaKey
         * + movementX
         * + movementY
         * + pageX
         * + pageY
         * + x
         * + y
         * + screen
         * + shiftKey
         * + global
         * @param from - The event to copy data from.
         * @param to - The event to copy data into.
         */
        copyMouseData(from3, to) {
          if (!(from3 instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent))
            return;
          to.altKey = from3.altKey;
          to.button = from3.button;
          to.buttons = from3.buttons;
          to.client.copyFrom(from3.client);
          to.ctrlKey = from3.ctrlKey;
          to.metaKey = from3.metaKey;
          to.movement.copyFrom(from3.movement);
          to.screen.copyFrom(from3.screen);
          to.shiftKey = from3.shiftKey;
          to.global.copyFrom(from3.global);
        }
        /**
         * Copies base {@link FederatedEvent} data from {@code from} into {@code to}.
         *
         * The following properties are copied:
         * + isTrusted
         * + srcElement
         * + timeStamp
         * + type
         * @param from - The event to copy data from.
         * @param to - The event to copy data into.
         */
        copyData(from3, to) {
          to.isTrusted = from3.isTrusted;
          to.srcElement = from3.srcElement;
          to.timeStamp = performance.now();
          to.type = from3.type;
          to.detail = from3.detail;
          to.view = from3.view;
          to.which = from3.which;
          to.layer.copyFrom(from3.layer);
          to.page.copyFrom(from3.page);
        }
        /**
         * @param id - The pointer ID.
         * @returns The tracking data stored for the given pointer. If no data exists, a blank
         *  state will be created.
         */
        trackingData(id) {
          if (!this.mappingState.trackingData[id]) {
            this.mappingState.trackingData[id] = {
              pressTargetsByButton: {},
              clicksByButton: {},
              overTarget: null
            };
          }
          return this.mappingState.trackingData[id];
        }
        /**
         * Allocate a specific type of event from {@link EventBoundary#eventPool this.eventPool}.
         *
         * This allocation is constructor-agnostic, as long as it only takes one argument - this event
         * boundary.
         * @param constructor - The event's constructor.
         */
        allocateEvent(constructor) {
          if (!this.eventPool.has(constructor)) {
            this.eventPool.set(constructor, []);
          }
          const event = this.eventPool.get(constructor).pop() || new constructor(this);
          event.eventPhase = event.NONE;
          event.currentTarget = null;
          event.path = null;
          event.target = null;
          return event;
        }
        /**
         * Frees the event and puts it back into the event pool.
         *
         * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.
         *
         * It is also advised that events not allocated from {@link EventBoundary#allocateEvent this.allocateEvent}
         * not be freed. This is because of the possibility that the same event is freed twice, which can cause
         * it to be allocated twice & result in overwriting.
         * @param event - The event to be freed.
         * @throws Error if the event is managed by another event boundary.
         */
        freeEvent(event) {
          if (event.manager !== this)
            throw new Error("It is illegal to free an event not managed by this EventBoundary!");
          const constructor = event.constructor;
          if (!this.eventPool.has(constructor)) {
            this.eventPool.set(constructor, []);
          }
          this.eventPool.get(constructor).push(event);
        }
        /**
         * Similar to {@link EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag
         * is set on the event.
         * @param e - The event to call each listener with.
         * @param type - The event key.
         */
        _notifyListeners(e2, type) {
          const listeners = e2.currentTarget._events[type];
          if (!listeners)
            return;
          if (!e2.currentTarget.isInteractive())
            return;
          if ("fn" in listeners) {
            if (listeners.once)
              e2.currentTarget.removeListener(type, listeners.fn, void 0, true);
            listeners.fn.call(listeners.context, e2);
          } else {
            for (let i2 = 0, j2 = listeners.length; i2 < j2 && !e2.propagationImmediatelyStopped; i2++) {
              if (listeners[i2].once)
                e2.currentTarget.removeListener(type, listeners[i2].fn, void 0, true);
              listeners[i2].fn.call(listeners[i2].context, e2);
            }
          }
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/events/EventSystem.mjs
  var MOUSE_POINTER_ID, TOUCH_TO_POINTER, _EventSystem, EventSystem;
  var init_EventSystem = __esm({
    "../core/node_modules/pixi.js/lib/events/EventSystem.mjs"() {
      init_Extensions();
      init_EventBoundary();
      init_EventTicker();
      init_FederatedPointerEvent();
      init_FederatedWheelEvent();
      MOUSE_POINTER_ID = 1;
      TOUCH_TO_POINTER = {
        touchstart: "pointerdown",
        touchend: "pointerup",
        touchendoutside: "pointerupoutside",
        touchmove: "pointermove",
        touchcancel: "pointercancel"
      };
      _EventSystem = class _EventSystem2 {
        /**
         * @param {Renderer} renderer
         */
        constructor(renderer) {
          this.supportsTouchEvents = "ontouchstart" in globalThis;
          this.supportsPointerEvents = !!globalThis.PointerEvent;
          this.domElement = null;
          this.resolution = 1;
          this.renderer = renderer;
          this.rootBoundary = new EventBoundary(null);
          EventsTicker.init(this);
          this.autoPreventDefault = true;
          this._eventsAdded = false;
          this._rootPointerEvent = new FederatedPointerEvent(null);
          this._rootWheelEvent = new FederatedWheelEvent(null);
          this.cursorStyles = {
            default: "inherit",
            pointer: "pointer"
          };
          this.features = new Proxy({ ..._EventSystem2.defaultEventFeatures }, {
            set: (target, key, value) => {
              if (key === "globalMove") {
                this.rootBoundary.enableGlobalMoveEvents = value;
              }
              target[key] = value;
              return true;
            }
          });
          this._onPointerDown = this._onPointerDown.bind(this);
          this._onPointerMove = this._onPointerMove.bind(this);
          this._onPointerUp = this._onPointerUp.bind(this);
          this._onPointerOverOut = this._onPointerOverOut.bind(this);
          this.onWheel = this.onWheel.bind(this);
        }
        /**
         * The default interaction mode for all display objects.
         * @see Container.eventMode
         * @type {EventMode}
         * @readonly
         * @since 7.2.0
         */
        static get defaultEventMode() {
          return this._defaultEventMode;
        }
        /**
         * Runner init called, view is available at this point.
         * @ignore
         */
        init(options) {
          const { canvas, resolution } = this.renderer;
          this.setTargetElement(canvas);
          this.resolution = resolution;
          _EventSystem2._defaultEventMode = options.eventMode ?? "passive";
          Object.assign(this.features, options.eventFeatures ?? {});
          this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;
        }
        /**
         * Handle changing resolution.
         * @ignore
         */
        resolutionChange(resolution) {
          this.resolution = resolution;
        }
        /** Destroys all event listeners and detaches the renderer. */
        destroy() {
          this.setTargetElement(null);
          this.renderer = null;
          this._currentCursor = null;
        }
        /**
         * Sets the current cursor mode, handling any callbacks or CSS style changes.
         * @param mode - cursor mode, a key from the cursorStyles dictionary
         */
        setCursor(mode) {
          mode = mode || "default";
          let applyStyles = true;
          if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas) {
            applyStyles = false;
          }
          if (this._currentCursor === mode) {
            return;
          }
          this._currentCursor = mode;
          const style = this.cursorStyles[mode];
          if (style) {
            switch (typeof style) {
              case "string":
                if (applyStyles) {
                  this.domElement.style.cursor = style;
                }
                break;
              case "function":
                style(mode);
                break;
              case "object":
                if (applyStyles) {
                  Object.assign(this.domElement.style, style);
                }
                break;
            }
          } else if (applyStyles && typeof mode === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
            this.domElement.style.cursor = mode;
          }
        }
        /**
         * The global pointer event.
         * Useful for getting the pointer position without listening to events.
         * @since 7.2.0
         */
        get pointer() {
          return this._rootPointerEvent;
        }
        /**
         * Event handler for pointer down events on {@link EventSystem#domElement this.domElement}.
         * @param nativeEvent - The native mouse/pointer/touch event.
         */
        _onPointerDown(nativeEvent) {
          if (!this.features.click)
            return;
          this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
          const events = this._normalizeToPointerData(nativeEvent);
          if (this.autoPreventDefault && events[0].isNormalized) {
            const cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);
            if (cancelable) {
              nativeEvent.preventDefault();
            }
          }
          for (let i2 = 0, j2 = events.length; i2 < j2; i2++) {
            const nativeEvent2 = events[i2];
            const federatedEvent = this._bootstrapEvent(this._rootPointerEvent, nativeEvent2);
            this.rootBoundary.mapEvent(federatedEvent);
          }
          this.setCursor(this.rootBoundary.cursor);
        }
        /**
         * Event handler for pointer move events on on {@link EventSystem#domElement this.domElement}.
         * @param nativeEvent - The native mouse/pointer/touch events.
         */
        _onPointerMove(nativeEvent) {
          if (!this.features.move)
            return;
          this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
          EventsTicker.pointerMoved();
          const normalizedEvents = this._normalizeToPointerData(nativeEvent);
          for (let i2 = 0, j2 = normalizedEvents.length; i2 < j2; i2++) {
            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i2]);
            this.rootBoundary.mapEvent(event);
          }
          this.setCursor(this.rootBoundary.cursor);
        }
        /**
         * Event handler for pointer up events on {@link EventSystem#domElement this.domElement}.
         * @param nativeEvent - The native mouse/pointer/touch event.
         */
        _onPointerUp(nativeEvent) {
          if (!this.features.click)
            return;
          this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
          let target = nativeEvent.target;
          if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0) {
            target = nativeEvent.composedPath()[0];
          }
          const outside = target !== this.domElement ? "outside" : "";
          const normalizedEvents = this._normalizeToPointerData(nativeEvent);
          for (let i2 = 0, j2 = normalizedEvents.length; i2 < j2; i2++) {
            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i2]);
            event.type += outside;
            this.rootBoundary.mapEvent(event);
          }
          this.setCursor(this.rootBoundary.cursor);
        }
        /**
         * Event handler for pointer over & out events on {@link EventSystem#domElement this.domElement}.
         * @param nativeEvent - The native mouse/pointer/touch event.
         */
        _onPointerOverOut(nativeEvent) {
          if (!this.features.click)
            return;
          this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
          const normalizedEvents = this._normalizeToPointerData(nativeEvent);
          for (let i2 = 0, j2 = normalizedEvents.length; i2 < j2; i2++) {
            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i2]);
            this.rootBoundary.mapEvent(event);
          }
          this.setCursor(this.rootBoundary.cursor);
        }
        /**
         * Passive handler for `wheel` events on {@link EventSystem.domElement this.domElement}.
         * @param nativeEvent - The native wheel event.
         */
        onWheel(nativeEvent) {
          if (!this.features.wheel)
            return;
          const wheelEvent = this.normalizeWheelEvent(nativeEvent);
          this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
          this.rootBoundary.mapEvent(wheelEvent);
        }
        /**
         * Sets the {@link EventSystem#domElement domElement} and binds event listeners.
         *
         * To deregister the current DOM element without setting a new one, pass {@code null}.
         * @param element - The new DOM element.
         */
        setTargetElement(element2) {
          this._removeEvents();
          this.domElement = element2;
          EventsTicker.domElement = element2;
          this._addEvents();
        }
        /** Register event listeners on {@link Renderer#domElement this.domElement}. */
        _addEvents() {
          if (this._eventsAdded || !this.domElement) {
            return;
          }
          EventsTicker.addTickerListener();
          const style = this.domElement.style;
          if (style) {
            if (globalThis.navigator.msPointerEnabled) {
              style.msContentZooming = "none";
              style.msTouchAction = "none";
            } else if (this.supportsPointerEvents) {
              style.touchAction = "none";
            }
          }
          if (this.supportsPointerEvents) {
            globalThis.document.addEventListener("pointermove", this._onPointerMove, true);
            this.domElement.addEventListener("pointerdown", this._onPointerDown, true);
            this.domElement.addEventListener("pointerleave", this._onPointerOverOut, true);
            this.domElement.addEventListener("pointerover", this._onPointerOverOut, true);
            globalThis.addEventListener("pointerup", this._onPointerUp, true);
          } else {
            globalThis.document.addEventListener("mousemove", this._onPointerMove, true);
            this.domElement.addEventListener("mousedown", this._onPointerDown, true);
            this.domElement.addEventListener("mouseout", this._onPointerOverOut, true);
            this.domElement.addEventListener("mouseover", this._onPointerOverOut, true);
            globalThis.addEventListener("mouseup", this._onPointerUp, true);
            if (this.supportsTouchEvents) {
              this.domElement.addEventListener("touchstart", this._onPointerDown, true);
              this.domElement.addEventListener("touchend", this._onPointerUp, true);
              this.domElement.addEventListener("touchmove", this._onPointerMove, true);
            }
          }
          this.domElement.addEventListener("wheel", this.onWheel, {
            passive: true,
            capture: true
          });
          this._eventsAdded = true;
        }
        /** Unregister event listeners on {@link EventSystem#domElement this.domElement}. */
        _removeEvents() {
          if (!this._eventsAdded || !this.domElement) {
            return;
          }
          EventsTicker.removeTickerListener();
          const style = this.domElement.style;
          if (style) {
            if (globalThis.navigator.msPointerEnabled) {
              style.msContentZooming = "";
              style.msTouchAction = "";
            } else if (this.supportsPointerEvents) {
              style.touchAction = "";
            }
          }
          if (this.supportsPointerEvents) {
            globalThis.document.removeEventListener("pointermove", this._onPointerMove, true);
            this.domElement.removeEventListener("pointerdown", this._onPointerDown, true);
            this.domElement.removeEventListener("pointerleave", this._onPointerOverOut, true);
            this.domElement.removeEventListener("pointerover", this._onPointerOverOut, true);
            globalThis.removeEventListener("pointerup", this._onPointerUp, true);
          } else {
            globalThis.document.removeEventListener("mousemove", this._onPointerMove, true);
            this.domElement.removeEventListener("mousedown", this._onPointerDown, true);
            this.domElement.removeEventListener("mouseout", this._onPointerOverOut, true);
            this.domElement.removeEventListener("mouseover", this._onPointerOverOut, true);
            globalThis.removeEventListener("mouseup", this._onPointerUp, true);
            if (this.supportsTouchEvents) {
              this.domElement.removeEventListener("touchstart", this._onPointerDown, true);
              this.domElement.removeEventListener("touchend", this._onPointerUp, true);
              this.domElement.removeEventListener("touchmove", this._onPointerMove, true);
            }
          }
          this.domElement.removeEventListener("wheel", this.onWheel, true);
          this.domElement = null;
          this._eventsAdded = false;
        }
        /**
         * Maps x and y coords from a DOM object and maps them correctly to the PixiJS view. The
         * resulting value is stored in the point. This takes into account the fact that the DOM
         * element could be scaled and positioned anywhere on the screen.
         * @param  {PointData} point - the point that the result will be stored in
         * @param  {number} x - the x coord of the position to map
         * @param  {number} y - the y coord of the position to map
         */
        mapPositionToPoint(point, x2, y2) {
          const rect = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : {
            x: 0,
            y: 0,
            width: this.domElement.width,
            height: this.domElement.height,
            left: 0,
            top: 0
          };
          const resolutionMultiplier = 1 / this.resolution;
          point.x = (x2 - rect.left) * (this.domElement.width / rect.width) * resolutionMultiplier;
          point.y = (y2 - rect.top) * (this.domElement.height / rect.height) * resolutionMultiplier;
        }
        /**
         * Ensures that the original event object contains all data that a regular pointer event would have
         * @param event - The original event data from a touch or mouse event
         * @returns An array containing a single normalized pointer event, in the case of a pointer
         *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches
         */
        _normalizeToPointerData(event) {
          const normalizedEvents = [];
          if (this.supportsTouchEvents && event instanceof TouchEvent) {
            for (let i2 = 0, li = event.changedTouches.length; i2 < li; i2++) {
              const touch = event.changedTouches[i2];
              if (typeof touch.button === "undefined")
                touch.button = 0;
              if (typeof touch.buttons === "undefined")
                touch.buttons = 1;
              if (typeof touch.isPrimary === "undefined") {
                touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
              }
              if (typeof touch.width === "undefined")
                touch.width = touch.radiusX || 1;
              if (typeof touch.height === "undefined")
                touch.height = touch.radiusY || 1;
              if (typeof touch.tiltX === "undefined")
                touch.tiltX = 0;
              if (typeof touch.tiltY === "undefined")
                touch.tiltY = 0;
              if (typeof touch.pointerType === "undefined")
                touch.pointerType = "touch";
              if (typeof touch.pointerId === "undefined")
                touch.pointerId = touch.identifier || 0;
              if (typeof touch.pressure === "undefined")
                touch.pressure = touch.force || 0.5;
              if (typeof touch.twist === "undefined")
                touch.twist = 0;
              if (typeof touch.tangentialPressure === "undefined")
                touch.tangentialPressure = 0;
              if (typeof touch.layerX === "undefined")
                touch.layerX = touch.offsetX = touch.clientX;
              if (typeof touch.layerY === "undefined")
                touch.layerY = touch.offsetY = touch.clientY;
              touch.isNormalized = true;
              touch.type = event.type;
              normalizedEvents.push(touch);
            }
          } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {
            const tempEvent = event;
            if (typeof tempEvent.isPrimary === "undefined")
              tempEvent.isPrimary = true;
            if (typeof tempEvent.width === "undefined")
              tempEvent.width = 1;
            if (typeof tempEvent.height === "undefined")
              tempEvent.height = 1;
            if (typeof tempEvent.tiltX === "undefined")
              tempEvent.tiltX = 0;
            if (typeof tempEvent.tiltY === "undefined")
              tempEvent.tiltY = 0;
            if (typeof tempEvent.pointerType === "undefined")
              tempEvent.pointerType = "mouse";
            if (typeof tempEvent.pointerId === "undefined")
              tempEvent.pointerId = MOUSE_POINTER_ID;
            if (typeof tempEvent.pressure === "undefined")
              tempEvent.pressure = 0.5;
            if (typeof tempEvent.twist === "undefined")
              tempEvent.twist = 0;
            if (typeof tempEvent.tangentialPressure === "undefined")
              tempEvent.tangentialPressure = 0;
            tempEvent.isNormalized = true;
            normalizedEvents.push(tempEvent);
          } else {
            normalizedEvents.push(event);
          }
          return normalizedEvents;
        }
        /**
         * Normalizes the native {@link https://w3c.github.io/uievents/#interface-wheelevent WheelEvent}.
         *
         * The returned {@link FederatedWheelEvent} is a shared instance. It will not persist across
         * multiple native wheel events.
         * @param nativeEvent - The native wheel event that occurred on the canvas.
         * @returns A federated wheel event.
         */
        normalizeWheelEvent(nativeEvent) {
          const event = this._rootWheelEvent;
          this._transferMouseData(event, nativeEvent);
          event.deltaX = nativeEvent.deltaX;
          event.deltaY = nativeEvent.deltaY;
          event.deltaZ = nativeEvent.deltaZ;
          event.deltaMode = nativeEvent.deltaMode;
          this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
          event.global.copyFrom(event.screen);
          event.offset.copyFrom(event.screen);
          event.nativeEvent = nativeEvent;
          event.type = nativeEvent.type;
          return event;
        }
        /**
         * Normalizes the `nativeEvent` into a federateed {@link FederatedPointerEvent}.
         * @param event
         * @param nativeEvent
         */
        _bootstrapEvent(event, nativeEvent) {
          event.originalEvent = null;
          event.nativeEvent = nativeEvent;
          event.pointerId = nativeEvent.pointerId;
          event.width = nativeEvent.width;
          event.height = nativeEvent.height;
          event.isPrimary = nativeEvent.isPrimary;
          event.pointerType = nativeEvent.pointerType;
          event.pressure = nativeEvent.pressure;
          event.tangentialPressure = nativeEvent.tangentialPressure;
          event.tiltX = nativeEvent.tiltX;
          event.tiltY = nativeEvent.tiltY;
          event.twist = nativeEvent.twist;
          this._transferMouseData(event, nativeEvent);
          this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
          event.global.copyFrom(event.screen);
          event.offset.copyFrom(event.screen);
          event.isTrusted = nativeEvent.isTrusted;
          if (event.type === "pointerleave") {
            event.type = "pointerout";
          }
          if (event.type.startsWith("mouse")) {
            event.type = event.type.replace("mouse", "pointer");
          }
          if (event.type.startsWith("touch")) {
            event.type = TOUCH_TO_POINTER[event.type] || event.type;
          }
          return event;
        }
        /**
         * Transfers base & mouse event data from the {@code nativeEvent} to the federated event.
         * @param event
         * @param nativeEvent
         */
        _transferMouseData(event, nativeEvent) {
          event.isTrusted = nativeEvent.isTrusted;
          event.srcElement = nativeEvent.srcElement;
          event.timeStamp = performance.now();
          event.type = nativeEvent.type;
          event.altKey = nativeEvent.altKey;
          event.button = nativeEvent.button;
          event.buttons = nativeEvent.buttons;
          event.client.x = nativeEvent.clientX;
          event.client.y = nativeEvent.clientY;
          event.ctrlKey = nativeEvent.ctrlKey;
          event.metaKey = nativeEvent.metaKey;
          event.movement.x = nativeEvent.movementX;
          event.movement.y = nativeEvent.movementY;
          event.page.x = nativeEvent.pageX;
          event.page.y = nativeEvent.pageY;
          event.relatedTarget = null;
          event.shiftKey = nativeEvent.shiftKey;
        }
      };
      _EventSystem.extension = {
        name: "events",
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.CanvasSystem,
          ExtensionType.WebGPUSystem
        ],
        priority: -1
      };
      _EventSystem.defaultEventFeatures = {
        /** Enables pointer events associated with pointer movement. */
        move: true,
        /** Enables global pointer move events. */
        globalMove: true,
        /** Enables pointer events associated with clicking. */
        click: true,
        /** Enables wheel events. */
        wheel: true
      };
      EventSystem = _EventSystem;
    }
  });

  // ../core/node_modules/pixi.js/lib/events/FederatedEventTarget.mjs
  var FederatedContainer;
  var init_FederatedEventTarget = __esm({
    "../core/node_modules/pixi.js/lib/events/FederatedEventTarget.mjs"() {
      init_EventSystem();
      init_FederatedEvent();
      FederatedContainer = {
        /**
         * Property-based event handler for the `click` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onclick = (event) => {
         *  //some function here that happens on click
         * }
         */
        onclick: null,
        /**
         * Property-based event handler for the `mousedown` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onmousedown = (event) => {
         *  //some function here that happens on mousedown
         * }
         */
        onmousedown: null,
        /**
         * Property-based event handler for the `mouseenter` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onmouseenter = (event) => {
         *  //some function here that happens on mouseenter
         * }
         */
        onmouseenter: null,
        /**
         * Property-based event handler for the `mouseleave` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onmouseleave = (event) => {
         *  //some function here that happens on mouseleave
         * }
         */
        onmouseleave: null,
        /**
         * Property-based event handler for the `mousemove` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onmousemove = (event) => {
         *  //some function here that happens on mousemove
         * }
         */
        onmousemove: null,
        /**
         * Property-based event handler for the `globalmousemove` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onglobalmousemove = (event) => {
         *  //some function here that happens on globalmousemove
         * }
         */
        onglobalmousemove: null,
        /**
         * Property-based event handler for the `mouseout` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onmouseout = (event) => {
         *  //some function here that happens on mouseout
         * }
         */
        onmouseout: null,
        /**
         * Property-based event handler for the `mouseover` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onmouseover = (event) => {
         *  //some function here that happens on mouseover
         * }
         */
        onmouseover: null,
        /**
         * Property-based event handler for the `mouseup` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onmouseup = (event) => {
         *  //some function here that happens on mouseup
         * }
         */
        onmouseup: null,
        /**
         * Property-based event handler for the `mouseupoutside` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onmouseupoutside = (event) => {
         *  //some function here that happens on mouseupoutside
         * }
         */
        onmouseupoutside: null,
        /**
         * Property-based event handler for the `pointercancel` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onpointercancel = (event) => {
         *  //some function here that happens on pointercancel
         * }
         */
        onpointercancel: null,
        /**
         * Property-based event handler for the `pointerdown` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onpointerdown = (event) => {
         *  //some function here that happens on pointerdown
         * }
         */
        onpointerdown: null,
        /**
         * Property-based event handler for the `pointerenter` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onpointerenter = (event) => {
         *  //some function here that happens on pointerenter
         * }
         */
        onpointerenter: null,
        /**
         * Property-based event handler for the `pointerleave` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onpointerleave = (event) => {
         *  //some function here that happens on pointerleave
         * }
         */
        onpointerleave: null,
        /**
         * Property-based event handler for the `pointermove` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onpointermove = (event) => {
         *  //some function here that happens on pointermove
         * }
         */
        onpointermove: null,
        /**
         * Property-based event handler for the `globalpointermove` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onglobalpointermove = (event) => {
         *  //some function here that happens on globalpointermove
         * }
         */
        onglobalpointermove: null,
        /**
         * Property-based event handler for the `pointerout` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onpointerout = (event) => {
         *  //some function here that happens on pointerout
         * }
         */
        onpointerout: null,
        /**
         * Property-based event handler for the `pointerover` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onpointerover = (event) => {
         *  //some function here that happens on pointerover
         * }
         */
        onpointerover: null,
        /**
         * Property-based event handler for the `pointertap` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onpointertap = (event) => {
         *  //some function here that happens on pointertap
         * }
         */
        onpointertap: null,
        /**
         * Property-based event handler for the `pointerup` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onpointerup = (event) => {
         *  //some function here that happens on pointerup
         * }
         */
        onpointerup: null,
        /**
         * Property-based event handler for the `pointerupoutside` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onpointerupoutside = (event) => {
         *  //some function here that happens on pointerupoutside
         * }
         */
        onpointerupoutside: null,
        /**
         * Property-based event handler for the `rightclick` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onrightclick = (event) => {
         *  //some function here that happens on rightclick
         * }
         */
        onrightclick: null,
        /**
         * Property-based event handler for the `rightdown` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onrightdown = (event) => {
         *  //some function here that happens on rightdown
         * }
         */
        onrightdown: null,
        /**
         * Property-based event handler for the `rightup` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onrightup = (event) => {
         *  //some function here that happens on rightup
         * }
         */
        onrightup: null,
        /**
         * Property-based event handler for the `rightupoutside` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onrightupoutside = (event) => {
         *  //some function here that happens on rightupoutside
         * }
         */
        onrightupoutside: null,
        /**
         * Property-based event handler for the `tap` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.ontap = (event) => {
         *  //some function here that happens on tap
         * }
         */
        ontap: null,
        /**
         * Property-based event handler for the `touchcancel` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.ontouchcancel = (event) => {
         *  //some function here that happens on touchcancel
         * }
         */
        ontouchcancel: null,
        /**
         * Property-based event handler for the `touchend` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.ontouchend = (event) => {
         *  //some function here that happens on touchend
         * }
         */
        ontouchend: null,
        /**
         * Property-based event handler for the `touchendoutside` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.ontouchendoutside = (event) => {
         *  //some function here that happens on touchendoutside
         * }
         */
        ontouchendoutside: null,
        /**
         * Property-based event handler for the `touchmove` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.ontouchmove = (event) => {
         *  //some function here that happens on touchmove
         * }
         */
        ontouchmove: null,
        /**
         * Property-based event handler for the `globaltouchmove` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onglobaltouchmove = (event) => {
         *  //some function here that happens on globaltouchmove
         * }
         */
        onglobaltouchmove: null,
        /**
         * Property-based event handler for the `touchstart` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.ontouchstart = (event) => {
         *  //some function here that happens on touchstart
         * }
         */
        ontouchstart: null,
        /**
         * Property-based event handler for the `wheel` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onwheel = (event) => {
         *  //some function here that happens on wheel
         * }
         */
        onwheel: null,
        /**
         * Enable interaction events for the Container. Touch, pointer and mouse
         * @memberof scene.Container#
         */
        get interactive() {
          return this.eventMode === "dynamic" || this.eventMode === "static";
        },
        set interactive(value) {
          this.eventMode = value ? "static" : "passive";
        },
        /**
         * @ignore
         */
        _internalEventMode: void 0,
        /**
         * Enable interaction events for the Container. Touch, pointer and mouse.
         * There are 5 types of interaction settings:
         * - `'none'`: Ignores all interaction events, even on its children.
         * - `'passive'`: **(default)** Does not emit events and ignores all hit testing on itself and non-interactive children.
         * Interactive children will still emit events.
         * - `'auto'`: Does not emit events but is hit tested if parent is interactive. Same as `interactive = false` in v7
         * - `'static'`: Emit events and is hit tested. Same as `interaction = true` in v7
         * - `'dynamic'`: Emits events and is hit tested but will also receive mock interaction events fired from a ticker to
         * allow for interaction when the mouse isn't moving
         * @example
         * import { Sprite } from 'pixi.js';
         *
         * const sprite = new Sprite(texture);
         * sprite.eventMode = 'static';
         * sprite.on('tap', (event) => {
         *     // Handle event
         * });
         * @memberof scene.Container#
         * @since 7.2.0
         */
        get eventMode() {
          return this._internalEventMode ?? EventSystem.defaultEventMode;
        },
        set eventMode(value) {
          this._internalEventMode = value;
        },
        /**
         * Determines if the container is interactive or not
         * @returns {boolean} Whether the container is interactive or not
         * @memberof scene.Container#
         * @since 7.2.0
         * @example
         * import { Sprite } from 'pixi.js';
         *
         * const sprite = new Sprite(texture);
         * sprite.eventMode = 'static';
         * sprite.isInteractive(); // true
         *
         * sprite.eventMode = 'dynamic';
         * sprite.isInteractive(); // true
         *
         * sprite.eventMode = 'none';
         * sprite.isInteractive(); // false
         *
         * sprite.eventMode = 'passive';
         * sprite.isInteractive(); // false
         *
         * sprite.eventMode = 'auto';
         * sprite.isInteractive(); // false
         */
        isInteractive() {
          return this.eventMode === "static" || this.eventMode === "dynamic";
        },
        /**
         * Determines if the children to the container can be clicked/touched
         * Setting this to false allows PixiJS to bypass a recursive `hitTest` function
         * @memberof scene.Container#
         */
        interactiveChildren: true,
        /**
         * Interaction shape. Children will be hit first, then this shape will be checked.
         * Setting this will cause this shape to be checked in hit tests rather than the container's bounds.
         * @example
         * import { Rectangle, Sprite } from 'pixi.js';
         *
         * const sprite = new Sprite(texture);
         * sprite.interactive = true;
         * sprite.hitArea = new Rectangle(0, 0, 100, 100);
         * @member {IHitArea}
         * @memberof scene.Container#
         */
        hitArea: null,
        /**
         * Unlike `on` or `addListener` which are methods from EventEmitter, `addEventListener`
         * seeks to be compatible with the DOM's `addEventListener` with support for options.
         * @memberof scene.Container
         * @param type - The type of event to listen to.
         * @param listener - The listener callback or object.
         * @param options - Listener options, used for capture phase.
         * @example
         * // Tell the user whether they did a single, double, triple, or nth click.
         * button.addEventListener('click', {
         *     handleEvent(e): {
         *         let prefix;
         *
         *         switch (e.detail) {
         *             case 1: prefix = 'single'; break;
         *             case 2: prefix = 'double'; break;
         *             case 3: prefix = 'triple'; break;
         *             default: prefix = e.detail + 'th'; break;
         *         }
         *
         *         console.log('That was a ' + prefix + 'click');
         *     }
         * });
         *
         * // But skip the first click!
         * button.parent.addEventListener('click', function blockClickOnce(e) {
         *     e.stopImmediatePropagation();
         *     button.parent.removeEventListener('click', blockClickOnce, true);
         * }, {
         *     capture: true,
         * });
         */
        addEventListener(type, listener, options) {
          const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
          const signal = typeof options === "object" ? options.signal : void 0;
          const once = typeof options === "object" ? options.once === true : false;
          const context4 = typeof listener === "function" ? void 0 : listener;
          type = capture ? `${type}capture` : type;
          const listenerFn = typeof listener === "function" ? listener : listener.handleEvent;
          const emitter = this;
          if (signal) {
            signal.addEventListener("abort", () => {
              emitter.off(type, listenerFn, context4);
            });
          }
          if (once) {
            emitter.once(type, listenerFn, context4);
          } else {
            emitter.on(type, listenerFn, context4);
          }
        },
        /**
         * Unlike `off` or `removeListener` which are methods from EventEmitter, `removeEventListener`
         * seeks to be compatible with the DOM's `removeEventListener` with support for options.
         * @memberof scene.Container
         * @param type - The type of event the listener is bound to.
         * @param listener - The listener callback or object.
         * @param options - The original listener options. This is required to deregister a capture phase listener.
         */
        removeEventListener(type, listener, options) {
          const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
          const context4 = typeof listener === "function" ? void 0 : listener;
          type = capture ? `${type}capture` : type;
          listener = typeof listener === "function" ? listener : listener.handleEvent;
          this.off(type, listener, context4);
        },
        /**
         * Dispatch the event on this {@link Container} using the event's {@link EventBoundary}.
         *
         * The target of the event is set to `this` and the `defaultPrevented` flag is cleared before dispatch.
         * @memberof scene.Container
         * @param e - The event to dispatch.
         * @returns Whether the {@link FederatedEvent.preventDefault preventDefault}() method was not invoked.
         * @example
         * // Reuse a click event!
         * button.dispatchEvent(clickEvent);
         */
        dispatchEvent(e2) {
          if (!(e2 instanceof FederatedEvent)) {
            throw new Error("Container cannot propagate events outside of the Federated Events API");
          }
          e2.defaultPrevented = false;
          e2.path = null;
          e2.target = this;
          e2.manager.dispatchEvent(e2);
          return !e2.defaultPrevented;
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/events/init.mjs
  var init_init3 = __esm({
    "../core/node_modules/pixi.js/lib/events/init.mjs"() {
      init_Extensions();
      init_Container();
      init_EventSystem();
      init_FederatedEventTarget();
      extensions.add(EventSystem);
      Container.mixin(FederatedContainer);
    }
  });

  // ../core/node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs
  var LoaderParserPriority;
  var init_LoaderParser = __esm({
    "../core/node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs"() {
      "use strict";
      LoaderParserPriority = /* @__PURE__ */ ((LoaderParserPriority2) => {
        LoaderParserPriority2[LoaderParserPriority2["Low"] = 0] = "Low";
        LoaderParserPriority2[LoaderParserPriority2["Normal"] = 1] = "Normal";
        LoaderParserPriority2[LoaderParserPriority2["High"] = 2] = "High";
        return LoaderParserPriority2;
      })(LoaderParserPriority || {});
    }
  });

  // ../core/node_modules/pixi.js/lib/environment-browser/BrowserAdapter.mjs
  var BrowserAdapter;
  var init_BrowserAdapter = __esm({
    "../core/node_modules/pixi.js/lib/environment-browser/BrowserAdapter.mjs"() {
      "use strict";
      BrowserAdapter = {
        createCanvas: (width, height) => {
          const canvas = document.createElement("canvas");
          canvas.width = width;
          canvas.height = height;
          return canvas;
        },
        getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
        getWebGLRenderingContext: () => WebGLRenderingContext,
        getNavigator: () => navigator,
        getBaseUrl: () => document.baseURI ?? window.location.href,
        getFontFaceSet: () => document.fonts,
        fetch: (url, options) => fetch(url, options),
        parseXML: (xml) => {
          const parser = new DOMParser();
          return parser.parseFromString(xml, "text/xml");
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/environment/adapter.mjs
  var currentAdapter, DOMAdapter;
  var init_adapter = __esm({
    "../core/node_modules/pixi.js/lib/environment/adapter.mjs"() {
      init_BrowserAdapter();
      currentAdapter = BrowserAdapter;
      DOMAdapter = {
        /**
         * Returns the current adapter.
         * @returns {environment.Adapter} The current adapter.
         */
        get() {
          return currentAdapter;
        },
        /**
         * Sets the current adapter.
         * @param adapter - The new adapter.
         */
        set(adapter) {
          currentAdapter = adapter;
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/utils/path.mjs
  function assertPath(path2) {
    if (typeof path2 !== "string") {
      throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);
    }
  }
  function removeUrlParams(url) {
    const re = url.split("?")[0];
    return re.split("#")[0];
  }
  function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function replaceAll(str, find, replace) {
    return str.replace(new RegExp(escapeRegExp(find), "g"), replace);
  }
  function normalizeStringPosix(path2, allowAboveRoot) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code = -1;
    for (let i2 = 0; i2 <= path2.length; ++i2) {
      if (i2 < path2.length) {
        code = path2.charCodeAt(i2);
      } else if (code === 47) {
        break;
      } else {
        code = 47;
      }
      if (code === 47) {
        if (lastSlash === i2 - 1 || dots === 1) {
        } else if (lastSlash !== i2 - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
            if (res.length > 2) {
              const lastSlashIndex = res.lastIndexOf("/");
              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1) {
                  res = "";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                }
                lastSlash = i2;
                dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i2;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0) {
              res += "/..";
            } else {
              res = "..";
            }
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0) {
            res += `/${path2.slice(lastSlash + 1, i2)}`;
          } else {
            res = path2.slice(lastSlash + 1, i2);
          }
          lastSegmentLength = i2 - lastSlash - 1;
        }
        lastSlash = i2;
        dots = 0;
      } else if (code === 46 && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  var path;
  var init_path = __esm({
    "../core/node_modules/pixi.js/lib/utils/path.mjs"() {
      init_adapter();
      path = {
        /**
         * Converts a path to posix format.
         * @param path - The path to convert to posix
         */
        toPosix(path2) {
          return replaceAll(path2, "\\", "/");
        },
        /**
         * Checks if the path is a URL e.g. http://, https://
         * @param path - The path to check
         */
        isUrl(path2) {
          return /^https?:/.test(this.toPosix(path2));
        },
        /**
         * Checks if the path is a data URL
         * @param path - The path to check
         */
        isDataUrl(path2) {
          return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(path2);
        },
        /**
         * Checks if the path is a blob URL
         * @param path - The path to check
         */
        isBlobUrl(path2) {
          return path2.startsWith("blob:");
        },
        /**
         * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/
         * This will return true for windows file paths
         * @param path - The path to check
         */
        hasProtocol(path2) {
          return /^[^/:]+:/.test(this.toPosix(path2));
        },
        /**
         * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/
         * @param path - The path to get the protocol from
         */
        getProtocol(path2) {
          assertPath(path2);
          path2 = this.toPosix(path2);
          const matchFile = /^file:\/\/\//.exec(path2);
          if (matchFile) {
            return matchFile[0];
          }
          const matchProtocol = /^[^/:]+:\/{0,2}/.exec(path2);
          if (matchProtocol) {
            return matchProtocol[0];
          }
          return "";
        },
        /**
         * Converts URL to an absolute path.
         * When loading from a Web Worker, we must use absolute paths.
         * If the URL is already absolute we return it as is
         * If it's not, we convert it
         * @param url - The URL to test
         * @param customBaseUrl - The base URL to use
         * @param customRootUrl - The root URL to use
         */
        toAbsolute(url, customBaseUrl, customRootUrl) {
          assertPath(url);
          if (this.isDataUrl(url) || this.isBlobUrl(url))
            return url;
          const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? DOMAdapter.get().getBaseUrl()));
          const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));
          url = this.toPosix(url);
          if (url.startsWith("/")) {
            return path.join(rootUrl, url.slice(1));
          }
          const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);
          return absolutePath;
        },
        /**
         * Normalizes the given path, resolving '..' and '.' segments
         * @param path - The path to normalize
         */
        normalize(path2) {
          assertPath(path2);
          if (path2.length === 0)
            return ".";
          if (this.isDataUrl(path2) || this.isBlobUrl(path2))
            return path2;
          path2 = this.toPosix(path2);
          let protocol = "";
          const isAbsolute = path2.startsWith("/");
          if (this.hasProtocol(path2)) {
            protocol = this.rootname(path2);
            path2 = path2.slice(protocol.length);
          }
          const trailingSeparator = path2.endsWith("/");
          path2 = normalizeStringPosix(path2, false);
          if (path2.length > 0 && trailingSeparator)
            path2 += "/";
          if (isAbsolute)
            return `/${path2}`;
          return protocol + path2;
        },
        /**
         * Determines if path is an absolute path.
         * Absolute paths can be urls, data urls, or paths on disk
         * @param path - The path to test
         */
        isAbsolute(path2) {
          assertPath(path2);
          path2 = this.toPosix(path2);
          if (this.hasProtocol(path2))
            return true;
          return path2.startsWith("/");
        },
        /**
         * Joins all given path segments together using the platform-specific separator as a delimiter,
         * then normalizes the resulting path
         * @param segments - The segments of the path to join
         */
        join(...segments) {
          if (segments.length === 0) {
            return ".";
          }
          let joined;
          for (let i2 = 0; i2 < segments.length; ++i2) {
            const arg = segments[i2];
            assertPath(arg);
            if (arg.length > 0) {
              if (joined === void 0)
                joined = arg;
              else {
                const prevArg = segments[i2 - 1] ?? "";
                if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase())) {
                  joined += `/../${arg}`;
                } else {
                  joined += `/${arg}`;
                }
              }
            }
          }
          if (joined === void 0) {
            return ".";
          }
          return this.normalize(joined);
        },
        /**
         * Returns the directory name of a path
         * @param path - The path to parse
         */
        dirname(path2) {
          assertPath(path2);
          if (path2.length === 0)
            return ".";
          path2 = this.toPosix(path2);
          let code = path2.charCodeAt(0);
          const hasRoot = code === 47;
          let end = -1;
          let matchedSlash = true;
          const proto = this.getProtocol(path2);
          const origpath = path2;
          path2 = path2.slice(proto.length);
          for (let i2 = path2.length - 1; i2 >= 1; --i2) {
            code = path2.charCodeAt(i2);
            if (code === 47) {
              if (!matchedSlash) {
                end = i2;
                break;
              }
            } else {
              matchedSlash = false;
            }
          }
          if (end === -1)
            return hasRoot ? "/" : this.isUrl(origpath) ? proto + path2 : proto;
          if (hasRoot && end === 1)
            return "//";
          return proto + path2.slice(0, end);
        },
        /**
         * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/
         * @param path - The path to parse
         */
        rootname(path2) {
          assertPath(path2);
          path2 = this.toPosix(path2);
          let root = "";
          if (path2.startsWith("/"))
            root = "/";
          else {
            root = this.getProtocol(path2);
          }
          if (this.isUrl(path2)) {
            const index = path2.indexOf("/", root.length);
            if (index !== -1) {
              root = path2.slice(0, index);
            } else
              root = path2;
            if (!root.endsWith("/"))
              root += "/";
          }
          return root;
        },
        /**
         * Returns the last portion of a path
         * @param path - The path to test
         * @param ext - Optional extension to remove
         */
        basename(path2, ext) {
          assertPath(path2);
          if (ext)
            assertPath(ext);
          path2 = removeUrlParams(this.toPosix(path2));
          let start = 0;
          let end = -1;
          let matchedSlash = true;
          let i2;
          if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
            if (ext.length === path2.length && ext === path2)
              return "";
            let extIdx = ext.length - 1;
            let firstNonSlashEnd = -1;
            for (i2 = path2.length - 1; i2 >= 0; --i2) {
              const code = path2.charCodeAt(i2);
              if (code === 47) {
                if (!matchedSlash) {
                  start = i2 + 1;
                  break;
                }
              } else {
                if (firstNonSlashEnd === -1) {
                  matchedSlash = false;
                  firstNonSlashEnd = i2 + 1;
                }
                if (extIdx >= 0) {
                  if (code === ext.charCodeAt(extIdx)) {
                    if (--extIdx === -1) {
                      end = i2;
                    }
                  } else {
                    extIdx = -1;
                    end = firstNonSlashEnd;
                  }
                }
              }
            }
            if (start === end)
              end = firstNonSlashEnd;
            else if (end === -1)
              end = path2.length;
            return path2.slice(start, end);
          }
          for (i2 = path2.length - 1; i2 >= 0; --i2) {
            if (path2.charCodeAt(i2) === 47) {
              if (!matchedSlash) {
                start = i2 + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i2 + 1;
            }
          }
          if (end === -1)
            return "";
          return path2.slice(start, end);
        },
        /**
         * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last
         * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than
         * the first character of the basename of path, an empty string is returned.
         * @param path - The path to parse
         */
        extname(path2) {
          assertPath(path2);
          path2 = removeUrlParams(this.toPosix(path2));
          let startDot = -1;
          let startPart = 0;
          let end = -1;
          let matchedSlash = true;
          let preDotState = 0;
          for (let i2 = path2.length - 1; i2 >= 0; --i2) {
            const code = path2.charCodeAt(i2);
            if (code === 47) {
              if (!matchedSlash) {
                startPart = i2 + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i2 + 1;
            }
            if (code === 46) {
              if (startDot === -1)
                startDot = i2;
              else if (preDotState !== 1)
                preDotState = 1;
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            return "";
          }
          return path2.slice(startDot, end);
        },
        /**
         * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.
         * @param path - The path to parse
         */
        parse(path2) {
          assertPath(path2);
          const ret = { root: "", dir: "", base: "", ext: "", name: "" };
          if (path2.length === 0)
            return ret;
          path2 = removeUrlParams(this.toPosix(path2));
          let code = path2.charCodeAt(0);
          const isAbsolute = this.isAbsolute(path2);
          let start;
          const protocol = "";
          ret.root = this.rootname(path2);
          if (isAbsolute || this.hasProtocol(path2)) {
            start = 1;
          } else {
            start = 0;
          }
          let startDot = -1;
          let startPart = 0;
          let end = -1;
          let matchedSlash = true;
          let i2 = path2.length - 1;
          let preDotState = 0;
          for (; i2 >= start; --i2) {
            code = path2.charCodeAt(i2);
            if (code === 47) {
              if (!matchedSlash) {
                startPart = i2 + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i2 + 1;
            }
            if (code === 46) {
              if (startDot === -1)
                startDot = i2;
              else if (preDotState !== 1)
                preDotState = 1;
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            if (end !== -1) {
              if (startPart === 0 && isAbsolute)
                ret.base = ret.name = path2.slice(1, end);
              else
                ret.base = ret.name = path2.slice(startPart, end);
            }
          } else {
            if (startPart === 0 && isAbsolute) {
              ret.name = path2.slice(1, startDot);
              ret.base = path2.slice(1, end);
            } else {
              ret.name = path2.slice(startPart, startDot);
              ret.base = path2.slice(startPart, end);
            }
            ret.ext = path2.slice(startDot, end);
          }
          ret.dir = this.dirname(path2);
          if (protocol)
            ret.dir = protocol + ret.dir;
          return ret;
        },
        sep: "/",
        delimiter: ":",
        joinExtensions: [".html"]
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/assets/utils/convertToList.mjs
  var convertToList;
  var init_convertToList = __esm({
    "../core/node_modules/pixi.js/lib/assets/utils/convertToList.mjs"() {
      "use strict";
      convertToList = (input, transform2, forceTransform = false) => {
        if (!Array.isArray(input)) {
          input = [input];
        }
        if (!transform2) {
          return input;
        }
        return input.map((item) => {
          if (typeof item === "string" || forceTransform) {
            return transform2(item);
          }
          return item;
        });
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/assets/utils/createStringVariations.mjs
  function processX(base, ids, depth, result, tags) {
    const id = ids[depth];
    for (let i2 = 0; i2 < id.length; i2++) {
      const value = id[i2];
      if (depth < ids.length - 1) {
        processX(base.replace(result[depth], value), ids, depth + 1, result, tags);
      } else {
        tags.push(base.replace(result[depth], value));
      }
    }
  }
  function createStringVariations(string) {
    const regex = /\{(.*?)\}/g;
    const result = string.match(regex);
    const tags = [];
    if (result) {
      const ids = [];
      result.forEach((vars) => {
        const split = vars.substring(1, vars.length - 1).split(",");
        ids.push(split);
      });
      processX(string, ids, 0, result, tags);
    } else {
      tags.push(string);
    }
    return tags;
  }
  var init_createStringVariations = __esm({
    "../core/node_modules/pixi.js/lib/assets/utils/createStringVariations.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs
  var isSingleItem;
  var init_isSingleItem = __esm({
    "../core/node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs"() {
      "use strict";
      isSingleItem = (item) => !Array.isArray(item);
    }
  });

  // ../core/node_modules/pixi.js/lib/assets/resolver/Resolver.mjs
  function getUrlExtension(url) {
    return url.split(".").pop().split("?").shift().split("#").shift();
  }
  var Resolver;
  var init_Resolver = __esm({
    "../core/node_modules/pixi.js/lib/assets/resolver/Resolver.mjs"() {
      init_warn();
      init_path();
      init_convertToList();
      init_createStringVariations();
      init_isSingleItem();
      Resolver = class {
        constructor() {
          this._defaultBundleIdentifierOptions = {
            connector: "-",
            createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,
            extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, "")
          };
          this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;
          this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;
          this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;
          this._assetMap = {};
          this._preferredOrder = [];
          this._parsers = [];
          this._resolverHash = {};
          this._bundles = {};
        }
        /**
         * Override how the resolver deals with generating bundle ids.
         * must be called before any bundles are added
         * @param bundleIdentifier - the bundle identifier options
         */
        setBundleIdentifier(bundleIdentifier) {
          this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;
          this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;
          this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;
          if (this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") {
            throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
          }
        }
        /**
         * Let the resolver know which assets you prefer to use when resolving assets.
         * Multiple prefer user defined rules can be added.
         * @example
         * resolver.prefer({
         *     // first look for something with the correct format, and then then correct resolution
         *     priority: ['format', 'resolution'],
         *     params:{
         *         format:'webp', // prefer webp images
         *         resolution: 2, // prefer a resolution of 2
         *     }
         * })
         * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);
         * resolver.resolveUrl('foo') // => 'bar@2x.webp'
         * @param preferOrders - the prefer options
         */
        prefer(...preferOrders) {
          preferOrders.forEach((prefer) => {
            this._preferredOrder.push(prefer);
            if (!prefer.priority) {
              prefer.priority = Object.keys(prefer.params);
            }
          });
          this._resolverHash = {};
        }
        /**
         * Set the base path to prepend to all urls when resolving
         * @example
         * resolver.basePath = 'https://home.com/';
         * resolver.add('foo', 'bar.ong');
         * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'
         * @param basePath - the base path to use
         */
        set basePath(basePath) {
          this._basePath = basePath;
        }
        get basePath() {
          return this._basePath;
        }
        /**
         * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the
         * default value for browsers is `window.location.origin`
         * @example
         * // Application hosted on https://home.com/some-path/index.html
         * resolver.basePath = 'https://home.com/some-path/';
         * resolver.rootPath = 'https://home.com/';
         * resolver.add('foo', '/bar.png');
         * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'
         * @param rootPath - the root path to use
         */
        set rootPath(rootPath) {
          this._rootPath = rootPath;
        }
        get rootPath() {
          return this._rootPath;
        }
        /**
         * All the active URL parsers that help the parser to extract information and create
         * an asset object-based on parsing the URL itself.
         *
         * Can be added using the extensions API
         * @example
         * resolver.add('foo', [
         *     {
         *         resolution: 2,
         *         format: 'png',
         *         src: 'image@2x.png',
         *     },
         *     {
         *         resolution:1,
         *         format:'png',
         *         src: 'image.png',
         *     },
         * ]);
         *
         * // With a url parser the information such as resolution and file format could extracted from the url itself:
         * extensions.add({
         *     extension: ExtensionType.ResolveParser,
         *     test: loadTextures.test, // test if url ends in an image
         *     parse: (value: string) =>
         *     ({
         *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),
         *         format: value.split('.').pop(),
         *         src: value,
         *     }),
         * });
         *
         * // Now resolution and format can be extracted from the url
         * resolver.add('foo', [
         *     'image@2x.png',
         *     'image.png',
         * ]);
         */
        get parsers() {
          return this._parsers;
        }
        /** Used for testing, this resets the resolver to its initial state */
        reset() {
          this.setBundleIdentifier(this._defaultBundleIdentifierOptions);
          this._assetMap = {};
          this._preferredOrder = [];
          this._resolverHash = {};
          this._rootPath = null;
          this._basePath = null;
          this._manifest = null;
          this._bundles = {};
          this._defaultSearchParams = null;
        }
        /**
         * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.
         * @param searchParams - the default url parameters to append when resolving urls
         */
        setDefaultSearchParams(searchParams) {
          if (typeof searchParams === "string") {
            this._defaultSearchParams = searchParams;
          } else {
            const queryValues = searchParams;
            this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join("&");
          }
        }
        /**
         * Returns the aliases for a given asset
         * @param asset - the asset to get the aliases for
         */
        getAlias(asset) {
          const { alias, src } = asset;
          const aliasesToUse = convertToList(
            alias || src,
            (value) => {
              if (typeof value === "string")
                return value;
              if (Array.isArray(value))
                return value.map((v2) => v2?.src ?? v2);
              if (value?.src)
                return value.src;
              return value;
            },
            true
          );
          return aliasesToUse;
        }
        /**
         * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.
         * generally a manifest would be built using a tool.
         * @param manifest - the manifest to add to the resolver
         */
        addManifest(manifest) {
          if (this._manifest) {
            warn("[Resolver] Manifest already exists, this will be overwritten");
          }
          this._manifest = manifest;
          manifest.bundles.forEach((bundle) => {
            this.addBundle(bundle.name, bundle.assets);
          });
        }
        /**
         * This adds a bundle of assets in one go so that you can resolve them as a group.
         * For example you could add a bundle for each screen in you pixi app
         * @example
         * resolver.addBundle('animals', [
         *  { alias: 'bunny', src: 'bunny.png' },
         *  { alias: 'chicken', src: 'chicken.png' },
         *  { alias: 'thumper', src: 'thumper.png' },
         * ]);
         * // or
         * resolver.addBundle('animals', {
         *     bunny: 'bunny.png',
         *     chicken: 'chicken.png',
         *     thumper: 'thumper.png',
         * });
         *
         * const resolvedAssets = await resolver.resolveBundle('animals');
         * @param bundleId - The id of the bundle to add
         * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key
         */
        addBundle(bundleId, assets) {
          const assetNames = [];
          let convertedAssets = assets;
          if (!Array.isArray(assets)) {
            convertedAssets = Object.entries(assets).map(([alias, src]) => {
              if (typeof src === "string" || Array.isArray(src)) {
                return { alias, src };
              }
              return { alias, ...src };
            });
          }
          convertedAssets.forEach((asset) => {
            const srcs = asset.src;
            const aliases = asset.alias;
            let ids;
            if (typeof aliases === "string") {
              const bundleAssetId = this._createBundleAssetId(bundleId, aliases);
              assetNames.push(bundleAssetId);
              ids = [aliases, bundleAssetId];
            } else {
              const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));
              assetNames.push(...bundleIds);
              ids = [...aliases, ...bundleIds];
            }
            this.add({
              ...asset,
              ...{
                alias: ids,
                src: srcs
              }
            });
          });
          this._bundles[bundleId] = assetNames;
        }
        /**
         * Tells the resolver what keys are associated with witch asset.
         * The most important thing the resolver does
         * @example
         * // Single key, single asset:
         * resolver.add({alias: 'foo', src: 'bar.png');
         * resolver.resolveUrl('foo') // => 'bar.png'
         *
         * // Multiple keys, single asset:
         * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});
         * resolver.resolveUrl('foo') // => 'bar.png'
         * resolver.resolveUrl('boo') // => 'bar.png'
         *
         * // Multiple keys, multiple assets:
         * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});
         * resolver.resolveUrl('foo') // => 'bar.png'
         *
         * // Add custom data attached to the resolver
         * Resolver.add({
         *     alias: 'bunnyBooBooSmooth',
         *     src: 'bunny{png,webp}',
         *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options
         * });
         *
         * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }
         * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver
         */
        add(aliases) {
          const assets = [];
          if (Array.isArray(aliases)) {
            assets.push(...aliases);
          } else {
            assets.push(aliases);
          }
          let keyCheck;
          keyCheck = (key) => {
            if (this.hasKey(key)) {
              warn(`[Resolver] already has key: ${key} overwriting`);
            }
          };
          const assetArray = convertToList(assets);
          assetArray.forEach((asset) => {
            const { src } = asset;
            let { data, format, loadParser } = asset;
            const srcsToUse = convertToList(src).map((src2) => {
              if (typeof src2 === "string") {
                return createStringVariations(src2);
              }
              return Array.isArray(src2) ? src2 : [src2];
            });
            const aliasesToUse = this.getAlias(asset);
            Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);
            const resolvedAssets = [];
            srcsToUse.forEach((srcs) => {
              srcs.forEach((src2) => {
                let formattedAsset = {};
                if (typeof src2 !== "object") {
                  formattedAsset.src = src2;
                  for (let i2 = 0; i2 < this._parsers.length; i2++) {
                    const parser = this._parsers[i2];
                    if (parser.test(src2)) {
                      formattedAsset = parser.parse(src2);
                      break;
                    }
                  }
                } else {
                  data = src2.data ?? data;
                  format = src2.format ?? format;
                  loadParser = src2.loadParser ?? loadParser;
                  formattedAsset = {
                    ...formattedAsset,
                    ...src2
                  };
                }
                if (!aliasesToUse) {
                  throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);
                }
                formattedAsset = this._buildResolvedAsset(formattedAsset, {
                  aliases: aliasesToUse,
                  data,
                  format,
                  loadParser
                });
                resolvedAssets.push(formattedAsset);
              });
            });
            aliasesToUse.forEach((alias) => {
              this._assetMap[alias] = resolvedAssets;
            });
          });
        }
        // TODO: this needs an overload like load did in Assets
        /**
         * If the resolver has had a manifest set via setManifest, this will return the assets urls for
         * a given bundleId or bundleIds.
         * @example
         * // Manifest Example
         * const manifest = {
         *     bundles: [
         *         {
         *             name: 'load-screen',
         *             assets: [
         *                 {
         *                     alias: 'background',
         *                     src: 'sunset.png',
         *                 },
         *                 {
         *                     alias: 'bar',
         *                     src: 'load-bar.{png,webp}',
         *                 },
         *             ],
         *         },
         *         {
         *             name: 'game-screen',
         *             assets: [
         *                 {
         *                     alias: 'character',
         *                     src: 'robot.png',
         *                 },
         *                 {
         *                     alias: 'enemy',
         *                     src: 'bad-guy.png',
         *                 },
         *             ],
         *         },
         *     ]
         * };
         *
         * resolver.setManifest(manifest);
         * const resolved = resolver.resolveBundle('load-screen');
         * @param bundleIds - The bundle ids to resolve
         * @returns All the bundles assets or a hash of assets for each bundle specified
         */
        resolveBundle(bundleIds) {
          const singleAsset = isSingleItem(bundleIds);
          bundleIds = convertToList(bundleIds);
          const out2 = {};
          bundleIds.forEach((bundleId) => {
            const assetNames = this._bundles[bundleId];
            if (assetNames) {
              const results = this.resolve(assetNames);
              const assets = {};
              for (const key in results) {
                const asset = results[key];
                assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;
              }
              out2[bundleId] = assets;
            }
          });
          return singleAsset ? out2[bundleIds[0]] : out2;
        }
        /**
         * Does exactly what resolve does, but returns just the URL rather than the whole asset object
         * @param key - The key or keys to resolve
         * @returns - The URLs associated with the key(s)
         */
        resolveUrl(key) {
          const result = this.resolve(key);
          if (typeof key !== "string") {
            const out2 = {};
            for (const i2 in result) {
              out2[i2] = result[i2].src;
            }
            return out2;
          }
          return result.src;
        }
        resolve(keys) {
          const singleAsset = isSingleItem(keys);
          keys = convertToList(keys);
          const result = {};
          keys.forEach((key) => {
            if (!this._resolverHash[key]) {
              if (this._assetMap[key]) {
                let assets = this._assetMap[key];
                const preferredOrder = this._getPreferredOrder(assets);
                preferredOrder?.priority.forEach((priorityKey) => {
                  preferredOrder.params[priorityKey].forEach((value) => {
                    const filteredAssets = assets.filter((asset) => {
                      if (asset[priorityKey]) {
                        return asset[priorityKey] === value;
                      }
                      return false;
                    });
                    if (filteredAssets.length) {
                      assets = filteredAssets;
                    }
                  });
                });
                this._resolverHash[key] = assets[0];
              } else {
                this._resolverHash[key] = this._buildResolvedAsset({
                  alias: [key],
                  src: key
                }, {});
              }
            }
            result[key] = this._resolverHash[key];
          });
          return singleAsset ? result[keys[0]] : result;
        }
        /**
         * Checks if an asset with a given key exists in the resolver
         * @param key - The key of the asset
         */
        hasKey(key) {
          return !!this._assetMap[key];
        }
        /**
         * Checks if a bundle with the given key exists in the resolver
         * @param key - The key of the bundle
         */
        hasBundle(key) {
          return !!this._bundles[key];
        }
        /**
         * Internal function for figuring out what prefer criteria an asset should use.
         * @param assets
         */
        _getPreferredOrder(assets) {
          for (let i2 = 0; i2 < assets.length; i2++) {
            const asset = assets[0];
            const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));
            if (preferred) {
              return preferred;
            }
          }
          return this._preferredOrder[0];
        }
        /**
         * Appends the default url parameters to the url
         * @param url - The url to append the default parameters to
         * @returns - The url with the default parameters appended
         */
        _appendDefaultSearchParams(url) {
          if (!this._defaultSearchParams)
            return url;
          const paramConnector = /\?/.test(url) ? "&" : "?";
          return `${url}${paramConnector}${this._defaultSearchParams}`;
        }
        _buildResolvedAsset(formattedAsset, data) {
          const { aliases, data: assetData, loadParser, format } = data;
          if (this._basePath || this._rootPath) {
            formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);
          }
          formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];
          formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);
          formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };
          formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;
          formattedAsset.format = format ?? formattedAsset.format ?? getUrlExtension(formattedAsset.src);
          return formattedAsset;
        }
      };
      Resolver.RETINA_PREFIX = /@([0-9\.]+)x/;
    }
  });

  // ../core/node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs
  var copySearchParams;
  var init_copySearchParams = __esm({
    "../core/node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs"() {
      "use strict";
      copySearchParams = (targetUrl, sourceUrl) => {
        const searchParams = sourceUrl.split("?")[1];
        if (searchParams) {
          targetUrl += `?${searchParams}`;
        }
        return targetUrl;
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/maths/matrix/groupD8.mjs
  function init2() {
    for (let i2 = 0; i2 < 16; i2++) {
      const row = [];
      rotationCayley.push(row);
      for (let j2 = 0; j2 < 16; j2++) {
        const _ux = signum(ux[i2] * ux[j2] + vx[i2] * uy[j2]);
        const _uy = signum(uy[i2] * ux[j2] + vy[i2] * uy[j2]);
        const _vx = signum(ux[i2] * vx[j2] + vx[i2] * vy[j2]);
        const _vy = signum(uy[i2] * vx[j2] + vy[i2] * vy[j2]);
        for (let k2 = 0; k2 < 16; k2++) {
          if (ux[k2] === _ux && uy[k2] === _uy && vx[k2] === _vx && vy[k2] === _vy) {
            row.push(k2);
            break;
          }
        }
      }
    }
    for (let i2 = 0; i2 < 16; i2++) {
      const mat = new Matrix();
      mat.set(ux[i2], uy[i2], vx[i2], vy[i2], 0, 0);
      rotationMatrices.push(mat);
    }
  }
  var ux, uy, vx, vy, rotationCayley, rotationMatrices, signum, groupD8;
  var init_groupD8 = __esm({
    "../core/node_modules/pixi.js/lib/maths/matrix/groupD8.mjs"() {
      init_Matrix();
      ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
      uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
      vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
      vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
      rotationCayley = [];
      rotationMatrices = [];
      signum = Math.sign;
      init2();
      groupD8 = {
        /**
         * | Rotation | Direction |
         * |----------|-----------|
         * | 0°       | East      |
         * @memberof maths.groupD8
         * @constant {GD8Symmetry}
         */
        E: 0,
        /**
         * | Rotation | Direction |
         * |----------|-----------|
         * | 45°↻     | Southeast |
         * @memberof maths.groupD8
         * @constant {GD8Symmetry}
         */
        SE: 1,
        /**
         * | Rotation | Direction |
         * |----------|-----------|
         * | 90°↻     | South     |
         * @memberof maths.groupD8
         * @constant {GD8Symmetry}
         */
        S: 2,
        /**
         * | Rotation | Direction |
         * |----------|-----------|
         * | 135°↻    | Southwest |
         * @memberof maths.groupD8
         * @constant {GD8Symmetry}
         */
        SW: 3,
        /**
         * | Rotation | Direction |
         * |----------|-----------|
         * | 180°     | West      |
         * @memberof maths.groupD8
         * @constant {GD8Symmetry}
         */
        W: 4,
        /**
         * | Rotation    | Direction    |
         * |-------------|--------------|
         * | -135°/225°↻ | Northwest    |
         * @memberof maths.groupD8
         * @constant {GD8Symmetry}
         */
        NW: 5,
        /**
         * | Rotation    | Direction    |
         * |-------------|--------------|
         * | -90°/270°↻  | North        |
         * @memberof maths.groupD8
         * @constant {GD8Symmetry}
         */
        N: 6,
        /**
         * | Rotation    | Direction    |
         * |-------------|--------------|
         * | -45°/315°↻  | Northeast    |
         * @memberof maths.groupD8
         * @constant {GD8Symmetry}
         */
        NE: 7,
        /**
         * Reflection about Y-axis.
         * @memberof maths.groupD8
         * @constant {GD8Symmetry}
         */
        MIRROR_VERTICAL: 8,
        /**
         * Reflection about the main diagonal.
         * @memberof maths.groupD8
         * @constant {GD8Symmetry}
         */
        MAIN_DIAGONAL: 10,
        /**
         * Reflection about X-axis.
         * @memberof maths.groupD8
         * @constant {GD8Symmetry}
         */
        MIRROR_HORIZONTAL: 12,
        /**
         * Reflection about reverse diagonal.
         * @memberof maths.groupD8
         * @constant {GD8Symmetry}
         */
        REVERSE_DIAGONAL: 14,
        /**
         * @memberof maths.groupD8
         * @param {GD8Symmetry} ind - sprite rotation angle.
         * @returns {GD8Symmetry} The X-component of the U-axis
         *    after rotating the axes.
         */
        uX: (ind) => ux[ind],
        /**
         * @memberof maths.groupD8
         * @param {GD8Symmetry} ind - sprite rotation angle.
         * @returns {GD8Symmetry} The Y-component of the U-axis
         *    after rotating the axes.
         */
        uY: (ind) => uy[ind],
        /**
         * @memberof maths.groupD8
         * @param {GD8Symmetry} ind - sprite rotation angle.
         * @returns {GD8Symmetry} The X-component of the V-axis
         *    after rotating the axes.
         */
        vX: (ind) => vx[ind],
        /**
         * @memberof maths.groupD8
         * @param {GD8Symmetry} ind - sprite rotation angle.
         * @returns {GD8Symmetry} The Y-component of the V-axis
         *    after rotating the axes.
         */
        vY: (ind) => vy[ind],
        /**
         * @memberof maths.groupD8
         * @param {GD8Symmetry} rotation - symmetry whose opposite
         *   is needed. Only rotations have opposite symmetries while
         *   reflections don't.
         * @returns {GD8Symmetry} The opposite symmetry of `rotation`
         */
        inv: (rotation) => {
          if (rotation & 8) {
            return rotation & 15;
          }
          return -rotation & 7;
        },
        /**
         * Composes the two D8 operations.
         *
         * Taking `^` as reflection:
         *
         * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
         * |-------|-----|-----|-----|-----|------|-------|-------|-------|
         * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
         * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
         * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
         * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
         * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
         * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
         * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
         * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
         *
         * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
         * @memberof maths.groupD8
         * @param {GD8Symmetry} rotationSecond - Second operation, which
         *   is the row in the above cayley table.
         * @param {GD8Symmetry} rotationFirst - First operation, which
         *   is the column in the above cayley table.
         * @returns {GD8Symmetry} Composed operation
         */
        add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],
        /**
         * Reverse of `add`.
         * @memberof maths.groupD8
         * @param {GD8Symmetry} rotationSecond - Second operation
         * @param {GD8Symmetry} rotationFirst - First operation
         * @returns {GD8Symmetry} Result
         */
        sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],
        /**
         * Adds 180 degrees to rotation, which is a commutative
         * operation.
         * @memberof maths.groupD8
         * @param {number} rotation - The number to rotate.
         * @returns {number} Rotated number
         */
        rotate180: (rotation) => rotation ^ 4,
        /**
         * Checks if the rotation angle is vertical, i.e. south
         * or north. It doesn't work for reflections.
         * @memberof maths.groupD8
         * @param {GD8Symmetry} rotation - The number to check.
         * @returns {boolean} Whether or not the direction is vertical
         */
        isVertical: (rotation) => (rotation & 3) === 2,
        // rotation % 4 === 2
        /**
         * Approximates the vector `V(dx,dy)` into one of the
         * eight directions provided by `groupD8`.
         * @memberof maths.groupD8
         * @param {number} dx - X-component of the vector
         * @param {number} dy - Y-component of the vector
         * @returns {GD8Symmetry} Approximation of the vector into
         *  one of the eight symmetries.
         */
        byDirection: (dx, dy) => {
          if (Math.abs(dx) * 2 <= Math.abs(dy)) {
            if (dy >= 0) {
              return groupD8.S;
            }
            return groupD8.N;
          } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
            if (dx > 0) {
              return groupD8.E;
            }
            return groupD8.W;
          } else if (dy > 0) {
            if (dx > 0) {
              return groupD8.SE;
            }
            return groupD8.SW;
          } else if (dx > 0) {
            return groupD8.NE;
          }
          return groupD8.NW;
        },
        /**
         * Helps sprite to compensate texture packer rotation.
         * @memberof maths.groupD8
         * @param {Matrix} matrix - sprite world matrix
         * @param {GD8Symmetry} rotation - The rotation factor to use.
         * @param {number} tx - sprite anchoring
         * @param {number} ty - sprite anchoring
         */
        matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {
          const mat = rotationMatrices[groupD8.inv(rotation)];
          mat.tx = tx;
          mat.ty = ty;
          matrix.append(mat);
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/utils/misc/NOOP.mjs
  var NOOP;
  var init_NOOP = __esm({
    "../core/node_modules/pixi.js/lib/utils/misc/NOOP.mjs"() {
      "use strict";
      NOOP = () => {
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/maths/misc/pow2.mjs
  function nextPow2(v2) {
    v2 += v2 === 0 ? 1 : 0;
    --v2;
    v2 |= v2 >>> 1;
    v2 |= v2 >>> 2;
    v2 |= v2 >>> 4;
    v2 |= v2 >>> 8;
    v2 |= v2 >>> 16;
    return v2 + 1;
  }
  function isPow2(v2) {
    return !(v2 & v2 - 1) && !!v2;
  }
  var init_pow2 = __esm({
    "../core/node_modules/pixi.js/lib/maths/misc/pow2.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs
  function definedProps(obj) {
    const result = {};
    for (const key in obj) {
      if (obj[key] !== void 0) {
        result[key] = obj[key];
      }
    }
    return result;
  }
  var init_definedProps = __esm({
    "../core/node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs
  function createResourceIdFromString(value) {
    const id = idHash[value];
    if (id === void 0) {
      idHash[value] = uid("resource");
    }
    return id;
  }
  var idHash, _TextureStyle, TextureStyle;
  var init_TextureStyle = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs"() {
      init_eventemitter3();
      init_uid();
      init_deprecation();
      idHash = /* @__PURE__ */ Object.create(null);
      _TextureStyle = class _TextureStyle2 extends eventemitter3_default {
        /**
         * @param options - options for the style
         */
        constructor(options = {}) {
          super();
          this._resourceType = "textureSampler";
          this._touched = 0;
          this._maxAnisotropy = 1;
          this.destroyed = false;
          options = { ..._TextureStyle2.defaultOptions, ...options };
          this.addressMode = options.addressMode;
          this.addressModeU = options.addressModeU ?? this.addressModeU;
          this.addressModeV = options.addressModeV ?? this.addressModeV;
          this.addressModeW = options.addressModeW ?? this.addressModeW;
          this.scaleMode = options.scaleMode;
          this.magFilter = options.magFilter ?? this.magFilter;
          this.minFilter = options.minFilter ?? this.minFilter;
          this.mipmapFilter = options.mipmapFilter ?? this.mipmapFilter;
          this.lodMinClamp = options.lodMinClamp;
          this.lodMaxClamp = options.lodMaxClamp;
          this.compare = options.compare;
          this.maxAnisotropy = options.maxAnisotropy ?? 1;
        }
        set addressMode(value) {
          this.addressModeU = value;
          this.addressModeV = value;
          this.addressModeW = value;
        }
        /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */
        get addressMode() {
          return this.addressModeU;
        }
        set wrapMode(value) {
          deprecation(v8_0_0, "TextureStyle.wrapMode is now TextureStyle.addressMode");
          this.addressMode = value;
        }
        get wrapMode() {
          return this.addressMode;
        }
        set scaleMode(value) {
          this.magFilter = value;
          this.minFilter = value;
          this.mipmapFilter = value;
        }
        /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */
        get scaleMode() {
          return this.magFilter;
        }
        /** Specifies the maximum anisotropy value clamp used by the sampler. */
        set maxAnisotropy(value) {
          this._maxAnisotropy = Math.min(value, 16);
          if (this._maxAnisotropy > 1) {
            this.scaleMode = "linear";
          }
        }
        get maxAnisotropy() {
          return this._maxAnisotropy;
        }
        // TODO - move this to WebGL?
        get _resourceId() {
          return this._sharedResourceId || this._generateResourceId();
        }
        update() {
          this.emit("change", this);
          this._sharedResourceId = null;
        }
        _generateResourceId() {
          const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
          this._sharedResourceId = createResourceIdFromString(bigKey);
          return this._resourceId;
        }
        /** Destroys the style */
        destroy() {
          this.destroyed = true;
          this.emit("destroy", this);
          this.emit("change", this);
          this.removeAllListeners();
        }
      };
      _TextureStyle.defaultOptions = {
        addressMode: "clamp-to-edge",
        scaleMode: "linear"
      };
      TextureStyle = _TextureStyle;
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs
  var _TextureSource, TextureSource;
  var init_TextureSource = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs"() {
      init_eventemitter3();
      init_pow2();
      init_definedProps();
      init_uid();
      init_TextureStyle();
      _TextureSource = class _TextureSource2 extends eventemitter3_default {
        /**
         * @param options - options for creating a new TextureSource
         */
        constructor(options = {}) {
          super();
          this.options = options;
          this.uid = uid("textureSource");
          this._resourceType = "textureSource";
          this._resourceId = uid("resource");
          this.uploadMethodId = "unknown";
          this._resolution = 1;
          this.pixelWidth = 1;
          this.pixelHeight = 1;
          this.width = 1;
          this.height = 1;
          this.sampleCount = 1;
          this.mipLevelCount = 1;
          this.autoGenerateMipmaps = false;
          this.format = "rgba8unorm";
          this.dimension = "2d";
          this.antialias = false;
          this._touched = 0;
          this._batchTick = -1;
          this._textureBindLocation = -1;
          options = { ..._TextureSource2.defaultOptions, ...options };
          this.label = options.label ?? "";
          this.resource = options.resource;
          this.autoGarbageCollect = options.autoGarbageCollect;
          this._resolution = options.resolution;
          if (options.width) {
            this.pixelWidth = options.width * this._resolution;
          } else {
            this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1;
          }
          if (options.height) {
            this.pixelHeight = options.height * this._resolution;
          } else {
            this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1;
          }
          this.width = this.pixelWidth / this._resolution;
          this.height = this.pixelHeight / this._resolution;
          this.format = options.format;
          this.dimension = options.dimensions;
          this.mipLevelCount = options.mipLevelCount;
          this.autoGenerateMipmaps = options.autoGenerateMipmaps;
          this.sampleCount = options.sampleCount;
          this.antialias = options.antialias;
          this.alphaMode = options.alphaMode;
          this.style = new TextureStyle(definedProps(options));
          this.destroyed = false;
          this._refreshPOT();
        }
        /** returns itself */
        get source() {
          return this;
        }
        /** the style of the texture */
        get style() {
          return this._style;
        }
        set style(value) {
          if (this.style === value)
            return;
          this._style?.off("change", this._onStyleChange, this);
          this._style = value;
          this._style?.on("change", this._onStyleChange, this);
          this._onStyleChange();
        }
        /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */
        get addressMode() {
          return this._style.addressMode;
        }
        set addressMode(value) {
          this._style.addressMode = value;
        }
        /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */
        get repeatMode() {
          return this._style.addressMode;
        }
        set repeatMode(value) {
          this._style.addressMode = value;
        }
        /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */
        get magFilter() {
          return this._style.magFilter;
        }
        set magFilter(value) {
          this._style.magFilter = value;
        }
        /** Specifies the sampling behavior when the sample footprint is larger than one texel. */
        get minFilter() {
          return this._style.minFilter;
        }
        set minFilter(value) {
          this._style.minFilter = value;
        }
        /** Specifies behavior for sampling between mipmap levels. */
        get mipmapFilter() {
          return this._style.mipmapFilter;
        }
        set mipmapFilter(value) {
          this._style.mipmapFilter = value;
        }
        /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */
        get lodMinClamp() {
          return this._style.lodMinClamp;
        }
        set lodMinClamp(value) {
          this._style.lodMinClamp = value;
        }
        /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */
        get lodMaxClamp() {
          return this._style.lodMaxClamp;
        }
        set lodMaxClamp(value) {
          this._style.lodMaxClamp = value;
        }
        _onStyleChange() {
          this.emit("styleChange", this);
        }
        /** call this if you have modified the texture outside of the constructor */
        update() {
          if (this.resource) {
            const resolution = this._resolution;
            const didResize = this.resize(this.resourceWidth / resolution, this.resourceHeight / resolution);
            if (didResize)
              return;
          }
          this.emit("update", this);
        }
        /** Destroys this texture source */
        destroy() {
          this.destroyed = true;
          this.emit("destroy", this);
          this.emit("change", this);
          if (this._style) {
            this._style.destroy();
            this._style = null;
          }
          this.uploadMethodId = null;
          this.resource = null;
          this.removeAllListeners();
        }
        /**
         * This will unload the Texture source from the GPU. This will free up the GPU memory
         * As soon as it is required fore rendering, it will be re-uploaded.
         */
        unload() {
          this._resourceId = uid("resource");
          this.emit("change", this);
          this.emit("unload", this);
        }
        /** the width of the resource. This is the REAL pure number, not accounting resolution   */
        get resourceWidth() {
          const { resource } = this;
          return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;
        }
        /** the height of the resource. This is the REAL pure number, not accounting resolution */
        get resourceHeight() {
          const { resource } = this;
          return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;
        }
        /**
         * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture
         * but will the size of the texture when rendered.
         *
         * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel
         * density will have increased)
         */
        get resolution() {
          return this._resolution;
        }
        set resolution(resolution) {
          if (this._resolution === resolution)
            return;
          this._resolution = resolution;
          this.width = this.pixelWidth / resolution;
          this.height = this.pixelHeight / resolution;
        }
        /**
         * Resize the texture, this is handy if you want to use the texture as a render texture
         * @param width - the new width of the texture
         * @param height - the new height of the texture
         * @param resolution - the new resolution of the texture
         * @returns - if the texture was resized
         */
        resize(width, height, resolution) {
          resolution = resolution || this._resolution;
          width = width || this.width;
          height = height || this.height;
          const newPixelWidth = Math.round(width * resolution);
          const newPixelHeight = Math.round(height * resolution);
          this.width = newPixelWidth / resolution;
          this.height = newPixelHeight / resolution;
          this._resolution = resolution;
          if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight) {
            return false;
          }
          this._refreshPOT();
          this.pixelWidth = newPixelWidth;
          this.pixelHeight = newPixelHeight;
          this.emit("resize", this);
          this._resourceId = uid("resource");
          this.emit("change", this);
          return true;
        }
        /**
         * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.
         * This is only important for RenderTexture instances, as standard Texture instances will have their
         * mipmaps generated on upload. You should call this method after you make any change to the texture
         *
         * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,
         * We want you, the developer to specify when this action should happen.
         *
         * Generally you don't want to have mipmaps generated on Render targets that are changed every frame,
         */
        updateMipmaps() {
          if (this.autoGenerateMipmaps && this.mipLevelCount > 1) {
            this.emit("updateMipmaps", this);
          }
        }
        set wrapMode(value) {
          this._style.wrapMode = value;
        }
        get wrapMode() {
          return this._style.wrapMode;
        }
        set scaleMode(value) {
          this._style.scaleMode = value;
        }
        /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */
        get scaleMode() {
          return this._style.scaleMode;
        }
        /**
         * Refresh check for isPowerOfTwo texture based on size
         * @private
         */
        _refreshPOT() {
          this.isPowerOfTwo = isPow2(this.pixelWidth) && isPow2(this.pixelHeight);
        }
        static test(_resource) {
          throw new Error("Unimplemented");
        }
      };
      _TextureSource.defaultOptions = {
        resolution: 1,
        format: "bgra8unorm",
        alphaMode: "premultiply-alpha-on-upload",
        dimensions: "2d",
        mipLevelCount: 1,
        autoGenerateMipmaps: false,
        sampleCount: 1,
        antialias: false,
        autoGarbageCollect: false
      };
      TextureSource = _TextureSource;
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferSource.mjs
  var BufferImageSource;
  var init_BufferSource = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferSource.mjs"() {
      init_Extensions();
      init_TextureSource();
      BufferImageSource = class extends TextureSource {
        constructor(options) {
          const buffer = options.resource || new Float32Array(options.width * options.height * 4);
          let format = options.format;
          if (!format) {
            if (buffer instanceof Float32Array) {
              format = "rgba32float";
            } else if (buffer instanceof Int32Array) {
              format = "rgba32uint";
            } else if (buffer instanceof Uint32Array) {
              format = "rgba32uint";
            } else if (buffer instanceof Int16Array) {
              format = "rgba16uint";
            } else if (buffer instanceof Uint16Array) {
              format = "rgba16uint";
            } else if (buffer instanceof Int8Array) {
              format = "bgra8unorm";
            } else {
              format = "bgra8unorm";
            }
          }
          super({
            ...options,
            resource: buffer,
            format
          });
          this.uploadMethodId = "buffer";
        }
        static test(resource) {
          return resource instanceof Int8Array || resource instanceof Uint8Array || resource instanceof Uint8ClampedArray || resource instanceof Int16Array || resource instanceof Uint16Array || resource instanceof Int32Array || resource instanceof Uint32Array || resource instanceof Float32Array;
        }
      };
      BufferImageSource.extension = ExtensionType.TextureSource;
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs
  var tempMat, TextureMatrix;
  var init_TextureMatrix = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs"() {
      init_Matrix();
      tempMat = new Matrix();
      TextureMatrix = class {
        /**
         * @param texture - observed texture
         * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.
         */
        constructor(texture, clampMargin) {
          this.mapCoord = new Matrix();
          this.uClampFrame = new Float32Array(4);
          this.uClampOffset = new Float32Array(2);
          this._textureID = -1;
          this._updateID = 0;
          this.clampOffset = 0;
          if (typeof clampMargin === "undefined") {
            this.clampMargin = texture.width < 10 ? 0 : 0.5;
          } else {
            this.clampMargin = clampMargin;
          }
          this.isSimple = false;
          this.texture = texture;
        }
        /** Texture property. */
        get texture() {
          return this._texture;
        }
        set texture(value) {
          if (this.texture === value)
            return;
          this._texture?.removeListener("update", this.update, this);
          this._texture = value;
          this._texture.addListener("update", this.update, this);
          this.update();
        }
        /**
         * Multiplies uvs array to transform
         * @param uvs - mesh uvs
         * @param [out=uvs] - output
         * @returns - output
         */
        multiplyUvs(uvs, out2) {
          if (out2 === void 0) {
            out2 = uvs;
          }
          const mat = this.mapCoord;
          for (let i2 = 0; i2 < uvs.length; i2 += 2) {
            const x2 = uvs[i2];
            const y2 = uvs[i2 + 1];
            out2[i2] = x2 * mat.a + y2 * mat.c + mat.tx;
            out2[i2 + 1] = x2 * mat.b + y2 * mat.d + mat.ty;
          }
          return out2;
        }
        /**
         * Updates matrices if texture was changed
         * @returns - whether or not it was updated
         */
        update() {
          const tex = this._texture;
          this._updateID++;
          const uvs = tex.uvs;
          this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
          const orig = tex.orig;
          const trim = tex.trim;
          if (trim) {
            tempMat.set(
              orig.width / trim.width,
              0,
              0,
              orig.height / trim.height,
              -trim.x / trim.width,
              -trim.y / trim.height
            );
            this.mapCoord.append(tempMat);
          }
          const texBase = tex.source;
          const frame = this.uClampFrame;
          const margin = this.clampMargin / texBase._resolution;
          const offset = this.clampOffset;
          frame[0] = (tex.frame.x + margin + offset) / texBase.width;
          frame[1] = (tex.frame.y + margin + offset) / texBase.height;
          frame[2] = (tex.frame.x + tex.frame.width - margin + offset) / texBase.width;
          frame[3] = (tex.frame.y + tex.frame.height - margin + offset) / texBase.height;
          this.uClampOffset[0] = offset / texBase.pixelWidth;
          this.uClampOffset[1] = offset / texBase.pixelHeight;
          this.isSimple = tex.frame.width === texBase.width && tex.frame.height === texBase.height && tex.rotate === 0;
          return true;
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs
  var Texture;
  var init_Texture = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs"() {
      init_eventemitter3();
      init_groupD8();
      init_Rectangle();
      init_uid();
      init_deprecation();
      init_NOOP();
      init_BufferSource();
      init_TextureSource();
      init_TextureMatrix();
      Texture = class extends eventemitter3_default {
        /**
         * @param {TextureOptions} param0 - Options for the texture
         */
        constructor({
          source: source2,
          label,
          frame,
          orig,
          trim,
          defaultAnchor,
          defaultBorders,
          rotate,
          dynamic
        } = {}) {
          super();
          this.uid = uid("texture");
          this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 };
          this.frame = new Rectangle();
          this.noFrame = false;
          this.dynamic = false;
          this.isTexture = true;
          this.label = label;
          this.source = source2?.source ?? new TextureSource();
          this.noFrame = !frame;
          if (frame) {
            this.frame.copyFrom(frame);
          } else {
            const { width, height } = this._source;
            this.frame.width = width;
            this.frame.height = height;
          }
          this.orig = orig || this.frame;
          this.trim = trim;
          this.rotate = rotate ?? 0;
          this.defaultAnchor = defaultAnchor;
          this.defaultBorders = defaultBorders;
          this.destroyed = false;
          this.dynamic = dynamic || false;
          this.updateUvs();
        }
        set source(value) {
          if (this._source) {
            this._source.off("resize", this.update, this);
          }
          this._source = value;
          value.on("resize", this.update, this);
          this.emit("update", this);
        }
        /** the underlying source of the texture (equivalent of baseTexture in v7) */
        get source() {
          return this._source;
        }
        /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */
        get textureMatrix() {
          if (!this._textureMatrix) {
            this._textureMatrix = new TextureMatrix(this);
          }
          return this._textureMatrix;
        }
        /** The width of the Texture in pixels. */
        get width() {
          return this.orig.width;
        }
        /** The height of the Texture in pixels. */
        get height() {
          return this.orig.height;
        }
        /** Call this function when you have modified the frame of this texture. */
        updateUvs() {
          const { uvs, frame } = this;
          const { width, height } = this._source;
          const nX = frame.x / width;
          const nY = frame.y / height;
          const nW = frame.width / width;
          const nH = frame.height / height;
          let rotate = this.rotate;
          if (rotate) {
            const w2 = nW / 2;
            const h2 = nH / 2;
            const cX = nX + w2;
            const cY = nY + h2;
            rotate = groupD8.add(rotate, groupD8.NW);
            uvs.x0 = cX + w2 * groupD8.uX(rotate);
            uvs.y0 = cY + h2 * groupD8.uY(rotate);
            rotate = groupD8.add(rotate, 2);
            uvs.x1 = cX + w2 * groupD8.uX(rotate);
            uvs.y1 = cY + h2 * groupD8.uY(rotate);
            rotate = groupD8.add(rotate, 2);
            uvs.x2 = cX + w2 * groupD8.uX(rotate);
            uvs.y2 = cY + h2 * groupD8.uY(rotate);
            rotate = groupD8.add(rotate, 2);
            uvs.x3 = cX + w2 * groupD8.uX(rotate);
            uvs.y3 = cY + h2 * groupD8.uY(rotate);
          } else {
            uvs.x0 = nX;
            uvs.y0 = nY;
            uvs.x1 = nX + nW;
            uvs.y1 = nY;
            uvs.x2 = nX + nW;
            uvs.y2 = nY + nH;
            uvs.x3 = nX;
            uvs.y3 = nY + nH;
          }
        }
        /**
         * Destroys this texture
         * @param destroySource - Destroy the source when the texture is destroyed.
         */
        destroy(destroySource = false) {
          if (this._source) {
            if (destroySource) {
              this._source.destroy();
              this._source = null;
            }
          }
          this._textureMatrix = null;
          this.destroyed = true;
          this.emit("destroy", this);
          this.removeAllListeners();
        }
        /** call this if you have modified the `texture outside` of the constructor */
        update() {
          if (this.noFrame) {
            this.frame.width = this._source.width;
            this.frame.height = this._source.height;
          }
          this.updateUvs();
          this.emit("update", this);
        }
        /** @deprecated since 8.0.0 */
        get baseTexture() {
          deprecation(v8_0_0, "Texture.baseTexture is now Texture.source");
          return this._source;
        }
      };
      Texture.EMPTY = new Texture({
        label: "EMPTY",
        source: new TextureSource({
          label: "EMPTY"
        })
      });
      Texture.EMPTY.destroy = NOOP;
      Texture.WHITE = new Texture({
        source: new BufferImageSource({
          resource: new Uint8Array([255, 255, 255, 255]),
          width: 1,
          height: 1,
          alphaMode: "premultiply-alpha-on-upload",
          label: "WHITE"
        }),
        label: "WHITE"
      });
      Texture.WHITE.destroy = NOOP;
    }
  });

  // ../core/node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs
  var _Spritesheet, Spritesheet;
  var init_Spritesheet = __esm({
    "../core/node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs"() {
      init_Rectangle();
      init_Texture();
      _Spritesheet = class _Spritesheet2 {
        /**
         * @param texture - Reference to the source BaseTexture object.
         * @param {object} data - Spritesheet image data.
         */
        constructor(texture, data) {
          this.linkedSheets = [];
          this._texture = texture instanceof Texture ? texture : null;
          this.textureSource = texture.source;
          this.textures = {};
          this.animations = {};
          this.data = data;
          const metaResolution = parseFloat(data.meta.scale);
          if (metaResolution) {
            this.resolution = metaResolution;
            texture.source.resolution = this.resolution;
          } else {
            this.resolution = texture.source._resolution;
          }
          this._frames = this.data.frames;
          this._frameKeys = Object.keys(this._frames);
          this._batchIndex = 0;
          this._callback = null;
        }
        /**
         * Parser spritesheet from loaded data. This is done asynchronously
         * to prevent creating too many Texture within a single process.
         */
        parse() {
          return new Promise((resolve) => {
            this._callback = resolve;
            this._batchIndex = 0;
            if (this._frameKeys.length <= _Spritesheet2.BATCH_SIZE) {
              this._processFrames(0);
              this._processAnimations();
              this._parseComplete();
            } else {
              this._nextBatch();
            }
          });
        }
        /**
         * Process a batch of frames
         * @param initialFrameIndex - The index of frame to start.
         */
        _processFrames(initialFrameIndex) {
          let frameIndex = initialFrameIndex;
          const maxFrames = _Spritesheet2.BATCH_SIZE;
          while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
            const i2 = this._frameKeys[frameIndex];
            const data = this._frames[i2];
            const rect = data.frame;
            if (rect) {
              let frame = null;
              let trim = null;
              const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;
              const orig = new Rectangle(
                0,
                0,
                Math.floor(sourceSize.w) / this.resolution,
                Math.floor(sourceSize.h) / this.resolution
              );
              if (data.rotated) {
                frame = new Rectangle(
                  Math.floor(rect.x) / this.resolution,
                  Math.floor(rect.y) / this.resolution,
                  Math.floor(rect.h) / this.resolution,
                  Math.floor(rect.w) / this.resolution
                );
              } else {
                frame = new Rectangle(
                  Math.floor(rect.x) / this.resolution,
                  Math.floor(rect.y) / this.resolution,
                  Math.floor(rect.w) / this.resolution,
                  Math.floor(rect.h) / this.resolution
                );
              }
              if (data.trimmed !== false && data.spriteSourceSize) {
                trim = new Rectangle(
                  Math.floor(data.spriteSourceSize.x) / this.resolution,
                  Math.floor(data.spriteSourceSize.y) / this.resolution,
                  Math.floor(rect.w) / this.resolution,
                  Math.floor(rect.h) / this.resolution
                );
              }
              this.textures[i2] = new Texture({
                source: this.textureSource,
                frame,
                orig,
                trim,
                rotate: data.rotated ? 2 : 0,
                defaultAnchor: data.anchor,
                defaultBorders: data.borders,
                label: i2.toString()
              });
            }
            frameIndex++;
          }
        }
        /** Parse animations config. */
        _processAnimations() {
          const animations = this.data.animations || {};
          for (const animName in animations) {
            this.animations[animName] = [];
            for (let i2 = 0; i2 < animations[animName].length; i2++) {
              const frameName = animations[animName][i2];
              this.animations[animName].push(this.textures[frameName]);
            }
          }
        }
        /** The parse has completed. */
        _parseComplete() {
          const callback = this._callback;
          this._callback = null;
          this._batchIndex = 0;
          callback.call(this, this.textures);
        }
        /** Begin the next batch of textures. */
        _nextBatch() {
          this._processFrames(this._batchIndex * _Spritesheet2.BATCH_SIZE);
          this._batchIndex++;
          setTimeout(() => {
            if (this._batchIndex * _Spritesheet2.BATCH_SIZE < this._frameKeys.length) {
              this._nextBatch();
            } else {
              this._processAnimations();
              this._parseComplete();
            }
          }, 0);
        }
        /**
         * Destroy Spritesheet and don't use after this.
         * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well
         */
        destroy(destroyBase = false) {
          for (const i2 in this.textures) {
            this.textures[i2].destroy();
          }
          this._frames = null;
          this._frameKeys = null;
          this.data = null;
          this.textures = null;
          if (destroyBase) {
            this._texture?.destroy();
            this.textureSource.destroy();
          }
          this._texture = null;
          this.textureSource = null;
          this.linkedSheets = [];
        }
      };
      _Spritesheet.BATCH_SIZE = 1e3;
      Spritesheet = _Spritesheet;
    }
  });

  // ../core/node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs
  function getCacheableAssets(keys, asset, ignoreMultiPack) {
    const out2 = {};
    keys.forEach((key) => {
      out2[key] = asset;
    });
    Object.keys(asset.textures).forEach((key) => {
      out2[key] = asset.textures[key];
    });
    if (!ignoreMultiPack) {
      const basePath = path.dirname(keys[0]);
      asset.linkedSheets.forEach((item, i2) => {
        const out22 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i2]}`], item, true);
        Object.assign(out2, out22);
      });
    }
    return out2;
  }
  var validImages, spritesheetAsset;
  var init_spritesheetAsset = __esm({
    "../core/node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs"() {
      init_LoaderParser();
      init_Resolver();
      init_copySearchParams();
      init_Extensions();
      init_Texture();
      init_path();
      init_Spritesheet();
      validImages = [
        "jpg",
        "png",
        "jpeg",
        "avif",
        "webp",
        "basis",
        "etc2",
        "bc7",
        "bc6h",
        "bc5",
        "bc4",
        "bc3",
        "bc2",
        "bc1",
        "eac",
        "astc"
      ];
      spritesheetAsset = {
        extension: ExtensionType.Asset,
        /** Handle the caching of the related Spritesheet Textures */
        cache: {
          test: (asset) => asset instanceof Spritesheet,
          getCacheableAssets: (keys, asset) => getCacheableAssets(keys, asset, false)
        },
        /** Resolve the resolution of the asset. */
        resolver: {
          test: (value) => {
            const tempURL = value.split("?")[0];
            const split = tempURL.split(".");
            const extension = split.pop();
            const format = split.pop();
            return extension === "json" && validImages.includes(format);
          },
          parse: (value) => {
            const split = value.split(".");
            return {
              resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
              format: split[split.length - 2],
              src: value
            };
          }
        },
        /**
         * Loader plugin that parses sprite sheets!
         * once the JSON has been loaded this checks to see if the JSON is spritesheet data.
         * If it is, we load the spritesheets image and parse the data into Spritesheet
         * All textures in the sprite sheet are then added to the cache
         */
        loader: {
          name: "spritesheetLoader",
          extension: {
            type: ExtensionType.LoadParser,
            priority: LoaderParserPriority.Normal
          },
          async testParse(asset, options) {
            return path.extname(options.src).toLowerCase() === ".json" && !!asset.frames;
          },
          async parse(asset, options, loader) {
            const {
              texture: imageTexture,
              // if user need to use preloaded texture
              imageFilename
              // if user need to use custom filename (not from jsonFile.meta.image)
            } = options?.data ?? {};
            let basePath = path.dirname(options.src);
            if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {
              basePath += "/";
            }
            let texture;
            if (imageTexture instanceof Texture) {
              texture = imageTexture;
            } else {
              const imagePath = copySearchParams(basePath + (imageFilename ?? asset.meta.image), options.src);
              const assets = await loader.load([imagePath]);
              texture = assets[imagePath];
            }
            const spritesheet = new Spritesheet(
              texture.source,
              asset
            );
            await spritesheet.parse();
            const multiPacks = asset?.meta?.related_multi_packs;
            if (Array.isArray(multiPacks)) {
              const promises = [];
              for (const item of multiPacks) {
                if (typeof item !== "string") {
                  continue;
                }
                let itemUrl = basePath + item;
                if (options.data?.ignoreMultiPack) {
                  continue;
                }
                itemUrl = copySearchParams(itemUrl, options.src);
                promises.push(loader.load({
                  src: itemUrl,
                  data: {
                    ignoreMultiPack: true
                  }
                }));
              }
              const res = await Promise.all(promises);
              spritesheet.linkedSheets = res;
              res.forEach((item) => {
                item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));
              });
            }
            return spritesheet;
          },
          async unload(spritesheet, _resolvedAsset, loader) {
            await loader.unload(spritesheet.textureSource._sourceOrigin);
            spritesheet.destroy(false);
          }
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/spritesheet/init.mjs
  var init_init4 = __esm({
    "../core/node_modules/pixi.js/lib/spritesheet/init.mjs"() {
      init_Extensions();
      init_spritesheetAsset();
      extensions.add(spritesheetAsset);
    }
  });

  // ../core/node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs
  function updateQuadBounds(bounds, anchor, texture, padding) {
    const { width, height } = texture.orig;
    const trim = texture.trim;
    if (trim) {
      const sourceWidth = trim.width;
      const sourceHeight = trim.height;
      bounds.minX = trim.x - anchor._x * width - padding;
      bounds.maxX = bounds.minX + sourceWidth;
      bounds.minY = trim.y - anchor._y * height - padding;
      bounds.maxY = bounds.minY + sourceHeight;
    } else {
      bounds.minX = -anchor._x * width - padding;
      bounds.maxX = bounds.minX + width;
      bounds.minY = -anchor._y * height - padding;
      bounds.maxY = bounds.minY + height;
    }
    return;
  }
  var init_updateQuadBounds = __esm({
    "../core/node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/sprite/Sprite.mjs
  var Sprite;
  var init_Sprite = __esm({
    "../core/node_modules/pixi.js/lib/scene/sprite/Sprite.mjs"() {
      init_ObservablePoint();
      init_Texture();
      init_updateQuadBounds();
      init_Container();
      Sprite = class extends Container {
        /**
         * @param options - The options for creating the sprite.
         */
        constructor(options = Texture.EMPTY) {
          if (options instanceof Texture) {
            options = { texture: options };
          }
          const { texture = Texture.EMPTY, anchor, roundPixels, width, height, ...rest } = options;
          super({
            label: "Sprite",
            ...rest
          });
          this.renderPipeId = "sprite";
          this.batched = true;
          this._didSpriteUpdate = false;
          this._bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };
          this._sourceBounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };
          this._boundsDirty = true;
          this._sourceBoundsDirty = true;
          this._roundPixels = 0;
          this._anchor = new ObservablePoint(
            {
              _onUpdate: () => {
                this.onViewUpdate();
              }
            }
          );
          if (anchor) {
            this.anchor = anchor;
          } else if (texture.defaultAnchor) {
            this.anchor = texture.defaultAnchor;
          }
          this.texture = texture;
          this.allowChildren = false;
          this.roundPixels = roundPixels ?? false;
          if (width)
            this.width = width;
          if (height)
            this.height = height;
        }
        /**
         * Helper function that creates a new sprite based on the source you provide.
         * The source can be - frame id, image, video, canvas element, video element, texture
         * @param source - Source to create texture from
         * @param [skipCache] - Whether to skip the cache or not
         * @returns The newly created sprite
         */
        static from(source2, skipCache = false) {
          if (source2 instanceof Texture) {
            return new Sprite(source2);
          }
          return new Sprite(Texture.from(source2, skipCache));
        }
        set texture(value) {
          value || (value = Texture.EMPTY);
          const currentTexture = this._texture;
          if (currentTexture === value)
            return;
          if (currentTexture && currentTexture.dynamic)
            currentTexture.off("update", this.onViewUpdate, this);
          if (value.dynamic)
            value.on("update", this.onViewUpdate, this);
          this._texture = value;
          this.onViewUpdate();
        }
        /** The texture that the sprite is using. */
        get texture() {
          return this._texture;
        }
        /**
         * The local bounds of the sprite.
         * @type {rendering.Bounds}
         */
        get bounds() {
          if (this._boundsDirty) {
            this._updateBounds();
            this._boundsDirty = false;
          }
          return this._bounds;
        }
        /**
         * The bounds of the sprite, taking the texture's trim into account.
         * @type {rendering.Bounds}
         */
        get sourceBounds() {
          if (this._sourceBoundsDirty) {
            this._updateSourceBounds();
            this._sourceBoundsDirty = false;
          }
          return this._sourceBounds;
        }
        /**
         * Checks if the object contains the given point.
         * @param point - The point to check
         */
        containsPoint(point) {
          const bounds = this.sourceBounds;
          if (point.x >= bounds.maxX && point.x <= bounds.minX) {
            if (point.y >= bounds.maxY && point.y <= bounds.minY) {
              return true;
            }
          }
          return false;
        }
        /**
         * Adds the bounds of this object to the bounds object.
         * @param bounds - The output bounds object.
         */
        addBounds(bounds) {
          const _bounds = this._texture.trim ? this.sourceBounds : this.bounds;
          bounds.addFrame(_bounds.minX, _bounds.minY, _bounds.maxX, _bounds.maxY);
        }
        onViewUpdate() {
          this._didChangeId += 1 << 12;
          this._didSpriteUpdate = true;
          this._sourceBoundsDirty = this._boundsDirty = true;
          if (this.didViewUpdate)
            return;
          this.didViewUpdate = true;
          const renderGroup = this.renderGroup || this.parentRenderGroup;
          if (renderGroup) {
            renderGroup.onChildViewUpdate(this);
          }
        }
        _updateBounds() {
          updateQuadBounds(this._bounds, this._anchor, this._texture, 0);
        }
        _updateSourceBounds() {
          const anchor = this._anchor;
          const texture = this._texture;
          const sourceBounds = this._sourceBounds;
          const { width, height } = texture.orig;
          sourceBounds.maxX = -anchor._x * width;
          sourceBounds.minX = sourceBounds.maxX + width;
          sourceBounds.maxY = -anchor._y * height;
          sourceBounds.minY = sourceBounds.maxY + height;
        }
        /**
         * Destroys this sprite renderable and optionally its texture.
         * @param options - Options parameter. A boolean will act as if all options
         *  have been set to that value
         * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
         * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
         */
        destroy(options = false) {
          super.destroy(options);
          const destroyTexture = typeof options === "boolean" ? options : options?.texture;
          if (destroyTexture) {
            const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
            this._texture.destroy(destroyTextureSource);
          }
          this._texture = null;
          this._bounds = null;
          this._sourceBounds = null;
          this._anchor = null;
        }
        /**
         * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}
         * and passed to the constructor.
         *
         * The default is `(0,0)`, this means the sprite's origin is the top left.
         *
         * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.
         *
         * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.
         *
         * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
         * @example
         * import { Sprite } from 'pixi.js';
         *
         * const sprite = new Sprite({texture: Texture.WHITE});
         * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).
         */
        get anchor() {
          return this._anchor;
        }
        set anchor(value) {
          typeof value === "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);
        }
        /**
         *  Whether or not to round the x/y position of the sprite.
         * @type {boolean}
         */
        get roundPixels() {
          return !!this._roundPixels;
        }
        set roundPixels(value) {
          this._roundPixels = value ? 1 : 0;
        }
        /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */
        get width() {
          return Math.abs(this.scale.x) * this._texture.orig.width;
        }
        set width(value) {
          this._setWidth(value, this._texture.orig.width);
        }
        /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */
        get height() {
          return Math.abs(this.scale.y) * this._texture.orig.height;
        }
        set height(value) {
          this._setHeight(value, this._texture.orig.height);
        }
        /**
         * Retrieves the size of the Sprite as a [Size]{@link Size} object.
         * This is faster than get the width and height separately.
         * @param out - Optional object to store the size in.
         * @returns - The size of the Sprite.
         */
        getSize(out2) {
          if (!out2) {
            out2 = {};
          }
          out2.width = Math.abs(this.scale.x) * this._texture.orig.width;
          out2.height = Math.abs(this.scale.y) * this._texture.orig.height;
          return out2;
        }
        /**
         * Sets the size of the Sprite to the specified width and height.
         * This is faster than setting the width and height separately.
         * @param value - This can be either a number or a [Size]{@link Size} object.
         * @param height - The height to set. Defaults to the value of `width` if not provided.
         */
        setSize(value, height) {
          let convertedWidth;
          let convertedHeight;
          if (typeof value !== "object") {
            convertedWidth = value;
            convertedHeight = height ?? value;
          } else {
            convertedWidth = value.width;
            convertedHeight = value.height ?? value.width;
          }
          if (convertedWidth !== void 0) {
            this._setWidth(convertedWidth, this._texture.orig.width);
          }
          if (convertedHeight !== void 0) {
            this._setHeight(convertedHeight, this._texture.orig.height);
          }
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.mjs
  function addMaskBounds(mask, bounds, skipUpdateTransform) {
    const boundsToMask = tempBounds;
    mask.measurable = true;
    getGlobalBounds(mask, skipUpdateTransform, boundsToMask);
    bounds.addBoundsMask(boundsToMask);
    mask.measurable = false;
  }
  var tempBounds;
  var init_addMaskBounds = __esm({
    "../core/node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.mjs"() {
      init_Bounds();
      init_getGlobalBounds();
      tempBounds = new Bounds();
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.mjs
  function addMaskLocalBounds(mask, bounds, localRoot) {
    const boundsToMask = boundsPool.get();
    mask.measurable = true;
    const tempMatrix6 = matrixPool.get().identity();
    const relativeMask = getMatrixRelativeToParent(mask, localRoot, tempMatrix6);
    getLocalBounds(mask, boundsToMask, relativeMask);
    mask.measurable = false;
    bounds.addBoundsMask(boundsToMask);
    matrixPool.return(tempMatrix6);
    boundsPool.return(boundsToMask);
  }
  function getMatrixRelativeToParent(target, root, matrix) {
    if (!target) {
      warn("Mask bounds, renderable is not inside the root container");
      return matrix;
    }
    if (target !== root) {
      getMatrixRelativeToParent(target.parent, root, matrix);
      target.updateLocalTransform();
      matrix.append(target.localTransform);
    }
    return matrix;
  }
  var init_addMaskLocalBounds = __esm({
    "../core/node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.mjs"() {
      init_getLocalBounds();
      init_matrixAndBoundsPool();
      init_warn();
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.mjs
  var AlphaMask;
  var init_AlphaMask = __esm({
    "../core/node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.mjs"() {
      init_Extensions();
      init_Sprite();
      init_addMaskBounds();
      init_addMaskLocalBounds();
      AlphaMask = class {
        constructor(options) {
          this.priority = 0;
          this.pipe = "alphaMask";
          if (options?.mask) {
            this.init(options.mask);
          }
        }
        init(mask) {
          this.mask = mask;
          this.renderMaskToTexture = !(mask instanceof Sprite);
          this.mask.renderable = this.renderMaskToTexture;
          this.mask.includeInBuild = !this.renderMaskToTexture;
          this.mask.measurable = false;
        }
        reset() {
          this.mask.measurable = true;
          this.mask = null;
        }
        addBounds(bounds, skipUpdateTransform) {
          addMaskBounds(this.mask, bounds, skipUpdateTransform);
        }
        addLocalBounds(bounds, localRoot) {
          addMaskLocalBounds(this.mask, bounds, localRoot);
        }
        containsPoint(point, hitTestFn) {
          const mask = this.mask;
          return hitTestFn(mask, point);
        }
        destroy() {
          this.reset();
        }
        static test(mask) {
          return mask instanceof Sprite;
        }
      };
      AlphaMask.extension = ExtensionType.MaskEffect;
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/mask/color/ColorMask.mjs
  var ColorMask;
  var init_ColorMask = __esm({
    "../core/node_modules/pixi.js/lib/rendering/mask/color/ColorMask.mjs"() {
      init_Extensions();
      ColorMask = class {
        constructor(options) {
          this.priority = 0;
          this.pipe = "colorMask";
          if (options?.mask) {
            this.init(options.mask);
          }
        }
        init(mask) {
          this.mask = mask;
        }
        destroy() {
        }
        static test(mask) {
          return typeof mask === "number";
        }
      };
      ColorMask.extension = ExtensionType.MaskEffect;
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.mjs
  var StencilMask;
  var init_StencilMask = __esm({
    "../core/node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.mjs"() {
      init_Extensions();
      init_Container();
      init_addMaskBounds();
      init_addMaskLocalBounds();
      StencilMask = class {
        constructor(options) {
          this.priority = 0;
          this.pipe = "stencilMask";
          if (options?.mask) {
            this.init(options.mask);
          }
        }
        init(mask) {
          this.mask = mask;
          this.mask.includeInBuild = false;
          this.mask.measurable = false;
        }
        reset() {
          this.mask.measurable = true;
          this.mask.includeInBuild = true;
          this.mask = null;
        }
        addBounds(bounds, skipUpdateTransform) {
          addMaskBounds(this.mask, bounds, skipUpdateTransform);
        }
        addLocalBounds(bounds, localRoot) {
          addMaskLocalBounds(this.mask, bounds, localRoot);
        }
        containsPoint(point, hitTestFn) {
          const mask = this.mask;
          return hitTestFn(mask, point);
        }
        destroy() {
          this.reset();
        }
        static test(mask) {
          return mask instanceof Container;
        }
      };
      StencilMask.extension = ExtensionType.MaskEffect;
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs
  var CanvasSource;
  var init_CanvasSource = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs"() {
      init_adapter();
      init_Extensions();
      init_TextureSource();
      CanvasSource = class extends TextureSource {
        constructor(options) {
          if (!options.resource) {
            options.resource = DOMAdapter.get().createCanvas();
          }
          if (!options.width) {
            options.width = options.resource.width;
            if (!options.autoDensity) {
              options.width /= options.resolution;
            }
          }
          if (!options.height) {
            options.height = options.resource.height;
            if (!options.autoDensity) {
              options.height /= options.resolution;
            }
          }
          super(options);
          this.uploadMethodId = "image";
          this.autoDensity = options.autoDensity;
          const canvas = options.resource;
          if (this.pixelWidth !== canvas.width || this.pixelWidth !== canvas.height) {
            this.resizeCanvas();
          }
          this.transparent = !!options.transparent;
        }
        resizeCanvas() {
          if (this.autoDensity) {
            this.resource.style.width = `${this.width}px`;
            this.resource.style.height = `${this.height}px`;
          }
          if (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) {
            this.resource.width = this.pixelWidth;
            this.resource.height = this.pixelHeight;
          }
        }
        resize(width = this.width, height = this.height, resolution = this._resolution) {
          const didResize = super.resize(width, height, resolution);
          if (didResize) {
            this.resizeCanvas();
          }
          return didResize;
        }
        static test(resource) {
          return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && resource instanceof OffscreenCanvas;
        }
      };
      CanvasSource.extension = ExtensionType.TextureSource;
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs
  var ImageSource;
  var init_ImageSource = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs"() {
      init_adapter();
      init_Extensions();
      init_warn();
      init_TextureSource();
      ImageSource = class extends TextureSource {
        constructor(options) {
          if (options.resource && (globalThis.HTMLImageElement && options.resource instanceof HTMLImageElement)) {
            const canvas = DOMAdapter.get().createCanvas(options.resource.width, options.resource.height);
            const context4 = canvas.getContext("2d");
            context4.drawImage(options.resource, 0, 0);
            options.resource = canvas;
            warn("ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.");
          }
          super(options);
          this.uploadMethodId = "image";
          this.autoGarbageCollect = true;
        }
        static test(resource) {
          return globalThis.HTMLImageElement && resource instanceof HTMLImageElement || typeof ImageBitmap !== "undefined" && resource instanceof ImageBitmap;
        }
      };
      ImageSource.extension = ExtensionType.TextureSource;
    }
  });

  // ../core/node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.mjs
  async function detectVideoAlphaMode() {
    promise ?? (promise = (async () => {
      const canvas = document.createElement("canvas");
      const gl = canvas.getContext("webgl");
      if (!gl) {
        return "premultiply-alpha-on-upload";
      }
      const video = await new Promise((resolve) => {
        const video2 = document.createElement("video");
        video2.onloadeddata = () => resolve(video2);
        video2.onerror = () => resolve(null);
        video2.autoplay = false;
        video2.crossOrigin = "anonymous";
        video2.preload = "auto";
        video2.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=";
        video2.load();
      });
      if (!video) {
        return "premultiply-alpha-on-upload";
      }
      const texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      const framebuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      gl.framebufferTexture2D(
        gl.FRAMEBUFFER,
        gl.COLOR_ATTACHMENT0,
        gl.TEXTURE_2D,
        texture,
        0
      );
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
      gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
      const pixel = new Uint8Array(4);
      gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
      gl.deleteFramebuffer(framebuffer);
      gl.deleteTexture(texture);
      gl.getExtension("WEBGL_lose_context")?.loseContext();
      return pixel[0] <= pixel[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload";
    })());
    return promise;
  }
  var promise;
  var init_detectVideoAlphaMode = __esm({
    "../core/node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs
  var _VideoSource, VideoSource;
  var init_VideoSource = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs"() {
      init_Extensions();
      init_Ticker();
      init_detectVideoAlphaMode();
      init_TextureSource();
      _VideoSource = class _VideoSource2 extends TextureSource {
        constructor(options) {
          super(options);
          this.isReady = false;
          this.uploadMethodId = "video";
          options = {
            ..._VideoSource2.defaultOptions,
            ...options
          };
          this._autoUpdate = true;
          this._isConnectedToTicker = false;
          this._updateFPS = options.updateFPS || 0;
          this._msToNextUpdate = 0;
          this.autoPlay = options.autoPlay !== false;
          this.alphaMode = options.alphaMode ?? "premultiply-alpha-on-upload";
          this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);
          this._videoFrameRequestCallbackHandle = null;
          this._load = null;
          this._resolve = null;
          this._reject = null;
          this._onCanPlay = this._onCanPlay.bind(this);
          this._onCanPlayThrough = this._onCanPlayThrough.bind(this);
          this._onError = this._onError.bind(this);
          this._onPlayStart = this._onPlayStart.bind(this);
          this._onPlayStop = this._onPlayStop.bind(this);
          this._onSeeked = this._onSeeked.bind(this);
          if (options.autoLoad !== false) {
            void this.load();
          }
        }
        /** Update the video frame if the source is not destroyed and meets certain conditions. */
        updateFrame() {
          if (this.destroyed) {
            return;
          }
          if (this._updateFPS) {
            const elapsedMS = Ticker.shared.elapsedMS * this.resource.playbackRate;
            this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
          }
          if (!this._updateFPS || this._msToNextUpdate <= 0) {
            this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;
          }
          if (this.isValid) {
            this.update();
          }
        }
        /** Callback to update the video frame and potentially request the next frame update. */
        _videoFrameRequestCallback() {
          this.updateFrame();
          if (this.destroyed) {
            this._videoFrameRequestCallbackHandle = null;
          } else {
            this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(
              this._videoFrameRequestCallback
            );
          }
        }
        /**
         * Checks if the resource has valid dimensions.
         * @returns {boolean} True if width and height are set, otherwise false.
         */
        get isValid() {
          return !!this.resource.videoWidth && !!this.resource.videoHeight;
        }
        /**
         * Start preloading the video resource.
         * @returns {Promise<this>} Handle the validate event
         */
        async load() {
          if (this._load) {
            return this._load;
          }
          const source2 = this.resource;
          const options = this.options;
          if ((source2.readyState === source2.HAVE_ENOUGH_DATA || source2.readyState === source2.HAVE_FUTURE_DATA) && source2.width && source2.height) {
            source2.complete = true;
          }
          source2.addEventListener("play", this._onPlayStart);
          source2.addEventListener("pause", this._onPlayStop);
          source2.addEventListener("seeked", this._onSeeked);
          if (!this._isSourceReady()) {
            if (!options.preload) {
              source2.addEventListener("canplay", this._onCanPlay);
            }
            source2.addEventListener("canplaythrough", this._onCanPlayThrough);
            source2.addEventListener("error", this._onError, true);
          } else {
            this._mediaReady();
          }
          this.alphaMode = await detectVideoAlphaMode();
          this._load = new Promise((resolve, reject) => {
            if (this.isValid) {
              resolve(this);
            } else {
              this._resolve = resolve;
              this._reject = reject;
              if (options.preloadTimeoutMs !== void 0) {
                this._preloadTimeout = setTimeout(() => {
                  this._onError(new ErrorEvent(`Preload exceeded timeout of ${options.preloadTimeoutMs}ms`));
                });
              }
              source2.load();
            }
          });
          return this._load;
        }
        /**
         * Handle video error events.
         * @param event - The error event
         */
        _onError(event) {
          this.resource.removeEventListener("error", this._onError, true);
          this.emit("error", event);
          if (this._reject) {
            this._reject(event);
            this._reject = null;
            this._resolve = null;
          }
        }
        /**
         * Checks if the underlying source is playing.
         * @returns True if playing.
         */
        _isSourcePlaying() {
          const source2 = this.resource;
          return !source2.paused && !source2.ended;
        }
        /**
         * Checks if the underlying source is ready for playing.
         * @returns True if ready.
         */
        _isSourceReady() {
          const source2 = this.resource;
          return source2.readyState > 2;
        }
        /** Runs the update loop when the video is ready to play. */
        _onPlayStart() {
          if (!this.isValid) {
            this._mediaReady();
          }
          this._configureAutoUpdate();
        }
        /** Stops the update loop when a pause event is triggered. */
        _onPlayStop() {
          this._configureAutoUpdate();
        }
        /** Handles behavior when the video completes seeking to the current playback position. */
        _onSeeked() {
          if (this._autoUpdate && !this._isSourcePlaying()) {
            this._msToNextUpdate = 0;
            this.updateFrame();
            this._msToNextUpdate = 0;
          }
        }
        _onCanPlay() {
          const source2 = this.resource;
          source2.removeEventListener("canplay", this._onCanPlay);
          this._mediaReady();
        }
        _onCanPlayThrough() {
          const source2 = this.resource;
          source2.removeEventListener("canplaythrough", this._onCanPlay);
          if (this._preloadTimeout) {
            clearTimeout(this._preloadTimeout);
            this._preloadTimeout = void 0;
          }
          this._mediaReady();
        }
        /** Fired when the video is loaded and ready to play. */
        _mediaReady() {
          const source2 = this.resource;
          if (this.isValid) {
            this.isReady = true;
            this.resize(source2.videoWidth, source2.videoHeight);
          }
          this._msToNextUpdate = 0;
          this.updateFrame();
          this._msToNextUpdate = 0;
          if (this._resolve) {
            this._resolve(this);
            this._resolve = null;
            this._reject = null;
          }
          if (this._isSourcePlaying()) {
            this._onPlayStart();
          } else if (this.autoPlay) {
            void this.resource.play();
          }
        }
        /** Cleans up resources and event listeners associated with this texture. */
        destroy() {
          this._configureAutoUpdate();
          const source2 = this.resource;
          if (source2) {
            source2.removeEventListener("play", this._onPlayStart);
            source2.removeEventListener("pause", this._onPlayStop);
            source2.removeEventListener("seeked", this._onSeeked);
            source2.removeEventListener("canplay", this._onCanPlay);
            source2.removeEventListener("canplaythrough", this._onCanPlayThrough);
            source2.removeEventListener("error", this._onError, true);
            source2.pause();
            source2.src = "";
            source2.load();
          }
          super.destroy();
        }
        /** Should the base texture automatically update itself, set to true by default. */
        get autoUpdate() {
          return this._autoUpdate;
        }
        set autoUpdate(value) {
          if (value !== this._autoUpdate) {
            this._autoUpdate = value;
            this._configureAutoUpdate();
          }
        }
        /**
         * How many times a second to update the texture from the video.
         * Leave at 0 to update at every render.
         * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.
         */
        get updateFPS() {
          return this._updateFPS;
        }
        set updateFPS(value) {
          if (value !== this._updateFPS) {
            this._updateFPS = value;
            this._configureAutoUpdate();
          }
        }
        /**
         * Configures the updating mechanism based on the current state and settings.
         *
         * This method decides between using the browser's native video frame callback or a custom ticker
         * for updating the video frame. It ensures optimal performance and responsiveness
         * based on the video's state, playback status, and the desired frames-per-second setting.
         *
         * - If `_autoUpdate` is enabled and the video source is playing:
         *   - It will prefer the native video frame callback if available and no specific FPS is set.
         *   - Otherwise, it will use a custom ticker for manual updates.
         * - If `_autoUpdate` is disabled or the video isn't playing, any active update mechanisms are halted.
         */
        _configureAutoUpdate() {
          if (this._autoUpdate && this._isSourcePlaying()) {
            if (!this._updateFPS && this.resource.requestVideoFrameCallback) {
              if (this._isConnectedToTicker) {
                Ticker.shared.remove(this.updateFrame, this);
                this._isConnectedToTicker = false;
                this._msToNextUpdate = 0;
              }
              if (this._videoFrameRequestCallbackHandle === null) {
                this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(
                  this._videoFrameRequestCallback
                );
              }
            } else {
              if (this._videoFrameRequestCallbackHandle !== null) {
                this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);
                this._videoFrameRequestCallbackHandle = null;
              }
              if (!this._isConnectedToTicker) {
                Ticker.shared.add(this.updateFrame, this);
                this._isConnectedToTicker = true;
                this._msToNextUpdate = 0;
              }
            }
          } else {
            if (this._videoFrameRequestCallbackHandle !== null) {
              this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);
              this._videoFrameRequestCallbackHandle = null;
            }
            if (this._isConnectedToTicker) {
              Ticker.shared.remove(this.updateFrame, this);
              this._isConnectedToTicker = false;
              this._msToNextUpdate = 0;
            }
          }
        }
        static test(resource) {
          return globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement || globalThis.VideoFrame && resource instanceof VideoFrame;
        }
      };
      _VideoSource.extension = ExtensionType.TextureSource;
      _VideoSource.defaultOptions = {
        ...TextureSource.defaultOptions,
        /** If true, the video will start loading immediately. */
        autoLoad: true,
        /** If true, the video will start playing as soon as it is loaded. */
        autoPlay: true,
        /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */
        updateFPS: 0,
        /** If true, the video will be loaded with the `crossorigin` attribute. */
        crossorigin: true,
        /** If true, the video will loop when it ends. */
        loop: false,
        /** If true, the video will be muted. */
        muted: true,
        /** If true, the video will play inline. */
        playsinline: true,
        /** If true, the video will be preloaded. */
        preload: false
      };
      _VideoSource.MIME_TYPES = {
        ogv: "video/ogg",
        mov: "video/quicktime",
        m4v: "video/mp4"
      };
      VideoSource = _VideoSource;
    }
  });

  // ../core/node_modules/pixi.js/lib/assets/cache/Cache.mjs
  var CacheClass, Cache;
  var init_Cache = __esm({
    "../core/node_modules/pixi.js/lib/assets/cache/Cache.mjs"() {
      init_warn();
      init_convertToList();
      CacheClass = class {
        constructor() {
          this._parsers = [];
          this._cache = /* @__PURE__ */ new Map();
          this._cacheMap = /* @__PURE__ */ new Map();
        }
        /** Clear all entries. */
        reset() {
          this._cacheMap.clear();
          this._cache.clear();
        }
        /**
         * Check if the key exists
         * @param key - The key to check
         */
        has(key) {
          return this._cache.has(key);
        }
        /**
         * Fetch entry by key
         * @param key - The key of the entry to get
         */
        get(key) {
          const result = this._cache.get(key);
          if (!result) {
            warn(`[Assets] Asset id ${key} was not found in the Cache`);
          }
          return result;
        }
        /**
         * Set a value by key or keys name
         * @param key - The key or keys to set
         * @param value - The value to store in the cache or from which cacheable assets will be derived.
         */
        set(key, value) {
          const keys = convertToList(key);
          let cacheableAssets;
          for (let i2 = 0; i2 < this.parsers.length; i2++) {
            const parser = this.parsers[i2];
            if (parser.test(value)) {
              cacheableAssets = parser.getCacheableAssets(keys, value);
              break;
            }
          }
          const cacheableMap = new Map(Object.entries(cacheableAssets || {}));
          if (!cacheableAssets) {
            keys.forEach((key2) => {
              cacheableMap.set(key2, value);
            });
          }
          const cacheKeys = [...cacheableMap.keys()];
          const cachedAssets = {
            cacheKeys,
            keys
          };
          keys.forEach((key2) => {
            this._cacheMap.set(key2, cachedAssets);
          });
          cacheKeys.forEach((key2) => {
            const val = cacheableAssets ? cacheableAssets[key2] : value;
            if (this._cache.has(key2) && this._cache.get(key2) !== val) {
              warn("[Cache] already has key:", key2);
            }
            this._cache.set(key2, cacheableMap.get(key2));
          });
        }
        /**
         * Remove entry by key
         *
         * This function will also remove any associated alias from the cache also.
         * @param key - The key of the entry to remove
         */
        remove(key) {
          if (!this._cacheMap.has(key)) {
            warn(`[Assets] Asset id ${key} was not found in the Cache`);
            return;
          }
          const cacheMap2 = this._cacheMap.get(key);
          const cacheKeys = cacheMap2.cacheKeys;
          cacheKeys.forEach((key2) => {
            this._cache.delete(key2);
          });
          cacheMap2.keys.forEach((key2) => {
            this._cacheMap.delete(key2);
          });
        }
        /** All loader parsers registered */
        get parsers() {
          return this._parsers;
        }
      };
      Cache = new CacheClass();
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.mjs
  function autoDetectSource(options = {}) {
    const hasResource = options && options.resource;
    const res = hasResource ? options.resource : options;
    const opts = hasResource ? options : { resource: options };
    for (let i2 = 0; i2 < sources.length; i2++) {
      const Source = sources[i2];
      if (Source.test(res)) {
        return new Source(opts);
      }
    }
    throw new Error(`Could not find a source type for resource: ${opts.resource}`);
  }
  function resourceToTexture(options = {}, skipCache = false) {
    const hasResource = options && options.resource;
    const resource = hasResource ? options.resource : options;
    const opts = hasResource ? options : { resource: options };
    if (!skipCache && Cache.has(resource)) {
      return Cache.get(resource);
    }
    const texture = new Texture({ source: autoDetectSource(opts) });
    texture.on("destroy", () => {
      if (Cache.has(resource)) {
        Cache.remove(resource);
      }
    });
    if (!skipCache) {
      Cache.set(resource, texture);
    }
    return texture;
  }
  function textureFrom(id, skipCache = false) {
    if (typeof id === "string") {
      return Cache.get(id);
    } else if (id instanceof TextureSource) {
      return new Texture({ source: id });
    }
    return resourceToTexture(id, skipCache);
  }
  var sources;
  var init_textureFrom = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.mjs"() {
      init_Cache();
      init_Extensions();
      init_TextureSource();
      init_Texture();
      sources = [];
      extensions.handleByList(ExtensionType.TextureSource, sources);
      Texture.from = textureFrom;
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/init.mjs
  var init_init5 = __esm({
    "../core/node_modules/pixi.js/lib/rendering/init.mjs"() {
      init_Extensions();
      init_AlphaMask();
      init_ColorMask();
      init_StencilMask();
      init_BufferSource();
      init_CanvasSource();
      init_ImageSource();
      init_VideoSource();
      init_textureFrom();
      extensions.add(AlphaMask, ColorMask, StencilMask, VideoSource, ImageSource, CanvasSource, BufferImageSource);
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs
  var BufferUsage;
  var init_const3 = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs"() {
      "use strict";
      BufferUsage = /* @__PURE__ */ ((BufferUsage2) => {
        BufferUsage2[BufferUsage2["MAP_READ"] = 1] = "MAP_READ";
        BufferUsage2[BufferUsage2["MAP_WRITE"] = 2] = "MAP_WRITE";
        BufferUsage2[BufferUsage2["COPY_SRC"] = 4] = "COPY_SRC";
        BufferUsage2[BufferUsage2["COPY_DST"] = 8] = "COPY_DST";
        BufferUsage2[BufferUsage2["INDEX"] = 16] = "INDEX";
        BufferUsage2[BufferUsage2["VERTEX"] = 32] = "VERTEX";
        BufferUsage2[BufferUsage2["UNIFORM"] = 64] = "UNIFORM";
        BufferUsage2[BufferUsage2["STORAGE"] = 128] = "STORAGE";
        BufferUsage2[BufferUsage2["INDIRECT"] = 256] = "INDIRECT";
        BufferUsage2[BufferUsage2["QUERY_RESOLVE"] = 512] = "QUERY_RESOLVE";
        BufferUsage2[BufferUsage2["STATIC"] = 1024] = "STATIC";
        return BufferUsage2;
      })(BufferUsage || {});
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs
  var Buffer2;
  var init_Buffer = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs"() {
      init_eventemitter3();
      init_uid();
      init_const3();
      Buffer2 = class extends eventemitter3_default {
        /**
         * Creates a new Buffer with the given options
         * @param options - the options for the buffer
         */
        constructor(options) {
          let { data, size } = options;
          const { usage, label, shrinkToFit } = options;
          super();
          this.uid = uid("buffer");
          this._resourceType = "buffer";
          this._resourceId = uid("resource");
          this._touched = 0;
          this._updateID = 1;
          this.shrinkToFit = true;
          this.destroyed = false;
          if (data instanceof Array) {
            data = new Float32Array(data);
          }
          this._data = data;
          size = size ?? data?.byteLength;
          const mappedAtCreation = !!data;
          this.descriptor = {
            size,
            usage,
            mappedAtCreation,
            label
          };
          this.shrinkToFit = shrinkToFit ?? true;
        }
        /** the data in the buffer */
        get data() {
          return this._data;
        }
        set data(value) {
          this.setDataWithSize(value, value.length, true);
        }
        /** whether the buffer is static or not */
        get static() {
          return !!(this.descriptor.usage & BufferUsage.STATIC);
        }
        set static(value) {
          if (value) {
            this.descriptor.usage |= BufferUsage.STATIC;
          } else {
            this.descriptor.usage &= ~BufferUsage.STATIC;
          }
        }
        /**
         * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.
         * If you only want to update a subset of the buffer, you can pass in the size of the data.
         * @param value - the data to set
         * @param size - the size of the data in bytes
         * @param syncGPU - should the buffer be updated on the GPU immediately?
         */
        setDataWithSize(value, size, syncGPU) {
          this._updateID++;
          this._updateSize = size * value.BYTES_PER_ELEMENT;
          if (this._data === value) {
            if (syncGPU)
              this.emit("update", this);
            return;
          }
          const oldData = this._data;
          this._data = value;
          if (oldData.length !== value.length) {
            if (!this.shrinkToFit && value.byteLength < oldData.byteLength) {
              if (syncGPU)
                this.emit("update", this);
            } else {
              this.descriptor.size = value.byteLength;
              this._resourceId = uid("resource");
              this.emit("change", this);
            }
            return;
          }
          if (syncGPU)
            this.emit("update", this);
        }
        /**
         * updates the buffer on the GPU to reflect the data in the buffer.
         * By default it will update the entire buffer. If you only want to update a subset of the buffer,
         * you can pass in the size of the buffer to update.
         * @param sizeInBytes - the new size of the buffer in bytes
         */
        update(sizeInBytes) {
          this._updateSize = sizeInBytes ?? this._updateSize;
          this._updateID++;
          this.emit("update", this);
        }
        /** Destroys the buffer */
        destroy() {
          this.destroyed = true;
          this.emit("destroy", this);
          this.emit("change", this);
          this._data = null;
          this.descriptor = null;
          this.removeAllListeners();
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs
  function ensureIsBuffer(buffer, index) {
    if (!(buffer instanceof Buffer2)) {
      let usage = index ? BufferUsage.INDEX : BufferUsage.VERTEX;
      if (buffer instanceof Array) {
        if (index) {
          buffer = new Uint32Array(buffer);
          usage = BufferUsage.INDEX | BufferUsage.COPY_DST;
        } else {
          buffer = new Float32Array(buffer);
          usage = BufferUsage.VERTEX | BufferUsage.COPY_DST;
        }
      }
      buffer = new Buffer2({
        data: buffer,
        label: index ? "index-mesh-buffer" : "vertex-mesh-buffer",
        usage
      });
    }
    return buffer;
  }
  var init_ensureIsBuffer = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs"() {
      init_Buffer();
      init_const3();
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getGeometryBounds.mjs
  function getGeometryBounds(geometry, attributeId, bounds) {
    const attribute = geometry.getAttribute(attributeId);
    if (!attribute) {
      bounds.minX = 0;
      bounds.minY = 0;
      bounds.maxX = 0;
      bounds.maxY = 0;
      return bounds;
    }
    const data = attribute.buffer.data;
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    const byteSize = data.BYTES_PER_ELEMENT;
    const offset = (attribute.offset || 0) / byteSize;
    const stride = (attribute.stride || 2 * 4) / byteSize;
    for (let i2 = offset; i2 < data.length; i2 += stride) {
      const x2 = data[i2];
      const y2 = data[i2 + 1];
      if (x2 > maxX)
        maxX = x2;
      if (y2 > maxY)
        maxY = y2;
      if (x2 < minX)
        minX = x2;
      if (y2 < minY)
        minY = y2;
    }
    bounds.minX = minX;
    bounds.minY = minY;
    bounds.maxX = maxX;
    bounds.maxY = maxY;
    return bounds;
  }
  var init_getGeometryBounds = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getGeometryBounds.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs
  function ensureIsAttribute(attribute) {
    if (attribute instanceof Buffer2 || Array.isArray(attribute) || attribute.BYTES_PER_ELEMENT) {
      attribute = {
        buffer: attribute
      };
    }
    attribute.buffer = ensureIsBuffer(attribute.buffer, false);
    return attribute;
  }
  var Geometry;
  var init_Geometry = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs"() {
      init_eventemitter3();
      init_Bounds();
      init_uid();
      init_Buffer();
      init_ensureIsBuffer();
      init_getGeometryBounds();
      Geometry = class extends eventemitter3_default {
        /**
         * Create a new instance of a geometry
         * @param options - The options for the geometry.
         */
        constructor(options) {
          const { attributes, indexBuffer, topology } = options;
          super();
          this.uid = uid("geometry");
          this._layoutKey = 0;
          this.instanceCount = 1;
          this._bounds = new Bounds();
          this._boundsDirty = true;
          this.attributes = attributes;
          this.buffers = [];
          this.instanceCount = options.instanceCount || 1;
          for (const i2 in attributes) {
            const attribute = attributes[i2] = ensureIsAttribute(attributes[i2]);
            const bufferIndex = this.buffers.indexOf(attribute.buffer);
            if (bufferIndex === -1) {
              this.buffers.push(attribute.buffer);
              attribute.buffer.on("update", this.onBufferUpdate, this);
              attribute.buffer.on("change", this.onBufferUpdate, this);
            }
          }
          if (indexBuffer) {
            this.indexBuffer = ensureIsBuffer(indexBuffer, true);
            this.buffers.push(this.indexBuffer);
          }
          this.topology = topology || "triangle-list";
        }
        onBufferUpdate() {
          this._boundsDirty = true;
          this.emit("update", this);
        }
        /**
         * Returns the requested attribute.
         * @param id - The name of the attribute required
         * @returns - The attribute requested.
         */
        getAttribute(id) {
          return this.attributes[id];
        }
        /**
         * Returns the index buffer
         * @returns - The index buffer.
         */
        getIndex() {
          return this.indexBuffer;
        }
        /**
         * Returns the requested buffer.
         * @param id - The name of the buffer required.
         * @returns - The buffer requested.
         */
        getBuffer(id) {
          return this.getAttribute(id).buffer;
        }
        /**
         * Used to figure out how many vertices there are in this geometry
         * @returns the number of vertices in the geometry
         */
        getSize() {
          for (const i2 in this.attributes) {
            const attribute = this.attributes[i2];
            const buffer = attribute.buffer;
            return buffer.data.length / (attribute.stride / 4 || attribute.size);
          }
          return 0;
        }
        /** Returns the bounds of the geometry. */
        get bounds() {
          if (!this._boundsDirty)
            return this._bounds;
          this._boundsDirty = false;
          return getGeometryBounds(this, "aPosition", this._bounds);
        }
        /**
         * destroys the geometry.
         * @param destroyBuffers - destroy the buffers associated with this geometry
         */
        destroy(destroyBuffers = false) {
          this.emit("destroy", this);
          this.removeAllListeners();
          if (destroyBuffers) {
            this.buffers.forEach((buffer) => buffer.destroy());
          }
          this.attributes = null;
          this.buffers = null;
          this.indexBuffer = null;
          this._bounds = null;
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/batcher/gpu/BatchGeometry.mjs
  var placeHolderBufferData, placeHolderIndexData, BatchGeometry;
  var init_BatchGeometry = __esm({
    "../core/node_modules/pixi.js/lib/rendering/batcher/gpu/BatchGeometry.mjs"() {
      init_Buffer();
      init_const3();
      init_Geometry();
      placeHolderBufferData = new Float32Array(1);
      placeHolderIndexData = new Uint32Array(1);
      BatchGeometry = class extends Geometry {
        constructor() {
          const vertexSize = 6;
          const attributeBuffer = new Buffer2({
            data: placeHolderBufferData,
            label: "attribute-batch-buffer",
            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,
            shrinkToFit: false
          });
          const indexBuffer = new Buffer2({
            data: placeHolderIndexData,
            label: "index-batch-buffer",
            usage: BufferUsage.INDEX | BufferUsage.COPY_DST,
            // | BufferUsage.STATIC,
            shrinkToFit: false
          });
          const stride = vertexSize * 4;
          super({
            attributes: {
              aPosition: {
                buffer: attributeBuffer,
                format: "float32x2",
                stride,
                offset: 0,
                location: 1
              },
              aUV: {
                buffer: attributeBuffer,
                format: "float32x2",
                stride,
                offset: 2 * 4,
                location: 3
              },
              aColor: {
                buffer: attributeBuffer,
                format: "unorm8x4",
                stride,
                offset: 4 * 4,
                location: 0
              },
              aTextureIdAndRound: {
                buffer: attributeBuffer,
                format: "uint16x2",
                stride,
                offset: 5 * 4,
                location: 2
              }
            },
            indexBuffer
          });
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs
  var BindGroup;
  var init_BindGroup = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs"() {
      "use strict";
      BindGroup = class {
        /**
         * Create a new instance eof the Bind Group.
         * @param resources - The resources that are bound together for use by a shader.
         */
        constructor(resources) {
          this.resources = /* @__PURE__ */ Object.create(null);
          this._dirty = true;
          let index = 0;
          for (const i2 in resources) {
            const resource = resources[i2];
            this.setResource(resource, index++);
          }
          this._updateKey();
        }
        /**
         * Updates the key if its flagged as dirty. This is used internally to
         * match this bind group to a WebGPU BindGroup.
         * @internal
         * @ignore
         */
        _updateKey() {
          if (!this._dirty)
            return;
          this._dirty = false;
          const keyParts = [];
          let index = 0;
          for (const i2 in this.resources) {
            keyParts[index++] = this.resources[i2]._resourceId;
          }
          this._key = keyParts.join("|");
        }
        /**
         * Set a resource at a given index. this function will
         * ensure that listeners will be removed from the current resource
         * and added to the new resource.
         * @param resource - The resource to set.
         * @param index - The index to set the resource at.
         */
        setResource(resource, index) {
          const currentResource = this.resources[index];
          if (resource === currentResource)
            return;
          if (currentResource) {
            resource.off?.("change", this.onResourceChange, this);
          }
          resource.on?.("change", this.onResourceChange, this);
          this.resources[index] = resource;
          this._dirty = true;
        }
        /**
         * Returns the resource at the current specified index.
         * @param index - The index of the resource to get.
         * @returns - The resource at the specified index.
         */
        getResource(index) {
          return this.resources[index];
        }
        /**
         * Used internally to 'touch' each resource, to ensure that the GC
         * knows that all resources in this bind group are still being used.
         * @param tick - The current tick.
         * @internal
         * @ignore
         */
        _touch(tick2) {
          const resources = this.resources;
          for (const i2 in resources) {
            resources[i2]._touched = tick2;
          }
        }
        /** Destroys this bind group and removes all listeners. */
        destroy() {
          const resources = this.resources;
          for (const i2 in resources) {
            const resource = resources[i2];
            resource.off?.("change", this.onResourceChange, this);
          }
          this.resources = null;
        }
        onResourceChange(resource) {
          this._dirty = true;
          if (resource.destroyed) {
            const resources = this.resources;
            for (const i2 in resources) {
              if (resources[i2] === resource) {
                resources[i2] = null;
              }
            }
          } else {
            this._updateKey();
          }
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/batcher/shared/const.mjs
  var MAX_TEXTURES;
  var init_const4 = __esm({
    "../core/node_modules/pixi.js/lib/rendering/batcher/shared/const.mjs"() {
      "use strict";
      MAX_TEXTURES = 16;
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs
  function getTextureBatchBindGroup(textures, size) {
    let uid3 = 0;
    for (let i2 = 0; i2 < size; i2++) {
      uid3 = uid3 * 31 + textures[i2].uid >>> 0;
    }
    return cachedGroups[uid3] || generateTextureBatchBindGroup(textures, uid3);
  }
  function generateTextureBatchBindGroup(textures, key) {
    const bindGroupResources = {};
    let bindIndex = 0;
    for (let i2 = 0; i2 < MAX_TEXTURES; i2++) {
      const texture = i2 < textures.length ? textures[i2] : Texture.EMPTY.source;
      bindGroupResources[bindIndex++] = texture.source;
      bindGroupResources[bindIndex++] = texture.style;
    }
    const bindGroup = new BindGroup(bindGroupResources);
    cachedGroups[key] = bindGroup;
    return bindGroup;
  }
  var cachedGroups;
  var init_getTextureBatchBindGroup = __esm({
    "../core/node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs"() {
      init_BindGroup();
      init_Texture();
      init_const4();
      cachedGroups = {};
    }
  });

  // ../core/node_modules/pixi.js/lib/utils/data/ViewableBuffer.mjs
  var ViewableBuffer;
  var init_ViewableBuffer = __esm({
    "../core/node_modules/pixi.js/lib/utils/data/ViewableBuffer.mjs"() {
      "use strict";
      ViewableBuffer = class {
        constructor(sizeOrBuffer) {
          if (typeof sizeOrBuffer === "number") {
            this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);
          } else if (sizeOrBuffer instanceof Uint8Array) {
            this.rawBinaryData = sizeOrBuffer.buffer;
          } else {
            this.rawBinaryData = sizeOrBuffer;
          }
          this.uint32View = new Uint32Array(this.rawBinaryData);
          this.float32View = new Float32Array(this.rawBinaryData);
          this.size = this.rawBinaryData.byteLength;
        }
        /** View on the raw binary data as a `Int8Array`. */
        get int8View() {
          if (!this._int8View) {
            this._int8View = new Int8Array(this.rawBinaryData);
          }
          return this._int8View;
        }
        /** View on the raw binary data as a `Uint8Array`. */
        get uint8View() {
          if (!this._uint8View) {
            this._uint8View = new Uint8Array(this.rawBinaryData);
          }
          return this._uint8View;
        }
        /**  View on the raw binary data as a `Int16Array`. */
        get int16View() {
          if (!this._int16View) {
            this._int16View = new Int16Array(this.rawBinaryData);
          }
          return this._int16View;
        }
        /** View on the raw binary data as a `Int32Array`. */
        get int32View() {
          if (!this._int32View) {
            this._int32View = new Int32Array(this.rawBinaryData);
          }
          return this._int32View;
        }
        /** View on the raw binary data as a `Float64Array`. */
        get float64View() {
          if (!this._float64Array) {
            this._float64Array = new Float64Array(this.rawBinaryData);
          }
          return this._float64Array;
        }
        /** View on the raw binary data as a `BigUint64Array`. */
        get bigUint64View() {
          if (!this._bigUint64Array) {
            this._bigUint64Array = new BigUint64Array(this.rawBinaryData);
          }
          return this._bigUint64Array;
        }
        /**
         * Returns the view of the given type.
         * @param type - One of `int8`, `uint8`, `int16`,
         *    `uint16`, `int32`, `uint32`, and `float32`.
         * @returns - typed array of given type
         */
        view(type) {
          return this[`${type}View`];
        }
        /** Destroys all buffer references. Do not use after calling this. */
        destroy() {
          this.rawBinaryData = null;
          this._int8View = null;
          this._uint8View = null;
          this._int16View = null;
          this.uint16View = null;
          this._int32View = null;
          this.uint32View = null;
          this.float32View = null;
        }
        /**
         * Returns the size of the given type in bytes.
         * @param type - One of `int8`, `uint8`, `int16`,
         *   `uint16`, `int32`, `uint32`, and `float32`.
         * @returns - size of the type in bytes
         */
        static sizeOf(type) {
          switch (type) {
            case "int8":
            case "uint8":
              return 1;
            case "int16":
            case "uint16":
              return 2;
            case "int32":
            case "uint32":
            case "float32":
              return 4;
            default:
              throw new Error(`${type} isn't a valid view type`);
          }
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs
  function fastCopy(sourceBuffer, destinationBuffer) {
    const lengthDouble = sourceBuffer.byteLength / 8 | 0;
    const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);
    const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);
    destinationFloat64View.set(sourceFloat64View);
    const remainingBytes = sourceBuffer.byteLength - lengthDouble * 8;
    if (remainingBytes > 0) {
      const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8, remainingBytes);
      const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8, remainingBytes);
      destinationUint8View.set(sourceUint8View);
    }
  }
  var init_fastCopy = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs
  var BLEND_TO_NPM, STENCIL_MODES;
  var init_const5 = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs"() {
      "use strict";
      BLEND_TO_NPM = {
        normal: "normal-npm",
        add: "add-npm",
        screen: "screen-npm"
      };
      STENCIL_MODES = /* @__PURE__ */ ((STENCIL_MODES2) => {
        STENCIL_MODES2[STENCIL_MODES2["DISABLED"] = 0] = "DISABLED";
        STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_ADD"] = 1] = "RENDERING_MASK_ADD";
        STENCIL_MODES2[STENCIL_MODES2["MASK_ACTIVE"] = 2] = "MASK_ACTIVE";
        STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_REMOVE"] = 3] = "RENDERING_MASK_REMOVE";
        STENCIL_MODES2[STENCIL_MODES2["NONE"] = 4] = "NONE";
        return STENCIL_MODES2;
      })(STENCIL_MODES || {});
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs
  function getAdjustedBlendModeBlend(blendMode, textureSource) {
    if (textureSource.alphaMode === "no-premultiply-alpha") {
      return BLEND_TO_NPM[blendMode] || blendMode;
    }
    return blendMode;
  }
  var init_getAdjustedBlendModeBlend = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs"() {
      init_const5();
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.mjs
  var BatchTextureArray;
  var init_BatchTextureArray = __esm({
    "../core/node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.mjs"() {
      "use strict";
      BatchTextureArray = class {
        constructor() {
          this.ids = /* @__PURE__ */ Object.create(null);
          this.textures = [];
          this.count = 0;
        }
        /** Clear the textures and their locations. */
        clear() {
          for (let i2 = 0; i2 < this.count; i2++) {
            const t2 = this.textures[i2];
            this.textures[i2] = null;
            this.ids[t2.uid] = null;
          }
          this.count = 0;
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs
  var Batch, BATCH_TICK, _Batcher, Batcher;
  var init_Batcher = __esm({
    "../core/node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs"() {
      init_uid();
      init_ViewableBuffer();
      init_fastCopy();
      init_getAdjustedBlendModeBlend();
      init_BatchTextureArray();
      init_const4();
      Batch = class {
        constructor() {
          this.renderPipeId = "batch";
          this.action = "startBatch";
          this.start = 0;
          this.size = 0;
          this.blendMode = "normal";
          this.canBundle = true;
        }
        destroy() {
          this.textures = null;
          this.gpuBindGroup = null;
          this.bindGroup = null;
          this.batcher = null;
        }
      };
      BATCH_TICK = 0;
      _Batcher = class _Batcher2 {
        constructor(options = {}) {
          this.uid = uid("batcher");
          this.dirty = true;
          this.batchIndex = 0;
          this.batches = [];
          this._vertexSize = 6;
          this._elements = [];
          this._batchPool = [];
          this._batchPoolIndex = 0;
          this._textureBatchPool = [];
          this._textureBatchPoolIndex = 0;
          options = { ..._Batcher2.defaultOptions, ...options };
          const { vertexSize, indexSize } = options;
          this.attributeBuffer = new ViewableBuffer(vertexSize * this._vertexSize * 4);
          this.indexBuffer = new Uint16Array(indexSize);
        }
        begin() {
          this.batchIndex = 0;
          this.elementSize = 0;
          this.elementStart = 0;
          this.indexSize = 0;
          this.attributeSize = 0;
          this._batchPoolIndex = 0;
          this._textureBatchPoolIndex = 0;
          this._batchIndexStart = 0;
          this._batchIndexSize = 0;
          this.dirty = true;
        }
        add(batchableObject) {
          this._elements[this.elementSize++] = batchableObject;
          batchableObject.indexStart = this.indexSize;
          batchableObject.location = this.attributeSize;
          batchableObject.batcher = this;
          this.indexSize += batchableObject.indexSize;
          this.attributeSize += batchableObject.vertexSize * this._vertexSize;
        }
        checkAndUpdateTexture(batchableObject, texture) {
          const textureId = batchableObject.batch.textures.ids[texture._source.uid];
          if (!textureId && textureId !== 0)
            return false;
          batchableObject.textureId = textureId;
          batchableObject.texture = texture;
          return true;
        }
        updateElement(batchableObject) {
          this.dirty = true;
          batchableObject.packAttributes(
            this.attributeBuffer.float32View,
            this.attributeBuffer.uint32View,
            batchableObject.location,
            batchableObject.textureId
          );
        }
        /**
         * breaks the batcher. This happens when a batch gets too big,
         * or we need to switch to a different type of rendering (a filter for example)
         * @param instructionSet
         */
        break(instructionSet) {
          const elements = this._elements;
          let textureBatch = this._textureBatchPool[this._textureBatchPoolIndex++] || new BatchTextureArray();
          textureBatch.clear();
          if (!elements[this.elementStart])
            return;
          const firstElement = elements[this.elementStart];
          let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);
          if (this.attributeSize * 4 > this.attributeBuffer.size) {
            this._resizeAttributeBuffer(this.attributeSize * 4);
          }
          if (this.indexSize > this.indexBuffer.length) {
            this._resizeIndexBuffer(this.indexSize);
          }
          const f32 = this.attributeBuffer.float32View;
          const u32 = this.attributeBuffer.uint32View;
          const iBuffer = this.indexBuffer;
          let size = this._batchIndexSize;
          let start = this._batchIndexStart;
          let action = "startBatch";
          let batch = this._batchPool[this._batchPoolIndex++] || new Batch();
          for (let i2 = this.elementStart; i2 < this.elementSize; ++i2) {
            const element2 = elements[i2];
            elements[i2] = null;
            const texture = element2.texture;
            const source2 = texture._source;
            const adjustedBlendMode = getAdjustedBlendModeBlend(element2.blendMode, source2);
            const blendModeChange = blendMode !== adjustedBlendMode;
            if (source2._batchTick === BATCH_TICK && !blendModeChange) {
              element2.textureId = source2._textureBindLocation;
              size += element2.indexSize;
              element2.packAttributes(f32, u32, element2.location, element2.textureId);
              element2.packIndex(iBuffer, element2.indexStart, element2.location / this._vertexSize);
              element2.batch = batch;
              continue;
            }
            source2._batchTick = BATCH_TICK;
            if (textureBatch.count >= MAX_TEXTURES || blendModeChange) {
              this._finishBatch(
                batch,
                start,
                size - start,
                textureBatch,
                blendMode,
                instructionSet,
                action
              );
              action = "renderBatch";
              start = size;
              blendMode = adjustedBlendMode;
              textureBatch = this._textureBatchPool[this._textureBatchPoolIndex++] || new BatchTextureArray();
              textureBatch.clear();
              batch = this._batchPool[this._batchPoolIndex++] || new Batch();
              ++BATCH_TICK;
            }
            element2.textureId = source2._textureBindLocation = textureBatch.count;
            textureBatch.ids[source2.uid] = textureBatch.count;
            textureBatch.textures[textureBatch.count++] = source2;
            element2.batch = batch;
            size += element2.indexSize;
            element2.packAttributes(f32, u32, element2.location, element2.textureId);
            element2.packIndex(iBuffer, element2.indexStart, element2.location / this._vertexSize);
          }
          if (textureBatch.count > 0) {
            this._finishBatch(
              batch,
              start,
              size - start,
              textureBatch,
              blendMode,
              instructionSet,
              action
            );
            start = size;
            ++BATCH_TICK;
          }
          this.elementStart = this.elementSize;
          this._batchIndexStart = start;
          this._batchIndexSize = size;
        }
        _finishBatch(batch, indexStart, indexSize, textureBatch, blendMode, instructionSet, action) {
          batch.gpuBindGroup = null;
          batch.action = action;
          batch.batcher = this;
          batch.textures = textureBatch;
          batch.blendMode = blendMode;
          batch.start = indexStart;
          batch.size = indexSize;
          ++BATCH_TICK;
          instructionSet.add(batch);
        }
        finish(instructionSet) {
          this.break(instructionSet);
        }
        /**
         * Resizes the attribute buffer to the given size (1 = 1 float32)
         * @param size - the size in vertices to ensure (not bytes!)
         */
        ensureAttributeBuffer(size) {
          if (size * 4 <= this.attributeBuffer.size)
            return;
          this._resizeAttributeBuffer(size * 4);
        }
        /**
         * Resizes the index buffer to the given size (1 = 1 float32)
         * @param size - the size in vertices to ensure (not bytes!)
         */
        ensureIndexBuffer(size) {
          if (size <= this.indexBuffer.length)
            return;
          this._resizeIndexBuffer(size);
        }
        _resizeAttributeBuffer(size) {
          const newSize = Math.max(size, this.attributeBuffer.size * 2);
          const newArrayBuffer = new ViewableBuffer(newSize);
          fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);
          this.attributeBuffer = newArrayBuffer;
        }
        _resizeIndexBuffer(size) {
          const indexBuffer = this.indexBuffer;
          let newSize = Math.max(size, indexBuffer.length * 1.5);
          newSize += newSize % 2;
          const newIndexBuffer = newSize > 65535 ? new Uint32Array(newSize) : new Uint16Array(newSize);
          if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT) {
            for (let i2 = 0; i2 < indexBuffer.length; i2++) {
              newIndexBuffer[i2] = indexBuffer[i2];
            }
          } else {
            fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);
          }
          this.indexBuffer = newIndexBuffer;
        }
        destroy() {
          for (let i2 = 0; i2 < this.batches.length; i2++) {
            this.batches[i2].destroy();
          }
          this.batches = null;
          for (let i2 = 0; i2 < this._elements.length; i2++) {
            this._elements[i2].batch = null;
          }
          this._elements = null;
          this.indexBuffer = null;
          this.attributeBuffer.destroy();
          this.attributeBuffer = null;
        }
      };
      _Batcher.defaultOptions = {
        vertexSize: 4,
        indexSize: 6
      };
      Batcher = _Batcher;
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs
  function buildUvs(vertices, verticesStride, verticesOffset, uvs, uvsOffset, uvsStride, size, matrix = null) {
    let index = 0;
    verticesOffset *= verticesStride;
    uvsOffset *= uvsStride;
    const a2 = matrix.a;
    const b2 = matrix.b;
    const c2 = matrix.c;
    const d2 = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    while (index < size) {
      const x2 = vertices[verticesOffset];
      const y2 = vertices[verticesOffset + 1];
      uvs[uvsOffset] = a2 * x2 + c2 * y2 + tx;
      uvs[uvsOffset + 1] = b2 * x2 + d2 * y2 + ty;
      uvsOffset += uvsStride;
      verticesOffset += verticesStride;
      index++;
    }
  }
  function buildSimpleUvs(uvs, uvsOffset, uvsStride, size) {
    let index = 0;
    uvsOffset *= uvsStride;
    while (index < size) {
      uvs[uvsOffset] = 0;
      uvs[uvsOffset + 1] = 0;
      uvsOffset += uvsStride;
      index++;
    }
  }
  var init_buildUvs = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs
  function transformVertices(vertices, m2, offset, stride, size) {
    const a2 = m2.a;
    const b2 = m2.b;
    const c2 = m2.c;
    const d2 = m2.d;
    const tx = m2.tx;
    const ty = m2.ty;
    offset = offset || 0;
    stride = stride || 2;
    size = size || vertices.length / stride - offset;
    let index = offset * stride;
    for (let i2 = 0; i2 < size; i2++) {
      const x2 = vertices[index];
      const y2 = vertices[index + 1];
      vertices[index] = a2 * x2 + c2 * y2 + tx;
      vertices[index + 1] = b2 * x2 + d2 * y2 + ty;
      index += stride;
    }
  }
  var init_transformVertices = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/container/utils/multiplyHexColors.mjs
  function multiplyHexColors(color1, color22) {
    if (color1 === 16777215 || !color22)
      return color22;
    if (color22 === 16777215 || !color1)
      return color1;
    const r1 = color1 >> 16 & 255;
    const g1 = color1 >> 8 & 255;
    const b1 = color1 & 255;
    const r2 = color22 >> 16 & 255;
    const g2 = color22 >> 8 & 255;
    const b2 = color22 & 255;
    const r3 = r1 * r2 / 255;
    const g3 = g1 * g2 / 255;
    const b3 = b1 * b2 / 255;
    return (r3 << 16) + (g3 << 8) + b3;
  }
  var init_multiplyHexColors = __esm({
    "../core/node_modules/pixi.js/lib/scene/container/utils/multiplyHexColors.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs
  var BatchableGraphics;
  var init_BatchableGraphics = __esm({
    "../core/node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs"() {
      init_multiplyHexColors();
      BatchableGraphics = class {
        constructor() {
          this.batcher = null;
          this.batch = null;
          this.applyTransform = true;
          this.roundPixels = 0;
        }
        get blendMode() {
          if (this.applyTransform) {
            return this.renderable.groupBlendMode;
          }
          return "normal";
        }
        packIndex(indexBuffer, index, indicesOffset) {
          const indices = this.geometryData.indices;
          for (let i2 = 0; i2 < this.indexSize; i2++) {
            indexBuffer[index++] = indices[i2 + this.indexOffset] + indicesOffset - this.vertexOffset;
          }
        }
        packAttributes(float32View, uint32View, index, textureId) {
          const geometry = this.geometryData;
          const graphics = this.renderable;
          const positions = geometry.vertices;
          const uvs = geometry.uvs;
          const offset = this.vertexOffset * 2;
          const vertSize = (this.vertexOffset + this.vertexSize) * 2;
          const rgb = this.color;
          const bgr = rgb >> 16 | rgb & 65280 | (rgb & 255) << 16;
          if (this.applyTransform) {
            const argb = multiplyHexColors(bgr, graphics.groupColor) + (this.alpha * graphics.groupAlpha * 255 << 24);
            const wt = graphics.groupTransform;
            const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;
            const a2 = wt.a;
            const b2 = wt.b;
            const c2 = wt.c;
            const d2 = wt.d;
            const tx = wt.tx;
            const ty = wt.ty;
            for (let i2 = offset; i2 < vertSize; i2 += 2) {
              const x2 = positions[i2];
              const y2 = positions[i2 + 1];
              float32View[index] = a2 * x2 + c2 * y2 + tx;
              float32View[index + 1] = b2 * x2 + d2 * y2 + ty;
              float32View[index + 2] = uvs[i2];
              float32View[index + 3] = uvs[i2 + 1];
              uint32View[index + 4] = argb;
              uint32View[index + 5] = textureIdAndRound;
              index += 6;
            }
          } else {
            const argb = bgr + (this.alpha * 255 << 24);
            for (let i2 = offset; i2 < vertSize; i2 += 2) {
              float32View[index] = positions[i2];
              float32View[index + 1] = positions[i2 + 1];
              float32View[index + 2] = uvs[i2];
              float32View[index + 3] = uvs[i2 + 1];
              uint32View[index + 4] = argb;
              uint32View[index + 5] = textureId << 16;
              index += 6;
            }
          }
        }
        // TODO rename to vertexSize
        get vertSize() {
          return this.vertexSize;
        }
        copyTo(gpuBuffer) {
          gpuBuffer.indexOffset = this.indexOffset;
          gpuBuffer.indexSize = this.indexSize;
          gpuBuffer.vertexOffset = this.vertexOffset;
          gpuBuffer.vertexSize = this.vertexSize;
          gpuBuffer.color = this.color;
          gpuBuffer.alpha = this.alpha;
          gpuBuffer.texture = this.texture;
          gpuBuffer.geometryData = this.geometryData;
        }
        reset() {
          this.applyTransform = true;
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.mjs
  var buildCircle;
  var init_buildCircle = __esm({
    "../core/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.mjs"() {
      "use strict";
      buildCircle = {
        build(shape, points) {
          let x2;
          let y2;
          let dx;
          let dy;
          let rx;
          let ry;
          if (shape.type === "circle") {
            const circle = shape;
            x2 = circle.x;
            y2 = circle.y;
            rx = ry = circle.radius;
            dx = dy = 0;
          } else if (shape.type === "ellipse") {
            const ellipse = shape;
            x2 = ellipse.x;
            y2 = ellipse.y;
            rx = ellipse.halfWidth;
            ry = ellipse.halfHeight;
            dx = dy = 0;
          } else {
            const roundedRect = shape;
            const halfWidth = roundedRect.width / 2;
            const halfHeight = roundedRect.height / 2;
            x2 = roundedRect.x + halfWidth;
            y2 = roundedRect.y + halfHeight;
            rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));
            dx = halfWidth - rx;
            dy = halfHeight - ry;
          }
          if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {
            return points;
          }
          const n2 = Math.ceil(2.3 * Math.sqrt(rx + ry));
          const m2 = n2 * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);
          if (m2 === 0) {
            return points;
          }
          if (n2 === 0) {
            points[0] = points[6] = x2 + dx;
            points[1] = points[3] = y2 + dy;
            points[2] = points[4] = x2 - dx;
            points[5] = points[7] = y2 - dy;
            return points;
          }
          let j1 = 0;
          let j2 = n2 * 4 + (dx ? 2 : 0) + 2;
          let j3 = j2;
          let j4 = m2;
          let x0 = dx + rx;
          let y0 = dy;
          let x1 = x2 + x0;
          let x22 = x2 - x0;
          let y1 = y2 + y0;
          points[j1++] = x1;
          points[j1++] = y1;
          points[--j2] = y1;
          points[--j2] = x22;
          if (dy) {
            const y222 = y2 - y0;
            points[j3++] = x22;
            points[j3++] = y222;
            points[--j4] = y222;
            points[--j4] = x1;
          }
          for (let i2 = 1; i2 < n2; i2++) {
            const a2 = Math.PI / 2 * (i2 / n2);
            const x02 = dx + Math.cos(a2) * rx;
            const y02 = dy + Math.sin(a2) * ry;
            const x12 = x2 + x02;
            const x222 = x2 - x02;
            const y12 = y2 + y02;
            const y222 = y2 - y02;
            points[j1++] = x12;
            points[j1++] = y12;
            points[--j2] = y12;
            points[--j2] = x222;
            points[j3++] = x222;
            points[j3++] = y222;
            points[--j4] = y222;
            points[--j4] = x12;
          }
          x0 = dx;
          y0 = dy + ry;
          x1 = x2 + x0;
          x22 = x2 - x0;
          y1 = y2 + y0;
          const y22 = y2 - y0;
          points[j1++] = x1;
          points[j1++] = y1;
          points[--j4] = y22;
          points[--j4] = x1;
          if (dx) {
            points[j1++] = x22;
            points[j1++] = y1;
            points[--j4] = y22;
            points[--j4] = x22;
          }
          return points;
        },
        triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
          if (points.length === 0) {
            return;
          }
          let centerX = 0;
          let centerY = 0;
          for (let i2 = 0; i2 < points.length; i2 += 2) {
            centerX += points[i2];
            centerY += points[i2 + 1];
          }
          centerX /= points.length / 2;
          centerY /= points.length / 2;
          let count2 = verticesOffset;
          vertices[count2 * verticesStride] = centerX;
          vertices[count2 * verticesStride + 1] = centerY;
          const centerIndex = count2++;
          for (let i2 = 0; i2 < points.length; i2 += 2) {
            vertices[count2 * verticesStride] = points[i2];
            vertices[count2 * verticesStride + 1] = points[i2 + 1];
            if (i2 > 0) {
              indices[indicesOffset++] = count2;
              indices[indicesOffset++] = centerIndex;
              indices[indicesOffset++] = count2 - 1;
            }
            count2++;
          }
          indices[indicesOffset++] = centerIndex + 1;
          indices[indicesOffset++] = centerIndex;
          indices[indicesOffset++] = count2 - 1;
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/graphics/shared/const.mjs
  var closePointEps, curveEps;
  var init_const6 = __esm({
    "../core/node_modules/pixi.js/lib/scene/graphics/shared/const.mjs"() {
      "use strict";
      closePointEps = 1e-4;
      curveEps = 1e-4;
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.mjs
  function getOrientationOfPoints(points) {
    const m2 = points.length;
    if (m2 < 6) {
      return 1;
    }
    let area = 0;
    for (let i2 = 0, x1 = points[m2 - 2], y1 = points[m2 - 1]; i2 < m2; i2 += 2) {
      const x2 = points[i2];
      const y2 = points[i2 + 1];
      area += (x2 - x1) * (y2 + y1);
      x1 = x2;
      y1 = y2;
    }
    if (area < 0) {
      return -1;
    }
    return 1;
  }
  var init_getOrientationOfPoints = __esm({
    "../core/node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.mjs
  function square(x2, y2, nx, ny, innerWeight, outerWeight, clockwise, verts) {
    const ix = x2 - nx * innerWeight;
    const iy = y2 - ny * innerWeight;
    const ox = x2 + nx * outerWeight;
    const oy = y2 + ny * outerWeight;
    let exx;
    let eyy;
    if (clockwise) {
      exx = ny;
      eyy = -nx;
    } else {
      exx = -ny;
      eyy = nx;
    }
    const eix = ix + exx;
    const eiy = iy + eyy;
    const eox = ox + exx;
    const eoy = oy + eyy;
    verts.push(eix, eiy);
    verts.push(eox, eoy);
    return 2;
  }
  function round(cx, cy, sx, sy, ex, ey, verts, clockwise) {
    const cx2p0x = sx - cx;
    const cy2p0y = sy - cy;
    let angle0 = Math.atan2(cx2p0x, cy2p0y);
    let angle1 = Math.atan2(ex - cx, ey - cy);
    if (clockwise && angle0 < angle1) {
      angle0 += Math.PI * 2;
    } else if (!clockwise && angle0 > angle1) {
      angle1 += Math.PI * 2;
    }
    let startAngle = angle0;
    const angleDiff = angle1 - angle0;
    const absAngleDiff = Math.abs(angleDiff);
    const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);
    const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;
    const angleInc = angleDiff / segCount;
    startAngle += angleInc;
    if (clockwise) {
      verts.push(cx, cy);
      verts.push(sx, sy);
      for (let i2 = 1, angle = startAngle; i2 < segCount; i2++, angle += angleInc) {
        verts.push(cx, cy);
        verts.push(
          cx + Math.sin(angle) * radius,
          cy + Math.cos(angle) * radius
        );
      }
      verts.push(cx, cy);
      verts.push(ex, ey);
    } else {
      verts.push(sx, sy);
      verts.push(cx, cy);
      for (let i2 = 1, angle = startAngle; i2 < segCount; i2++, angle += angleInc) {
        verts.push(
          cx + Math.sin(angle) * radius,
          cy + Math.cos(angle) * radius
        );
        verts.push(cx, cy);
      }
      verts.push(ex, ey);
      verts.push(cx, cy);
    }
    return segCount * 2;
  }
  function buildLine(points, lineStyle, flipAlignment, closed, vertices, _verticesStride, _verticesOffset, indices, _indicesOffset) {
    const eps = closePointEps;
    if (points.length === 0) {
      return;
    }
    const style = lineStyle;
    let alignment = style.alignment;
    if (lineStyle.alignment !== 0.5) {
      let orientation = getOrientationOfPoints(points);
      if (flipAlignment)
        orientation *= -1;
      alignment = (alignment - 0.5) * orientation + 0.5;
    }
    const firstPoint = new Point(points[0], points[1]);
    const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);
    const closedShape = closed;
    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
    if (closedShape) {
      points = points.slice();
      if (closedPath) {
        points.pop();
        points.pop();
        lastPoint.set(points[points.length - 2], points[points.length - 1]);
      }
      const midPointX = (firstPoint.x + lastPoint.x) * 0.5;
      const midPointY = (lastPoint.y + firstPoint.y) * 0.5;
      points.unshift(midPointX, midPointY);
      points.push(midPointX, midPointY);
    }
    const verts = vertices;
    const length = points.length / 2;
    let indexCount = points.length;
    const indexStart = verts.length / 2;
    const width = style.width / 2;
    const widthSquared = width * width;
    const miterLimitSquared = style.miterLimit * style.miterLimit;
    let x0 = points[0];
    let y0 = points[1];
    let x1 = points[2];
    let y1 = points[3];
    let x2 = 0;
    let y2 = 0;
    let perpX = -(y0 - y1);
    let perpY = x0 - x1;
    let perp1x = 0;
    let perp1y = 0;
    let dist = Math.sqrt(perpX * perpX + perpY * perpY);
    perpX /= dist;
    perpY /= dist;
    perpX *= width;
    perpY *= width;
    const ratio = alignment;
    const innerWeight = (1 - ratio) * 2;
    const outerWeight = ratio * 2;
    if (!closedShape) {
      if (style.cap === "round") {
        indexCount += round(
          x0 - perpX * (innerWeight - outerWeight) * 0.5,
          y0 - perpY * (innerWeight - outerWeight) * 0.5,
          x0 - perpX * innerWeight,
          y0 - perpY * innerWeight,
          x0 + perpX * outerWeight,
          y0 + perpY * outerWeight,
          verts,
          true
        ) + 2;
      } else if (style.cap === "square") {
        indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);
      }
    }
    verts.push(
      x0 - perpX * innerWeight,
      y0 - perpY * innerWeight
    );
    verts.push(
      x0 + perpX * outerWeight,
      y0 + perpY * outerWeight
    );
    for (let i2 = 1; i2 < length - 1; ++i2) {
      x0 = points[(i2 - 1) * 2];
      y0 = points[(i2 - 1) * 2 + 1];
      x1 = points[i2 * 2];
      y1 = points[i2 * 2 + 1];
      x2 = points[(i2 + 1) * 2];
      y2 = points[(i2 + 1) * 2 + 1];
      perpX = -(y0 - y1);
      perpY = x0 - x1;
      dist = Math.sqrt(perpX * perpX + perpY * perpY);
      perpX /= dist;
      perpY /= dist;
      perpX *= width;
      perpY *= width;
      perp1x = -(y1 - y2);
      perp1y = x1 - x2;
      dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);
      perp1x /= dist;
      perp1y /= dist;
      perp1x *= width;
      perp1y *= width;
      const dx0 = x1 - x0;
      const dy0 = y0 - y1;
      const dx1 = x1 - x2;
      const dy1 = y2 - y1;
      const dot = dx0 * dx1 + dy0 * dy1;
      const cross = dy0 * dx1 - dy1 * dx0;
      const clockwise = cross < 0;
      if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {
        verts.push(
          x1 - perpX * innerWeight,
          y1 - perpY * innerWeight
        );
        verts.push(
          x1 + perpX * outerWeight,
          y1 + perpY * outerWeight
        );
        if (dot >= 0) {
          if (style.join === "round") {
            indexCount += round(
              x1,
              y1,
              x1 - perpX * innerWeight,
              y1 - perpY * innerWeight,
              x1 - perp1x * innerWeight,
              y1 - perp1y * innerWeight,
              verts,
              false
            ) + 4;
          } else {
            indexCount += 2;
          }
          verts.push(
            x1 - perp1x * outerWeight,
            y1 - perp1y * outerWeight
          );
          verts.push(
            x1 + perp1x * innerWeight,
            y1 + perp1y * innerWeight
          );
        }
        continue;
      }
      const c1 = (-perpX + x0) * (-perpY + y1) - (-perpX + x1) * (-perpY + y0);
      const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);
      const px = (dx0 * c2 - dx1 * c1) / cross;
      const py = (dy1 * c1 - dy0 * c2) / cross;
      const pDist = (px - x1) * (px - x1) + (py - y1) * (py - y1);
      const imx = x1 + (px - x1) * innerWeight;
      const imy = y1 + (py - y1) * innerWeight;
      const omx = x1 - (px - x1) * outerWeight;
      const omy = y1 - (py - y1) * outerWeight;
      const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);
      const insideWeight = clockwise ? innerWeight : outerWeight;
      const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;
      const insideMiterOk = pDist <= smallerInsideDiagonalSq;
      if (insideMiterOk) {
        if (style.join === "bevel" || pDist / widthSquared > miterLimitSquared) {
          if (clockwise) {
            verts.push(imx, imy);
            verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
            verts.push(imx, imy);
            verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          } else {
            verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
            verts.push(omx, omy);
            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
            verts.push(omx, omy);
          }
          indexCount += 2;
        } else if (style.join === "round") {
          if (clockwise) {
            verts.push(imx, imy);
            verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
            indexCount += round(
              x1,
              y1,
              x1 + perpX * outerWeight,
              y1 + perpY * outerWeight,
              x1 + perp1x * outerWeight,
              y1 + perp1y * outerWeight,
              verts,
              true
            ) + 4;
            verts.push(imx, imy);
            verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          } else {
            verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
            verts.push(omx, omy);
            indexCount += round(
              x1,
              y1,
              x1 - perpX * innerWeight,
              y1 - perpY * innerWeight,
              x1 - perp1x * innerWeight,
              y1 - perp1y * innerWeight,
              verts,
              false
            ) + 4;
            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
            verts.push(omx, omy);
          }
        } else {
          verts.push(imx, imy);
          verts.push(omx, omy);
        }
      } else {
        verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
        verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
        if (style.join === "round") {
          if (clockwise) {
            indexCount += round(
              x1,
              y1,
              x1 + perpX * outerWeight,
              y1 + perpY * outerWeight,
              x1 + perp1x * outerWeight,
              y1 + perp1y * outerWeight,
              verts,
              true
            ) + 2;
          } else {
            indexCount += round(
              x1,
              y1,
              x1 - perpX * innerWeight,
              y1 - perpY * innerWeight,
              x1 - perp1x * innerWeight,
              y1 - perp1y * innerWeight,
              verts,
              false
            ) + 2;
          }
        } else if (style.join === "miter" && pDist / widthSquared <= miterLimitSquared) {
          if (clockwise) {
            verts.push(omx, omy);
            verts.push(omx, omy);
          } else {
            verts.push(imx, imy);
            verts.push(imx, imy);
          }
          indexCount += 2;
        }
        verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
        verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        indexCount += 2;
      }
    }
    x0 = points[(length - 2) * 2];
    y0 = points[(length - 2) * 2 + 1];
    x1 = points[(length - 1) * 2];
    y1 = points[(length - 1) * 2 + 1];
    perpX = -(y0 - y1);
    perpY = x0 - x1;
    dist = Math.sqrt(perpX * perpX + perpY * perpY);
    perpX /= dist;
    perpY /= dist;
    perpX *= width;
    perpY *= width;
    verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
    verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
    if (!closedShape) {
      if (style.cap === "round") {
        indexCount += round(
          x1 - perpX * (innerWeight - outerWeight) * 0.5,
          y1 - perpY * (innerWeight - outerWeight) * 0.5,
          x1 - perpX * innerWeight,
          y1 - perpY * innerWeight,
          x1 + perpX * outerWeight,
          y1 + perpY * outerWeight,
          verts,
          false
        ) + 2;
      } else if (style.cap === "square") {
        indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);
      }
    }
    const eps2 = curveEps * curveEps;
    for (let i2 = indexStart; i2 < indexCount + indexStart - 2; ++i2) {
      x0 = verts[i2 * 2];
      y0 = verts[i2 * 2 + 1];
      x1 = verts[(i2 + 1) * 2];
      y1 = verts[(i2 + 1) * 2 + 1];
      x2 = verts[(i2 + 2) * 2];
      y2 = verts[(i2 + 2) * 2 + 1];
      if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {
        continue;
      }
      indices.push(i2, i2 + 1, i2 + 2);
    }
  }
  var init_buildLine = __esm({
    "../core/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.mjs"() {
      init_Point();
      init_const6();
      init_getOrientationOfPoints();
    }
  });

  // ../core/node_modules/earcut/src/earcut.js
  var require_earcut = __commonJS({
    "../core/node_modules/earcut/src/earcut.js"(exports, module) {
      "use strict";
      module.exports = earcut2;
      module.exports.default = earcut2;
      function earcut2(data, holeIndices, dim) {
        dim = dim || 2;
        var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
        if (!outerNode || outerNode.next === outerNode.prev)
          return triangles;
        var minX, minY, maxX, maxY, x2, y2, invSize;
        if (hasHoles)
          outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
        if (data.length > 80 * dim) {
          minX = maxX = data[0];
          minY = maxY = data[1];
          for (var i2 = dim; i2 < outerLen; i2 += dim) {
            x2 = data[i2];
            y2 = data[i2 + 1];
            if (x2 < minX)
              minX = x2;
            if (y2 < minY)
              minY = y2;
            if (x2 > maxX)
              maxX = x2;
            if (y2 > maxY)
              maxY = y2;
          }
          invSize = Math.max(maxX - minX, maxY - minY);
          invSize = invSize !== 0 ? 32767 / invSize : 0;
        }
        earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
        return triangles;
      }
      function linkedList(data, start, end, dim, clockwise) {
        var i2, last3;
        if (clockwise === signedArea(data, start, end, dim) > 0) {
          for (i2 = start; i2 < end; i2 += dim)
            last3 = insertNode(i2, data[i2], data[i2 + 1], last3);
        } else {
          for (i2 = end - dim; i2 >= start; i2 -= dim)
            last3 = insertNode(i2, data[i2], data[i2 + 1], last3);
        }
        if (last3 && equals(last3, last3.next)) {
          removeNode(last3);
          last3 = last3.next;
        }
        return last3;
      }
      function filterPoints(start, end) {
        if (!start)
          return start;
        if (!end)
          end = start;
        var p2 = start, again;
        do {
          again = false;
          if (!p2.steiner && (equals(p2, p2.next) || area(p2.prev, p2, p2.next) === 0)) {
            removeNode(p2);
            p2 = end = p2.prev;
            if (p2 === p2.next)
              break;
            again = true;
          } else {
            p2 = p2.next;
          }
        } while (again || p2 !== end);
        return end;
      }
      function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
        if (!ear)
          return;
        if (!pass && invSize)
          indexCurve(ear, minX, minY, invSize);
        var stop = ear, prev, next;
        while (ear.prev !== ear.next) {
          prev = ear.prev;
          next = ear.next;
          if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            triangles.push(prev.i / dim | 0);
            triangles.push(ear.i / dim | 0);
            triangles.push(next.i / dim | 0);
            removeNode(ear);
            ear = next.next;
            stop = next.next;
            continue;
          }
          ear = next;
          if (ear === stop) {
            if (!pass) {
              earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
            } else if (pass === 1) {
              ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
              earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
            } else if (pass === 2) {
              splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }
            break;
          }
        }
      }
      function isEar(ear) {
        var a2 = ear.prev, b2 = ear, c2 = ear.next;
        if (area(a2, b2, c2) >= 0)
          return false;
        var ax = a2.x, bx = b2.x, cx = c2.x, ay = a2.y, by = b2.y, cy = c2.y;
        var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
        var p2 = c2.next;
        while (p2 !== a2) {
          if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
            return false;
          p2 = p2.next;
        }
        return true;
      }
      function isEarHashed(ear, minX, minY, invSize) {
        var a2 = ear.prev, b2 = ear, c2 = ear.next;
        if (area(a2, b2, c2) >= 0)
          return false;
        var ax = a2.x, bx = b2.x, cx = c2.x, ay = a2.y, by = b2.y, cy = c2.y;
        var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
        var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
        var p2 = ear.prevZ, n2 = ear.nextZ;
        while (p2 && p2.z >= minZ && n2 && n2.z <= maxZ) {
          if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a2 && p2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
            return false;
          p2 = p2.prevZ;
          if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
            return false;
          n2 = n2.nextZ;
        }
        while (p2 && p2.z >= minZ) {
          if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a2 && p2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
            return false;
          p2 = p2.prevZ;
        }
        while (n2 && n2.z <= maxZ) {
          if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
            return false;
          n2 = n2.nextZ;
        }
        return true;
      }
      function cureLocalIntersections(start, triangles, dim) {
        var p2 = start;
        do {
          var a2 = p2.prev, b2 = p2.next.next;
          if (!equals(a2, b2) && intersects(a2, p2, p2.next, b2) && locallyInside(a2, b2) && locallyInside(b2, a2)) {
            triangles.push(a2.i / dim | 0);
            triangles.push(p2.i / dim | 0);
            triangles.push(b2.i / dim | 0);
            removeNode(p2);
            removeNode(p2.next);
            p2 = start = b2;
          }
          p2 = p2.next;
        } while (p2 !== start);
        return filterPoints(p2);
      }
      function splitEarcut(start, triangles, dim, minX, minY, invSize) {
        var a2 = start;
        do {
          var b2 = a2.next.next;
          while (b2 !== a2.prev) {
            if (a2.i !== b2.i && isValidDiagonal(a2, b2)) {
              var c2 = splitPolygon(a2, b2);
              a2 = filterPoints(a2, a2.next);
              c2 = filterPoints(c2, c2.next);
              earcutLinked(a2, triangles, dim, minX, minY, invSize, 0);
              earcutLinked(c2, triangles, dim, minX, minY, invSize, 0);
              return;
            }
            b2 = b2.next;
          }
          a2 = a2.next;
        } while (a2 !== start);
      }
      function eliminateHoles(data, holeIndices, outerNode, dim) {
        var queue = [], i2, len, start, end, list;
        for (i2 = 0, len = holeIndices.length; i2 < len; i2++) {
          start = holeIndices[i2] * dim;
          end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
          list = linkedList(data, start, end, dim, false);
          if (list === list.next)
            list.steiner = true;
          queue.push(getLeftmost(list));
        }
        queue.sort(compareX);
        for (i2 = 0; i2 < queue.length; i2++) {
          outerNode = eliminateHole(queue[i2], outerNode);
        }
        return outerNode;
      }
      function compareX(a2, b2) {
        return a2.x - b2.x;
      }
      function eliminateHole(hole, outerNode) {
        var bridge = findHoleBridge(hole, outerNode);
        if (!bridge) {
          return outerNode;
        }
        var bridgeReverse = splitPolygon(bridge, hole);
        filterPoints(bridgeReverse, bridgeReverse.next);
        return filterPoints(bridge, bridge.next);
      }
      function findHoleBridge(hole, outerNode) {
        var p2 = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m2;
        do {
          if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
            var x2 = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
            if (x2 <= hx && x2 > qx) {
              qx = x2;
              m2 = p2.x < p2.next.x ? p2 : p2.next;
              if (x2 === hx)
                return m2;
            }
          }
          p2 = p2.next;
        } while (p2 !== outerNode);
        if (!m2)
          return null;
        var stop = m2, mx = m2.x, my = m2.y, tanMin = Infinity, tan;
        p2 = m2;
        do {
          if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
            tan = Math.abs(hy - p2.y) / (hx - p2.x);
            if (locallyInside(p2, hole) && (tan < tanMin || tan === tanMin && (p2.x > m2.x || p2.x === m2.x && sectorContainsSector(m2, p2)))) {
              m2 = p2;
              tanMin = tan;
            }
          }
          p2 = p2.next;
        } while (p2 !== stop);
        return m2;
      }
      function sectorContainsSector(m2, p2) {
        return area(m2.prev, m2, p2.prev) < 0 && area(p2.next, m2, m2.next) < 0;
      }
      function indexCurve(start, minX, minY, invSize) {
        var p2 = start;
        do {
          if (p2.z === 0)
            p2.z = zOrder(p2.x, p2.y, minX, minY, invSize);
          p2.prevZ = p2.prev;
          p2.nextZ = p2.next;
          p2 = p2.next;
        } while (p2 !== start);
        p2.prevZ.nextZ = null;
        p2.prevZ = null;
        sortLinked(p2);
      }
      function sortLinked(list) {
        var i2, p2, q, e2, tail, numMerges, pSize, qSize, inSize = 1;
        do {
          p2 = list;
          list = null;
          tail = null;
          numMerges = 0;
          while (p2) {
            numMerges++;
            q = p2;
            pSize = 0;
            for (i2 = 0; i2 < inSize; i2++) {
              pSize++;
              q = q.nextZ;
              if (!q)
                break;
            }
            qSize = inSize;
            while (pSize > 0 || qSize > 0 && q) {
              if (pSize !== 0 && (qSize === 0 || !q || p2.z <= q.z)) {
                e2 = p2;
                p2 = p2.nextZ;
                pSize--;
              } else {
                e2 = q;
                q = q.nextZ;
                qSize--;
              }
              if (tail)
                tail.nextZ = e2;
              else
                list = e2;
              e2.prevZ = tail;
              tail = e2;
            }
            p2 = q;
          }
          tail.nextZ = null;
          inSize *= 2;
        } while (numMerges > 1);
        return list;
      }
      function zOrder(x2, y2, minX, minY, invSize) {
        x2 = (x2 - minX) * invSize | 0;
        y2 = (y2 - minY) * invSize | 0;
        x2 = (x2 | x2 << 8) & 16711935;
        x2 = (x2 | x2 << 4) & 252645135;
        x2 = (x2 | x2 << 2) & 858993459;
        x2 = (x2 | x2 << 1) & 1431655765;
        y2 = (y2 | y2 << 8) & 16711935;
        y2 = (y2 | y2 << 4) & 252645135;
        y2 = (y2 | y2 << 2) & 858993459;
        y2 = (y2 | y2 << 1) & 1431655765;
        return x2 | y2 << 1;
      }
      function getLeftmost(start) {
        var p2 = start, leftmost = start;
        do {
          if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y)
            leftmost = p2;
          p2 = p2.next;
        } while (p2 !== start);
        return leftmost;
      }
      function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
      }
      function isValidDiagonal(a2, b2) {
        return a2.next.i !== b2.i && a2.prev.i !== b2.i && !intersectsPolygon(a2, b2) && // dones't intersect other edges
        (locallyInside(a2, b2) && locallyInside(b2, a2) && middleInside(a2, b2) && // locally visible
        (area(a2.prev, a2, b2.prev) || area(a2, b2.prev, b2)) || // does not create opposite-facing sectors
        equals(a2, b2) && area(a2.prev, a2, a2.next) > 0 && area(b2.prev, b2, b2.next) > 0);
      }
      function area(p2, q, r2) {
        return (q.y - p2.y) * (r2.x - q.x) - (q.x - p2.x) * (r2.y - q.y);
      }
      function equals(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
      }
      function intersects(p1, q1, p2, q2) {
        var o1 = sign(area(p1, q1, p2));
        var o2 = sign(area(p1, q1, q2));
        var o3 = sign(area(p2, q2, p1));
        var o4 = sign(area(p2, q2, q1));
        if (o1 !== o2 && o3 !== o4)
          return true;
        if (o1 === 0 && onSegment(p1, p2, q1))
          return true;
        if (o2 === 0 && onSegment(p1, q2, q1))
          return true;
        if (o3 === 0 && onSegment(p2, p1, q2))
          return true;
        if (o4 === 0 && onSegment(p2, q1, q2))
          return true;
        return false;
      }
      function onSegment(p2, q, r2) {
        return q.x <= Math.max(p2.x, r2.x) && q.x >= Math.min(p2.x, r2.x) && q.y <= Math.max(p2.y, r2.y) && q.y >= Math.min(p2.y, r2.y);
      }
      function sign(num) {
        return num > 0 ? 1 : num < 0 ? -1 : 0;
      }
      function intersectsPolygon(a2, b2) {
        var p2 = a2;
        do {
          if (p2.i !== a2.i && p2.next.i !== a2.i && p2.i !== b2.i && p2.next.i !== b2.i && intersects(p2, p2.next, a2, b2))
            return true;
          p2 = p2.next;
        } while (p2 !== a2);
        return false;
      }
      function locallyInside(a2, b2) {
        return area(a2.prev, a2, a2.next) < 0 ? area(a2, b2, a2.next) >= 0 && area(a2, a2.prev, b2) >= 0 : area(a2, b2, a2.prev) < 0 || area(a2, a2.next, b2) < 0;
      }
      function middleInside(a2, b2) {
        var p2 = a2, inside = false, px = (a2.x + b2.x) / 2, py = (a2.y + b2.y) / 2;
        do {
          if (p2.y > py !== p2.next.y > py && p2.next.y !== p2.y && px < (p2.next.x - p2.x) * (py - p2.y) / (p2.next.y - p2.y) + p2.x)
            inside = !inside;
          p2 = p2.next;
        } while (p2 !== a2);
        return inside;
      }
      function splitPolygon(a2, b2) {
        var a22 = new Node(a2.i, a2.x, a2.y), b22 = new Node(b2.i, b2.x, b2.y), an = a2.next, bp = b2.prev;
        a2.next = b2;
        b2.prev = a2;
        a22.next = an;
        an.prev = a22;
        b22.next = a22;
        a22.prev = b22;
        bp.next = b22;
        b22.prev = bp;
        return b22;
      }
      function insertNode(i2, x2, y2, last3) {
        var p2 = new Node(i2, x2, y2);
        if (!last3) {
          p2.prev = p2;
          p2.next = p2;
        } else {
          p2.next = last3.next;
          p2.prev = last3;
          last3.next.prev = p2;
          last3.next = p2;
        }
        return p2;
      }
      function removeNode(p2) {
        p2.next.prev = p2.prev;
        p2.prev.next = p2.next;
        if (p2.prevZ)
          p2.prevZ.nextZ = p2.nextZ;
        if (p2.nextZ)
          p2.nextZ.prevZ = p2.prevZ;
      }
      function Node(i2, x2, y2) {
        this.i = i2;
        this.x = x2;
        this.y = y2;
        this.prev = null;
        this.next = null;
        this.z = 0;
        this.prevZ = null;
        this.nextZ = null;
        this.steiner = false;
      }
      earcut2.deviation = function(data, holeIndices, dim, triangles) {
        var hasHoles = holeIndices && holeIndices.length;
        var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
        var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
        if (hasHoles) {
          for (var i2 = 0, len = holeIndices.length; i2 < len; i2++) {
            var start = holeIndices[i2] * dim;
            var end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
          }
        }
        var trianglesArea = 0;
        for (i2 = 0; i2 < triangles.length; i2 += 3) {
          var a2 = triangles[i2] * dim;
          var b2 = triangles[i2 + 1] * dim;
          var c2 = triangles[i2 + 2] * dim;
          trianglesArea += Math.abs(
            (data[a2] - data[c2]) * (data[b2 + 1] - data[a2 + 1]) - (data[a2] - data[b2]) * (data[c2 + 1] - data[a2 + 1])
          );
        }
        return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
      };
      function signedArea(data, start, end, dim) {
        var sum = 0;
        for (var i2 = start, j2 = end - dim; i2 < end; i2 += dim) {
          sum += (data[j2] - data[i2]) * (data[i2 + 1] + data[j2 + 1]);
          j2 = i2;
        }
        return sum;
      }
      earcut2.flatten = function(data) {
        var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
        for (var i2 = 0; i2 < data.length; i2++) {
          for (var j2 = 0; j2 < data[i2].length; j2++) {
            for (var d2 = 0; d2 < dim; d2++)
              result.vertices.push(data[i2][j2][d2]);
          }
          if (i2 > 0) {
            holeIndex += data[i2 - 1].length;
            result.holes.push(holeIndex);
          }
        }
        return result;
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs
  function triangulateWithHoles(points, holes, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
    const triangles = (0, import_earcut.default)(points, holes, 2);
    if (!triangles) {
      return;
    }
    for (let i2 = 0; i2 < triangles.length; i2 += 3) {
      indices[indicesOffset++] = triangles[i2] + verticesOffset;
      indices[indicesOffset++] = triangles[i2 + 1] + verticesOffset;
      indices[indicesOffset++] = triangles[i2 + 2] + verticesOffset;
    }
    let index = verticesOffset * verticesStride;
    for (let i2 = 0; i2 < points.length; i2 += 2) {
      vertices[index] = points[i2];
      vertices[index + 1] = points[i2 + 1];
      index += verticesStride;
    }
  }
  var import_earcut;
  var init_triangulateWithHoles = __esm({
    "../core/node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs"() {
      import_earcut = __toESM(require_earcut(), 1);
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs
  var emptyArray, buildPolygon;
  var init_buildPolygon = __esm({
    "../core/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs"() {
      init_triangulateWithHoles();
      emptyArray = [];
      buildPolygon = {
        build(shape, points) {
          for (let i2 = 0; i2 < shape.points.length; i2++) {
            points[i2] = shape.points[i2];
          }
          return points;
        },
        triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
          triangulateWithHoles(points, emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs
  var buildRectangle;
  var init_buildRectangle = __esm({
    "../core/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs"() {
      "use strict";
      buildRectangle = {
        build(shape, points) {
          const rectData = shape;
          const x2 = rectData.x;
          const y2 = rectData.y;
          const width = rectData.width;
          const height = rectData.height;
          if (!(width >= 0 && height >= 0)) {
            return points;
          }
          points[0] = x2;
          points[1] = y2;
          points[2] = x2 + width;
          points[3] = y2;
          points[4] = x2 + width;
          points[5] = y2 + height;
          points[6] = x2;
          points[7] = y2 + height;
          return points;
        },
        triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
          let count2 = 0;
          verticesOffset *= verticesStride;
          vertices[verticesOffset + count2] = points[0];
          vertices[verticesOffset + count2 + 1] = points[1];
          count2 += verticesStride;
          vertices[verticesOffset + count2] = points[2];
          vertices[verticesOffset + count2 + 1] = points[3];
          count2 += verticesStride;
          vertices[verticesOffset + count2] = points[6];
          vertices[verticesOffset + count2 + 1] = points[7];
          count2 += verticesStride;
          vertices[verticesOffset + count2] = points[4];
          vertices[verticesOffset + count2 + 1] = points[5];
          count2 += verticesStride;
          const verticesIndex = verticesOffset / verticesStride;
          indices[indicesOffset++] = verticesIndex;
          indices[indicesOffset++] = verticesIndex + 1;
          indices[indicesOffset++] = verticesIndex + 2;
          indices[indicesOffset++] = verticesIndex + 1;
          indices[indicesOffset++] = verticesIndex + 3;
          indices[indicesOffset++] = verticesIndex + 2;
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs
  var buildTriangle;
  var init_buildTriangle = __esm({
    "../core/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs"() {
      "use strict";
      buildTriangle = {
        build(shape, points) {
          points[0] = shape.x;
          points[1] = shape.y;
          points[2] = shape.x2;
          points[3] = shape.y2;
          points[4] = shape.x3;
          points[5] = shape.y3;
          return points;
        },
        triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
          let count2 = 0;
          verticesOffset *= verticesStride;
          vertices[verticesOffset + count2] = points[0];
          vertices[verticesOffset + count2 + 1] = points[1];
          count2 += verticesStride;
          vertices[verticesOffset + count2] = points[2];
          vertices[verticesOffset + count2 + 1] = points[3];
          count2 += verticesStride;
          vertices[verticesOffset + count2] = points[4];
          vertices[verticesOffset + count2 + 1] = points[5];
          const verticesIndex = verticesOffset / verticesStride;
          indices[indicesOffset++] = verticesIndex;
          indices[indicesOffset++] = verticesIndex + 1;
          indices[indicesOffset++] = verticesIndex + 2;
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.mjs
  function buildContextBatches(context4, gpuContext) {
    const { geometryData, batches } = gpuContext;
    batches.length = 0;
    geometryData.indices.length = 0;
    geometryData.vertices.length = 0;
    geometryData.uvs.length = 0;
    for (let i2 = 0; i2 < context4.instructions.length; i2++) {
      const instruction = context4.instructions[i2];
      if (instruction.action === "texture") {
        addTextureToGeometryData(instruction.data, batches, geometryData);
      } else if (instruction.action === "fill" || instruction.action === "stroke") {
        const isStroke = instruction.action === "stroke";
        const shapePath = instruction.data.path.shapePath;
        const style = instruction.data.style;
        const hole = instruction.data.hole;
        if (isStroke && hole) {
          addShapePathToGeometryData(hole.shapePath, style, null, true, batches, geometryData);
        }
        addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData);
      }
    }
  }
  function addTextureToGeometryData(data, batches, geometryData) {
    const { vertices, uvs, indices } = geometryData;
    const indexOffset = indices.length;
    const vertOffset = vertices.length / 2;
    const points = [];
    const build = buildMap.rectangle;
    const rect = tempRect;
    const texture = data.image;
    rect.x = data.dx;
    rect.y = data.dy;
    rect.width = data.dw;
    rect.height = data.dh;
    const matrix = data.transform;
    build.build(rect, points);
    if (matrix) {
      transformVertices(points, matrix);
    }
    build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
    const textureUvs = texture.uvs;
    uvs.push(
      textureUvs.x0,
      textureUvs.y0,
      textureUvs.x1,
      textureUvs.y1,
      textureUvs.x3,
      textureUvs.y3,
      textureUvs.x2,
      textureUvs.y2
    );
    const graphicsBatch = BigPool.get(BatchableGraphics);
    graphicsBatch.indexOffset = indexOffset;
    graphicsBatch.indexSize = indices.length - indexOffset;
    graphicsBatch.vertexOffset = vertOffset;
    graphicsBatch.vertexSize = vertices.length / 2 - vertOffset;
    graphicsBatch.color = data.style;
    graphicsBatch.alpha = data.alpha;
    graphicsBatch.texture = texture;
    graphicsBatch.geometryData = geometryData;
    batches.push(graphicsBatch);
  }
  function addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData) {
    const { vertices, uvs, indices } = geometryData;
    const lastIndex = shapePath.shapePrimitives.length - 1;
    shapePath.shapePrimitives.forEach(({ shape, transform: matrix }, i2) => {
      const indexOffset = indices.length;
      const vertOffset = vertices.length / 2;
      const points = [];
      const build = buildMap[shape.type];
      build.build(shape, points);
      if (matrix) {
        transformVertices(points, matrix);
      }
      if (!isStroke) {
        if (hole && lastIndex === i2) {
          if (lastIndex !== 0) {
            console.warn("[Pixi Graphics] only the last shape have be cut out");
          }
          const holeIndices = [];
          const otherPoints = points.slice();
          const holeArrays = getHoleArrays(hole.shapePath);
          holeArrays.forEach((holePoints) => {
            holeIndices.push(otherPoints.length / 2);
            otherPoints.push(...holePoints);
          });
          triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);
        } else {
          build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
        }
      } else {
        const close = shape.closePath ?? true;
        const lineStyle = style;
        buildLine(points, lineStyle, false, close, vertices, 2, vertOffset, indices, indexOffset);
      }
      const uvsOffset = uvs.length / 2;
      const texture = style.texture;
      if (texture !== Texture.WHITE) {
        const textureMatrix = style.matrix;
        if (matrix) {
          textureMatrix.append(matrix.clone().invert());
        }
        buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);
      } else {
        buildSimpleUvs(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);
      }
      const graphicsBatch = BigPool.get(BatchableGraphics);
      graphicsBatch.indexOffset = indexOffset;
      graphicsBatch.indexSize = indices.length - indexOffset;
      graphicsBatch.vertexOffset = vertOffset;
      graphicsBatch.vertexSize = vertices.length / 2 - vertOffset;
      graphicsBatch.color = style.color;
      graphicsBatch.alpha = style.alpha;
      graphicsBatch.texture = texture;
      graphicsBatch.geometryData = geometryData;
      batches.push(graphicsBatch);
    });
  }
  function getHoleArrays(shape) {
    if (!shape)
      return [];
    const holePrimitives = shape.shapePrimitives;
    const holeArrays = [];
    for (let k2 = 0; k2 < holePrimitives.length; k2++) {
      const holePrimitive = holePrimitives[k2].shape;
      const holePoints = [];
      const holeBuilder = buildMap[holePrimitive.type];
      holeBuilder.build(holePrimitive, holePoints);
      holeArrays.push(holePoints);
    }
    return holeArrays;
  }
  var buildMap, tempRect;
  var init_buildContextBatches = __esm({
    "../core/node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.mjs"() {
      init_Rectangle();
      init_buildUvs();
      init_transformVertices();
      init_Texture();
      init_PoolGroup();
      init_BatchableGraphics();
      init_buildCircle();
      init_buildLine();
      init_buildPolygon();
      init_buildRectangle();
      init_buildTriangle();
      init_triangulateWithHoles();
      buildMap = {
        rectangle: buildRectangle,
        polygon: buildPolygon,
        triangle: buildTriangle,
        circle: buildCircle,
        ellipse: buildCircle,
        roundedRectangle: buildCircle
      };
      tempRect = new Rectangle();
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs
  var GpuGraphicsContext, GraphicsContextRenderData, _GraphicsContextSystem, GraphicsContextSystem;
  var init_GraphicsContextSystem = __esm({
    "../core/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs"() {
      init_Extensions();
      init_BatchGeometry();
      init_getTextureBatchBindGroup();
      init_Batcher();
      init_InstructionSet();
      init_PoolGroup();
      init_buildContextBatches();
      GpuGraphicsContext = class {
        constructor() {
          this.batches = [];
          this.geometryData = {
            vertices: [],
            uvs: [],
            indices: []
          };
        }
      };
      GraphicsContextRenderData = class {
        constructor() {
          this.geometry = new BatchGeometry();
          this.instructions = new InstructionSet();
        }
        init() {
          this.instructions.reset();
        }
      };
      _GraphicsContextSystem = class _GraphicsContextSystem2 {
        constructor() {
          this._activeBatchers = [];
          this._gpuContextHash = {};
          this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null);
          this._needsContextNeedsRebuild = [];
        }
        /**
         * Runner init called, update the default options
         * @ignore
         */
        init(options) {
          _GraphicsContextSystem2.defaultOptions.bezierSmoothness = options?.bezierSmoothness ?? _GraphicsContextSystem2.defaultOptions.bezierSmoothness;
        }
        prerender() {
          this._returnActiveBatchers();
        }
        getContextRenderData(context4) {
          return this._graphicsDataContextHash[context4.uid] || this._initContextRenderData(context4);
        }
        // Context management functions
        updateGpuContext(context4) {
          let gpuContext = this._gpuContextHash[context4.uid] || this._initContext(context4);
          if (context4.dirty) {
            if (gpuContext) {
              this._cleanGraphicsContextData(context4);
            } else {
              gpuContext = this._initContext(context4);
            }
            buildContextBatches(context4, gpuContext);
            const batchMode = context4.batchMode;
            if (context4.customShader || batchMode === "no-batch") {
              gpuContext.isBatchable = false;
            } else if (batchMode === "auto") {
              gpuContext.isBatchable = gpuContext.geometryData.vertices.length < 400;
            }
            context4.dirty = false;
          }
          return gpuContext;
        }
        getGpuContext(context4) {
          return this._gpuContextHash[context4.uid] || this._initContext(context4);
        }
        _returnActiveBatchers() {
          for (let i2 = 0; i2 < this._activeBatchers.length; i2++) {
            BigPool.return(this._activeBatchers[i2]);
          }
          this._activeBatchers.length = 0;
        }
        _initContextRenderData(context4) {
          const graphicsData = BigPool.get(GraphicsContextRenderData);
          const { batches, geometryData } = this._gpuContextHash[context4.uid];
          const vertexSize = geometryData.vertices.length;
          const indexSize = geometryData.indices.length;
          for (let i2 = 0; i2 < batches.length; i2++) {
            batches[i2].applyTransform = false;
          }
          const batcher = BigPool.get(Batcher);
          this._activeBatchers.push(batcher);
          batcher.ensureAttributeBuffer(vertexSize);
          batcher.ensureIndexBuffer(indexSize);
          batcher.begin();
          for (let i2 = 0; i2 < batches.length; i2++) {
            const batch = batches[i2];
            batcher.add(batch);
          }
          batcher.finish(graphicsData.instructions);
          const geometry = graphicsData.geometry;
          geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);
          geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);
          const drawBatches = batcher.batches;
          for (let i2 = 0; i2 < drawBatches.length; i2++) {
            const batch = drawBatches[i2];
            batch.bindGroup = getTextureBatchBindGroup(batch.textures.textures, batch.textures.count);
          }
          this._graphicsDataContextHash[context4.uid] = graphicsData;
          return graphicsData;
        }
        _initContext(context4) {
          const gpuContext = new GpuGraphicsContext();
          this._gpuContextHash[context4.uid] = gpuContext;
          context4.on("update", this.onGraphicsContextUpdate, this);
          context4.on("destroy", this.onGraphicsContextDestroy, this);
          return this._gpuContextHash[context4.uid];
        }
        onGraphicsContextUpdate(context4) {
          this._needsContextNeedsRebuild.push(context4);
        }
        onGraphicsContextDestroy(context4) {
          this._cleanGraphicsContextData(context4);
          context4.off("update", this.onGraphicsContextUpdate, this);
          context4.off("destroy", this.onGraphicsContextDestroy, this);
          this._gpuContextHash[context4.uid] = null;
        }
        _cleanGraphicsContextData(context4) {
          const gpuContext = this._gpuContextHash[context4.uid];
          if (!gpuContext.isBatchable) {
            if (this._graphicsDataContextHash[context4.uid]) {
              BigPool.return(this.getContextRenderData(context4));
              this._graphicsDataContextHash[context4.uid] = null;
            }
          }
          if (gpuContext.batches) {
            gpuContext.batches.forEach((batch) => {
              BigPool.return(batch);
            });
          }
        }
        destroy() {
          for (const context4 of this._needsContextNeedsRebuild) {
            if (this._gpuContextHash[context4.uid]) {
              this.onGraphicsContextDestroy(context4);
            }
          }
          this._needsContextNeedsRebuild.length = 0;
        }
      };
      _GraphicsContextSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "graphicsContext"
      };
      _GraphicsContextSystem.defaultOptions = {
        /**
         * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)
         * @default 0.5
         */
        bezierSmoothness: 0.5
      };
      GraphicsContextSystem = _GraphicsContextSystem;
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs
  var blendModeIds, BLEND, OFFSET, CULLING, DEPTH_TEST, WINDING, DEPTH_MASK, _State, State;
  var init_State = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs"() {
      "use strict";
      blendModeIds = {
        normal: 0,
        add: 1,
        multiply: 2,
        screen: 3,
        overlay: 4,
        erase: 5,
        "normal-npm": 6,
        "add-npm": 7,
        "screen-npm": 8
      };
      BLEND = 0;
      OFFSET = 1;
      CULLING = 2;
      DEPTH_TEST = 3;
      WINDING = 4;
      DEPTH_MASK = 5;
      _State = class _State2 {
        constructor() {
          this.data = 0;
          this.blendMode = "normal";
          this.polygonOffset = 0;
          this.blend = true;
          this.depthMask = true;
        }
        /**
         * Activates blending of the computed fragment color values.
         * @default true
         */
        get blend() {
          return !!(this.data & 1 << BLEND);
        }
        set blend(value) {
          if (!!(this.data & 1 << BLEND) !== value) {
            this.data ^= 1 << BLEND;
          }
        }
        /**
         * Activates adding an offset to depth values of polygon's fragments
         * @default false
         */
        get offsets() {
          return !!(this.data & 1 << OFFSET);
        }
        set offsets(value) {
          if (!!(this.data & 1 << OFFSET) !== value) {
            this.data ^= 1 << OFFSET;
          }
        }
        /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */
        set cullMode(value) {
          if (value === "none") {
            this.culling = false;
            return;
          }
          this.culling = true;
          this.clockwiseFrontFace = value === "front";
        }
        get cullMode() {
          if (!this.culling) {
            return "none";
          }
          return this.clockwiseFrontFace ? "front" : "back";
        }
        /**
         * Activates culling of polygons.
         * @default false
         */
        get culling() {
          return !!(this.data & 1 << CULLING);
        }
        set culling(value) {
          if (!!(this.data & 1 << CULLING) !== value) {
            this.data ^= 1 << CULLING;
          }
        }
        /**
         * Activates depth comparisons and updates to the depth buffer.
         * @default false
         */
        get depthTest() {
          return !!(this.data & 1 << DEPTH_TEST);
        }
        set depthTest(value) {
          if (!!(this.data & 1 << DEPTH_TEST) !== value) {
            this.data ^= 1 << DEPTH_TEST;
          }
        }
        /**
         * Enables or disables writing to the depth buffer.
         * @default true
         */
        get depthMask() {
          return !!(this.data & 1 << DEPTH_MASK);
        }
        set depthMask(value) {
          if (!!(this.data & 1 << DEPTH_MASK) !== value) {
            this.data ^= 1 << DEPTH_MASK;
          }
        }
        /**
         * Specifies whether or not front or back-facing polygons can be culled.
         * @default false
         */
        get clockwiseFrontFace() {
          return !!(this.data & 1 << WINDING);
        }
        set clockwiseFrontFace(value) {
          if (!!(this.data & 1 << WINDING) !== value) {
            this.data ^= 1 << WINDING;
          }
        }
        /**
         * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.
         * Setting this mode to anything other than NO_BLEND will automatically switch blending on.
         * @default 'normal'
         */
        get blendMode() {
          return this._blendMode;
        }
        set blendMode(value) {
          this.blend = value !== "none";
          this._blendMode = value;
          this._blendModeId = blendModeIds[value] || 0;
        }
        /**
         * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.
         * @default 0
         */
        get polygonOffset() {
          return this._polygonOffset;
        }
        set polygonOffset(value) {
          this.offsets = !!value;
          this._polygonOffset = value;
        }
        toString() {
          return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
        }
        /**
         * A quickly getting an instance of a State that is configured for 2d rendering.
         * @returns a new State with values set for 2d rendering
         */
        static for2d() {
          const state = new _State2();
          state.depthTest = false;
          state.blend = true;
          return state;
        }
      };
      _State.default2d = _State.for2d();
      State = _State;
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs
  function color32BitToUniform(abgr, out2, offset) {
    const alpha = (abgr >> 24 & 255) / 255;
    out2[offset++] = (abgr & 255) / 255 * alpha;
    out2[offset++] = (abgr >> 8 & 255) / 255 * alpha;
    out2[offset++] = (abgr >> 16 & 255) / 255 * alpha;
    out2[offset++] = alpha;
  }
  var init_colorToUniform = __esm({
    "../core/node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.mjs
  var GraphicsPipe;
  var init_GraphicsPipe = __esm({
    "../core/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.mjs"() {
      init_Extensions();
      init_State();
      init_PoolGroup();
      init_colorToUniform();
      init_BatchableGraphics();
      GraphicsPipe = class {
        constructor(renderer, adaptor) {
          this.state = State.for2d();
          this._graphicsBatchesHash = /* @__PURE__ */ Object.create(null);
          this.renderer = renderer;
          this._adaptor = adaptor;
          this._adaptor.init();
        }
        validateRenderable(graphics) {
          const context4 = graphics.context;
          const wasBatched = !!this._graphicsBatchesHash[graphics.uid];
          const gpuContext = this.renderer.graphicsContext.updateGpuContext(context4);
          if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable) {
            return true;
          }
          return false;
        }
        addRenderable(graphics, instructionSet) {
          const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);
          if (graphics._didGraphicsUpdate) {
            graphics._didGraphicsUpdate = false;
            this._rebuild(graphics);
          }
          if (gpuContext.isBatchable) {
            this._addToBatcher(graphics, instructionSet);
          } else {
            this.renderer.renderPipes.batch.break(instructionSet);
            instructionSet.add(graphics);
          }
        }
        updateRenderable(graphics) {
          const batches = this._graphicsBatchesHash[graphics.uid];
          if (batches) {
            for (let i2 = 0; i2 < batches.length; i2++) {
              const batch = batches[i2];
              batch.batcher.updateElement(batch);
            }
          }
        }
        destroyRenderable(graphics) {
          if (this._graphicsBatchesHash[graphics.uid]) {
            this._removeBatchForRenderable(graphics.uid);
          }
        }
        execute(graphics) {
          if (!graphics.isRenderable)
            return;
          const renderer = this.renderer;
          const context4 = graphics.context;
          const contextSystem = renderer.graphicsContext;
          if (!contextSystem.getGpuContext(context4).batches.length) {
            return;
          }
          const shader = context4.customShader || this._adaptor.shader;
          this.state.blendMode = graphics.groupBlendMode;
          const localUniforms = shader.resources.localUniforms.uniforms;
          localUniforms.uTransformMatrix = graphics.groupTransform;
          localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;
          color32BitToUniform(
            graphics.groupColorAlpha,
            localUniforms.uColor,
            0
          );
          this._adaptor.execute(this, graphics);
        }
        _rebuild(graphics) {
          const wasBatched = !!this._graphicsBatchesHash[graphics.uid];
          const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);
          if (wasBatched) {
            this._removeBatchForRenderable(graphics.uid);
          }
          if (gpuContext.isBatchable) {
            this._initBatchesForRenderable(graphics);
          }
          graphics.batched = gpuContext.isBatchable;
        }
        _addToBatcher(graphics, instructionSet) {
          const batchPipe = this.renderer.renderPipes.batch;
          const batches = this._getBatchesForRenderable(graphics);
          for (let i2 = 0; i2 < batches.length; i2++) {
            const batch = batches[i2];
            batchPipe.addToBatch(batch, instructionSet);
          }
        }
        _getBatchesForRenderable(graphics) {
          return this._graphicsBatchesHash[graphics.uid] || this._initBatchesForRenderable(graphics);
        }
        _initBatchesForRenderable(graphics) {
          const context4 = graphics.context;
          const gpuContext = this.renderer.graphicsContext.getGpuContext(context4);
          const roundPixels = this.renderer._roundPixels | graphics._roundPixels;
          const batches = gpuContext.batches.map((batch) => {
            const batchClone = BigPool.get(BatchableGraphics);
            batch.copyTo(batchClone);
            batchClone.renderable = graphics;
            batchClone.roundPixels = roundPixels;
            return batchClone;
          });
          this._graphicsBatchesHash[graphics.uid] = batches;
          graphics.on("destroyed", () => {
            this.destroyRenderable(graphics);
          });
          return batches;
        }
        _removeBatchForRenderable(graphicsUid) {
          this._graphicsBatchesHash[graphicsUid].forEach((batch) => {
            BigPool.return(batch);
          });
          this._graphicsBatchesHash[graphicsUid] = null;
        }
        destroy() {
          this.renderer = null;
          this._adaptor.destroy();
          this._adaptor = null;
          this.state = null;
          for (const i2 in this._graphicsBatchesHash) {
            this._removeBatchForRenderable(i2);
          }
          this._graphicsBatchesHash = null;
        }
      };
      GraphicsPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "graphics"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/graphics/init.mjs
  var init_init6 = __esm({
    "../core/node_modules/pixi.js/lib/scene/graphics/init.mjs"() {
      init_Extensions();
      init_GraphicsContextSystem();
      init_GraphicsPipe();
      extensions.add(GraphicsPipe);
      extensions.add(GraphicsContextSystem);
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs
  function createIdFromString(value, groupId) {
    let id = idHash2[value];
    if (id === void 0) {
      if (idCounts[groupId] === void 0) {
        idCounts[groupId] = 1;
      }
      idHash2[value] = id = idCounts[groupId]++;
    }
    return id;
  }
  var idCounts, idHash2;
  var init_createIdFromString = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs"() {
      "use strict";
      idCounts = /* @__PURE__ */ Object.create(null);
      idHash2 = /* @__PURE__ */ Object.create(null);
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/getDefaultUniformValue.mjs
  function getDefaultUniformValue(type, size) {
    switch (type) {
      case "f32":
        return 0;
      case "vec2<f32>":
        return new Float32Array(2 * size);
      case "vec3<f32>":
        return new Float32Array(3 * size);
      case "vec4<f32>":
        return new Float32Array(4 * size);
      case "mat2x2<f32>":
        return new Float32Array([
          1,
          0,
          0,
          1
        ]);
      case "mat3x3<f32>":
        return new Float32Array([
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ]);
      case "mat4x4<f32>":
        return new Float32Array([
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ]);
    }
    return null;
  }
  var init_getDefaultUniformValue = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/getDefaultUniformValue.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs
  var _UniformGroup, UniformGroup;
  var init_UniformGroup = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs"() {
      init_uid();
      init_createIdFromString();
      init_getDefaultUniformValue();
      _UniformGroup = class _UniformGroup2 {
        /**
         * Create a new Uniform group
         * @param uniformStructures - The structures of the uniform group
         * @param options - The optional parameters of this uniform group
         */
        constructor(uniformStructures, options) {
          this._touched = 0;
          this.uid = uid("uniform");
          this._resourceType = "uniformGroup";
          this._resourceId = uid("resource");
          this.isUniformGroup = true;
          this._dirtyId = 0;
          this.destroyed = false;
          options = { ..._UniformGroup2.defaultOptions, ...options };
          this.uniformStructures = uniformStructures;
          const uniforms = {};
          for (const i2 in uniformStructures) {
            const uniformData = uniformStructures[i2];
            uniformData.name = i2;
            uniformData.size = uniformData.size ?? 1;
            uniformData.value ?? (uniformData.value = getDefaultUniformValue(uniformData.type, uniformData.size));
            uniforms[i2] = uniformData.value;
          }
          this.uniforms = uniforms;
          this._dirtyId = 1;
          this.ubo = options.ubo;
          this.isStatic = options.isStatic;
          this._signature = createIdFromString(Object.keys(uniforms).map(
            (i2) => `${i2}-${uniformStructures[i2].type}`
          ).join("-"), "uniform-group");
        }
        /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */
        update() {
          this._dirtyId++;
        }
      };
      _UniformGroup.defaultOptions = {
        /** if true the UniformGroup is handled as an Uniform buffer object. */
        ubo: false,
        /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */
        isStatic: false
      };
      UniformGroup = _UniformGroup;
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs
  var BatchableMesh;
  var init_BatchableMesh = __esm({
    "../core/node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs"() {
      "use strict";
      BatchableMesh = class {
        constructor() {
          this.batcher = null;
          this.batch = null;
          this.roundPixels = 0;
          this._uvUpdateId = -1;
          this._textureMatrixUpdateId = -1;
        }
        get blendMode() {
          return this.mesh.groupBlendMode;
        }
        reset() {
          this.mesh = null;
          this.texture = null;
          this.batcher = null;
          this.batch = null;
        }
        packIndex(indexBuffer, index, indicesOffset) {
          const indices = this.geometry.indices;
          for (let i2 = 0; i2 < indices.length; i2++) {
            indexBuffer[index++] = indices[i2] + indicesOffset;
          }
        }
        packAttributes(float32View, uint32View, index, textureId) {
          const mesh = this.mesh;
          const geometry = this.geometry;
          const wt = mesh.groupTransform;
          const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;
          const a2 = wt.a;
          const b2 = wt.b;
          const c2 = wt.c;
          const d2 = wt.d;
          const tx = wt.tx;
          const ty = wt.ty;
          const positions = geometry.positions;
          const uvBuffer = geometry.getBuffer("aUV");
          const uvs = uvBuffer.data;
          let transformedUvs = uvs;
          const textureMatrix = this.texture.textureMatrix;
          if (!textureMatrix.isSimple) {
            transformedUvs = this._transformedUvs;
            if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID) {
              if (!transformedUvs || transformedUvs.length < uvs.length) {
                transformedUvs = this._transformedUvs = new Float32Array(uvs.length);
              }
              this._textureMatrixUpdateId = textureMatrix._updateID;
              this._uvUpdateId = uvBuffer._updateID;
              textureMatrix.multiplyUvs(uvs, transformedUvs);
            }
          }
          const abgr = mesh.groupColorAlpha;
          for (let i2 = 0; i2 < positions.length; i2 += 2) {
            const x2 = positions[i2];
            const y2 = positions[i2 + 1];
            float32View[index] = a2 * x2 + c2 * y2 + tx;
            float32View[index + 1] = b2 * x2 + d2 * y2 + ty;
            float32View[index + 2] = transformedUvs[i2];
            float32View[index + 3] = transformedUvs[i2 + 1];
            uint32View[index + 4] = abgr;
            uint32View[index + 5] = textureIdAndRound;
            index += 6;
          }
        }
        get vertexSize() {
          return this.geometry.positions.length / 2;
        }
        get indexSize() {
          return this.geometry.indices.length;
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.mjs
  var MeshPipe;
  var init_MeshPipe = __esm({
    "../core/node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.mjs"() {
      init_Extensions();
      init_Matrix();
      init_BindGroup();
      init_UniformGroup();
      init_PoolGroup();
      init_colorToUniform();
      init_BatchableMesh();
      MeshPipe = class {
        constructor(renderer, adaptor) {
          this.localUniforms = new UniformGroup({
            uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
            uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
            uRound: { value: 0, type: "f32" }
          });
          this.localUniformsBindGroup = new BindGroup({
            0: this.localUniforms
          });
          this._meshDataHash = /* @__PURE__ */ Object.create(null);
          this._gpuBatchableMeshHash = /* @__PURE__ */ Object.create(null);
          this.renderer = renderer;
          this._adaptor = adaptor;
          this._adaptor.init();
        }
        validateRenderable(mesh) {
          const meshData = this._getMeshData(mesh);
          const wasBatched = meshData.batched;
          const isBatched = mesh.batched;
          meshData.batched = isBatched;
          if (wasBatched !== isBatched) {
            return true;
          } else if (isBatched) {
            const geometry = mesh._geometry;
            if (geometry.indices.length !== meshData.indexSize || geometry.positions.length !== meshData.vertexSize) {
              meshData.indexSize = geometry.indices.length;
              meshData.vertexSize = geometry.positions.length;
              return true;
            }
            const batchableMesh = this._getBatchableMesh(mesh);
            const texture = mesh.texture;
            if (batchableMesh.texture._source !== texture._source) {
              if (batchableMesh.texture._source !== texture._source) {
                return !batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, texture);
              }
            }
          }
          return false;
        }
        addRenderable(mesh, instructionSet) {
          const batcher = this.renderer.renderPipes.batch;
          const { batched } = this._getMeshData(mesh);
          if (batched) {
            const gpuBatchableMesh = this._getBatchableMesh(mesh);
            gpuBatchableMesh.texture = mesh._texture;
            gpuBatchableMesh.geometry = mesh._geometry;
            batcher.addToBatch(gpuBatchableMesh);
          } else {
            batcher.break(instructionSet);
            instructionSet.add({
              renderPipeId: "mesh",
              mesh
            });
          }
        }
        updateRenderable(mesh) {
          if (mesh.batched) {
            const gpuBatchableMesh = this._gpuBatchableMeshHash[mesh.uid];
            gpuBatchableMesh.texture = mesh._texture;
            gpuBatchableMesh.geometry = mesh._geometry;
            gpuBatchableMesh.batcher.updateElement(gpuBatchableMesh);
          }
        }
        destroyRenderable(mesh) {
          this._meshDataHash[mesh.uid] = null;
          const gpuMesh = this._gpuBatchableMeshHash[mesh.uid];
          if (gpuMesh) {
            BigPool.return(gpuMesh);
            this._gpuBatchableMeshHash[mesh.uid] = null;
          }
        }
        execute({ mesh }) {
          if (!mesh.isRenderable)
            return;
          mesh.state.blendMode = mesh.groupBlendMode;
          const localUniforms = this.localUniforms;
          localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;
          localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;
          localUniforms.update();
          color32BitToUniform(
            mesh.groupColorAlpha,
            localUniforms.uniforms.uColor,
            0
          );
          this._adaptor.execute(this, mesh);
        }
        _getMeshData(mesh) {
          return this._meshDataHash[mesh.uid] || this._initMeshData(mesh);
        }
        _initMeshData(mesh) {
          this._meshDataHash[mesh.uid] = {
            batched: mesh.batched,
            indexSize: mesh._geometry.indices?.length,
            vertexSize: mesh._geometry.positions?.length
          };
          mesh.on("destroyed", () => {
            this.destroyRenderable(mesh);
          });
          return this._meshDataHash[mesh.uid];
        }
        _getBatchableMesh(mesh) {
          return this._gpuBatchableMeshHash[mesh.uid] || this._initBatchableMesh(mesh);
        }
        _initBatchableMesh(mesh) {
          const gpuMesh = BigPool.get(BatchableMesh);
          gpuMesh.mesh = mesh;
          gpuMesh.texture = mesh._texture;
          gpuMesh.roundPixels = this.renderer._roundPixels | mesh._roundPixels;
          this._gpuBatchableMeshHash[mesh.uid] = gpuMesh;
          gpuMesh.mesh = mesh;
          return gpuMesh;
        }
        destroy() {
          for (const i2 in this._gpuBatchableMeshHash) {
            if (this._gpuBatchableMeshHash[i2]) {
              BigPool.return(this._gpuBatchableMeshHash[i2]);
            }
          }
          this._gpuBatchableMeshHash = null;
          this._meshDataHash = null;
          this.localUniforms = null;
          this.localUniformsBindGroup = null;
          this._adaptor.destroy();
          this._adaptor = null;
          this.renderer = null;
        }
      };
      MeshPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "mesh"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/mesh/init.mjs
  var init_init7 = __esm({
    "../core/node_modules/pixi.js/lib/scene/mesh/init.mjs"() {
      init_Extensions();
      init_MeshPipe();
      extensions.add(MeshPipe);
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs
  var BatchableSprite;
  var init_BatchableSprite = __esm({
    "../core/node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs"() {
      "use strict";
      BatchableSprite = class {
        constructor() {
          this.vertexSize = 4;
          this.indexSize = 6;
          this.location = 0;
          this.batcher = null;
          this.batch = null;
          this.roundPixels = 0;
        }
        get blendMode() {
          return this.renderable.groupBlendMode;
        }
        packAttributes(float32View, uint32View, index, textureId) {
          const sprite = this.renderable;
          const texture = this.texture;
          const wt = sprite.groupTransform;
          const a2 = wt.a;
          const b2 = wt.b;
          const c2 = wt.c;
          const d2 = wt.d;
          const tx = wt.tx;
          const ty = wt.ty;
          const bounds = this.bounds;
          const w0 = bounds.maxX;
          const w1 = bounds.minX;
          const h0 = bounds.maxY;
          const h1 = bounds.minY;
          const uvs = texture.uvs;
          const argb = sprite.groupColorAlpha;
          const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;
          float32View[index + 0] = a2 * w1 + c2 * h1 + tx;
          float32View[index + 1] = d2 * h1 + b2 * w1 + ty;
          float32View[index + 2] = uvs.x0;
          float32View[index + 3] = uvs.y0;
          uint32View[index + 4] = argb;
          uint32View[index + 5] = textureIdAndRound;
          float32View[index + 6] = a2 * w0 + c2 * h1 + tx;
          float32View[index + 7] = d2 * h1 + b2 * w0 + ty;
          float32View[index + 8] = uvs.x1;
          float32View[index + 9] = uvs.y1;
          uint32View[index + 10] = argb;
          uint32View[index + 11] = textureIdAndRound;
          float32View[index + 12] = a2 * w0 + c2 * h0 + tx;
          float32View[index + 13] = d2 * h0 + b2 * w0 + ty;
          float32View[index + 14] = uvs.x2;
          float32View[index + 15] = uvs.y2;
          uint32View[index + 16] = argb;
          uint32View[index + 17] = textureIdAndRound;
          float32View[index + 18] = a2 * w1 + c2 * h0 + tx;
          float32View[index + 19] = d2 * h0 + b2 * w1 + ty;
          float32View[index + 20] = uvs.x3;
          float32View[index + 21] = uvs.y3;
          uint32View[index + 22] = argb;
          uint32View[index + 23] = textureIdAndRound;
        }
        packIndex(indexBuffer, index, indicesOffset) {
          indexBuffer[index] = indicesOffset + 0;
          indexBuffer[index + 1] = indicesOffset + 1;
          indexBuffer[index + 2] = indicesOffset + 2;
          indexBuffer[index + 3] = indicesOffset + 0;
          indexBuffer[index + 4] = indicesOffset + 2;
          indexBuffer[index + 5] = indicesOffset + 3;
        }
        reset() {
          this.renderable = null;
          this.texture = null;
          this.batcher = null;
          this.batch = null;
          this.bounds = null;
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.mjs
  var CanvasTextPipe;
  var init_CanvasTextPipe = __esm({
    "../core/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.mjs"() {
      init_Extensions();
      init_updateQuadBounds();
      init_PoolGroup();
      init_BatchableSprite();
      CanvasTextPipe = class {
        constructor(renderer) {
          this._gpuText = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
        }
        validateRenderable(text2) {
          const gpuText = this._getGpuText(text2);
          const newKey = text2._getKey();
          if (gpuText.currentKey !== newKey) {
            const resolution = text2.resolution ?? this._renderer.resolution;
            const { width, height } = this._renderer.canvasText.getTextureSize(
              text2.text,
              resolution,
              text2._style
            );
            if (
              // is only being used by this text:
              this._renderer.canvasText.getReferenceCount(gpuText.currentKey) === 1 && width === gpuText.texture._source.width && height === gpuText.texture._source.height
            ) {
              return false;
            }
            return true;
          }
          return false;
        }
        addRenderable(text2, _instructionSet) {
          const gpuText = this._getGpuText(text2);
          const batchableSprite = gpuText.batchableSprite;
          if (text2._didTextUpdate) {
            this._updateText(text2);
          }
          this._renderer.renderPipes.batch.addToBatch(batchableSprite);
        }
        updateRenderable(text2) {
          const gpuText = this._getGpuText(text2);
          const batchableSprite = gpuText.batchableSprite;
          if (text2._didTextUpdate) {
            this._updateText(text2);
          }
          batchableSprite.batcher.updateElement(batchableSprite);
        }
        destroyRenderable(text2) {
          this._destroyRenderableById(text2.uid);
        }
        _destroyRenderableById(textUid) {
          const gpuText = this._gpuText[textUid];
          this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);
          BigPool.return(gpuText.batchableSprite);
          this._gpuText[textUid] = null;
        }
        _updateText(text2) {
          const newKey = text2._getKey();
          const gpuText = this._getGpuText(text2);
          const batchableSprite = gpuText.batchableSprite;
          if (gpuText.currentKey !== newKey) {
            this._updateGpuText(text2);
          }
          text2._didTextUpdate = false;
          const padding = text2._style.padding;
          updateQuadBounds(batchableSprite.bounds, text2._anchor, batchableSprite.texture, padding);
        }
        _updateGpuText(text2) {
          const gpuText = this._getGpuText(text2);
          const batchableSprite = gpuText.batchableSprite;
          if (gpuText.texture) {
            this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);
          }
          gpuText.texture = batchableSprite.texture = this._renderer.canvasText.getManagedTexture(text2);
          gpuText.currentKey = text2._getKey();
          batchableSprite.texture = gpuText.texture;
        }
        _getGpuText(text2) {
          return this._gpuText[text2.uid] || this.initGpuText(text2);
        }
        initGpuText(text2) {
          const gpuTextData = {
            texture: null,
            currentKey: "--",
            batchableSprite: BigPool.get(BatchableSprite)
          };
          gpuTextData.batchableSprite.renderable = text2;
          gpuTextData.batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };
          gpuTextData.batchableSprite.roundPixels = this._renderer._roundPixels | text2._roundPixels;
          this._gpuText[text2.uid] = gpuTextData;
          this._updateText(text2);
          text2.on("destroyed", () => {
            this.destroyRenderable(text2);
          });
          return gpuTextData;
        }
        destroy() {
          for (const i2 in this._gpuText) {
            this._destroyRenderableById(i2);
          }
          this._gpuText = null;
          this._renderer = null;
        }
      };
      CanvasTextPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "text"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs
  var CanvasPoolClass, CanvasPool;
  var init_CanvasPool = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs"() {
      init_adapter();
      init_pow2();
      CanvasPoolClass = class {
        constructor(canvasOptions) {
          this._canvasPool = /* @__PURE__ */ Object.create(null);
          this.canvasOptions = canvasOptions || {};
          this.enableFullScreen = false;
        }
        /**
         * Creates texture with params that were specified in pool constructor.
         * @param pixelWidth - Width of texture in pixels.
         * @param pixelHeight - Height of texture in pixels.
         */
        _createCanvasAndContext(pixelWidth, pixelHeight) {
          const canvas = DOMAdapter.get().createCanvas();
          canvas.width = pixelWidth;
          canvas.height = pixelHeight;
          const context4 = canvas.getContext("2d");
          return { canvas, context: context4 };
        }
        /**
         * Gets a Power-of-Two render texture or fullScreen texture
         * @param minWidth - The minimum width of the render texture.
         * @param minHeight - The minimum height of the render texture.
         * @param resolution - The resolution of the render texture.
         * @returns The new render texture.
         */
        getOptimalCanvasAndContext(minWidth, minHeight, resolution = 1) {
          minWidth = Math.ceil(minWidth * resolution - 1e-6);
          minHeight = Math.ceil(minHeight * resolution - 1e-6);
          minWidth = nextPow2(minWidth);
          minHeight = nextPow2(minHeight);
          const key = (minWidth << 17) + (minHeight << 1);
          if (!this._canvasPool[key]) {
            this._canvasPool[key] = [];
          }
          let canvasAndContext = this._canvasPool[key].pop();
          if (!canvasAndContext) {
            canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);
          }
          return canvasAndContext;
        }
        /**
         * Place a render texture back into the pool.
         * @param canvasAndContext
         */
        returnCanvasAndContext(canvasAndContext) {
          const { width, height } = canvasAndContext.canvas;
          const key = (width << 17) + (height << 1);
          this._canvasPool[key].push(canvasAndContext);
        }
        clear() {
          this._canvasPool = {};
        }
      };
      CanvasPool = new CanvasPoolClass();
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs
  var count, TexturePoolClass, TexturePool;
  var init_TexturePool = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs"() {
      init_pow2();
      init_TextureSource();
      init_Texture();
      count = 0;
      TexturePoolClass = class {
        /**
         * @param textureOptions - options that will be passed to BaseRenderTexture constructor
         * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.
         */
        constructor(textureOptions) {
          this._poolKeyHash = /* @__PURE__ */ Object.create(null);
          this._texturePool = {};
          this.textureOptions = textureOptions || {};
          this.enableFullScreen = false;
        }
        /**
         * Creates texture with params that were specified in pool constructor.
         * @param pixelWidth - Width of texture in pixels.
         * @param pixelHeight - Height of texture in pixels.
         * @param antialias
         */
        createTexture(pixelWidth, pixelHeight, antialias) {
          const textureSource = new TextureSource({
            ...this.textureOptions,
            width: pixelWidth,
            height: pixelHeight,
            resolution: 1,
            antialias,
            autoGarbageCollect: true
          });
          return new Texture({
            source: textureSource,
            label: `texturePool_${count++}`
          });
        }
        /**
         * Gets a Power-of-Two render texture or fullScreen texture
         * @param frameWidth - The minimum width of the render texture.
         * @param frameHeight - The minimum height of the render texture.
         * @param resolution - The resolution of the render texture.
         * @param antialias
         * @returns The new render texture.
         */
        getOptimalTexture(frameWidth, frameHeight, resolution = 1, antialias) {
          let po2Width = Math.ceil(frameWidth * resolution - 1e-6);
          let po2Height = Math.ceil(frameHeight * resolution - 1e-6);
          po2Width = nextPow2(po2Width);
          po2Height = nextPow2(po2Height);
          const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);
          if (!this._texturePool[key]) {
            this._texturePool[key] = [];
          }
          let texture = this._texturePool[key].pop();
          if (!texture) {
            texture = this.createTexture(po2Width, po2Height, antialias);
          }
          texture.source._resolution = resolution;
          texture.source.width = po2Width / resolution;
          texture.source.height = po2Height / resolution;
          texture.source.pixelWidth = po2Width;
          texture.source.pixelHeight = po2Height;
          texture.frame.x = 0;
          texture.frame.y = 0;
          texture.frame.width = frameWidth;
          texture.frame.height = frameHeight;
          texture.updateUvs();
          this._poolKeyHash[texture.uid] = key;
          return texture;
        }
        /**
         * Gets extra texture of the same size as input renderTexture
         * @param texture - The texture to check what size it is.
         * @param antialias - Whether to use antialias.
         * @returns A texture that is a power of two
         */
        getSameSizeTexture(texture, antialias = false) {
          const source2 = texture.source;
          return this.getOptimalTexture(texture.width, texture.height, source2._resolution, antialias);
        }
        /**
         * Place a render texture back into the pool.
         * @param renderTexture - The renderTexture to free
         */
        returnTexture(renderTexture) {
          const key = this._poolKeyHash[renderTexture.uid];
          this._texturePool[key].push(renderTexture);
        }
        /**
         * Clears the pool.
         * @param destroyTextures - Destroy all stored textures.
         */
        clear(destroyTextures) {
          destroyTextures = destroyTextures !== false;
          if (destroyTextures) {
            for (const i2 in this._texturePool) {
              const textures = this._texturePool[i2];
              if (textures) {
                for (let j2 = 0; j2 < textures.length; j2++) {
                  textures[j2].destroy(true);
                }
              }
            }
          }
          this._texturePool = {};
        }
      };
      TexturePool = new TexturePoolClass();
    }
  });

  // ../core/node_modules/pixi.js/lib/utils/canvas/getCanvasBoundingBox.mjs
  function checkRow(data, width, y2) {
    for (let x2 = 0, index = 4 * y2 * width; x2 < width; ++x2, index += 4) {
      if (data[index + 3] !== 0)
        return false;
    }
    return true;
  }
  function checkColumn(data, width, x2, top, bottom) {
    const stride = 4 * width;
    for (let y2 = top, index = top * stride + 4 * x2; y2 <= bottom; ++y2, index += stride) {
      if (data[index + 3] !== 0)
        return false;
    }
    return true;
  }
  function getCanvasBoundingBox(canvas, resolution = 1) {
    const { width, height } = canvas;
    const context4 = canvas.getContext("2d", {
      willReadFrequently: true
    });
    if (context4 === null) {
      throw new TypeError("Failed to get canvas 2D context");
    }
    const imageData = context4.getImageData(0, 0, width, height);
    const data = imageData.data;
    let left = 0;
    let top = 0;
    let right = width - 1;
    let bottom = height - 1;
    while (top < height && checkRow(data, width, top))
      ++top;
    if (top === height)
      return Rectangle.EMPTY;
    while (checkRow(data, width, bottom))
      --bottom;
    while (checkColumn(data, width, left, top, bottom))
      ++left;
    while (checkColumn(data, width, right, top, bottom))
      --right;
    ++right;
    ++bottom;
    return new Rectangle(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);
  }
  var init_getCanvasBoundingBox = __esm({
    "../core/node_modules/pixi.js/lib/utils/canvas/getCanvasBoundingBox.mjs"() {
      init_Rectangle();
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs
  var _FillGradient, FillGradient;
  var init_FillGradient = __esm({
    "../core/node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs"() {
      init_Color();
      init_adapter();
      init_Matrix();
      init_ImageSource();
      init_Texture();
      init_uid();
      _FillGradient = class _FillGradient2 {
        constructor(x0, y0, x1, y1) {
          this.uid = uid("fillGradient");
          this.type = "linear";
          this.gradientStops = [];
          this.x0 = x0;
          this.y0 = y0;
          this.x1 = x1;
          this.y1 = y1;
        }
        addColorStop(offset, color3) {
          this.gradientStops.push({ offset, color: Color.shared.setValue(color3).toHex() });
          return this;
        }
        // TODO move to the system!
        buildLinearGradient() {
          const defaultSize = _FillGradient2.defaultTextureSize;
          const { gradientStops } = this;
          const canvas = DOMAdapter.get().createCanvas();
          canvas.width = defaultSize;
          canvas.height = defaultSize;
          const ctx = canvas.getContext("2d");
          const gradient = ctx.createLinearGradient(0, 0, _FillGradient2.defaultTextureSize, 1);
          for (let i2 = 0; i2 < gradientStops.length; i2++) {
            const stop = gradientStops[i2];
            gradient.addColorStop(stop.offset, stop.color);
          }
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, defaultSize, defaultSize);
          this.texture = new Texture({
            source: new ImageSource({
              resource: canvas,
              addressModeU: "clamp-to-edge",
              addressModeV: "repeat"
            })
          });
          const { x0, y0, x1, y1 } = this;
          const m2 = new Matrix();
          const dx = x1 - x0;
          const dy = y1 - y0;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const angle = Math.atan2(dy, dx);
          m2.translate(-x0, -y0);
          m2.scale(1 / defaultSize, 1 / defaultSize);
          m2.rotate(-angle);
          m2.scale(256 / dist, 1);
          this.transform = m2;
        }
      };
      _FillGradient.defaultTextureSize = 256;
      FillGradient = _FillGradient;
    }
  });

  // ../core/node_modules/parse-svg-path/index.js
  var require_parse_svg_path = __commonJS({
    "../core/node_modules/parse-svg-path/index.js"(exports, module) {
      module.exports = parse2;
      var length = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };
      var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
      function parse2(path2) {
        var data = [];
        path2.replace(segment, function(_, command, args) {
          var type = command.toLowerCase();
          args = parseValues(args);
          if (type == "m" && args.length > 2) {
            data.push([command].concat(args.splice(0, 2)));
            type = "l";
            command = command == "m" ? "l" : "L";
          }
          while (true) {
            if (args.length == length[type]) {
              args.unshift(command);
              return data.push(args);
            }
            if (args.length < length[type])
              throw new Error("malformed path data");
            data.push([command].concat(args.splice(0, length[type])));
          }
        });
        return data;
      }
      var number = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
      function parseValues(args) {
        var numbers = args.match(number);
        return numbers ? numbers.map(Number) : [];
      }
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGToGraphicsPath.mjs
  function SVGToGraphicsPath(svgPath, path2) {
    const commands = (0, import_parse_svg_path.default)(svgPath);
    const subpaths = [];
    let currentSubPath = null;
    let lastX = 0;
    let lastY = 0;
    for (let i2 = 0; i2 < commands.length; i2++) {
      const command = commands[i2];
      const type = command[0];
      const data = command;
      switch (type) {
        case "M":
          lastX = data[1];
          lastY = data[2];
          path2.moveTo(lastX, lastY);
          break;
        case "m":
          lastX += data[1];
          lastY += data[2];
          path2.moveTo(lastX, lastY);
          break;
        case "H":
          lastX = data[1];
          path2.lineTo(lastX, lastY);
          break;
        case "h":
          lastX += data[1];
          path2.lineTo(lastX, lastY);
          break;
        case "V":
          lastY = data[1];
          path2.lineTo(lastX, lastY);
          break;
        case "v":
          lastY += data[1];
          path2.lineTo(lastX, lastY);
          break;
        case "L":
          lastX = data[1];
          lastY = data[2];
          path2.lineTo(lastX, lastY);
          break;
        case "l":
          lastX += data[1];
          lastY += data[2];
          path2.lineTo(lastX, lastY);
          break;
        case "C":
          lastX = data[5];
          lastY = data[6];
          path2.bezierCurveTo(
            data[1],
            data[2],
            data[3],
            data[4],
            lastX,
            lastY
          );
          break;
        case "c":
          path2.bezierCurveTo(
            lastX + data[1],
            lastY + data[2],
            lastX + data[3],
            lastY + data[4],
            lastX + data[5],
            lastY + data[6]
          );
          lastX += data[5];
          lastY += data[6];
          break;
        case "S":
          lastX = data[3];
          lastY = data[4];
          path2.bezierCurveToShort(
            data[1],
            data[2],
            lastX,
            lastY
          );
          break;
        case "s":
          path2.bezierCurveToShort(
            lastX + data[1],
            lastY + data[2],
            lastX + data[3],
            lastY + data[4]
          );
          lastX += data[3];
          lastY += data[4];
          break;
        case "Q":
          lastX = data[3];
          lastY = data[4];
          path2.quadraticCurveTo(
            data[1],
            data[2],
            lastX,
            lastY
          );
          break;
        case "q":
          path2.quadraticCurveTo(
            lastX + data[1],
            lastY + data[2],
            lastX + data[3],
            lastY + data[4]
          );
          lastX += data[3];
          lastY += data[4];
          break;
        case "T":
          lastX = data[1];
          lastY = data[2];
          path2.quadraticCurveToShort(
            lastX,
            lastY
          );
          break;
        case "t":
          lastX += data[1];
          lastY += data[2];
          path2.quadraticCurveToShort(
            lastX,
            lastY
          );
          break;
        case "A":
          lastX = data[6];
          lastY = data[7];
          path2.arcToSvg(
            data[1],
            data[2],
            data[3],
            data[4],
            data[5],
            lastX,
            lastY
          );
          break;
        case "a":
          lastX += data[6];
          lastY += data[7];
          path2.arcToSvg(
            data[1],
            data[2],
            data[3],
            data[4],
            data[5],
            lastX,
            lastY
          );
          break;
        case "Z":
        case "z":
          path2.closePath();
          if (subpaths.length > 0) {
            currentSubPath = subpaths.pop();
            if (currentSubPath) {
              lastX = currentSubPath.startX;
              lastY = currentSubPath.startY;
            } else {
              lastX = 0;
              lastY = 0;
            }
          }
          currentSubPath = null;
          break;
        default:
          warn(`Unknown SVG path command: ${type}`);
      }
      if (type !== "Z" && type !== "z") {
        if (currentSubPath === null) {
          currentSubPath = { startX: lastX, startY: lastY };
          subpaths.push(currentSubPath);
        }
      }
    }
    return path2;
  }
  var import_parse_svg_path;
  var init_SVGToGraphicsPath = __esm({
    "../core/node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGToGraphicsPath.mjs"() {
      import_parse_svg_path = __toESM(require_parse_svg_path(), 1);
      init_warn();
    }
  });

  // ../core/node_modules/pixi.js/lib/maths/shapes/Circle.mjs
  var Circle;
  var init_Circle = __esm({
    "../core/node_modules/pixi.js/lib/maths/shapes/Circle.mjs"() {
      init_Rectangle();
      Circle = class {
        /**
         * @param x - The X coordinate of the center of this circle
         * @param y - The Y coordinate of the center of this circle
         * @param radius - The radius of the circle
         */
        constructor(x2 = 0, y2 = 0, radius = 0) {
          this.type = "circle";
          this.x = x2;
          this.y = y2;
          this.radius = radius;
        }
        /**
         * Creates a clone of this Circle instance
         * @returns A copy of the Circle
         */
        clone() {
          return new Circle(this.x, this.y, this.radius);
        }
        /**
         * Checks whether the x and y coordinates given are contained within this circle
         * @param x - The X coordinate of the point to test
         * @param y - The Y coordinate of the point to test
         * @returns Whether the x/y coordinates are within this Circle
         */
        contains(x2, y2) {
          if (this.radius <= 0)
            return false;
          const r2 = this.radius * this.radius;
          let dx = this.x - x2;
          let dy = this.y - y2;
          dx *= dx;
          dy *= dy;
          return dx + dy <= r2;
        }
        /**
         * Checks whether the x and y coordinates given are contained within this circle including the stroke.
         * @param x - The X coordinate of the point to test
         * @param y - The Y coordinate of the point to test
         * @param width - The width of the line to check
         * @returns Whether the x/y coordinates are within this Circle
         */
        strokeContains(x2, y2, width) {
          if (this.radius === 0)
            return false;
          const dx = this.x - x2;
          const dy = this.y - y2;
          const r2 = this.radius;
          const w2 = width / 2;
          const distance = Math.sqrt(dx * dx + dy * dy);
          return distance < r2 + w2 && distance > r2 - w2;
        }
        /**
         * Returns the framing rectangle of the circle as a Rectangle object
         * @param out
         * @returns The framing rectangle
         */
        getBounds(out2) {
          out2 = out2 || new Rectangle();
          out2.x = this.x - this.radius;
          out2.y = this.y - this.radius;
          out2.width = this.radius * 2;
          out2.height = this.radius * 2;
          return out2;
        }
        /**
         * Copies another circle to this one.
         * @param circle - The circle to copy from.
         * @returns Returns itself.
         */
        copyFrom(circle) {
          this.x = circle.x;
          this.y = circle.y;
          this.radius = circle.radius;
          return this;
        }
        /**
         * Copies this circle to another one.
         * @param circle - The circle to copy to.
         * @returns Returns given parameter.
         */
        copyTo(circle) {
          circle.copyFrom(this);
          return circle;
        }
        toString() {
          return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/maths/shapes/Ellipse.mjs
  var Ellipse;
  var init_Ellipse = __esm({
    "../core/node_modules/pixi.js/lib/maths/shapes/Ellipse.mjs"() {
      init_Rectangle();
      Ellipse = class {
        /**
         * @param x - The X coordinate of the center of this ellipse
         * @param y - The Y coordinate of the center of this ellipse
         * @param halfWidth - The half width of this ellipse
         * @param halfHeight - The half height of this ellipse
         */
        constructor(x2 = 0, y2 = 0, halfWidth = 0, halfHeight = 0) {
          this.type = "ellipse";
          this.x = x2;
          this.y = y2;
          this.halfWidth = halfWidth;
          this.halfHeight = halfHeight;
        }
        /**
         * Creates a clone of this Ellipse instance
         * @returns {Ellipse} A copy of the ellipse
         */
        clone() {
          return new Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);
        }
        /**
         * Checks whether the x and y coordinates given are contained within this ellipse
         * @param x - The X coordinate of the point to test
         * @param y - The Y coordinate of the point to test
         * @returns Whether the x/y coords are within this ellipse
         */
        contains(x2, y2) {
          if (this.halfWidth <= 0 || this.halfHeight <= 0) {
            return false;
          }
          let normx = (x2 - this.x) / this.halfWidth;
          let normy = (y2 - this.y) / this.halfHeight;
          normx *= normx;
          normy *= normy;
          return normx + normy <= 1;
        }
        /**
         * Checks whether the x and y coordinates given are contained within this ellipse including stroke
         * @param x - The X coordinate of the point to test
         * @param y - The Y coordinate of the point to test
         * @param width
         * @returns Whether the x/y coords are within this ellipse
         */
        strokeContains(x2, y2, width) {
          const { halfWidth, halfHeight } = this;
          if (halfWidth <= 0 || halfHeight <= 0) {
            return false;
          }
          const halfStrokeWidth = width / 2;
          const innerA = halfWidth - halfStrokeWidth;
          const innerB = halfHeight - halfStrokeWidth;
          const outerA = halfWidth + halfStrokeWidth;
          const outerB = halfHeight + halfStrokeWidth;
          const normalizedX = x2 - this.x;
          const normalizedY = y2 - this.y;
          const innerEllipse = normalizedX * normalizedX / (innerA * innerA) + normalizedY * normalizedY / (innerB * innerB);
          const outerEllipse = normalizedX * normalizedX / (outerA * outerA) + normalizedY * normalizedY / (outerB * outerB);
          return innerEllipse > 1 && outerEllipse <= 1;
        }
        /**
         * Returns the framing rectangle of the ellipse as a Rectangle object
         * @returns The framing rectangle
         */
        getBounds() {
          return new Rectangle(this.x - this.halfWidth, this.y - this.halfHeight, this.halfWidth * 2, this.halfHeight * 2);
        }
        /**
         * Copies another ellipse to this one.
         * @param ellipse - The ellipse to copy from.
         * @returns Returns itself.
         */
        copyFrom(ellipse) {
          this.x = ellipse.x;
          this.y = ellipse.y;
          this.halfWidth = ellipse.halfWidth;
          this.halfHeight = ellipse.halfHeight;
          return this;
        }
        /**
         * Copies this ellipse to another one.
         * @param ellipse - The ellipse to copy to.
         * @returns Returns given parameter.
         */
        copyTo(ellipse) {
          ellipse.copyFrom(this);
          return ellipse;
        }
        toString() {
          return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/maths/misc/squaredDistanceToLineSegment.mjs
  function squaredDistanceToLineSegment(x2, y2, x1, y1, x22, y22) {
    const a2 = x2 - x1;
    const b2 = y2 - y1;
    const c2 = x22 - x1;
    const d2 = y22 - y1;
    const dot = a2 * c2 + b2 * d2;
    const lenSq = c2 * c2 + d2 * d2;
    let param = -1;
    if (lenSq !== 0) {
      param = dot / lenSq;
    }
    let xx;
    let yy;
    if (param < 0) {
      xx = x1;
      yy = y1;
    } else if (param > 1) {
      xx = x22;
      yy = y22;
    } else {
      xx = x1 + param * c2;
      yy = y1 + param * d2;
    }
    const dx = x2 - xx;
    const dy = y2 - yy;
    return dx * dx + dy * dy;
  }
  var init_squaredDistanceToLineSegment = __esm({
    "../core/node_modules/pixi.js/lib/maths/misc/squaredDistanceToLineSegment.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/maths/shapes/Polygon.mjs
  var Polygon;
  var init_Polygon = __esm({
    "../core/node_modules/pixi.js/lib/maths/shapes/Polygon.mjs"() {
      init_squaredDistanceToLineSegment();
      init_Rectangle();
      Polygon = class {
        /**
         * @param points - This can be an array of Points
         *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or
         *  the arguments passed can be all the points of the polygon e.g.
         *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat
         *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.
         */
        constructor(...points) {
          this.type = "polygon";
          let flat = Array.isArray(points[0]) ? points[0] : points;
          if (typeof flat[0] !== "number") {
            const p2 = [];
            for (let i2 = 0, il = flat.length; i2 < il; i2++) {
              p2.push(flat[i2].x, flat[i2].y);
            }
            flat = p2;
          }
          this.points = flat;
          this.closePath = true;
        }
        /**
         * Creates a clone of this polygon.
         * @returns - A copy of the polygon.
         */
        clone() {
          const points = this.points.slice();
          const polygon = new Polygon(points);
          polygon.closePath = this.closePath;
          return polygon;
        }
        /**
         * Checks whether the x and y coordinates passed to this function are contained within this polygon.
         * @param x - The X coordinate of the point to test.
         * @param y - The Y coordinate of the point to test.
         * @returns - Whether the x/y coordinates are within this polygon.
         */
        contains(x2, y2) {
          let inside = false;
          const length = this.points.length / 2;
          for (let i2 = 0, j2 = length - 1; i2 < length; j2 = i2++) {
            const xi = this.points[i2 * 2];
            const yi = this.points[i2 * 2 + 1];
            const xj = this.points[j2 * 2];
            const yj = this.points[j2 * 2 + 1];
            const intersect = yi > y2 !== yj > y2 && x2 < (xj - xi) * ((y2 - yi) / (yj - yi)) + xi;
            if (intersect) {
              inside = !inside;
            }
          }
          return inside;
        }
        /**
         * Checks whether the x and y coordinates given are contained within this polygon including the stroke.
         * @param x - The X coordinate of the point to test
         * @param y - The Y coordinate of the point to test
         * @param strokeWidth - The width of the line to check
         * @returns Whether the x/y coordinates are within this polygon
         */
        strokeContains(x2, y2, strokeWidth) {
          const halfStrokeWidth = strokeWidth / 2;
          const halfStrokeWidthSqrd = halfStrokeWidth * halfStrokeWidth;
          const { points } = this;
          const iterationLength = points.length - (this.closePath ? 0 : 2);
          for (let i2 = 0; i2 < iterationLength; i2 += 2) {
            const x1 = points[i2];
            const y1 = points[i2 + 1];
            const x22 = points[(i2 + 2) % points.length];
            const y22 = points[(i2 + 3) % points.length];
            const distanceSqrd = squaredDistanceToLineSegment(x2, y2, x1, y1, x22, y22);
            if (distanceSqrd <= halfStrokeWidthSqrd) {
              return true;
            }
          }
          return false;
        }
        /**
         * Returns the framing rectangle of the polygon as a Rectangle object
         * @param out - optional rectangle to store the result
         * @returns The framing rectangle
         */
        getBounds(out2) {
          out2 = out2 || new Rectangle();
          const points = this.points;
          let minX = Infinity;
          let maxX = -Infinity;
          let minY = Infinity;
          let maxY = -Infinity;
          for (let i2 = 0, n2 = points.length; i2 < n2; i2 += 2) {
            const x2 = points[i2];
            const y2 = points[i2 + 1];
            minX = x2 < minX ? x2 : minX;
            maxX = x2 > maxX ? x2 : maxX;
            minY = y2 < minY ? y2 : minY;
            maxY = y2 > maxY ? y2 : maxY;
          }
          out2.x = minX;
          out2.width = maxX - minX;
          out2.y = minY;
          out2.height = maxY - minY;
          return out2;
        }
        /**
         * Copies another polygon to this one.
         * @param polygon - The polygon to copy from.
         * @returns Returns itself.
         */
        copyFrom(polygon) {
          this.points = polygon.points.slice();
          this.closePath = polygon.closePath;
          return this;
        }
        /**
         * Copies this polygon to another one.
         * @param polygon - The polygon to copy to.
         * @returns Returns given parameter.
         */
        copyTo(polygon) {
          polygon.copyFrom(this);
          return polygon;
        }
        toString() {
          return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, "")}]`;
        }
        /**
         * Get the last X coordinate of the polygon
         * @readonly
         */
        get lastX() {
          return this.points[this.points.length - 2];
        }
        /**
         * Get the last Y coordinate of the polygon
         * @readonly
         */
        get lastY() {
          return this.points[this.points.length - 1];
        }
        /**
         * Get the first X coordinate of the polygon
         * @readonly
         */
        get x() {
          return this.points[this.points.length - 2];
        }
        /**
         * Get the first Y coordinate of the polygon
         * @readonly
         */
        get y() {
          return this.points[this.points.length - 1];
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.mjs
  var isCornerWithinStroke, RoundedRectangle;
  var init_RoundedRectangle = __esm({
    "../core/node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.mjs"() {
      init_Rectangle();
      isCornerWithinStroke = (pX, pY, cornerX, cornerY, radius, halfStrokeWidth) => {
        const dx = pX - cornerX;
        const dy = pY - cornerY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        return distance >= radius - halfStrokeWidth && distance <= radius + halfStrokeWidth;
      };
      RoundedRectangle = class {
        /**
         * @param x - The X coordinate of the upper-left corner of the rounded rectangle
         * @param y - The Y coordinate of the upper-left corner of the rounded rectangle
         * @param width - The overall width of this rounded rectangle
         * @param height - The overall height of this rounded rectangle
         * @param radius - Controls the radius of the rounded corners
         */
        constructor(x2 = 0, y2 = 0, width = 0, height = 0, radius = 20) {
          this.type = "roundedRectangle";
          this.x = x2;
          this.y = y2;
          this.width = width;
          this.height = height;
          this.radius = radius;
        }
        /**
         * Returns the framing rectangle of the rounded rectangle as a Rectangle object
         * @param out - optional rectangle to store the result
         * @returns The framing rectangle
         */
        getBounds(out2) {
          out2 = out2 || new Rectangle();
          out2.x = this.x;
          out2.y = this.y;
          out2.width = this.width;
          out2.height = this.height;
          return out2;
        }
        /**
         * Creates a clone of this Rounded Rectangle.
         * @returns - A copy of the rounded rectangle.
         */
        clone() {
          return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
        }
        /**
         * Copies another rectangle to this one.
         * @param rectangle - The rectangle to copy from.
         * @returns Returns itself.
         */
        copyFrom(rectangle) {
          this.x = rectangle.x;
          this.y = rectangle.y;
          this.width = rectangle.width;
          this.height = rectangle.height;
          return this;
        }
        /**
         * Copies this rectangle to another one.
         * @param rectangle - The rectangle to copy to.
         * @returns Returns given parameter.
         */
        copyTo(rectangle) {
          rectangle.copyFrom(this);
          return rectangle;
        }
        /**
         * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
         * @param x - The X coordinate of the point to test.
         * @param y - The Y coordinate of the point to test.
         * @returns - Whether the x/y coordinates are within this Rounded Rectangle.
         */
        contains(x2, y2) {
          if (this.width <= 0 || this.height <= 0) {
            return false;
          }
          if (x2 >= this.x && x2 <= this.x + this.width) {
            if (y2 >= this.y && y2 <= this.y + this.height) {
              const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
              if (y2 >= this.y + radius && y2 <= this.y + this.height - radius || x2 >= this.x + radius && x2 <= this.x + this.width - radius) {
                return true;
              }
              let dx = x2 - (this.x + radius);
              let dy = y2 - (this.y + radius);
              const radius2 = radius * radius;
              if (dx * dx + dy * dy <= radius2) {
                return true;
              }
              dx = x2 - (this.x + this.width - radius);
              if (dx * dx + dy * dy <= radius2) {
                return true;
              }
              dy = y2 - (this.y + this.height - radius);
              if (dx * dx + dy * dy <= radius2) {
                return true;
              }
              dx = x2 - (this.x + radius);
              if (dx * dx + dy * dy <= radius2) {
                return true;
              }
            }
          }
          return false;
        }
        /**
         * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.
         * @param pX - The X coordinate of the point to test
         * @param pY - The Y coordinate of the point to test
         * @param strokeWidth - The width of the line to check
         * @returns Whether the x/y coordinates are within this rectangle
         */
        strokeContains(pX, pY, strokeWidth) {
          const { x: x2, y: y2, width, height, radius } = this;
          const halfStrokeWidth = strokeWidth / 2;
          const innerX = x2 + radius;
          const innerY = y2 + radius;
          const innerWidth = width - radius * 2;
          const innerHeight = height - radius * 2;
          const rightBound = x2 + width;
          const bottomBound = y2 + height;
          if ((pX >= x2 - halfStrokeWidth && pX <= x2 + halfStrokeWidth || pX >= rightBound - halfStrokeWidth && pX <= rightBound + halfStrokeWidth) && pY >= innerY && pY <= innerY + innerHeight) {
            return true;
          }
          if ((pY >= y2 - halfStrokeWidth && pY <= y2 + halfStrokeWidth || pY >= bottomBound - halfStrokeWidth && pY <= bottomBound + halfStrokeWidth) && pX >= innerX && pX <= innerX + innerWidth) {
            return true;
          }
          return (
            // Top-left
            pX < innerX && pY < innerY && isCornerWithinStroke(pX, pY, innerX, innerY, radius, halfStrokeWidth) || pX > rightBound - radius && pY < innerY && isCornerWithinStroke(pX, pY, rightBound - radius, innerY, radius, halfStrokeWidth) || pX > rightBound - radius && pY > bottomBound - radius && isCornerWithinStroke(pX, pY, rightBound - radius, bottomBound - radius, radius, halfStrokeWidth) || pX < innerX && pY > bottomBound - radius && isCornerWithinStroke(pX, pY, innerX, bottomBound - radius, radius, halfStrokeWidth)
          );
        }
        toString() {
          return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs
  function buildAdaptiveBezier(points, sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, smoothness) {
    const scale = 1;
    const smoothing = Math.min(
      0.99,
      // a value of 1.0 actually inverts smoothing, so we cap it at 0.99
      Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)
    );
    let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;
    distanceTolerance *= distanceTolerance;
    begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);
    return points;
  }
  function begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance) {
    recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);
    points.push(eX, eY);
  }
  function recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {
    if (level > RECURSION_LIMIT) {
      return;
    }
    const pi = Math.PI;
    const x12 = (x1 + x2) / 2;
    const y12 = (y1 + y2) / 2;
    const x23 = (x2 + x3) / 2;
    const y23 = (y2 + y3) / 2;
    const x34 = (x3 + x4) / 2;
    const y34 = (y3 + y4) / 2;
    const x123 = (x12 + x23) / 2;
    const y123 = (y12 + y23) / 2;
    const x234 = (x23 + x34) / 2;
    const y234 = (y23 + y34) / 2;
    const x1234 = (x123 + x234) / 2;
    const y1234 = (y123 + y234) / 2;
    if (level > 0) {
      let dx = x4 - x1;
      let dy = y4 - y1;
      const d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx);
      const d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);
      let da1;
      let da2;
      if (d2 > FLT_EPSILON && d3 > FLT_EPSILON) {
        if ((d2 + d3) * (d2 + d3) <= distanceTolerance * (dx * dx + dy * dy)) {
          if (mAngleTolerance < curveAngleToleranceEpsilon) {
            points.push(x1234, y1234);
            return;
          }
          const a23 = Math.atan2(y3 - y2, x3 - x2);
          da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));
          da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);
          if (da1 >= pi)
            da1 = 2 * pi - da1;
          if (da2 >= pi)
            da2 = 2 * pi - da2;
          if (da1 + da2 < mAngleTolerance) {
            points.push(x1234, y1234);
            return;
          }
          if (mCuspLimit !== 0) {
            if (da1 > mCuspLimit) {
              points.push(x2, y2);
              return;
            }
            if (da2 > mCuspLimit) {
              points.push(x3, y3);
              return;
            }
          }
        }
      } else if (d2 > FLT_EPSILON) {
        if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {
          if (mAngleTolerance < curveAngleToleranceEpsilon) {
            points.push(x1234, y1234);
            return;
          }
          da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));
          if (da1 >= pi)
            da1 = 2 * pi - da1;
          if (da1 < mAngleTolerance) {
            points.push(x2, y2);
            points.push(x3, y3);
            return;
          }
          if (mCuspLimit !== 0) {
            if (da1 > mCuspLimit) {
              points.push(x2, y2);
              return;
            }
          }
        }
      } else if (d3 > FLT_EPSILON) {
        if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {
          if (mAngleTolerance < curveAngleToleranceEpsilon) {
            points.push(x1234, y1234);
            return;
          }
          da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));
          if (da1 >= pi)
            da1 = 2 * pi - da1;
          if (da1 < mAngleTolerance) {
            points.push(x2, y2);
            points.push(x3, y3);
            return;
          }
          if (mCuspLimit !== 0) {
            if (da1 > mCuspLimit) {
              points.push(x3, y3);
              return;
            }
          }
        }
      } else {
        dx = x1234 - (x1 + x4) / 2;
        dy = y1234 - (y1 + y4) / 2;
        if (dx * dx + dy * dy <= distanceTolerance) {
          points.push(x1234, y1234);
          return;
        }
      }
    }
    recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);
    recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);
  }
  var RECURSION_LIMIT, FLT_EPSILON, PATH_DISTANCE_EPSILON, curveAngleToleranceEpsilon, mAngleTolerance, mCuspLimit;
  var init_buildAdaptiveBezier = __esm({
    "../core/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs"() {
      init_GraphicsContextSystem();
      RECURSION_LIMIT = 8;
      FLT_EPSILON = 11920929e-14;
      PATH_DISTANCE_EPSILON = 1;
      curveAngleToleranceEpsilon = 0.01;
      mAngleTolerance = 0;
      mCuspLimit = 0;
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs
  function buildAdaptiveQuadratic(points, sX, sY, cp1x, cp1y, eX, eY, smoothness) {
    const scale = 1;
    const smoothing = Math.min(
      0.99,
      // a value of 1.0 actually inverts smoothing, so we cap it at 0.99
      Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)
    );
    let distanceTolerance = (PATH_DISTANCE_EPSILON2 - smoothing) / scale;
    distanceTolerance *= distanceTolerance;
    begin2(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);
    return points;
  }
  function begin2(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance) {
    recursive2(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);
    points.push(eX, eY);
  }
  function recursive2(points, x1, y1, x2, y2, x3, y3, distanceTolerance, level) {
    if (level > RECURSION_LIMIT2) {
      return;
    }
    const pi = Math.PI;
    const x12 = (x1 + x2) / 2;
    const y12 = (y1 + y2) / 2;
    const x23 = (x2 + x3) / 2;
    const y23 = (y2 + y3) / 2;
    const x123 = (x12 + x23) / 2;
    const y123 = (y12 + y23) / 2;
    let dx = x3 - x1;
    let dy = y3 - y1;
    const d2 = Math.abs((x2 - x3) * dy - (y2 - y3) * dx);
    if (d2 > FLT_EPSILON2) {
      if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {
        if (mAngleTolerance2 < curveAngleToleranceEpsilon2) {
          points.push(x123, y123);
          return;
        }
        let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));
        if (da >= pi)
          da = 2 * pi - da;
        if (da < mAngleTolerance2) {
          points.push(x123, y123);
          return;
        }
      }
    } else {
      dx = x123 - (x1 + x3) / 2;
      dy = y123 - (y1 + y3) / 2;
      if (dx * dx + dy * dy <= distanceTolerance) {
        points.push(x123, y123);
        return;
      }
    }
    recursive2(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);
    recursive2(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);
  }
  var RECURSION_LIMIT2, FLT_EPSILON2, PATH_DISTANCE_EPSILON2, curveAngleToleranceEpsilon2, mAngleTolerance2;
  var init_buildAdaptiveQuadratic = __esm({
    "../core/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs"() {
      init_GraphicsContextSystem();
      RECURSION_LIMIT2 = 8;
      FLT_EPSILON2 = 11920929e-14;
      PATH_DISTANCE_EPSILON2 = 1;
      curveAngleToleranceEpsilon2 = 0.01;
      mAngleTolerance2 = 0;
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.mjs
  function buildArc(points, x2, y2, radius, start, end, clockwise, steps) {
    let dist = Math.abs(start - end);
    if (!clockwise && start > end) {
      dist = 2 * Math.PI - dist;
    } else if (clockwise && end > start) {
      dist = 2 * Math.PI - dist;
    }
    steps = steps || Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / Math.PI)));
    steps = Math.max(steps, 3);
    let f2 = dist / steps;
    let t2 = start;
    f2 *= clockwise ? -1 : 1;
    for (let i2 = 0; i2 < steps + 1; i2++) {
      const cs = Math.cos(t2);
      const sn = Math.sin(t2);
      const nx = x2 + cs * radius;
      const ny = y2 + sn * radius;
      points.push(nx, ny);
      t2 += f2;
    }
  }
  var init_buildArc = __esm({
    "../core/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs
  function buildArcTo(points, x1, y1, x2, y2, radius) {
    const fromX = points[points.length - 2];
    const fromY = points[points.length - 1];
    const a1 = fromY - y1;
    const b1 = fromX - x1;
    const a2 = y2 - y1;
    const b2 = x2 - x1;
    const mm = Math.abs(a1 * b2 - b1 * a2);
    if (mm < 1e-8 || radius === 0) {
      if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
        points.push(x1, y1);
      }
      return;
    }
    const dd = a1 * a1 + b1 * b1;
    const cc = a2 * a2 + b2 * b2;
    const tt = a1 * a2 + b1 * b2;
    const k1 = radius * Math.sqrt(dd) / mm;
    const k2 = radius * Math.sqrt(cc) / mm;
    const j1 = k1 * tt / dd;
    const j2 = k2 * tt / cc;
    const cx = k1 * b2 + k2 * b1;
    const cy = k1 * a2 + k2 * a1;
    const px = b1 * (k2 + j1);
    const py = a1 * (k2 + j1);
    const qx = b2 * (k1 + j2);
    const qy = a2 * (k1 + j2);
    const startAngle = Math.atan2(py - cy, px - cx);
    const endAngle = Math.atan2(qy - cy, qx - cx);
    buildArc(
      points,
      cx + x1,
      cy + y1,
      radius,
      startAngle,
      endAngle,
      b1 * a2 > b2 * a1
    );
  }
  var init_buildArcTo = __esm({
    "../core/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs"() {
      init_buildArc();
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs
  function approxUnitArc(ang1, ang2) {
    const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);
    const a2 = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;
    const x1 = Math.cos(ang1);
    const y1 = Math.sin(ang1);
    const x2 = Math.cos(ang1 + ang2);
    const y2 = Math.sin(ang1 + ang2);
    return [
      {
        x: x1 - y1 * a2,
        y: y1 + x1 * a2
      },
      {
        x: x2 + y2 * a2,
        y: y2 - x2 * a2
      },
      {
        x: x2,
        y: y2
      }
    ];
  }
  function buildArcToSvg(points, px, py, cx, cy, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0) {
    if (rx === 0 || ry === 0) {
      return;
    }
    const sinPhi = Math.sin(xAxisRotation * TAU / 360);
    const cosPhi = Math.cos(xAxisRotation * TAU / 360);
    const pxp = cosPhi * (px - cx) / 2 + sinPhi * (py - cy) / 2;
    const pyp = -sinPhi * (px - cx) / 2 + cosPhi * (py - cy) / 2;
    if (pxp === 0 && pyp === 0) {
      return;
    }
    rx = Math.abs(rx);
    ry = Math.abs(ry);
    const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);
    if (lambda > 1) {
      rx *= Math.sqrt(lambda);
      ry *= Math.sqrt(lambda);
    }
    getArcCenter(
      px,
      py,
      cx,
      cy,
      rx,
      ry,
      largeArcFlag,
      sweepFlag,
      sinPhi,
      cosPhi,
      pxp,
      pyp,
      out
    );
    let { ang1, ang2 } = out;
    const { centerX, centerY } = out;
    let ratio = Math.abs(ang2) / (TAU / 4);
    if (Math.abs(1 - ratio) < 1e-7) {
      ratio = 1;
    }
    const segments = Math.max(Math.ceil(ratio), 1);
    ang2 /= segments;
    let lastX = points[points.length - 2];
    let lastY = points[points.length - 1];
    const outCurvePoint = { x: 0, y: 0 };
    for (let i2 = 0; i2 < segments; i2++) {
      const curve = approxUnitArc(ang1, ang2);
      const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
      const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
      const { x: x3, y: y3 } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
      buildAdaptiveBezier(
        points,
        lastX,
        lastY,
        x1,
        y1,
        x2,
        y2,
        x3,
        y3
      );
      lastX = x3;
      lastY = y3;
      ang1 += ang2;
    }
  }
  var TAU, out, mapToEllipse, vectorAngle, getArcCenter;
  var init_buildArcToSvg = __esm({
    "../core/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs"() {
      init_buildAdaptiveBezier();
      TAU = Math.PI * 2;
      out = {
        centerX: 0,
        centerY: 0,
        ang1: 0,
        ang2: 0
      };
      mapToEllipse = ({ x: x2, y: y2 }, rx, ry, cosPhi, sinPhi, centerX, centerY, out2) => {
        x2 *= rx;
        y2 *= ry;
        const xp = cosPhi * x2 - sinPhi * y2;
        const yp = sinPhi * x2 + cosPhi * y2;
        out2.x = xp + centerX;
        out2.y = yp + centerY;
        return out2;
      };
      vectorAngle = (ux2, uy2, vx2, vy2) => {
        const sign = ux2 * vy2 - uy2 * vx2 < 0 ? -1 : 1;
        let dot = ux2 * vx2 + uy2 * vy2;
        if (dot > 1) {
          dot = 1;
        }
        if (dot < -1) {
          dot = -1;
        }
        return sign * Math.acos(dot);
      };
      getArcCenter = (px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, out2) => {
        const rxSq = Math.pow(rx, 2);
        const rySq = Math.pow(ry, 2);
        const pxpSq = Math.pow(pxp, 2);
        const pypSq = Math.pow(pyp, 2);
        let radicant = rxSq * rySq - rxSq * pypSq - rySq * pxpSq;
        if (radicant < 0) {
          radicant = 0;
        }
        radicant /= rxSq * pypSq + rySq * pxpSq;
        radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
        const centerXp = radicant * rx / ry * pyp;
        const centerYp = radicant * -ry / rx * pxp;
        const centerX = cosPhi * centerXp - sinPhi * centerYp + (px + cx) / 2;
        const centerY = sinPhi * centerXp + cosPhi * centerYp + (py + cy) / 2;
        const vx1 = (pxp - centerXp) / rx;
        const vy1 = (pyp - centerYp) / ry;
        const vx2 = (-pxp - centerXp) / rx;
        const vy2 = (-pyp - centerYp) / ry;
        const ang1 = vectorAngle(1, 0, vx1, vy1);
        let ang2 = vectorAngle(vx1, vy1, vx2, vy2);
        if (sweepFlag === 0 && ang2 > 0) {
          ang2 -= TAU;
        }
        if (sweepFlag === 1 && ang2 < 0) {
          ang2 += TAU;
        }
        out2.centerX = centerX;
        out2.centerY = centerY;
        out2.ang1 = ang1;
        out2.ang2 = ang2;
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/graphics/shared/path/roundShape.mjs
  function roundedShapeArc(g2, points, radius) {
    const vecFrom = (p2, pp) => {
      const x2 = pp.x - p2.x;
      const y2 = pp.y - p2.y;
      const len = Math.sqrt(x2 * x2 + y2 * y2);
      const nx = x2 / len;
      const ny = y2 / len;
      return { len, nx, ny };
    };
    const sharpCorner = (i2, p2) => {
      if (i2 === 0) {
        g2.moveTo(p2.x, p2.y);
      } else {
        g2.lineTo(p2.x, p2.y);
      }
    };
    let p1 = points[points.length - 1];
    for (let i2 = 0; i2 < points.length; i2++) {
      const p2 = points[i2 % points.length];
      const pRadius = p2.radius ?? radius;
      if (pRadius <= 0) {
        sharpCorner(i2, p2);
        p1 = p2;
        continue;
      }
      const p3 = points[(i2 + 1) % points.length];
      const v1 = vecFrom(p2, p1);
      const v2 = vecFrom(p2, p3);
      if (v1.len < 1e-4 || v2.len < 1e-4) {
        sharpCorner(i2, p2);
        p1 = p2;
        continue;
      }
      let angle = Math.asin(v1.nx * v2.ny - v1.ny * v2.nx);
      let radDirection = 1;
      let drawDirection = false;
      if (v1.nx * v2.nx - v1.ny * -v2.ny < 0) {
        if (angle < 0) {
          angle = Math.PI + angle;
        } else {
          angle = Math.PI - angle;
          radDirection = -1;
          drawDirection = true;
        }
      } else if (angle > 0) {
        radDirection = -1;
        drawDirection = true;
      }
      const halfAngle = angle / 2;
      let cRadius;
      let lenOut = Math.abs(
        Math.cos(halfAngle) * pRadius / Math.sin(halfAngle)
      );
      if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {
        lenOut = Math.min(v1.len / 2, v2.len / 2);
        cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));
      } else {
        cRadius = pRadius;
      }
      const cX = p2.x + v2.nx * lenOut + -v2.ny * cRadius * radDirection;
      const cY = p2.y + v2.ny * lenOut + v2.nx * cRadius * radDirection;
      const startAngle = Math.atan2(v1.ny, v1.nx) + Math.PI / 2 * radDirection;
      const endAngle = Math.atan2(v2.ny, v2.nx) - Math.PI / 2 * radDirection;
      if (i2 === 0) {
        g2.moveTo(
          cX + Math.cos(startAngle) * cRadius,
          cY + Math.sin(startAngle) * cRadius
        );
      }
      g2.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);
      p1 = p2;
    }
  }
  function roundedShapeQuadraticCurve(g2, points, radius, smoothness) {
    const distance = (p1, p2) => Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
    const pointLerp = (p1, p2, t2) => ({
      x: p1.x + (p2.x - p1.x) * t2,
      y: p1.y + (p2.y - p1.y) * t2
    });
    const numPoints = points.length;
    for (let i2 = 0; i2 < numPoints; i2++) {
      const thisPoint = points[(i2 + 1) % numPoints];
      const pRadius = thisPoint.radius ?? radius;
      if (pRadius <= 0) {
        if (i2 === 0) {
          g2.moveTo(thisPoint.x, thisPoint.y);
        } else {
          g2.lineTo(thisPoint.x, thisPoint.y);
        }
        continue;
      }
      const lastPoint = points[i2];
      const nextPoint = points[(i2 + 2) % numPoints];
      const lastEdgeLength = distance(lastPoint, thisPoint);
      let start;
      if (lastEdgeLength < 1e-4) {
        start = thisPoint;
      } else {
        const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);
        start = pointLerp(
          thisPoint,
          lastPoint,
          lastOffsetDistance / lastEdgeLength
        );
      }
      const nextEdgeLength = distance(nextPoint, thisPoint);
      let end;
      if (nextEdgeLength < 1e-4) {
        end = thisPoint;
      } else {
        const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);
        end = pointLerp(
          thisPoint,
          nextPoint,
          nextOffsetDistance / nextEdgeLength
        );
      }
      if (i2 === 0) {
        g2.moveTo(start.x, start.y);
      } else {
        g2.lineTo(start.x, start.y);
      }
      g2.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);
    }
  }
  var init_roundShape = __esm({
    "../core/node_modules/pixi.js/lib/scene/graphics/shared/path/roundShape.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.mjs
  var tempRectangle, ShapePath;
  var init_ShapePath = __esm({
    "../core/node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.mjs"() {
      init_Circle();
      init_Ellipse();
      init_Polygon();
      init_Rectangle();
      init_RoundedRectangle();
      init_Bounds();
      init_buildAdaptiveBezier();
      init_buildAdaptiveQuadratic();
      init_buildArc();
      init_buildArcTo();
      init_buildArcToSvg();
      init_roundShape();
      tempRectangle = new Rectangle();
      ShapePath = class {
        constructor(graphicsPath2D) {
          this.shapePrimitives = [];
          this._currentPoly = null;
          this._bounds = new Bounds();
          this._graphicsPath2D = graphicsPath2D;
        }
        /**
         * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.
         * @param x - The x-coordinate for the starting point.
         * @param y - The y-coordinate for the starting point.
         * @returns The instance of the current object for chaining.
         */
        moveTo(x2, y2) {
          this.startPoly(x2, y2);
          return this;
        }
        /**
         * Connects the current point to a new point with a straight line. This method updates the current path.
         * @param x - The x-coordinate of the new point to connect to.
         * @param y - The y-coordinate of the new point to connect to.
         * @returns The instance of the current object for chaining.
         */
        lineTo(x2, y2) {
          this._ensurePoly();
          const points = this._currentPoly.points;
          const fromX = points[points.length - 2];
          const fromY = points[points.length - 1];
          if (fromX !== x2 || fromY !== y2) {
            points.push(x2, y2);
          }
          return this;
        }
        /**
         * Adds an arc to the path. The arc is centered at (x, y)
         *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.
         * @param x - The x-coordinate of the arc's center.
         * @param y - The y-coordinate of the arc's center.
         * @param radius - The radius of the arc.
         * @param startAngle - The starting angle of the arc, in radians.
         * @param endAngle - The ending angle of the arc, in radians.
         * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.
         * @returns The instance of the current object for chaining.
         */
        arc(x2, y2, radius, startAngle, endAngle, counterclockwise) {
          this._ensurePoly(false);
          const points = this._currentPoly.points;
          buildArc(points, x2, y2, radius, startAngle, endAngle, counterclockwise);
          return this;
        }
        /**
         * Adds an arc to the path with the arc tangent to the line joining two specified points.
         * The arc radius is specified by `radius`.
         * @param x1 - The x-coordinate of the first point.
         * @param y1 - The y-coordinate of the first point.
         * @param x2 - The x-coordinate of the second point.
         * @param y2 - The y-coordinate of the second point.
         * @param radius - The radius of the arc.
         * @returns The instance of the current object for chaining.
         */
        arcTo(x1, y1, x2, y2, radius) {
          this._ensurePoly();
          const points = this._currentPoly.points;
          buildArcTo(points, x1, y1, x2, y2, radius);
          return this;
        }
        /**
         * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.
         * @param rx - The x-radius of the ellipse.
         * @param ry - The y-radius of the ellipse.
         * @param xAxisRotation - The rotation of the ellipse's x-axis relative
         * to the x-axis of the coordinate system, in degrees.
         * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.
         * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.
         * @param x - The x-coordinate of the arc's end point.
         * @param y - The y-coordinate of the arc's end point.
         * @returns The instance of the current object for chaining.
         */
        arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x2, y2) {
          const points = this._currentPoly.points;
          buildArcToSvg(
            points,
            this._currentPoly.lastX,
            this._currentPoly.lastY,
            x2,
            y2,
            rx,
            ry,
            xAxisRotation,
            largeArcFlag,
            sweepFlag
          );
          return this;
        }
        /**
         * Adds a cubic Bezier curve to the path.
         * It requires three points: the first two are control points and the third one is the end point.
         * The starting point is the last point in the current path.
         * @param cp1x - The x-coordinate of the first control point.
         * @param cp1y - The y-coordinate of the first control point.
         * @param cp2x - The x-coordinate of the second control point.
         * @param cp2y - The y-coordinate of the second control point.
         * @param x - The x-coordinate of the end point.
         * @param y - The y-coordinate of the end point.
         * @param smoothness - Optional parameter to adjust the smoothness of the curve.
         * @returns The instance of the current object for chaining.
         */
        bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y2, smoothness) {
          this._ensurePoly();
          const currentPoly = this._currentPoly;
          buildAdaptiveBezier(
            this._currentPoly.points,
            currentPoly.lastX,
            currentPoly.lastY,
            cp1x,
            cp1y,
            cp2x,
            cp2y,
            x2,
            y2,
            smoothness
          );
          return this;
        }
        /**
         * Adds a quadratic curve to the path. It requires two points: the control point and the end point.
         * The starting point is the last point in the current path.
         * @param cp1x - The x-coordinate of the control point.
         * @param cp1y - The y-coordinate of the control point.
         * @param x - The x-coordinate of the end point.
         * @param y - The y-coordinate of the end point.
         * @param smoothing - Optional parameter to adjust the smoothness of the curve.
         * @returns The instance of the current object for chaining.
         */
        quadraticCurveTo(cp1x, cp1y, x2, y2, smoothing) {
          this._ensurePoly();
          const currentPoly = this._currentPoly;
          buildAdaptiveQuadratic(
            this._currentPoly.points,
            currentPoly.lastX,
            currentPoly.lastY,
            cp1x,
            cp1y,
            x2,
            y2,
            smoothing
          );
          return this;
        }
        /**
         * Closes the current path by drawing a straight line back to the start.
         * If the shape is already closed or there are no points in the path, this method does nothing.
         * @returns The instance of the current object for chaining.
         */
        closePath() {
          this.endPoly(true);
          return this;
        }
        /**
         * Adds another path to the current path. This method allows for the combination of multiple paths into one.
         * @param path - The `GraphicsPath` object representing the path to add.
         * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.
         * @returns The instance of the current object for chaining.
         */
        addPath(path2, transform2) {
          this.endPoly();
          if (transform2 && !transform2.isIdentity()) {
            path2 = path2.clone(true);
            path2.transform(transform2);
          }
          for (let i2 = 0; i2 < path2.instructions.length; i2++) {
            const instruction = path2.instructions[i2];
            this[instruction.action](...instruction.data);
          }
          return this;
        }
        /**
         * Finalizes the drawing of the current path. Optionally, it can close the path.
         * @param closePath - A boolean indicating whether to close the path after finishing. False by default.
         */
        finish(closePath = false) {
          this.endPoly(closePath);
        }
        /**
         * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
         * @param x - The x-coordinate of the top-left corner of the rectangle.
         * @param y - The y-coordinate of the top-left corner of the rectangle.
         * @param w - The width of the rectangle.
         * @param h - The height of the rectangle.
         * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
         * @returns The instance of the current object for chaining.
         */
        rect(x2, y2, w2, h2, transform2) {
          this.drawShape(new Rectangle(x2, y2, w2, h2), transform2);
          return this;
        }
        /**
         * Draws a circle shape. This method adds a new circle path to the current drawing.
         * @param x - The x-coordinate of the center of the circle.
         * @param y - The y-coordinate of the center of the circle.
         * @param radius - The radius of the circle.
         * @param transform - An optional `Matrix` object to apply a transformation to the circle.
         * @returns The instance of the current object for chaining.
         */
        circle(x2, y2, radius, transform2) {
          this.drawShape(new Circle(x2, y2, radius), transform2);
          return this;
        }
        /**
         * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.
         * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]
         * representing the x and y coordinates of the polygon's vertices, in sequence.
         * @param close - A boolean indicating whether to close the polygon path. True by default.
         * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
         * @returns The instance of the current object for chaining.
         */
        poly(points, close, transform2) {
          const polygon = new Polygon(points);
          polygon.closePath = close;
          this.drawShape(polygon, transform2);
          return this;
        }
        /**
         * Draws a regular polygon with a specified number of sides. All sides and angles are equal.
         * @param x - The x-coordinate of the center of the polygon.
         * @param y - The y-coordinate of the center of the polygon.
         * @param radius - The radius of the circumscribed circle of the polygon.
         * @param sides - The number of sides of the polygon. Must be 3 or more.
         * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
         * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
         * @returns The instance of the current object for chaining.
         */
        regularPoly(x2, y2, radius, sides, rotation = 0, transform2) {
          sides = Math.max(sides | 0, 3);
          const startAngle = -1 * Math.PI / 2 + rotation;
          const delta = Math.PI * 2 / sides;
          const polygon = [];
          for (let i2 = 0; i2 < sides; i2++) {
            const angle = i2 * delta + startAngle;
            polygon.push(
              x2 + radius * Math.cos(angle),
              y2 + radius * Math.sin(angle)
            );
          }
          this.poly(polygon, true, transform2);
          return this;
        }
        /**
         * Draws a polygon with rounded corners.
         * Similar to `regularPoly` but with the ability to round the corners of the polygon.
         * @param x - The x-coordinate of the center of the polygon.
         * @param y - The y-coordinate of the center of the polygon.
         * @param radius - The radius of the circumscribed circle of the polygon.
         * @param sides - The number of sides of the polygon. Must be 3 or more.
         * @param corner - The radius of the rounding of the corners.
         * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
         * @param smoothness - Optional parameter to adjust the smoothness of the rounding.
         * @returns The instance of the current object for chaining.
         */
        roundPoly(x2, y2, radius, sides, corner, rotation = 0, smoothness) {
          sides = Math.max(sides | 0, 3);
          if (corner <= 0) {
            return this.regularPoly(x2, y2, radius, sides, rotation);
          }
          const sideLength = radius * Math.sin(Math.PI / sides) - 1e-3;
          corner = Math.min(corner, sideLength);
          const startAngle = -1 * Math.PI / 2 + rotation;
          const delta = Math.PI * 2 / sides;
          const internalAngle = (sides - 2) * Math.PI / sides / 2;
          for (let i2 = 0; i2 < sides; i2++) {
            const angle = i2 * delta + startAngle;
            const x0 = x2 + radius * Math.cos(angle);
            const y0 = y2 + radius * Math.sin(angle);
            const a1 = angle + Math.PI + internalAngle;
            const a2 = angle - Math.PI - internalAngle;
            const x1 = x0 + corner * Math.cos(a1);
            const y1 = y0 + corner * Math.sin(a1);
            const x3 = x0 + corner * Math.cos(a2);
            const y3 = y0 + corner * Math.sin(a2);
            if (i2 === 0) {
              this.moveTo(x1, y1);
            } else {
              this.lineTo(x1, y1);
            }
            this.quadraticCurveTo(x0, y0, x3, y3, smoothness);
          }
          return this.closePath();
        }
        /**
         * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.
         * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.
         * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.
         * A minimum of 3 points is required.
         * @param radius - The default radius for the corners.
         * This radius is applied to all corners unless overridden in `points`.
         * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve
         *  method instead of an arc method. Defaults to false.
         * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.
         * Higher values make the curve smoother.
         * @returns The instance of the current object for chaining.
         */
        roundShape(points, radius, useQuadratic = false, smoothness) {
          if (points.length < 3) {
            return this;
          }
          if (useQuadratic) {
            roundedShapeQuadraticCurve(this, points, radius, smoothness);
          } else {
            roundedShapeArc(this, points, radius);
          }
          return this.closePath();
        }
        /**
         * Draw Rectangle with fillet corners. This is much like rounded rectangle
         * however it support negative numbers as well for the corner radius.
         * @param x - Upper left corner of rect
         * @param y - Upper right corner of rect
         * @param width - Width of rect
         * @param height - Height of rect
         * @param fillet - accept negative or positive values
         */
        filletRect(x2, y2, width, height, fillet) {
          if (fillet === 0) {
            return this.rect(x2, y2, width, height);
          }
          const maxFillet = Math.min(width, height) / 2;
          const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));
          const right = x2 + width;
          const bottom = y2 + height;
          const dir = inset < 0 ? -inset : 0;
          const size = Math.abs(inset);
          return this.moveTo(x2, y2 + size).arcTo(x2 + dir, y2 + dir, x2 + size, y2, size).lineTo(right - size, y2).arcTo(right - dir, y2 + dir, right, y2 + size, size).lineTo(right, bottom - size).arcTo(right - dir, bottom - dir, x2 + width - size, bottom, size).lineTo(x2 + size, bottom).arcTo(x2 + dir, bottom - dir, x2, bottom - size, size).closePath();
        }
        /**
         * Draw Rectangle with chamfer corners. These are angled corners.
         * @param x - Upper left corner of rect
         * @param y - Upper right corner of rect
         * @param width - Width of rect
         * @param height - Height of rect
         * @param chamfer - non-zero real number, size of corner cutout
         * @param transform
         */
        chamferRect(x2, y2, width, height, chamfer, transform2) {
          if (chamfer <= 0) {
            return this.rect(x2, y2, width, height);
          }
          const inset = Math.min(chamfer, Math.min(width, height) / 2);
          const right = x2 + width;
          const bottom = y2 + height;
          const points = [
            x2 + inset,
            y2,
            right - inset,
            y2,
            right,
            y2 + inset,
            right,
            bottom - inset,
            right - inset,
            bottom,
            x2 + inset,
            bottom,
            x2,
            bottom - inset,
            x2,
            y2 + inset
          ];
          for (let i2 = points.length - 1; i2 >= 2; i2 -= 2) {
            if (points[i2] === points[i2 - 2] && points[i2 - 1] === points[i2 - 3]) {
              points.splice(i2 - 1, 2);
            }
          }
          return this.poly(points, true, transform2);
        }
        /**
         * Draws an ellipse at the specified location and with the given x and y radii.
         * An optional transformation can be applied, allowing for rotation, scaling, and translation.
         * @param x - The x-coordinate of the center of the ellipse.
         * @param y - The y-coordinate of the center of the ellipse.
         * @param radiusX - The horizontal radius of the ellipse.
         * @param radiusY - The vertical radius of the ellipse.
         * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.
         * @returns The instance of the current object for chaining.
         */
        ellipse(x2, y2, radiusX, radiusY, transform2) {
          this.drawShape(new Ellipse(x2, y2, radiusX, radiusY), transform2);
          return this;
        }
        /**
         * Draws a rectangle with rounded corners.
         * The corner radius can be specified to determine how rounded the corners should be.
         * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.
         * @param x - The x-coordinate of the top-left corner of the rectangle.
         * @param y - The y-coordinate of the top-left corner of the rectangle.
         * @param w - The width of the rectangle.
         * @param h - The height of the rectangle.
         * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.
         * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
         * @returns The instance of the current object for chaining.
         */
        roundRect(x2, y2, w2, h2, radius, transform2) {
          this.drawShape(new RoundedRectangle(x2, y2, w2, h2, radius), transform2);
          return this;
        }
        /**
         * Draws a given shape on the canvas.
         * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.
         * An optional transformation matrix can be applied to the shape, allowing for complex transformations.
         * @param shape - The shape to draw, defined as a `ShapePrimitive` object.
         * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,
         * scaling, and translations.
         * @returns The instance of the current object for chaining.
         */
        drawShape(shape, matrix) {
          this.endPoly();
          this.shapePrimitives.push({ shape, transform: matrix });
          return this;
        }
        /**
         * Starts a new polygon path from the specified starting point.
         * This method initializes a new polygon or ends the current one if it exists.
         * @param x - The x-coordinate of the starting point of the new polygon.
         * @param y - The y-coordinate of the starting point of the new polygon.
         * @returns The instance of the current object for chaining.
         */
        startPoly(x2, y2) {
          let currentPoly = this._currentPoly;
          if (currentPoly) {
            this.endPoly();
          }
          currentPoly = new Polygon();
          currentPoly.points.push(x2, y2);
          this._currentPoly = currentPoly;
          return this;
        }
        /**
         * Ends the current polygon path. If `closePath` is set to true,
         * the path is closed by connecting the last point to the first one.
         * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.
         * @param closePath - A boolean indicating whether to close the polygon by connecting the last point
         *  back to the starting point. False by default.
         * @returns The instance of the current object for chaining.
         */
        endPoly(closePath = false) {
          const shape = this._currentPoly;
          if (shape && shape.points.length > 2) {
            shape.closePath = closePath;
            this.shapePrimitives.push({ shape });
          }
          this._currentPoly = null;
          return this;
        }
        _ensurePoly(start = true) {
          if (this._currentPoly)
            return;
          this._currentPoly = new Polygon();
          if (start) {
            const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];
            if (lastShape) {
              let lx = lastShape.shape.x;
              let ly = lastShape.shape.y;
              if (!lastShape.transform.isIdentity()) {
                const t2 = lastShape.transform;
                const tempX = lx;
                lx = t2.a * lx + t2.c * ly + t2.tx;
                ly = t2.b * tempX + t2.d * ly + t2.ty;
              }
              this._currentPoly.points.push(lx, ly);
            } else {
              this._currentPoly.points.push(0, 0);
            }
          }
        }
        /** Builds the path. */
        buildPath() {
          const path2 = this._graphicsPath2D;
          this.shapePrimitives.length = 0;
          this._currentPoly = null;
          for (let i2 = 0; i2 < path2.instructions.length; i2++) {
            const instruction = path2.instructions[i2];
            this[instruction.action](...instruction.data);
          }
          this.finish();
        }
        /** Gets the bounds of the path. */
        get bounds() {
          const bounds = this._bounds;
          bounds.clear();
          const shapePrimitives = this.shapePrimitives;
          for (let i2 = 0; i2 < shapePrimitives.length; i2++) {
            const shapePrimitive = shapePrimitives[i2];
            const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);
            if (shapePrimitive.transform) {
              bounds.addRect(boundsRect, shapePrimitive.transform);
            } else {
              bounds.addRect(boundsRect);
            }
          }
          return bounds;
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs
  function adjustTransform(currentMatrix, transform2) {
    if (currentMatrix) {
      return currentMatrix.prepend(transform2);
    }
    return transform2.clone();
  }
  var GraphicsPath;
  var init_GraphicsPath = __esm({
    "../core/node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs"() {
      init_Point();
      init_uid();
      init_warn();
      init_SVGToGraphicsPath();
      init_ShapePath();
      GraphicsPath = class {
        /**
         * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.
         * @param instructions - An SVG path string or an array of `PathInstruction` objects.
         */
        constructor(instructions) {
          this.instructions = [];
          this.uid = uid("graphicsPath");
          this._dirty = true;
          if (typeof instructions === "string") {
            SVGToGraphicsPath(instructions, this);
          } else {
            this.instructions = instructions?.slice() ?? [];
          }
        }
        /**
         * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.
         * @returns The `ShapePath` instance associated with this `GraphicsPath`.
         */
        get shapePath() {
          if (!this._shapePath) {
            this._shapePath = new ShapePath(this);
          }
          if (this._dirty) {
            this._dirty = false;
            this._shapePath.buildPath();
          }
          return this._shapePath;
        }
        /**
         * Adds another `GraphicsPath` to this path, optionally applying a transformation.
         * @param path - The `GraphicsPath` to add.
         * @param transform - An optional transformation to apply to the added path.
         * @returns The instance of the current object for chaining.
         */
        addPath(path2, transform2) {
          path2 = path2.clone();
          this.instructions.push({ action: "addPath", data: [path2, transform2] });
          this._dirty = true;
          return this;
        }
        arc(...args) {
          this.instructions.push({ action: "arc", data: args });
          this._dirty = true;
          return this;
        }
        arcTo(...args) {
          this.instructions.push({ action: "arcTo", data: args });
          this._dirty = true;
          return this;
        }
        arcToSvg(...args) {
          this.instructions.push({ action: "arcToSvg", data: args });
          this._dirty = true;
          return this;
        }
        bezierCurveTo(...args) {
          this.instructions.push({ action: "bezierCurveTo", data: args });
          this._dirty = true;
          return this;
        }
        /**
         * Adds a cubic Bezier curve to the path.
         * It requires two points: the second control point and the end point. The first control point is assumed to be
         * The starting point is the last point in the current path.
         * @param cp2x - The x-coordinate of the second control point.
         * @param cp2y - The y-coordinate of the second control point.
         * @param x - The x-coordinate of the end point.
         * @param y - The y-coordinate of the end point.
         * @param smoothness - Optional parameter to adjust the smoothness of the curve.
         * @returns The instance of the current object for chaining.
         */
        bezierCurveToShort(cp2x, cp2y, x2, y2, smoothness) {
          const last3 = this.instructions[this.instructions.length - 1];
          const lastPoint = this.getLastPoint(Point.shared);
          let cp1x = 0;
          let cp1y = 0;
          if (!last3 || last3.action !== "bezierCurveTo") {
            cp1x = lastPoint.x;
            cp1y = lastPoint.y;
          } else {
            cp1x = last3.data[2];
            cp1y = last3.data[3];
            const currentX = lastPoint.x;
            const currentY = lastPoint.y;
            cp1x = currentX + (currentX - cp1x);
            cp1y = currentY + (currentY - cp1y);
          }
          this.instructions.push({ action: "bezierCurveTo", data: [cp1x, cp1y, cp2x, cp2y, x2, y2, smoothness] });
          this._dirty = true;
          return this;
        }
        /**
         * Closes the current path by drawing a straight line back to the start.
         * If the shape is already closed or there are no points in the path, this method does nothing.
         * @returns The instance of the current object for chaining.
         */
        closePath() {
          this.instructions.push({ action: "closePath", data: [] });
          this._dirty = true;
          return this;
        }
        ellipse(...args) {
          this.instructions.push({ action: "ellipse", data: args });
          this._dirty = true;
          return this;
        }
        lineTo(...args) {
          this.instructions.push({ action: "lineTo", data: args });
          this._dirty = true;
          return this;
        }
        moveTo(...args) {
          this.instructions.push({ action: "moveTo", data: args });
          return this;
        }
        quadraticCurveTo(...args) {
          this.instructions.push({ action: "quadraticCurveTo", data: args });
          this._dirty = true;
          return this;
        }
        /**
         * Adds a quadratic curve to the path. It uses the previous point as the control point.
         * @param x - The x-coordinate of the end point.
         * @param y - The y-coordinate of the end point.
         * @param smoothness - Optional parameter to adjust the smoothness of the curve.
         * @returns The instance of the current object for chaining.
         */
        quadraticCurveToShort(x2, y2, smoothness) {
          const last3 = this.instructions[this.instructions.length - 1];
          const lastPoint = this.getLastPoint(Point.shared);
          let cpx1 = 0;
          let cpy1 = 0;
          if (!last3 || last3.action !== "quadraticCurveTo") {
            cpx1 = lastPoint.x;
            cpy1 = lastPoint.y;
          } else {
            cpx1 = last3.data[0];
            cpy1 = last3.data[1];
            const currentX = lastPoint.x;
            const currentY = lastPoint.y;
            cpx1 = currentX + (currentX - cpx1);
            cpy1 = currentY + (currentY - cpy1);
          }
          this.instructions.push({ action: "quadraticCurveTo", data: [cpx1, cpy1, x2, y2, smoothness] });
          this._dirty = true;
          return this;
        }
        /**
         * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
         * @param x - The x-coordinate of the top-left corner of the rectangle.
         * @param y - The y-coordinate of the top-left corner of the rectangle.
         * @param w - The width of the rectangle.
         * @param h - The height of the rectangle.
         * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
         * @returns The instance of the current object for chaining.
         */
        rect(x2, y2, w2, h2, transform2) {
          this.instructions.push({ action: "rect", data: [x2, y2, w2, h2, transform2] });
          this._dirty = true;
          return this;
        }
        /**
         * Draws a circle shape. This method adds a new circle path to the current drawing.
         * @param x - The x-coordinate of the center of the circle.
         * @param y - The y-coordinate of the center of the circle.
         * @param radius - The radius of the circle.
         * @param transform - An optional `Matrix` object to apply a transformation to the circle.
         * @returns The instance of the current object for chaining.
         */
        circle(x2, y2, radius, transform2) {
          this.instructions.push({ action: "circle", data: [x2, y2, radius, transform2] });
          this._dirty = true;
          return this;
        }
        roundRect(...args) {
          this.instructions.push({ action: "roundRect", data: args });
          this._dirty = true;
          return this;
        }
        poly(...args) {
          this.instructions.push({ action: "poly", data: args });
          this._dirty = true;
          return this;
        }
        regularPoly(...args) {
          this.instructions.push({ action: "regularPoly", data: args });
          this._dirty = true;
          return this;
        }
        roundPoly(...args) {
          this.instructions.push({ action: "roundPoly", data: args });
          this._dirty = true;
          return this;
        }
        roundShape(...args) {
          this.instructions.push({ action: "roundShape", data: args });
          this._dirty = true;
          return this;
        }
        filletRect(...args) {
          this.instructions.push({ action: "filletRect", data: args });
          this._dirty = true;
          return this;
        }
        chamferRect(...args) {
          this.instructions.push({ action: "chamferRect", data: args });
          this._dirty = true;
          return this;
        }
        /**
         * Draws a star shape centered at a specified location. This method allows for the creation
         *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.
         * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.
         * An optional transformation can be applied to scale, rotate, or translate the star as needed.
         * @param x - The x-coordinate of the center of the star.
         * @param y - The y-coordinate of the center of the star.
         * @param points - The number of points of the star.
         * @param radius - The outer radius of the star (distance from the center to the outer points).
         * @param innerRadius - Optional. The inner radius of the star
         * (distance from the center to the inner points between the outer points).
         * If not provided, defaults to half of the `radius`.
         * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.
         * Defaults to 0, meaning one point is directly upward.
         * @param transform - An optional `Matrix` object to apply a transformation to the star.
         * This can include rotations, scaling, and translations.
         * @returns The instance of the current object for chaining further drawing commands.
         */
        // eslint-disable-next-line max-len
        star(x2, y2, points, radius, innerRadius, rotation, transform2) {
          innerRadius = innerRadius || radius / 2;
          const startAngle = -1 * Math.PI / 2 + rotation;
          const len = points * 2;
          const delta = Math.PI * 2 / len;
          const polygon = [];
          for (let i2 = 0; i2 < len; i2++) {
            const r2 = i2 % 2 ? innerRadius : radius;
            const angle = i2 * delta + startAngle;
            polygon.push(
              x2 + r2 * Math.cos(angle),
              y2 + r2 * Math.sin(angle)
            );
          }
          this.poly(polygon, true, transform2);
          return this;
        }
        /**
         * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.
         * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and
         * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`
         * do not affect the original `GraphicsPath` and vice versa.
         * @param deep - A boolean flag indicating whether the clone should be deep.
         * @returns A new `GraphicsPath` instance that is a clone of the current instance.
         */
        clone(deep = false) {
          const newGraphicsPath2D = new GraphicsPath();
          if (!deep) {
            newGraphicsPath2D.instructions = this.instructions.slice();
          } else {
            for (let i2 = 0; i2 < this.instructions.length; i2++) {
              const instruction = this.instructions[i2];
              newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });
            }
          }
          return newGraphicsPath2D;
        }
        clear() {
          this.instructions.length = 0;
          this._dirty = true;
          return this;
        }
        /**
         * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.
         * This method enables the modification of the path's geometry according to the provided
         * transformation matrix, which can include translations, rotations, scaling, and skewing.
         *
         * Each drawing instruction in the path is updated to reflect the transformation,
         * ensuring the visual representation of the path is consistent with the applied matrix.
         *
         * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,
         * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,
         * allowing for fine-grained control over the path's appearance.
         * @param matrix - A `Matrix` object representing the transformation to apply.
         * @returns The instance of the current object for chaining further operations.
         */
        transform(matrix) {
          if (matrix.isIdentity())
            return this;
          const a2 = matrix.a;
          const b2 = matrix.b;
          const c2 = matrix.c;
          const d2 = matrix.d;
          const tx = matrix.tx;
          const ty = matrix.ty;
          let x2 = 0;
          let y2 = 0;
          let cpx1 = 0;
          let cpy1 = 0;
          let cpx2 = 0;
          let cpy2 = 0;
          let rx = 0;
          let ry = 0;
          for (let i2 = 0; i2 < this.instructions.length; i2++) {
            const instruction = this.instructions[i2];
            const data = instruction.data;
            switch (instruction.action) {
              case "moveTo":
              case "lineTo":
                x2 = data[0];
                y2 = data[1];
                data[0] = a2 * x2 + c2 * y2 + tx;
                data[1] = b2 * x2 + d2 * y2 + ty;
                break;
              case "bezierCurveTo":
                cpx1 = data[0];
                cpy1 = data[1];
                cpx2 = data[2];
                cpy2 = data[3];
                x2 = data[4];
                y2 = data[5];
                data[0] = a2 * cpx1 + c2 * cpy1 + tx;
                data[1] = b2 * cpx1 + d2 * cpy1 + ty;
                data[2] = a2 * cpx2 + c2 * cpy2 + tx;
                data[3] = b2 * cpx2 + d2 * cpy2 + ty;
                data[4] = a2 * x2 + c2 * y2 + tx;
                data[5] = b2 * x2 + d2 * y2 + ty;
                break;
              case "quadraticCurveTo":
                cpx1 = data[0];
                cpy1 = data[1];
                x2 = data[2];
                y2 = data[3];
                data[0] = a2 * cpx1 + c2 * cpy1 + tx;
                data[1] = b2 * cpx1 + d2 * cpy1 + ty;
                data[2] = a2 * x2 + c2 * y2 + tx;
                data[3] = b2 * x2 + d2 * y2 + ty;
                break;
              case "arcToSvg":
                x2 = data[5];
                y2 = data[6];
                rx = data[0];
                ry = data[1];
                data[0] = a2 * rx + c2 * ry;
                data[1] = b2 * rx + d2 * ry;
                data[5] = a2 * x2 + c2 * y2 + tx;
                data[6] = b2 * x2 + d2 * y2 + ty;
                break;
              case "circle":
                data[4] = adjustTransform(data[3], matrix);
                break;
              case "rect":
                data[4] = adjustTransform(data[4], matrix);
                break;
              case "ellipse":
                data[8] = adjustTransform(data[8], matrix);
                break;
              case "roundRect":
                data[5] = adjustTransform(data[5], matrix);
                break;
              case "addPath":
                data[0].transform(matrix);
                break;
              case "poly":
                data[2] = adjustTransform(data[2], matrix);
                break;
              default:
                warn("unknown transform action", instruction.action);
                break;
            }
          }
          this._dirty = true;
          return this;
        }
        get bounds() {
          return this.shapePath.bounds;
        }
        /**
         * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.
         * This method is useful for operations that depend on the path's current endpoint,
         * such as connecting subsequent shapes or paths. It supports various drawing instructions,
         * ensuring the last point's position is accurately determined regardless of the path's complexity.
         *
         * If the last instruction is a `closePath`, the method iterates backward through the instructions
         *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,
         * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves
         * the last point from the nested path.
         * @param out - A `Point` object where the last point's coordinates will be stored.
         * This object is modified directly to contain the result.
         * @returns The `Point` object containing the last point's coordinates.
         */
        getLastPoint(out2) {
          let index = this.instructions.length - 1;
          let lastInstruction = this.instructions[index];
          if (!lastInstruction) {
            out2.x = 0;
            out2.y = 0;
            return out2;
          }
          while (lastInstruction.action === "closePath") {
            index--;
            if (index < 0) {
              out2.x = 0;
              out2.y = 0;
              return out2;
            }
            lastInstruction = this.instructions[index];
          }
          switch (lastInstruction.action) {
            case "moveTo":
            case "lineTo":
              out2.x = lastInstruction.data[0];
              out2.y = lastInstruction.data[1];
              break;
            case "quadraticCurveTo":
              out2.x = lastInstruction.data[2];
              out2.y = lastInstruction.data[3];
              break;
            case "bezierCurveTo":
              out2.x = lastInstruction.data[4];
              out2.y = lastInstruction.data[5];
              break;
            case "arc":
            case "arcToSvg":
              out2.x = lastInstruction.data[5];
              out2.y = lastInstruction.data[6];
              break;
            case "addPath":
              lastInstruction.data[0].getLastPoint(out2);
              break;
          }
          return out2;
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.mjs
  function SVGParser(svg, graphicsContext) {
    if (typeof svg === "string") {
      const div = document.createElement("div");
      div.innerHTML = svg.trim();
      svg = div.querySelector("svg");
    }
    const session = {
      context: graphicsContext,
      path: new GraphicsPath()
    };
    renderChildren(svg, session, null, null);
    return graphicsContext;
  }
  function renderChildren(svg, session, fillStyle, strokeStyle) {
    const children2 = svg.children;
    const { fillStyle: f1, strokeStyle: s1 } = parseStyle(svg);
    if (f1 && fillStyle) {
      fillStyle = { ...fillStyle, ...f1 };
    } else if (f1) {
      fillStyle = f1;
    }
    if (s1 && strokeStyle) {
      strokeStyle = { ...strokeStyle, ...s1 };
    } else if (s1) {
      strokeStyle = s1;
    }
    session.context.fillStyle = fillStyle;
    session.context.strokeStyle = strokeStyle;
    let x2;
    let y2;
    let x1;
    let y1;
    let x22;
    let y22;
    let cx;
    let cy;
    let r2;
    let rx;
    let ry;
    let points;
    let pointsString;
    let d2;
    let graphicsPath;
    let width;
    let height;
    switch (svg.nodeName.toLowerCase()) {
      case "path":
        d2 = svg.getAttribute("d");
        graphicsPath = new GraphicsPath(d2);
        session.context.path(graphicsPath);
        if (fillStyle)
          session.context.fill();
        if (strokeStyle)
          session.context.stroke();
        break;
      case "circle":
        cx = parseFloatAttribute(svg, "cx", 0);
        cy = parseFloatAttribute(svg, "cy", 0);
        r2 = parseFloatAttribute(svg, "r", 0);
        session.context.ellipse(cx, cy, r2, r2);
        if (fillStyle)
          session.context.fill();
        if (strokeStyle)
          session.context.stroke();
        break;
      case "rect":
        x2 = parseFloatAttribute(svg, "x", 0);
        y2 = parseFloatAttribute(svg, "y", 0);
        width = parseFloatAttribute(svg, "width", 0);
        height = parseFloatAttribute(svg, "height", 0);
        rx = parseFloatAttribute(svg, "rx", 0);
        ry = parseFloatAttribute(svg, "ry", 0);
        if (rx || ry) {
          session.context.roundRect(x2, y2, width, height, rx || ry);
        } else {
          session.context.rect(x2, y2, width, height);
        }
        if (fillStyle)
          session.context.fill();
        if (strokeStyle)
          session.context.stroke();
        break;
      case "ellipse":
        cx = parseFloatAttribute(svg, "cx", 0);
        cy = parseFloatAttribute(svg, "cy", 0);
        rx = parseFloatAttribute(svg, "rx", 0);
        ry = parseFloatAttribute(svg, "ry", 0);
        session.context.beginPath();
        session.context.ellipse(cx, cy, rx, ry);
        if (fillStyle)
          session.context.fill();
        if (strokeStyle)
          session.context.stroke();
        break;
      case "line":
        x1 = parseFloatAttribute(svg, "x1", 0);
        y1 = parseFloatAttribute(svg, "y1", 0);
        x22 = parseFloatAttribute(svg, "x2", 0);
        y22 = parseFloatAttribute(svg, "y2", 0);
        session.context.beginPath();
        session.context.moveTo(x1, y1);
        session.context.lineTo(x22, y22);
        if (strokeStyle)
          session.context.stroke();
        break;
      case "polygon":
        pointsString = svg.getAttribute("points");
        points = pointsString.match(/\d+/g).map((n2) => parseInt(n2, 10));
        session.context.poly(points, true);
        if (fillStyle)
          session.context.fill();
        if (strokeStyle)
          session.context.stroke();
        break;
      case "polyline":
        pointsString = svg.getAttribute("points");
        points = pointsString.match(/\d+/g).map((n2) => parseInt(n2, 10));
        session.context.poly(points, false);
        if (strokeStyle)
          session.context.stroke();
        break;
      case "g":
      case "svg":
        break;
      default: {
        console.info(`[SVG parser] <${svg.nodeName}> elements unsupported`);
        break;
      }
    }
    for (let i2 = 0; i2 < children2.length; i2++) {
      renderChildren(children2[i2], session, fillStyle, strokeStyle);
    }
  }
  function parseFloatAttribute(svg, id, defaultValue2) {
    const value = svg.getAttribute(id);
    return value ? Number(value) : defaultValue2;
  }
  function parseStyle(svg) {
    const style = svg.getAttribute("style");
    const strokeStyle = {};
    const fillStyle = {};
    let useFill = false;
    let useStroke = false;
    if (style) {
      const styleParts = style.split(";");
      for (let i2 = 0; i2 < styleParts.length; i2++) {
        const stylePart = styleParts[i2];
        const [key, value] = stylePart.split(":");
        switch (key) {
          case "stroke":
            if (value !== "none") {
              strokeStyle.color = Color.shared.setValue(value).toNumber();
              useStroke = true;
            }
            break;
          case "stroke-width":
            strokeStyle.width = Number(value);
            break;
          case "fill":
            if (value !== "none") {
              useFill = true;
              fillStyle.color = Color.shared.setValue(value).toNumber();
            }
            break;
          case "fill-opacity":
            fillStyle.alpha = Number(value);
            break;
          case "stroke-opacity":
            strokeStyle.alpha = Number(value);
            break;
          case "opacity":
            fillStyle.alpha = Number(value);
            strokeStyle.alpha = Number(value);
            break;
        }
      }
    } else {
      const stroke = svg.getAttribute("stroke");
      if (stroke && stroke !== "none") {
        useStroke = true;
        strokeStyle.color = Color.shared.setValue(stroke).toNumber();
        strokeStyle.width = parseFloatAttribute(svg, "stroke-width", 1);
      }
      const fill = svg.getAttribute("fill");
      if (fill && fill !== "none") {
        useFill = true;
        fillStyle.color = Color.shared.setValue(fill).toNumber();
      }
    }
    return {
      strokeStyle: useStroke ? strokeStyle : null,
      fillStyle: useFill ? fillStyle : null
    };
  }
  var init_SVGParser = __esm({
    "../core/node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.mjs"() {
      init_Color();
      init_GraphicsPath();
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.mjs
  var repetitionMap, FillPattern;
  var init_FillPattern = __esm({
    "../core/node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.mjs"() {
      init_Matrix();
      init_uid();
      repetitionMap = {
        repeat: {
          addressModeU: "repeat",
          addressModeV: "repeat"
        },
        "repeat-x": {
          addressModeU: "repeat",
          addressModeV: "clamp-to-edge"
        },
        "repeat-y": {
          addressModeU: "clamp-to-edge",
          addressModeV: "repeat"
        },
        "no-repeat": {
          addressModeU: "clamp-to-edge",
          addressModeV: "clamp-to-edge"
        }
      };
      FillPattern = class {
        constructor(texture, repetition) {
          this.uid = uid("fillPattern");
          this.transform = new Matrix();
          this.texture = texture;
          this.transform.scale(
            1 / texture.frame.width,
            1 / texture.frame.height
          );
          if (repetition) {
            texture.source.style.addressModeU = repetitionMap[repetition].addressModeU;
            texture.source.style.addressModeV = repetitionMap[repetition].addressModeV;
          }
        }
        setTransform(transform2) {
          const texture = this.texture;
          this.transform.copyFrom(transform2);
          this.transform.invert();
          this.transform.scale(
            1 / texture.frame.width,
            1 / texture.frame.height
          );
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs
  function convertFillInputToFillStyle(value, defaultStyle) {
    if (value === void 0 || value === null) {
      return null;
    }
    let fillStyleToParse;
    let styleToMerge;
    if (value?.fill) {
      styleToMerge = value.fill;
      fillStyleToParse = { ...defaultStyle, ...value };
    } else {
      styleToMerge = value;
      fillStyleToParse = defaultStyle;
    }
    if (Color.isColorLike(styleToMerge)) {
      const temp = Color.shared.setValue(styleToMerge ?? 0);
      const opts = {
        ...fillStyleToParse,
        color: temp.toNumber(),
        alpha: temp.alpha === 1 ? fillStyleToParse.alpha : temp.alpha,
        texture: Texture.WHITE
      };
      return opts;
    } else if (styleToMerge instanceof FillPattern) {
      const pattern = styleToMerge;
      return {
        ...fillStyleToParse,
        color: 16777215,
        texture: pattern.texture,
        matrix: pattern.transform,
        fill: fillStyleToParse.fill ?? null
      };
    } else if (styleToMerge instanceof FillGradient) {
      const gradient = styleToMerge;
      gradient.buildLinearGradient();
      return {
        ...fillStyleToParse,
        color: 16777215,
        texture: gradient.texture,
        matrix: gradient.transform
      };
    }
    const style = { ...defaultStyle, ...value };
    if (style.texture) {
      if (style.texture !== Texture.WHITE) {
        const m2 = style.matrix?.invert() || new Matrix();
        m2.scale(
          1 / style.texture.frame.width,
          1 / style.texture.frame.height
        );
        style.matrix = m2;
      }
      const sourceStyle = style.texture.source.style;
      if (sourceStyle.addressMode === "clamp-to-edge") {
        sourceStyle.addressMode = "repeat";
      }
    }
    const color3 = Color.shared.setValue(style.color);
    style.alpha *= color3.alpha;
    style.color = color3.toNumber();
    style.matrix = style.matrix ? style.matrix.clone() : null;
    return style;
  }
  var init_convertFillInputToFillStyle = __esm({
    "../core/node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs"() {
      init_Color();
      init_Matrix();
      init_Texture();
      init_FillGradient();
      init_FillPattern();
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs
  var tmpPoint, tempMatrix3, _GraphicsContext, GraphicsContext;
  var init_GraphicsContext = __esm({
    "../core/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs"() {
      init_eventemitter3();
      init_Color();
      init_Matrix();
      init_Point();
      init_Texture();
      init_uid();
      init_deprecation();
      init_Bounds();
      init_GraphicsPath();
      init_SVGParser();
      init_convertFillInputToFillStyle();
      tmpPoint = new Point();
      tempMatrix3 = new Matrix();
      _GraphicsContext = class _GraphicsContext2 extends eventemitter3_default {
        constructor() {
          super(...arguments);
          this.uid = uid("graphicsContext");
          this.dirty = true;
          this.batchMode = "auto";
          this.instructions = [];
          this._activePath = new GraphicsPath();
          this._transform = new Matrix();
          this._fillStyle = { ..._GraphicsContext2.defaultFillStyle };
          this._strokeStyle = { ..._GraphicsContext2.defaultStrokeStyle };
          this._stateStack = [];
          this._tick = 0;
          this._bounds = new Bounds();
          this._boundsDirty = true;
        }
        /**
         * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,
         * including the current drawing state, transformations, styles, and instructions.
         * @returns A new GraphicsContext instance with the same properties and state as this one.
         */
        clone() {
          const clone = new _GraphicsContext2();
          clone.batchMode = this.batchMode;
          clone.instructions = this.instructions.slice();
          clone._activePath = this._activePath.clone();
          clone._transform = this._transform.clone();
          clone._fillStyle = { ...this._fillStyle };
          clone._strokeStyle = { ...this._strokeStyle };
          clone._stateStack = this._stateStack.slice();
          clone._bounds = this._bounds.clone();
          clone._boundsDirty = true;
          return clone;
        }
        /**
         * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.
         */
        get fillStyle() {
          return this._fillStyle;
        }
        set fillStyle(value) {
          this._fillStyle = convertFillInputToFillStyle(value, _GraphicsContext2.defaultFillStyle);
        }
        /**
         * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
         */
        get strokeStyle() {
          return this._strokeStyle;
        }
        set strokeStyle(value) {
          this._strokeStyle = convertFillInputToFillStyle(value, _GraphicsContext2.defaultStrokeStyle);
        }
        /**
         * Sets the current fill style of the graphics context. The fill style can be a color, gradient,
         * pattern, or a more complex style defined by a FillStyle object.
         * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,
         *                or a FillStyle or ConvertedFillStyle object.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        setFillStyle(style) {
          this._fillStyle = convertFillInputToFillStyle(style, _GraphicsContext2.defaultFillStyle);
          return this;
        }
        /**
         * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can
         * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
         * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,
         *                or a StrokeStyle or ConvertedStrokeStyle object.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        setStrokeStyle(style) {
          this._strokeStyle = convertFillInputToFillStyle(style, _GraphicsContext2.defaultStrokeStyle);
          return this;
        }
        texture(texture, tint, dx, dy, dw, dh) {
          this.instructions.push({
            action: "texture",
            data: {
              image: texture,
              dx: dx || 0,
              dy: dy || 0,
              dw: dw || texture.frame.width,
              dh: dh || texture.frame.height,
              transform: this._transform.clone(),
              alpha: this._fillStyle.alpha,
              style: tint ? Color.shared.setValue(tint).toNumber() : 16777215
            }
          });
          this.onUpdate();
          return this;
        }
        /**
         * Resets the current path. Any previous path and its commands are discarded and a new path is
         * started. This is typically called before beginning a new shape or series of drawing commands.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        beginPath() {
          this._activePath = new GraphicsPath();
          return this;
        }
        fill(style, alpha) {
          let path2;
          const lastInstruction = this.instructions[this.instructions.length - 1];
          if (this._tick === 0 && lastInstruction && lastInstruction.action === "stroke") {
            path2 = lastInstruction.data.path;
          } else {
            path2 = this._activePath.clone();
          }
          if (!path2)
            return this;
          if (style != null) {
            if (alpha !== void 0 && typeof style === "number") {
              deprecation(v8_0_0, "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead");
              style = { color: style, alpha };
            }
            this._fillStyle = convertFillInputToFillStyle(style, _GraphicsContext2.defaultFillStyle);
          }
          this.instructions.push({
            action: "fill",
            // TODO copy fill style!
            data: { style: this.fillStyle, path: path2 }
          });
          this.onUpdate();
          this._initNextPathLocation();
          this._tick = 0;
          return this;
        }
        _initNextPathLocation() {
          const { x: x2, y: y2 } = this._activePath.getLastPoint(Point.shared);
          this._activePath.clear();
          this._activePath.moveTo(x2, y2);
        }
        /**
         * Strokes the current path with the current stroke style. This method can take an optional
         * FillStyleInputs parameter to define the stroke's appearance, including its color, width, and other properties.
         * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        stroke(style) {
          let path2;
          const lastInstruction = this.instructions[this.instructions.length - 1];
          if (this._tick === 0 && lastInstruction && lastInstruction.action === "fill") {
            path2 = lastInstruction.data.path;
          } else {
            path2 = this._activePath.clone();
          }
          if (!path2)
            return this;
          if (style != null) {
            this._strokeStyle = convertFillInputToFillStyle(style, _GraphicsContext2.defaultStrokeStyle);
          }
          this.instructions.push({
            action: "stroke",
            // TODO copy fill style!
            data: { style: this.strokeStyle, path: path2 }
          });
          this.onUpdate();
          this._initNextPathLocation();
          this._tick = 0;
          return this;
        }
        /**
         * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by
         * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will
         * fail to cut correctly!
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        cut() {
          for (let i2 = 0; i2 < 2; i2++) {
            const lastInstruction = this.instructions[this.instructions.length - 1 - i2];
            const holePath = this._activePath.clone();
            if (lastInstruction) {
              if (lastInstruction.action === "stroke" || lastInstruction.action === "fill") {
                if (lastInstruction.data.hole) {
                  lastInstruction.data.hole.addPath(holePath);
                } else {
                  lastInstruction.data.hole = holePath;
                  break;
                }
              }
            }
          }
          this._initNextPathLocation();
          return this;
        }
        /**
         * Adds an arc to the current path, which is centered at (x, y) with the specified radius,
         * starting and ending angles, and direction.
         * @param x - The x-coordinate of the arc's center.
         * @param y - The y-coordinate of the arc's center.
         * @param radius - The arc's radius.
         * @param startAngle - The starting angle, in radians.
         * @param endAngle - The ending angle, in radians.
         * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        arc(x2, y2, radius, startAngle, endAngle, counterclockwise) {
          this._tick++;
          const t2 = this._transform;
          this._activePath.arc(
            t2.a * x2 + t2.c * y2 + t2.tx,
            t2.b * x2 + t2.d * y2 + t2.ty,
            radius,
            startAngle,
            endAngle,
            counterclockwise
          );
          return this;
        }
        /**
         * Adds an arc to the current path with the given control points and radius, connected to the previous point
         * by a straight line if necessary.
         * @param x1 - The x-coordinate of the first control point.
         * @param y1 - The y-coordinate of the first control point.
         * @param x2 - The x-coordinate of the second control point.
         * @param y2 - The y-coordinate of the second control point.
         * @param radius - The arc's radius.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        arcTo(x1, y1, x2, y2, radius) {
          this._tick++;
          const t2 = this._transform;
          this._activePath.arcTo(
            t2.a * x1 + t2.c * y1 + t2.tx,
            t2.b * x1 + t2.d * y1 + t2.ty,
            t2.a * x2 + t2.c * y2 + t2.tx,
            t2.b * x2 + t2.d * y2 + t2.ty,
            radius
          );
          return this;
        }
        /**
         * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.
         * @param rx - The x-radius of the ellipse.
         * @param ry - The y-radius of the ellipse.
         * @param xAxisRotation - The rotation of the ellipse's x-axis relative
         * to the x-axis of the coordinate system, in degrees.
         * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.
         * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.
         * @param x - The x-coordinate of the arc's end point.
         * @param y - The y-coordinate of the arc's end point.
         * @returns The instance of the current object for chaining.
         */
        arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x2, y2) {
          this._tick++;
          const t2 = this._transform;
          this._activePath.arcToSvg(
            rx,
            ry,
            xAxisRotation,
            // should we rotate this with transform??
            largeArcFlag,
            sweepFlag,
            t2.a * x2 + t2.c * y2 + t2.tx,
            t2.b * x2 + t2.d * y2 + t2.ty
          );
          return this;
        }
        /**
         * Adds a cubic Bezier curve to the path.
         * It requires three points: the first two are control points and the third one is the end point.
         * The starting point is the last point in the current path.
         * @param cp1x - The x-coordinate of the first control point.
         * @param cp1y - The y-coordinate of the first control point.
         * @param cp2x - The x-coordinate of the second control point.
         * @param cp2y - The y-coordinate of the second control point.
         * @param x - The x-coordinate of the end point.
         * @param y - The y-coordinate of the end point.
         * @param smoothness - Optional parameter to adjust the smoothness of the curve.
         * @returns The instance of the current object for chaining.
         */
        bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y2, smoothness) {
          this._tick++;
          const t2 = this._transform;
          this._activePath.bezierCurveTo(
            t2.a * cp1x + t2.c * cp1y + t2.tx,
            t2.b * cp1x + t2.d * cp1y + t2.ty,
            t2.a * cp2x + t2.c * cp2y + t2.tx,
            t2.b * cp2x + t2.d * cp2y + t2.ty,
            t2.a * x2 + t2.c * y2 + t2.tx,
            t2.b * x2 + t2.d * y2 + t2.ty,
            smoothness
          );
          return this;
        }
        /**
         * Closes the current path by drawing a straight line back to the start.
         * If the shape is already closed or there are no points in the path, this method does nothing.
         * @returns The instance of the current object for chaining.
         */
        closePath() {
          this._tick++;
          this._activePath?.closePath();
          return this;
        }
        /**
         * Draws an ellipse at the specified location and with the given x and y radii.
         * An optional transformation can be applied, allowing for rotation, scaling, and translation.
         * @param x - The x-coordinate of the center of the ellipse.
         * @param y - The y-coordinate of the center of the ellipse.
         * @param radiusX - The horizontal radius of the ellipse.
         * @param radiusY - The vertical radius of the ellipse.
         * @returns The instance of the current object for chaining.
         */
        ellipse(x2, y2, radiusX, radiusY) {
          this._tick++;
          this._activePath.ellipse(x2, y2, radiusX, radiusY, this._transform.clone());
          return this;
        }
        /**
         * Draws a circle shape. This method adds a new circle path to the current drawing.
         * @param x - The x-coordinate of the center of the circle.
         * @param y - The y-coordinate of the center of the circle.
         * @param radius - The radius of the circle.
         * @returns The instance of the current object for chaining.
         */
        circle(x2, y2, radius) {
          this._tick++;
          this._activePath.circle(x2, y2, radius, this._transform.clone());
          return this;
        }
        /**
         * Adds another `GraphicsPath` to this path, optionally applying a transformation.
         * @param path - The `GraphicsPath` to add.
         * @returns The instance of the current object for chaining.
         */
        path(path2) {
          this._tick++;
          this._activePath.addPath(path2, this._transform.clone());
          return this;
        }
        /**
         * Connects the current point to a new point with a straight line. This method updates the current path.
         * @param x - The x-coordinate of the new point to connect to.
         * @param y - The y-coordinate of the new point to connect to.
         * @returns The instance of the current object for chaining.
         */
        lineTo(x2, y2) {
          this._tick++;
          const t2 = this._transform;
          this._activePath.lineTo(
            t2.a * x2 + t2.c * y2 + t2.tx,
            t2.b * x2 + t2.d * y2 + t2.ty
          );
          return this;
        }
        /**
         * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.
         * @param x - The x-coordinate for the starting point.
         * @param y - The y-coordinate for the starting point.
         * @returns The instance of the current object for chaining.
         */
        moveTo(x2, y2) {
          this._tick++;
          const t2 = this._transform;
          const instructions = this._activePath.instructions;
          const transformedX = t2.a * x2 + t2.c * y2 + t2.tx;
          const transformedY = t2.b * x2 + t2.d * y2 + t2.ty;
          if (instructions.length === 1 && instructions[0].action === "moveTo") {
            instructions[0].data[0] = transformedX;
            instructions[0].data[1] = transformedY;
            return this;
          }
          this._activePath.moveTo(
            transformedX,
            transformedY
          );
          return this;
        }
        /**
         * Adds a quadratic curve to the path. It requires two points: the control point and the end point.
         * The starting point is the last point in the current path.
         * @param cpx - The x-coordinate of the control point.
         * @param cpy - The y-coordinate of the control point.
         * @param x - The x-coordinate of the end point.
         * @param y - The y-coordinate of the end point.
         * @param smoothness - Optional parameter to adjust the smoothness of the curve.
         * @returns The instance of the current object for chaining.
         */
        quadraticCurveTo(cpx, cpy, x2, y2, smoothness) {
          this._tick++;
          const t2 = this._transform;
          this._activePath.quadraticCurveTo(
            t2.a * cpx + t2.c * cpy + t2.tx,
            t2.b * cpx + t2.d * cpy + t2.ty,
            t2.a * x2 + t2.c * y2 + t2.tx,
            t2.b * x2 + t2.d * y2 + t2.ty,
            smoothness
          );
          return this;
        }
        /**
         * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
         * @param x - The x-coordinate of the top-left corner of the rectangle.
         * @param y - The y-coordinate of the top-left corner of the rectangle.
         * @param w - The width of the rectangle.
         * @param h - The height of the rectangle.
         * @returns The instance of the current object for chaining.
         */
        rect(x2, y2, w2, h2) {
          this._tick++;
          this._activePath.rect(x2, y2, w2, h2, this._transform.clone());
          return this;
        }
        /**
         * Draws a rectangle with rounded corners.
         * The corner radius can be specified to determine how rounded the corners should be.
         * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.
         * @param x - The x-coordinate of the top-left corner of the rectangle.
         * @param y - The y-coordinate of the top-left corner of the rectangle.
         * @param w - The width of the rectangle.
         * @param h - The height of the rectangle.
         * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.
         * @returns The instance of the current object for chaining.
         */
        roundRect(x2, y2, w2, h2, radius) {
          this._tick++;
          this._activePath.roundRect(x2, y2, w2, h2, radius, this._transform.clone());
          return this;
        }
        /**
         * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,
         * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,
         * rotated, or translated as needed.
         * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]
         * representing the x and y coordinates, of the polygon's vertices, in sequence.
         * @param close - A boolean indicating whether to close the polygon path. True by default.
         */
        poly(points, close) {
          this._tick++;
          this._activePath.poly(points, close, this._transform.clone());
          return this;
        }
        /**
         * Draws a regular polygon with a specified number of sides. All sides and angles are equal.
         * @param x - The x-coordinate of the center of the polygon.
         * @param y - The y-coordinate of the center of the polygon.
         * @param radius - The radius of the circumscribed circle of the polygon.
         * @param sides - The number of sides of the polygon. Must be 3 or more.
         * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
         * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
         * @returns The instance of the current object for chaining.
         */
        regularPoly(x2, y2, radius, sides, rotation = 0, transform2) {
          this._tick++;
          this._activePath.regularPoly(x2, y2, radius, sides, rotation, transform2);
          return this;
        }
        /**
         * Draws a polygon with rounded corners.
         * Similar to `regularPoly` but with the ability to round the corners of the polygon.
         * @param x - The x-coordinate of the center of the polygon.
         * @param y - The y-coordinate of the center of the polygon.
         * @param radius - The radius of the circumscribed circle of the polygon.
         * @param sides - The number of sides of the polygon. Must be 3 or more.
         * @param corner - The radius of the rounding of the corners.
         * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
         * @returns The instance of the current object for chaining.
         */
        roundPoly(x2, y2, radius, sides, corner, rotation) {
          this._tick++;
          this._activePath.roundPoly(x2, y2, radius, sides, corner, rotation);
          return this;
        }
        /**
         * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.
         * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.
         * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.
         * A minimum of 3 points is required.
         * @param radius - The default radius for the corners.
         * This radius is applied to all corners unless overridden in `points`.
         * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve
         *  method instead of an arc method. Defaults to false.
         * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.
         * Higher values make the curve smoother.
         * @returns The instance of the current object for chaining.
         */
        roundShape(points, radius, useQuadratic, smoothness) {
          this._tick++;
          this._activePath.roundShape(points, radius, useQuadratic, smoothness);
          return this;
        }
        /**
         * Draw Rectangle with fillet corners. This is much like rounded rectangle
         * however it support negative numbers as well for the corner radius.
         * @param x - Upper left corner of rect
         * @param y - Upper right corner of rect
         * @param width - Width of rect
         * @param height - Height of rect
         * @param fillet - accept negative or positive values
         */
        filletRect(x2, y2, width, height, fillet) {
          this._tick++;
          this._activePath.filletRect(x2, y2, width, height, fillet);
          return this;
        }
        /**
         * Draw Rectangle with chamfer corners. These are angled corners.
         * @param x - Upper left corner of rect
         * @param y - Upper right corner of rect
         * @param width - Width of rect
         * @param height - Height of rect
         * @param chamfer - non-zero real number, size of corner cutout
         * @param transform
         */
        chamferRect(x2, y2, width, height, chamfer, transform2) {
          this._tick++;
          this._activePath.chamferRect(x2, y2, width, height, chamfer, transform2);
          return this;
        }
        /**
         * Draws a star shape centered at a specified location. This method allows for the creation
         *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.
         * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.
         * An optional transformation can be applied to scale, rotate, or translate the star as needed.
         * @param x - The x-coordinate of the center of the star.
         * @param y - The y-coordinate of the center of the star.
         * @param points - The number of points of the star.
         * @param radius - The outer radius of the star (distance from the center to the outer points).
         * @param innerRadius - Optional. The inner radius of the star
         * (distance from the center to the inner points between the outer points).
         * If not provided, defaults to half of the `radius`.
         * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.
         * Defaults to 0, meaning one point is directly upward.
         * @returns The instance of the current object for chaining further drawing commands.
         */
        star(x2, y2, points, radius, innerRadius = 0, rotation = 0) {
          this._tick++;
          this._activePath.star(x2, y2, points, radius, innerRadius, rotation, this._transform.clone());
          return this;
        }
        /**
         * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths
         * defined in SVG format to be drawn within the graphics context.
         * @param svg - The SVG string to be parsed and rendered.
         */
        svg(svg) {
          this._tick++;
          SVGParser(svg, this);
          return this;
        }
        /**
         * Restores the most recently saved graphics state by popping the top of the graphics state stack.
         * This includes transformations, fill styles, and stroke styles.
         */
        restore() {
          const state = this._stateStack.pop();
          if (state) {
            this._transform = state.transform;
            this._fillStyle = state.fillStyle;
            this._strokeStyle = state.strokeStyle;
          }
          return this;
        }
        /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */
        save() {
          this._stateStack.push({
            transform: this._transform.clone(),
            fillStyle: { ...this._fillStyle },
            strokeStyle: { ...this._strokeStyle }
          });
          return this;
        }
        /**
         * Returns the current transformation matrix of the graphics context.
         * @returns The current transformation matrix.
         */
        getTransform() {
          return this._transform;
        }
        /**
         * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        resetTransform() {
          this._transform.identity();
          return this;
        }
        /**
         * Applies a rotation transformation to the graphics context around the current origin.
         * @param angle - The angle of rotation in radians.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        rotate(angle) {
          this._transform.rotate(angle);
          return this;
        }
        /**
         * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.
         * @param x - The scale factor in the horizontal direction.
         * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        scale(x2, y2 = x2) {
          this._transform.scale(x2, y2);
          return this;
        }
        setTransform(a2, b2, c2, d2, dx, dy) {
          if (a2 instanceof Matrix) {
            this._transform.set(a2.a, a2.b, a2.c, a2.d, a2.tx, a2.ty);
            return this;
          }
          this._transform.set(a2, b2, c2, d2, dx, dy);
          return this;
        }
        transform(a2, b2, c2, d2, dx, dy) {
          if (a2 instanceof Matrix) {
            this._transform.append(a2);
            return this;
          }
          tempMatrix3.set(a2, b2, c2, d2, dx, dy);
          this._transform.append(tempMatrix3);
          return this;
        }
        /**
         * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.
         * @param x - The amount to translate in the horizontal direction.
         * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        translate(x2, y2 = x2) {
          this._transform.translate(x2, y2);
          return this;
        }
        /**
         * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,
         * and optionally resetting transformations to the identity matrix.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        clear() {
          this.instructions.length = 0;
          this.resetTransform();
          this.onUpdate();
          return this;
        }
        onUpdate() {
          if (this.dirty)
            return;
          this.emit("update", this, 16);
          this.dirty = true;
          this._boundsDirty = true;
        }
        /** The bounds of the graphic shape. */
        get bounds() {
          if (!this._boundsDirty)
            return this._bounds;
          const bounds = this._bounds;
          bounds.clear();
          for (let i2 = 0; i2 < this.instructions.length; i2++) {
            const instruction = this.instructions[i2];
            const action = instruction.action;
            if (action === "fill") {
              const data = instruction.data;
              bounds.addBounds(data.path.bounds);
            } else if (action === "texture") {
              const data = instruction.data;
              bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);
            }
            if (action === "stroke") {
              const data = instruction.data;
              const padding = data.style.width / 2;
              const _bounds = data.path.bounds;
              bounds.addFrame(
                _bounds.minX - padding,
                _bounds.minY - padding,
                _bounds.maxX + padding,
                _bounds.maxY + padding
              );
            }
          }
          return bounds;
        }
        /**
         * Check to see if a point is contained within this geometry.
         * @param point - Point to check if it's contained.
         * @returns {boolean} `true` if the point is contained within geometry.
         */
        containsPoint(point) {
          if (!this.bounds.containsPoint(point.x, point.y))
            return false;
          const instructions = this.instructions;
          let hasHit = false;
          for (let k2 = 0; k2 < instructions.length; k2++) {
            const instruction = instructions[k2];
            const data = instruction.data;
            const path2 = data.path;
            if (!instruction.action || !path2)
              continue;
            const style = data.style;
            const shapes = path2.shapePath.shapePrimitives;
            for (let i2 = 0; i2 < shapes.length; i2++) {
              const shape = shapes[i2].shape;
              if (!style || !shape)
                continue;
              const transform2 = shapes[i2].transform;
              const transformedPoint = transform2 ? transform2.applyInverse(point, tmpPoint) : point;
              if (instruction.action === "fill") {
                hasHit = shape.contains(transformedPoint.x, transformedPoint.y);
              } else {
                hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, style.width);
              }
              const holes = data.hole;
              if (holes) {
                const holeShapes = holes.shapePath?.shapePrimitives;
                if (holeShapes) {
                  for (let j2 = 0; j2 < holeShapes.length; j2++) {
                    if (holeShapes[j2].shape.contains(transformedPoint.x, transformedPoint.y)) {
                      hasHit = false;
                    }
                  }
                }
              }
              if (hasHit) {
                return true;
              }
            }
          }
          return hasHit;
        }
        /**
         * Destroys the GraphicsData object.
         * @param options - Options parameter. A boolean will act as if all options
         *  have been set to that value
         * @param {boolean} [options.texture=false] - Should it destroy the current texture of the fill/stroke style?
         * @param {boolean} [options.textureSource=false] - Should it destroy the texture source of the fill/stroke style?
         */
        destroy(options = false) {
          this._stateStack.length = 0;
          this._transform = null;
          this.emit("destroy", this);
          this.removeAllListeners();
          const destroyTexture = typeof options === "boolean" ? options : options?.texture;
          if (destroyTexture) {
            const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
            if (this._fillStyle.texture) {
              this._fillStyle.texture.destroy(destroyTextureSource);
            }
            if (this._strokeStyle.texture) {
              this._strokeStyle.texture.destroy(destroyTextureSource);
            }
          }
          this._fillStyle = null;
          this._strokeStyle = null;
          this.instructions = null;
          this._activePath = null;
          this._bounds = null;
          this._stateStack = null;
          this.customShader = null;
          this._transform = null;
        }
      };
      _GraphicsContext.defaultFillStyle = {
        /** The color to use for the fill. */
        color: 16777215,
        /** The alpha value to use for the fill. */
        alpha: 1,
        /** The texture to use for the fill. */
        texture: Texture.WHITE,
        /** The matrix to apply. */
        matrix: null,
        /** The fill pattern to use. */
        fill: null
      };
      _GraphicsContext.defaultStrokeStyle = {
        /** The width of the stroke. */
        width: 1,
        /** The color to use for the stroke. */
        color: 16777215,
        /** The alpha value to use for the stroke. */
        alpha: 1,
        /** The alignment of the stroke. */
        alignment: 0.5,
        /** The miter limit to use. */
        miterLimit: 10,
        /** The line cap style to use. */
        cap: "butt",
        /** The line join style to use. */
        join: "miter",
        /** The texture to use for the fill. */
        texture: Texture.WHITE,
        /** The matrix to apply. */
        matrix: null,
        /** The fill pattern to use. */
        fill: null
      };
      GraphicsContext = _GraphicsContext;
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/text/utils/generateTextStyleKey.mjs
  function generateTextStyleKey(style) {
    const key = [];
    let index = 0;
    for (let i2 = 0; i2 < valuesToIterateForKeys.length; i2++) {
      const prop = valuesToIterateForKeys[i2];
      key[index++] = style[prop];
    }
    index = addFillStyleKey(style._fill, key, index);
    index = addStokeStyleKey(style._stroke, key, index);
    return key.join("-");
  }
  function addFillStyleKey(fillStyle, key, index) {
    if (!fillStyle)
      return index;
    key[index++] = fillStyle.color;
    key[index++] = fillStyle.alpha;
    key[index++] = fillStyle.fill?.uid;
    return index;
  }
  function addStokeStyleKey(strokeStyle, key, index) {
    if (!strokeStyle)
      return index;
    index = addFillStyleKey(strokeStyle, key, index);
    key[index++] = strokeStyle.width;
    key[index++] = strokeStyle.alignment;
    key[index++] = strokeStyle.cap;
    key[index++] = strokeStyle.join;
    key[index++] = strokeStyle.miterLimit;
    return index;
  }
  var valuesToIterateForKeys;
  var init_generateTextStyleKey = __esm({
    "../core/node_modules/pixi.js/lib/scene/text/utils/generateTextStyleKey.mjs"() {
      "use strict";
      valuesToIterateForKeys = [
        "_fontFamily",
        "_fontStyle",
        "_fontSize",
        "_fontVariant",
        "_fontWeight",
        "_breakWords",
        "_align",
        "_leading",
        "_letterSpacing",
        "_lineHeight",
        "_textBaseline",
        "_whiteSpace",
        "_wordWrap",
        "_wordWrapWidth",
        "_padding",
        "_cssOverrides",
        "_trim"
      ];
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/text/TextStyle.mjs
  function convertV7Tov8Style(style) {
    const oldStyle = style;
    if (typeof oldStyle.dropShadow === "boolean" && oldStyle.dropShadow) {
      const defaults = TextStyle.defaultDropShadow;
      style.dropShadow = {
        alpha: oldStyle.dropShadowAlpha ?? defaults.alpha,
        angle: oldStyle.dropShadowAngle ?? defaults.angle,
        blur: oldStyle.dropShadowBlur ?? defaults.blur,
        color: oldStyle.dropShadowColor ?? defaults.color,
        distance: oldStyle.dropShadowDistance ?? defaults.distance
      };
    }
    if (oldStyle.strokeThickness !== void 0) {
      deprecation(v8_0_0, "strokeThickness is now a part of stroke");
      const color3 = oldStyle.stroke;
      style.stroke = {
        color: color3,
        width: oldStyle.strokeThickness
      };
    }
    if (Array.isArray(oldStyle.fill)) {
      deprecation(v8_0_0, "gradient fill is now a fill pattern: `new FillGradient(...)`");
      const gradientFill = new FillGradient(0, 0, 0, style.fontSize * 1.7);
      const fills = oldStyle.fill.map((color3) => Color.shared.setValue(color3).toNumber());
      fills.forEach((number, index) => {
        const ratio = oldStyle.fillGradientStops[index] ?? index / fills.length;
        gradientFill.addColorStop(ratio, number);
      });
      style.fill = {
        fill: gradientFill
      };
    }
  }
  var _TextStyle, TextStyle;
  var init_TextStyle = __esm({
    "../core/node_modules/pixi.js/lib/scene/text/TextStyle.mjs"() {
      init_eventemitter3();
      init_Color();
      init_deprecation();
      init_FillGradient();
      init_GraphicsContext();
      init_convertFillInputToFillStyle();
      init_generateTextStyleKey();
      _TextStyle = class _TextStyle2 extends eventemitter3_default {
        constructor(style = {}) {
          super();
          convertV7Tov8Style(style);
          const fullStyle = { ..._TextStyle2.defaultTextStyle, ...style };
          for (const key in fullStyle) {
            const thisKey = key;
            this[thisKey] = fullStyle[key];
          }
          this.update();
        }
        /**
         * Alignment for multiline text, does not affect single line text.
         * @member {'left'|'center'|'right'|'justify'}
         */
        get align() {
          return this._align;
        }
        set align(value) {
          this._align = value;
          this.update();
        }
        /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */
        get breakWords() {
          return this._breakWords;
        }
        set breakWords(value) {
          this._breakWords = value;
          this.update();
        }
        /** Set a drop shadow for the text. */
        get dropShadow() {
          return this._dropShadow;
        }
        set dropShadow(value) {
          if (value !== null && typeof value === "object") {
            this._dropShadow = {
              ..._TextStyle2.defaultDropShadow,
              ...value
            };
          } else {
            this._dropShadow = value ? {
              ..._TextStyle2.defaultDropShadow
            } : null;
          }
          this.update();
        }
        /** The font family, can be a single font name, or a list of names where the first is the preferred font. */
        get fontFamily() {
          return this._fontFamily;
        }
        set fontFamily(value) {
          this._fontFamily = value;
          this.update();
        }
        /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */
        get fontSize() {
          return this._fontSize;
        }
        set fontSize(value) {
          if (typeof value === "string") {
            this._fontSize = parseInt(value, 10);
          } else {
            this._fontSize = value;
          }
          this.update();
        }
        /**
         * The font style.
         * @member {'normal'|'italic'|'oblique'}
         */
        get fontStyle() {
          return this._fontStyle;
        }
        set fontStyle(value) {
          this._fontStyle = value;
          this.update();
        }
        /**
         * The font variant.
         * @member {'normal'|'small-caps'}
         */
        get fontVariant() {
          return this._fontVariant;
        }
        set fontVariant(value) {
          this._fontVariant = value;
          this.update();
        }
        /**
         * The font weight.
         * @member {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}
         */
        get fontWeight() {
          return this._fontWeight;
        }
        set fontWeight(value) {
          this._fontWeight = value;
          this.update();
        }
        /** The space between lines. */
        get leading() {
          return this._leading;
        }
        set leading(value) {
          this._leading = value;
          this.update();
        }
        /** The amount of spacing between letters, default is 0. */
        get letterSpacing() {
          return this._letterSpacing;
        }
        set letterSpacing(value) {
          this._letterSpacing = value;
          this.update();
        }
        /** The line height, a number that represents the vertical space that a letter uses. */
        get lineHeight() {
          return this._lineHeight;
        }
        set lineHeight(value) {
          this._lineHeight = value;
          this.update();
        }
        /**
         * Occasionally some fonts are cropped. Adding some padding will prevent this from happening
         * by adding padding to all sides of the text.
         */
        get padding() {
          return this._padding;
        }
        set padding(value) {
          this._padding = value;
          this.update();
        }
        /** Trim transparent borders. This is an expensive operation so only use this if you have to! */
        get trim() {
          return this._trim;
        }
        set trim(value) {
          this._trim = value;
          this.update();
        }
        /**
         * The baseline of the text that is rendered.
         * @member {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}
         */
        get textBaseline() {
          return this._textBaseline;
        }
        set textBaseline(value) {
          this._textBaseline = value;
          this.update();
        }
        /**
         * How newlines and spaces should be handled.
         * Default is 'pre' (preserve, preserve).
         *
         *  value       | New lines     |   Spaces
         *  ---         | ---           |   ---
         * 'normal'     | Collapse      |   Collapse
         * 'pre'        | Preserve      |   Preserve
         * 'pre-line'   | Preserve      |   Collapse
         * @member {'normal'|'pre'|'pre-line'}
         */
        get whiteSpace() {
          return this._whiteSpace;
        }
        set whiteSpace(value) {
          this._whiteSpace = value;
          this.update();
        }
        /** Indicates if word wrap should be used. */
        get wordWrap() {
          return this._wordWrap;
        }
        set wordWrap(value) {
          this._wordWrap = value;
          this.update();
        }
        /** The width at which text will wrap, it needs wordWrap to be set to true. */
        get wordWrapWidth() {
          return this._wordWrapWidth;
        }
        set wordWrapWidth(value) {
          this._wordWrapWidth = value;
          this.update();
        }
        /** A fillstyle that will be used on the text e.g., 'red', '#00FF00'. */
        get fill() {
          return this._originalFill;
        }
        set fill(value) {
          if (value === this._originalFill)
            return;
          this._originalFill = value;
          this._fill = convertFillInputToFillStyle(
            value === 0 ? "black" : value,
            GraphicsContext.defaultFillStyle
          );
          this.update();
        }
        /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */
        get stroke() {
          return this._originalStroke;
        }
        set stroke(value) {
          if (value === this._originalStroke)
            return;
          this._originalStroke = value;
          this._stroke = convertFillInputToFillStyle(value, GraphicsContext.defaultStrokeStyle);
          this.update();
        }
        _generateKey() {
          this._styleKey = generateTextStyleKey(this);
          return this._styleKey;
        }
        update() {
          this._styleKey = null;
          this.emit("update", this);
        }
        /** Resets all properties to the default values */
        reset() {
          const defaultStyle = _TextStyle2.defaultTextStyle;
          for (const key in defaultStyle) {
            this[key] = defaultStyle[key];
          }
        }
        get styleKey() {
          return this._styleKey || this._generateKey();
        }
        /**
         * Creates a new TextStyle object with the same values as this one.
         * @returns New cloned TextStyle object
         */
        clone() {
          return new _TextStyle2({
            align: this.align,
            breakWords: this.breakWords,
            dropShadow: this.dropShadow,
            fill: this._fill,
            fontFamily: this.fontFamily,
            fontSize: this.fontSize,
            fontStyle: this.fontStyle,
            fontVariant: this.fontVariant,
            fontWeight: this.fontWeight,
            leading: this.leading,
            letterSpacing: this.letterSpacing,
            lineHeight: this.lineHeight,
            padding: this.padding,
            stroke: this._stroke,
            textBaseline: this.textBaseline,
            whiteSpace: this.whiteSpace,
            wordWrap: this.wordWrap,
            wordWrapWidth: this.wordWrapWidth
          });
        }
        /**
         * Destroys this text style.
         * @param options - Options parameter. A boolean will act as if all options
         *  have been set to that value
         * @param {boolean} [options.texture=false] - Should it destroy the texture of the this style
         * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the this style
         */
        destroy(options = false) {
          this.removeAllListeners();
          const destroyTexture = typeof options === "boolean" ? options : options?.texture;
          if (destroyTexture) {
            const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
            if (this._fill?.texture) {
              this._fill.texture.destroy(destroyTextureSource);
            }
            if (this._originalFill?.texture) {
              this._originalFill.texture.destroy(destroyTextureSource);
            }
            if (this._stroke?.texture) {
              this._stroke.texture.destroy(destroyTextureSource);
            }
            if (this._originalStroke?.texture) {
              this._originalStroke.texture.destroy(destroyTextureSource);
            }
          }
          this._fill = null;
          this._stroke = null;
          this.dropShadow = null;
          this._originalStroke = null;
          this._originalFill = null;
        }
      };
      _TextStyle.defaultDropShadow = {
        /** Set alpha for the drop shadow */
        alpha: 1,
        /** Set a angle of the drop shadow */
        angle: Math.PI / 6,
        /** Set a shadow blur radius */
        blur: 0,
        /** A fill style to be used on the  e.g., 'red', '#00FF00' */
        color: "black",
        /** Set a distance of the drop shadow */
        distance: 5
      };
      _TextStyle.defaultTextStyle = {
        /**
         * See {@link TextStyle.align}
         * @type {'left'|'center'|'right'|'justify'}
         */
        align: "left",
        /** See {@link TextStyle.breakWords} */
        breakWords: false,
        /** See {@link TextStyle.dropShadow} */
        dropShadow: null,
        /**
         * See {@link TextStyle.fill}
         * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}
         */
        fill: "black",
        /**
         * See {@link TextStyle.fontFamily}
         * @type {string|string[]}
         */
        fontFamily: "Arial",
        /**
         * See {@link TextStyle.fontSize}
         * @type {number|string}
         */
        fontSize: 26,
        /**
         * See {@link TextStyle.fontStyle}
         * @type {'normal'|'italic'|'oblique'}
         */
        fontStyle: "normal",
        /**
         * See {@link TextStyle.fontVariant}
         * @type {'normal'|'small-caps'}
         */
        fontVariant: "normal",
        /**
         * See {@link TextStyle.fontWeight}
         * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}
         */
        fontWeight: "normal",
        /** See {@link TextStyle.leading} */
        leading: 0,
        /** See {@link TextStyle.letterSpacing} */
        letterSpacing: 0,
        /** See {@link TextStyle.lineHeight} */
        lineHeight: 0,
        /** See {@link TextStyle.padding} */
        padding: 0,
        /**
         * See {@link TextStyle.stroke}
         * @type {string|number}
         */
        stroke: null,
        /**
         * See {@link TextStyle.textBaseline}
         * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}
         */
        textBaseline: "alphabetic",
        /** See {@link TextStyle.trim} */
        trim: false,
        /**
         * See {@link TextStyle.whiteSpace}
         * @type {'normal'|'pre'|'pre-line'}
         */
        whiteSpace: "pre",
        /** See {@link TextStyle.wordWrap} */
        wordWrap: false,
        /** See {@link TextStyle.wordWrapWidth} */
        wordWrapWidth: 100
      };
      TextStyle = _TextStyle;
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs
  function getPo2TextureFromSource(image, width, height, resolution) {
    const bounds = tempBounds2;
    bounds.minX = 0;
    bounds.minY = 0;
    bounds.maxX = image.width / resolution | 0;
    bounds.maxY = image.height / resolution | 0;
    const texture = TexturePool.getOptimalTexture(
      bounds.width,
      bounds.height,
      resolution,
      false
    );
    texture.source.uploadMethodId = "image";
    texture.source.resource = image;
    texture.source.alphaMode = "premultiply-alpha-on-upload";
    texture.frame.width = width / resolution;
    texture.frame.height = height / resolution;
    texture.source.emit("update", texture.source);
    texture.updateUvs();
    return texture;
  }
  var tempBounds2;
  var init_getPo2TextureFromSource = __esm({
    "../core/node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs"() {
      init_TexturePool();
      init_Bounds();
      tempBounds2 = new Bounds();
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs
  function fontStringFromTextStyle(style) {
    const fontSizeString = typeof style.fontSize === "number" ? `${style.fontSize}px` : style.fontSize;
    let fontFamilies = style.fontFamily;
    if (!Array.isArray(style.fontFamily)) {
      fontFamilies = style.fontFamily.split(",");
    }
    for (let i2 = fontFamilies.length - 1; i2 >= 0; i2--) {
      let fontFamily = fontFamilies[i2].trim();
      if (!/([\"\'])[^\'\"]+\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily)) {
        fontFamily = `"${fontFamily}"`;
      }
      fontFamilies[i2] = fontFamily;
    }
    return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${fontFamilies.join(",")}`;
  }
  var genericFontFamilies;
  var init_fontStringFromTextStyle = __esm({
    "../core/node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs"() {
      "use strict";
      genericFontFamilies = [
        "serif",
        "sans-serif",
        "monospace",
        "cursive",
        "fantasy",
        "system-ui"
      ];
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs
  var contextSettings, _CanvasTextMetrics, CanvasTextMetrics;
  var init_CanvasTextMetrics = __esm({
    "../core/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs"() {
      init_adapter();
      init_fontStringFromTextStyle();
      contextSettings = {
        // TextMetrics requires getImageData readback for measuring fonts.
        willReadFrequently: true
      };
      _CanvasTextMetrics = class _CanvasTextMetrics2 {
        /**
         * Checking that we can use modern canvas 2D API.
         *
         * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.
         * @see TextMetrics.experimentalLetterSpacing
         * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing
         * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441
         */
        static get experimentalLetterSpacingSupported() {
          let result = _CanvasTextMetrics2._experimentalLetterSpacingSupported;
          if (result !== void 0) {
            const proto = DOMAdapter.get().getCanvasRenderingContext2D().prototype;
            result = _CanvasTextMetrics2._experimentalLetterSpacingSupported = "letterSpacing" in proto || "textLetterSpacing" in proto;
          }
          return result;
        }
        /**
         * @param text - the text that was measured
         * @param style - the style that was measured
         * @param width - the measured width of the text
         * @param height - the measured height of the text
         * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style
         * @param lineWidths - an array of the line widths for each line matched to `lines`
         * @param lineHeight - the measured line height for this style
         * @param maxLineWidth - the maximum line width for all measured lines
         * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont
         */
        constructor(text2, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
          this.text = text2;
          this.style = style;
          this.width = width;
          this.height = height;
          this.lines = lines;
          this.lineWidths = lineWidths;
          this.lineHeight = lineHeight;
          this.maxLineWidth = maxLineWidth;
          this.fontProperties = fontProperties;
        }
        /**
         * Measures the supplied string of text and returns a Rectangle.
         * @param text - The text to measure.
         * @param style - The text style to use for measuring
         * @param canvas - optional specification of the canvas to use for measuring.
         * @param wordWrap
         * @returns Measured width and height of the text.
         */
        static measureText(text2 = " ", style, canvas = _CanvasTextMetrics2._canvas, wordWrap = style.wordWrap) {
          const textKey = `${text2}:${style.styleKey}`;
          if (_CanvasTextMetrics2._measurementCache[textKey])
            return _CanvasTextMetrics2._measurementCache[textKey];
          const font = fontStringFromTextStyle(style);
          const fontProperties = _CanvasTextMetrics2.measureFont(font);
          if (fontProperties.fontSize === 0) {
            fontProperties.fontSize = style.fontSize;
            fontProperties.ascent = style.fontSize;
          }
          const context4 = _CanvasTextMetrics2.__context;
          context4.font = font;
          const outputText = wordWrap ? _CanvasTextMetrics2._wordWrap(text2, style, canvas) : text2;
          const lines = outputText.split(/(?:\r\n|\r|\n)/);
          const lineWidths = new Array(lines.length);
          let maxLineWidth = 0;
          for (let i2 = 0; i2 < lines.length; i2++) {
            const lineWidth = _CanvasTextMetrics2._measureText(lines[i2], style.letterSpacing, context4);
            lineWidths[i2] = lineWidth;
            maxLineWidth = Math.max(maxLineWidth, lineWidth);
          }
          const strokeWidth = style._stroke?.width || 0;
          let width = maxLineWidth + strokeWidth;
          if (style.dropShadow) {
            width += style.dropShadow.distance;
          }
          const lineHeight = style.lineHeight || fontProperties.fontSize + strokeWidth;
          let height = Math.max(lineHeight, fontProperties.fontSize + strokeWidth * 2) + (lines.length - 1) * (lineHeight + style.leading);
          if (style.dropShadow) {
            height += style.dropShadow.distance;
          }
          const measurements = new _CanvasTextMetrics2(
            text2,
            style,
            width,
            height,
            lines,
            lineWidths,
            lineHeight + style.leading,
            maxLineWidth,
            fontProperties
          );
          return measurements;
        }
        static _measureText(text2, letterSpacing, context4) {
          let useExperimentalLetterSpacing = false;
          if (_CanvasTextMetrics2.experimentalLetterSpacingSupported) {
            if (_CanvasTextMetrics2.experimentalLetterSpacing) {
              context4.letterSpacing = `${letterSpacing}px`;
              context4.textLetterSpacing = `${letterSpacing}px`;
              useExperimentalLetterSpacing = true;
            } else {
              context4.letterSpacing = "0px";
              context4.textLetterSpacing = "0px";
            }
          }
          let width = context4.measureText(text2).width;
          if (width > 0) {
            if (useExperimentalLetterSpacing) {
              width -= letterSpacing;
            } else {
              width += (_CanvasTextMetrics2.graphemeSegmenter(text2).length - 1) * letterSpacing;
            }
          }
          return width;
        }
        /**
         * Applies newlines to a string to have it optimally fit into the horizontal
         * bounds set by the Text object's wordWrapWidth property.
         * @param text - String to apply word wrapping to
         * @param style - the style to use when wrapping
         * @param canvas - optional specification of the canvas to use for measuring.
         * @returns New string with new lines applied where required
         */
        static _wordWrap(text2, style, canvas = _CanvasTextMetrics2._canvas) {
          const context4 = canvas.getContext("2d", contextSettings);
          let width = 0;
          let line = "";
          let lines = "";
          const cache = /* @__PURE__ */ Object.create(null);
          const { letterSpacing, whiteSpace } = style;
          const collapseSpaces = _CanvasTextMetrics2._collapseSpaces(whiteSpace);
          const collapseNewlines = _CanvasTextMetrics2._collapseNewlines(whiteSpace);
          let canPrependSpaces = !collapseSpaces;
          const wordWrapWidth = style.wordWrapWidth + letterSpacing;
          const tokens = _CanvasTextMetrics2._tokenize(text2);
          for (let i2 = 0; i2 < tokens.length; i2++) {
            let token = tokens[i2];
            if (_CanvasTextMetrics2._isNewline(token)) {
              if (!collapseNewlines) {
                lines += _CanvasTextMetrics2._addLine(line);
                canPrependSpaces = !collapseSpaces;
                line = "";
                width = 0;
                continue;
              }
              token = " ";
            }
            if (collapseSpaces) {
              const currIsBreakingSpace = _CanvasTextMetrics2.isBreakingSpace(token);
              const lastIsBreakingSpace = _CanvasTextMetrics2.isBreakingSpace(line[line.length - 1]);
              if (currIsBreakingSpace && lastIsBreakingSpace) {
                continue;
              }
            }
            const tokenWidth = _CanvasTextMetrics2._getFromCache(token, letterSpacing, cache, context4);
            if (tokenWidth > wordWrapWidth) {
              if (line !== "") {
                lines += _CanvasTextMetrics2._addLine(line);
                line = "";
                width = 0;
              }
              if (_CanvasTextMetrics2.canBreakWords(token, style.breakWords)) {
                const characters = _CanvasTextMetrics2.wordWrapSplit(token);
                for (let j2 = 0; j2 < characters.length; j2++) {
                  let char = characters[j2];
                  let lastChar = char;
                  let k2 = 1;
                  while (characters[j2 + k2]) {
                    const nextChar = characters[j2 + k2];
                    if (!_CanvasTextMetrics2.canBreakChars(lastChar, nextChar, token, j2, style.breakWords)) {
                      char += nextChar;
                    } else {
                      break;
                    }
                    lastChar = nextChar;
                    k2++;
                  }
                  j2 += k2 - 1;
                  const characterWidth = _CanvasTextMetrics2._getFromCache(char, letterSpacing, cache, context4);
                  if (characterWidth + width > wordWrapWidth) {
                    lines += _CanvasTextMetrics2._addLine(line);
                    canPrependSpaces = false;
                    line = "";
                    width = 0;
                  }
                  line += char;
                  width += characterWidth;
                }
              } else {
                if (line.length > 0) {
                  lines += _CanvasTextMetrics2._addLine(line);
                  line = "";
                  width = 0;
                }
                const isLastToken = i2 === tokens.length - 1;
                lines += _CanvasTextMetrics2._addLine(token, !isLastToken);
                canPrependSpaces = false;
                line = "";
                width = 0;
              }
            } else {
              if (tokenWidth + width > wordWrapWidth) {
                canPrependSpaces = false;
                lines += _CanvasTextMetrics2._addLine(line);
                line = "";
                width = 0;
              }
              if (line.length > 0 || !_CanvasTextMetrics2.isBreakingSpace(token) || canPrependSpaces) {
                line += token;
                width += tokenWidth;
              }
            }
          }
          lines += _CanvasTextMetrics2._addLine(line, false);
          return lines;
        }
        /**
         * Convienience function for logging each line added during the wordWrap method.
         * @param line    - The line of text to add
         * @param newLine - Add new line character to end
         * @returns A formatted line
         */
        static _addLine(line, newLine = true) {
          line = _CanvasTextMetrics2._trimRight(line);
          line = newLine ? `${line}
` : line;
          return line;
        }
        /**
         * Gets & sets the widths of calculated characters in a cache object
         * @param key            - The key
         * @param letterSpacing  - The letter spacing
         * @param cache          - The cache
         * @param context        - The canvas context
         * @returns The from cache.
         */
        static _getFromCache(key, letterSpacing, cache, context4) {
          let width = cache[key];
          if (typeof width !== "number") {
            width = _CanvasTextMetrics2._measureText(key, letterSpacing, context4) + letterSpacing;
            cache[key] = width;
          }
          return width;
        }
        /**
         * Determines whether we should collapse breaking spaces.
         * @param whiteSpace - The TextStyle property whiteSpace
         * @returns Should collapse
         */
        static _collapseSpaces(whiteSpace) {
          return whiteSpace === "normal" || whiteSpace === "pre-line";
        }
        /**
         * Determines whether we should collapse newLine chars.
         * @param whiteSpace - The white space
         * @returns should collapse
         */
        static _collapseNewlines(whiteSpace) {
          return whiteSpace === "normal";
        }
        /**
         * Trims breaking whitespaces from string.
         * @param text - The text
         * @returns Trimmed string
         */
        static _trimRight(text2) {
          if (typeof text2 !== "string") {
            return "";
          }
          for (let i2 = text2.length - 1; i2 >= 0; i2--) {
            const char = text2[i2];
            if (!_CanvasTextMetrics2.isBreakingSpace(char)) {
              break;
            }
            text2 = text2.slice(0, -1);
          }
          return text2;
        }
        /**
         * Determines if char is a newline.
         * @param char - The character
         * @returns True if newline, False otherwise.
         */
        static _isNewline(char) {
          if (typeof char !== "string") {
            return false;
          }
          return _CanvasTextMetrics2._newlines.includes(char.charCodeAt(0));
        }
        /**
         * Determines if char is a breaking whitespace.
         *
         * It allows one to determine whether char should be a breaking whitespace
         * For example certain characters in CJK langs or numbers.
         * It must return a boolean.
         * @param char - The character
         * @param [_nextChar] - The next character
         * @returns True if whitespace, False otherwise.
         */
        static isBreakingSpace(char, _nextChar) {
          if (typeof char !== "string") {
            return false;
          }
          return _CanvasTextMetrics2._breakingSpaces.includes(char.charCodeAt(0));
        }
        /**
         * Splits a string into words, breaking-spaces and newLine characters
         * @param text - The text
         * @returns A tokenized array
         */
        static _tokenize(text2) {
          const tokens = [];
          let token = "";
          if (typeof text2 !== "string") {
            return tokens;
          }
          for (let i2 = 0; i2 < text2.length; i2++) {
            const char = text2[i2];
            const nextChar = text2[i2 + 1];
            if (_CanvasTextMetrics2.isBreakingSpace(char, nextChar) || _CanvasTextMetrics2._isNewline(char)) {
              if (token !== "") {
                tokens.push(token);
                token = "";
              }
              tokens.push(char);
              continue;
            }
            token += char;
          }
          if (token !== "") {
            tokens.push(token);
          }
          return tokens;
        }
        /**
         * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
         *
         * It allows one to customise which words should break
         * Examples are if the token is CJK or numbers.
         * It must return a boolean.
         * @param _token - The token
         * @param breakWords - The style attr break words
         * @returns Whether to break word or not
         */
        static canBreakWords(_token, breakWords) {
          return breakWords;
        }
        /**
         * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
         *
         * It allows one to determine whether a pair of characters
         * should be broken by newlines
         * For example certain characters in CJK langs or numbers.
         * It must return a boolean.
         * @param _char - The character
         * @param _nextChar - The next character
         * @param _token - The token/word the characters are from
         * @param _index - The index in the token of the char
         * @param _breakWords - The style attr break words
         * @returns whether to break word or not
         */
        static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {
          return true;
        }
        /**
         * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
         *
         * It is called when a token (usually a word) has to be split into separate pieces
         * in order to determine the point to break a word.
         * It must return an array of characters.
         * @param token - The token to split
         * @returns The characters of the token
         * @see CanvasTextMetrics.graphemeSegmenter
         */
        static wordWrapSplit(token) {
          return _CanvasTextMetrics2.graphemeSegmenter(token);
        }
        /**
         * Calculates the ascent, descent and fontSize of a given font-style
         * @param font - String representing the style of the font
         * @returns Font properties object
         */
        static measureFont(font) {
          if (_CanvasTextMetrics2._fonts[font]) {
            return _CanvasTextMetrics2._fonts[font];
          }
          const context4 = _CanvasTextMetrics2._context;
          context4.font = font;
          const metrics = context4.measureText(_CanvasTextMetrics2.METRICS_STRING + _CanvasTextMetrics2.BASELINE_SYMBOL);
          const properties = {
            ascent: metrics.actualBoundingBoxAscent,
            descent: metrics.actualBoundingBoxDescent,
            fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent
          };
          _CanvasTextMetrics2._fonts[font] = properties;
          return properties;
        }
        /**
         * Clear font metrics in metrics cache.
         * @param {string} [font] - font name. If font name not set then clear cache for all fonts.
         */
        static clearMetrics(font = "") {
          if (font) {
            delete _CanvasTextMetrics2._fonts[font];
          } else {
            _CanvasTextMetrics2._fonts = {};
          }
        }
        /**
         * Cached canvas element for measuring text
         * TODO: this should be private, but isn't because of backward compat, will fix later.
         * @ignore
         */
        static get _canvas() {
          if (!_CanvasTextMetrics2.__canvas) {
            let canvas;
            try {
              const c2 = new OffscreenCanvas(0, 0);
              const context4 = c2.getContext("2d", contextSettings);
              if (context4?.measureText) {
                _CanvasTextMetrics2.__canvas = c2;
                return c2;
              }
              canvas = DOMAdapter.get().createCanvas();
            } catch (ex) {
              canvas = DOMAdapter.get().createCanvas();
            }
            canvas.width = canvas.height = 10;
            _CanvasTextMetrics2.__canvas = canvas;
          }
          return _CanvasTextMetrics2.__canvas;
        }
        /**
         * TODO: this should be private, but isn't because of backward compat, will fix later.
         * @ignore
         */
        static get _context() {
          if (!_CanvasTextMetrics2.__context) {
            _CanvasTextMetrics2.__context = _CanvasTextMetrics2._canvas.getContext("2d", contextSettings);
          }
          return _CanvasTextMetrics2.__context;
        }
      };
      _CanvasTextMetrics.METRICS_STRING = "|\xC9q\xC5";
      _CanvasTextMetrics.BASELINE_SYMBOL = "M";
      _CanvasTextMetrics.BASELINE_MULTIPLIER = 1.4;
      _CanvasTextMetrics.HEIGHT_MULTIPLIER = 2;
      _CanvasTextMetrics.graphemeSegmenter = (() => {
        if (typeof Intl?.Segmenter === "function") {
          const segmenter = new Intl.Segmenter();
          return (s2) => [...segmenter.segment(s2)].map((x2) => x2.segment);
        }
        return (s2) => [...s2];
      })();
      _CanvasTextMetrics.experimentalLetterSpacing = false;
      _CanvasTextMetrics._fonts = {};
      _CanvasTextMetrics._newlines = [
        10,
        // line feed
        13
        // carriage return
      ];
      _CanvasTextMetrics._breakingSpaces = [
        9,
        // character tabulation
        32,
        // space
        8192,
        // en quad
        8193,
        // em quad
        8194,
        // en space
        8195,
        // em space
        8196,
        // three-per-em space
        8197,
        // four-per-em space
        8198,
        // six-per-em space
        8200,
        // punctuation space
        8201,
        // thin space
        8202,
        // hair space
        8287,
        // medium mathematical space
        12288
        // ideographic space
      ];
      _CanvasTextMetrics._measurementCache = {};
      CanvasTextMetrics = _CanvasTextMetrics;
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs
  function getCanvasFillStyle(fillStyle, context4) {
    if (fillStyle.texture === Texture.WHITE && !fillStyle.fill) {
      return Color.shared.setValue(fillStyle.color).toHex();
    } else if (!fillStyle.fill) {
      const pattern = context4.createPattern(fillStyle.texture.source.resource, "repeat");
      const tempMatrix6 = fillStyle.matrix.copyTo(Matrix.shared);
      tempMatrix6.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height);
      pattern.setTransform(tempMatrix6);
      return pattern;
    } else if (fillStyle.fill instanceof FillPattern) {
      const fillPattern = fillStyle.fill;
      const pattern = context4.createPattern(fillPattern.texture.source.resource, "repeat");
      const tempMatrix6 = fillPattern.transform.copyTo(Matrix.shared);
      tempMatrix6.scale(
        fillPattern.texture.frame.width,
        fillPattern.texture.frame.height
      );
      pattern.setTransform(tempMatrix6);
      return pattern;
    } else if (fillStyle.fill instanceof FillGradient) {
      const fillGradient = fillStyle.fill;
      if (fillGradient.type === "linear") {
        const gradient = context4.createLinearGradient(
          fillGradient.x0,
          fillGradient.y0,
          fillGradient.x1,
          fillGradient.y1
        );
        fillGradient.gradientStops.forEach((stop) => {
          gradient.addColorStop(stop.offset, Color.shared.setValue(stop.color).toHex());
        });
        return gradient;
      }
    }
    warn("FillStyle not recognised", fillStyle);
    return "red";
  }
  var init_getCanvasFillStyle = __esm({
    "../core/node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs"() {
      init_Color();
      init_Matrix();
      init_Texture();
      init_warn();
      init_FillGradient();
      init_FillPattern();
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.mjs
  var CanvasTextSystem;
  var init_CanvasTextSystem = __esm({
    "../core/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.mjs"() {
      init_Color();
      init_Extensions();
      init_pow2();
      init_CanvasPool();
      init_TexturePool();
      init_getCanvasBoundingBox();
      init_deprecation();
      init_TextStyle();
      init_getPo2TextureFromSource();
      init_CanvasTextMetrics();
      init_fontStringFromTextStyle();
      init_getCanvasFillStyle();
      CanvasTextSystem = class {
        constructor(_renderer) {
          this._activeTextures = {};
          this._renderer = _renderer;
        }
        getTextureSize(text2, resolution, style) {
          const measured = CanvasTextMetrics.measureText(text2 || " ", style);
          let width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);
          let height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);
          width = Math.ceil(width - 1e-6);
          height = Math.ceil(height - 1e-6);
          width = nextPow2(width);
          height = nextPow2(height);
          return { width, height };
        }
        getTexture(options, resolution, style, _textKey) {
          if (typeof options === "string") {
            deprecation("8.0.0", "CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments");
            options = {
              text: options,
              style,
              resolution
            };
          }
          if (!(options.style instanceof TextStyle)) {
            options.style = new TextStyle(options.style);
          }
          const { texture, canvasAndContext } = this.createTextureAndCanvas(
            options
          );
          this._renderer.texture.initSource(texture._source);
          CanvasPool.returnCanvasAndContext(canvasAndContext);
          return texture;
        }
        createTextureAndCanvas(options) {
          const { text: text2, style } = options;
          const resolution = options.resolution ?? this._renderer.resolution;
          const measured = CanvasTextMetrics.measureText(text2 || " ", style);
          const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);
          const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);
          const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width, height);
          const { canvas } = canvasAndContext;
          this.renderTextToCanvas(text2, style, resolution, canvasAndContext);
          const texture = getPo2TextureFromSource(canvas, width, height, resolution);
          if (style.trim) {
            const trimmed = getCanvasBoundingBox(canvas, resolution);
            texture.frame.copyFrom(trimmed);
            texture.updateUvs();
          }
          return { texture, canvasAndContext };
        }
        getManagedTexture(text2) {
          const textKey = text2._getKey();
          if (this._activeTextures[textKey]) {
            this._increaseReferenceCount(textKey);
            return this._activeTextures[textKey].texture;
          }
          const { texture, canvasAndContext } = this.createTextureAndCanvas(text2);
          this._activeTextures[textKey] = {
            canvasAndContext,
            texture,
            usageCount: 1
          };
          return texture;
        }
        _increaseReferenceCount(textKey) {
          this._activeTextures[textKey].usageCount++;
        }
        decreaseReferenceCount(textKey) {
          const activeTexture = this._activeTextures[textKey];
          activeTexture.usageCount--;
          if (activeTexture.usageCount === 0) {
            CanvasPool.returnCanvasAndContext(activeTexture.canvasAndContext);
            TexturePool.returnTexture(activeTexture.texture);
            const source2 = activeTexture.texture.source;
            source2.resource = null;
            source2.uploadMethodId = "unknown";
            source2.alphaMode = "no-premultiply-alpha";
            this._activeTextures[textKey] = null;
          }
        }
        getReferenceCount(textKey) {
          return this._activeTextures[textKey].usageCount;
        }
        /**
         * Renders text to its canvas, and updates its texture.
         *
         * By default this is used internally to ensure the texture is correct before rendering,
         * but it can be used called externally, for example from this class to 'pre-generate' the texture from a piece of text,
         * and then shared across multiple Sprites.
         * @param text
         * @param style
         * @param resolution
         * @param canvasAndContext
         */
        renderTextToCanvas(text2, style, resolution, canvasAndContext) {
          const { canvas, context: context4 } = canvasAndContext;
          const font = fontStringFromTextStyle(style);
          const measured = CanvasTextMetrics.measureText(text2 || " ", style);
          const lines = measured.lines;
          const lineHeight = measured.lineHeight;
          const lineWidths = measured.lineWidths;
          const maxLineWidth = measured.maxLineWidth;
          const fontProperties = measured.fontProperties;
          const height = canvas.height;
          context4.resetTransform();
          context4.scale(resolution, resolution);
          const padding = style.padding * 2;
          context4.clearRect(0, 0, measured.width + 4 + padding, measured.height + 4 + padding);
          if (style._stroke?.width) {
            const strokeStyle = style._stroke;
            context4.lineWidth = strokeStyle.width;
            context4.miterLimit = strokeStyle.miterLimit;
            context4.lineJoin = strokeStyle.join;
            context4.lineCap = strokeStyle.cap;
          }
          context4.font = font;
          let linePositionX;
          let linePositionY;
          const passesCount = style.dropShadow ? 2 : 1;
          for (let i2 = 0; i2 < passesCount; ++i2) {
            const isShadowPass = style.dropShadow && i2 === 0;
            const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;
            const dsOffsetShadow = dsOffsetText * resolution;
            if (isShadowPass) {
              context4.fillStyle = "black";
              context4.strokeStyle = "black";
              const shadowOptions = style.dropShadow;
              const dropShadowColor = shadowOptions.color;
              const dropShadowAlpha = shadowOptions.alpha;
              context4.shadowColor = Color.shared.setValue(dropShadowColor).setAlpha(dropShadowAlpha).toRgbaString();
              const dropShadowBlur = shadowOptions.blur * resolution;
              const dropShadowDistance = shadowOptions.distance * resolution;
              context4.shadowBlur = dropShadowBlur;
              context4.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;
              context4.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance + dsOffsetShadow;
            } else {
              context4.globalAlpha = style._fill?.alpha ?? 1;
              context4.fillStyle = style._fill ? getCanvasFillStyle(style._fill, context4) : null;
              if (style._stroke?.width) {
                context4.strokeStyle = getCanvasFillStyle(style._stroke, context4);
              }
              context4.shadowColor = "black";
            }
            let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;
            if (lineHeight - fontProperties.fontSize < 0) {
              linePositionYShift = 0;
            }
            const strokeWidth = style._stroke?.width ?? 0;
            for (let i22 = 0; i22 < lines.length; i22++) {
              linePositionX = strokeWidth / 2;
              linePositionY = strokeWidth / 2 + i22 * lineHeight + fontProperties.ascent + linePositionYShift;
              if (style.align === "right") {
                linePositionX += maxLineWidth - lineWidths[i22];
              } else if (style.align === "center") {
                linePositionX += (maxLineWidth - lineWidths[i22]) / 2;
              }
              if (style._stroke?.width) {
                this._drawLetterSpacing(
                  lines[i22],
                  style,
                  canvasAndContext,
                  linePositionX + style.padding,
                  linePositionY + style.padding - dsOffsetText,
                  true
                );
              }
              if (style._fill !== void 0) {
                this._drawLetterSpacing(
                  lines[i22],
                  style,
                  canvasAndContext,
                  linePositionX + style.padding,
                  linePositionY + style.padding - dsOffsetText
                );
              }
            }
          }
        }
        /**
         * Render the text with letter-spacing.
         * @param text - The text to draw
         * @param style
         * @param canvasAndContext
         * @param x - Horizontal position to draw the text
         * @param y - Vertical position to draw the text
         * @param isStroke - Is this drawing for the outside stroke of the
         *  text? If not, it's for the inside fill
         */
        _drawLetterSpacing(text2, style, canvasAndContext, x2, y2, isStroke = false) {
          const { context: context4 } = canvasAndContext;
          const letterSpacing = style.letterSpacing;
          let useExperimentalLetterSpacing = false;
          if (CanvasTextMetrics.experimentalLetterSpacingSupported) {
            if (CanvasTextMetrics.experimentalLetterSpacing) {
              context4.letterSpacing = `${letterSpacing}px`;
              context4.textLetterSpacing = `${letterSpacing}px`;
              useExperimentalLetterSpacing = true;
            } else {
              context4.letterSpacing = "0px";
              context4.textLetterSpacing = "0px";
            }
          }
          if (letterSpacing === 0 || useExperimentalLetterSpacing) {
            if (isStroke) {
              context4.strokeText(text2, x2, y2);
            } else {
              context4.fillText(text2, x2, y2);
            }
            return;
          }
          let currentPosition = x2;
          const stringArray = CanvasTextMetrics.graphemeSegmenter(text2);
          let previousWidth = context4.measureText(text2).width;
          let currentWidth = 0;
          for (let i2 = 0; i2 < stringArray.length; ++i2) {
            const currentChar = stringArray[i2];
            if (isStroke) {
              context4.strokeText(currentChar, currentPosition, y2);
            } else {
              context4.fillText(currentChar, currentPosition, y2);
            }
            let textStr = "";
            for (let j2 = i2 + 1; j2 < stringArray.length; ++j2) {
              textStr += stringArray[j2];
            }
            currentWidth = context4.measureText(textStr).width;
            currentPosition += previousWidth - currentWidth + letterSpacing;
            previousWidth = currentWidth;
          }
        }
        destroy() {
          this._activeTextures = null;
        }
      };
      CanvasTextSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "canvasText"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/text/init.mjs
  var init_init8 = __esm({
    "../core/node_modules/pixi.js/lib/scene/text/init.mjs"() {
      init_Extensions();
      init_CanvasTextPipe();
      init_CanvasTextSystem();
      extensions.add(CanvasTextSystem);
      extensions.add(CanvasTextPipe);
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.mjs
  var AbstractBitmapFont;
  var init_AbstractBitmapFont = __esm({
    "../core/node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.mjs"() {
      init_eventemitter3();
      init_deprecation();
      AbstractBitmapFont = class extends eventemitter3_default {
        constructor() {
          super(...arguments);
          this.chars = /* @__PURE__ */ Object.create(null);
          this.lineHeight = 0;
          this.fontFamily = "";
          this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 };
          this.baseLineOffset = 0;
          this.distanceField = { type: "none", range: 0 };
          this.pages = [];
          this.baseMeasurementFontSize = 100;
          this.baseRenderedFontSize = 100;
        }
        /**
         * The name of the font face.
         * @deprecated since 8.0.0 Use `fontFamily` instead.
         */
        get font() {
          deprecation(v8_0_0, "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.");
          return this.fontFamily;
        }
        /**
         * The map of base page textures (i.e., sheets of glyphs).
         * @deprecated since 8.0.0 Use `pages` instead.
         */
        get pageTextures() {
          deprecation(v8_0_0, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");
          return this.pages;
        }
        /**
         * The size of the font face in pixels.
         * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.
         */
        get size() {
          deprecation(v8_0_0, "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.");
          return this.fontMetrics.fontSize;
        }
        /**
         * The kind of distance field for this font or "none".
         * @deprecated since 8.0.0 Use `distanceField.type` instead.
         */
        get distanceFieldRange() {
          deprecation(v8_0_0, "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.");
          return this.distanceField.range;
        }
        /**
         * The range of the distance field in pixels.
         * @deprecated since 8.0.0 Use `distanceField.range` instead.
         */
        get distanceFieldType() {
          deprecation(v8_0_0, "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.");
          return this.distanceField.type;
        }
        destroy(destroyTextures = false) {
          this.emit("destroy", this);
          this.removeAllListeners();
          for (const i2 in this.chars) {
            this.chars[i2].texture.destroy();
          }
          this.chars = null;
          if (destroyTextures) {
            this.pages.forEach((page) => page.texture.destroy(true));
            this.pages = null;
          }
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/text-bitmap/utils/resolveCharacters.mjs
  function resolveCharacters(chars) {
    if (chars === "") {
      return [];
    }
    if (typeof chars === "string") {
      chars = [chars];
    }
    const result = [];
    for (let i2 = 0, j2 = chars.length; i2 < j2; i2++) {
      const item = chars[i2];
      if (Array.isArray(item)) {
        if (item.length !== 2) {
          throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);
        }
        if (item[0].length === 0 || item[1].length === 0) {
          throw new Error("[BitmapFont]: Invalid character delimiter.");
        }
        const startCode = item[0].charCodeAt(0);
        const endCode = item[1].charCodeAt(0);
        if (endCode < startCode) {
          throw new Error("[BitmapFont]: Invalid character range.");
        }
        for (let i22 = startCode, j22 = endCode; i22 <= j22; i22++) {
          result.push(String.fromCharCode(i22));
        }
      } else {
        result.push(...Array.from(item));
      }
    }
    if (result.length === 0) {
      throw new Error("[BitmapFont]: Empty set when resolving characters.");
    }
    return result;
  }
  var init_resolveCharacters = __esm({
    "../core/node_modules/pixi.js/lib/scene/text-bitmap/utils/resolveCharacters.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/text-bitmap/DynamicBitmapFont.mjs
  var DynamicBitmapFont;
  var init_DynamicBitmapFont = __esm({
    "../core/node_modules/pixi.js/lib/scene/text-bitmap/DynamicBitmapFont.mjs"() {
      init_Color();
      init_Rectangle();
      init_CanvasPool();
      init_ImageSource();
      init_Texture();
      init_deprecation();
      init_CanvasTextMetrics();
      init_fontStringFromTextStyle();
      init_getCanvasFillStyle();
      init_AbstractBitmapFont();
      init_resolveCharacters();
      DynamicBitmapFont = class extends AbstractBitmapFont {
        /**
         * @param options - The options for the dynamic bitmap font.
         */
        constructor(options) {
          super();
          this.resolution = 1;
          this.pages = [];
          this._padding = 4;
          this._measureCache = /* @__PURE__ */ Object.create(null);
          this._currentChars = [];
          this._currentX = 0;
          this._currentY = 0;
          this._currentPageIndex = -1;
          this._skipKerning = false;
          const dynamicOptions = options;
          const style = dynamicOptions.style.clone();
          if (dynamicOptions.overrideFill) {
            style._fill.color = 16777215;
            style._fill.alpha = 1;
            style._fill.texture = Texture.WHITE;
            style._fill.fill = null;
          }
          const requestedFontSize = style.fontSize;
          style.fontSize = this.baseMeasurementFontSize;
          const font = fontStringFromTextStyle(style);
          if (dynamicOptions.overrideSize) {
            if (style._stroke) {
              style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;
            }
          } else {
            style.fontSize = this.baseRenderedFontSize = requestedFontSize;
          }
          this._style = style;
          this._skipKerning = dynamicOptions.skipKerning ?? false;
          this.resolution = dynamicOptions.resolution ?? 1;
          this._padding = dynamicOptions.padding ?? 4;
          this.fontMetrics = CanvasTextMetrics.measureFont(font);
          this.lineHeight = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;
        }
        ensureCharacters(chars) {
          const charList = resolveCharacters(chars).filter((char) => !this._currentChars.includes(char)).filter((char, index, self2) => self2.indexOf(char) === index);
          if (!charList.length)
            return;
          this._currentChars = [...this._currentChars, ...charList];
          let pageData;
          if (this._currentPageIndex === -1) {
            pageData = this._nextPage();
          } else {
            pageData = this.pages[this._currentPageIndex];
          }
          let { canvas, context: context4 } = pageData.canvasAndContext;
          let textureSource = pageData.texture.source;
          const style = this._style;
          let currentX = this._currentX;
          let currentY = this._currentY;
          const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;
          const padding = this._padding * fontScale;
          const widthScale = style.fontStyle === "italic" ? 2 : 1;
          let maxCharHeight = 0;
          let skipTexture = false;
          for (let i2 = 0; i2 < charList.length; i2++) {
            const char = charList[i2];
            const metrics = CanvasTextMetrics.measureText(char, style, canvas, false);
            metrics.lineHeight = metrics.height;
            const width = widthScale * metrics.width * fontScale;
            const height = metrics.height * fontScale;
            const paddedWidth = width + padding * 2;
            const paddedHeight = height + padding * 2;
            skipTexture = false;
            if (char !== "\n" && char !== "\r" && char !== "	" && char !== " ") {
              skipTexture = true;
              maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight));
            }
            if (currentX + paddedWidth > 512) {
              currentY += maxCharHeight;
              maxCharHeight = paddedHeight;
              currentX = 0;
              if (currentY + maxCharHeight > 512) {
                textureSource.update();
                const pageData2 = this._nextPage();
                canvas = pageData2.canvasAndContext.canvas;
                context4 = pageData2.canvasAndContext.context;
                textureSource = pageData2.texture.source;
                currentY = 0;
              }
            }
            const xAdvance = width / fontScale - (style.dropShadow?.distance ?? 0) - (style._stroke?.width ?? 0);
            this.chars[char] = {
              id: char.codePointAt(0),
              xOffset: -this._padding,
              yOffset: -this._padding,
              xAdvance,
              kerning: {}
            };
            if (skipTexture) {
              this._drawGlyph(
                context4,
                metrics,
                currentX + padding,
                currentY + padding,
                fontScale,
                style
              );
              const px = textureSource.width * fontScale;
              const py = textureSource.height * fontScale;
              const frame = new Rectangle(
                currentX / px * textureSource.width,
                currentY / py * textureSource.height,
                paddedWidth / px * textureSource.width,
                paddedHeight / py * textureSource.height
              );
              this.chars[char].texture = new Texture({
                source: textureSource,
                frame
              });
              currentX += Math.ceil(paddedWidth);
            }
          }
          textureSource.update();
          this._currentX = currentX;
          this._currentY = currentY;
          this._skipKerning && this._applyKerning(charList, context4);
        }
        /**
         * @deprecated since 8.0.0
         * The map of base page textures (i.e., sheets of glyphs).
         */
        get pageTextures() {
          deprecation(v8_0_0, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");
          return this.pages;
        }
        _applyKerning(newChars, context4) {
          const measureCache = this._measureCache;
          for (let i2 = 0; i2 < newChars.length; i2++) {
            const first2 = newChars[i2];
            for (let j2 = 0; j2 < this._currentChars.length; j2++) {
              const second = this._currentChars[j2];
              let c1 = measureCache[first2];
              if (!c1)
                c1 = measureCache[first2] = context4.measureText(first2).width;
              let c2 = measureCache[second];
              if (!c2)
                c2 = measureCache[second] = context4.measureText(second).width;
              let total = context4.measureText(first2 + second).width;
              let amount = total - (c1 + c2);
              if (amount) {
                this.chars[first2].kerning[second] = amount;
              }
              total = context4.measureText(first2 + second).width;
              amount = total - (c1 + c2);
              if (amount) {
                this.chars[second].kerning[first2] = amount;
              }
            }
          }
        }
        _nextPage() {
          this._currentPageIndex++;
          const textureResolution = this.resolution;
          const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(512, 512, textureResolution);
          this._setupContext(canvasAndContext.context, this._style, textureResolution);
          const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);
          const texture = new Texture({
            source: new ImageSource({
              resource: canvasAndContext.canvas,
              resolution,
              alphaMode: "premultiply-alpha-on-upload"
            })
          });
          const pageData = {
            canvasAndContext,
            texture
          };
          this.pages[this._currentPageIndex] = pageData;
          return pageData;
        }
        // canvas style!
        _setupContext(context4, style, resolution) {
          style.fontSize = this.baseRenderedFontSize;
          context4.scale(resolution, resolution);
          context4.font = fontStringFromTextStyle(style);
          style.fontSize = this.baseMeasurementFontSize;
          context4.textBaseline = style.textBaseline;
          const stroke = style._stroke;
          const strokeThickness = stroke?.width ?? 0;
          if (stroke) {
            context4.lineWidth = strokeThickness;
            context4.lineJoin = stroke.join;
            context4.miterLimit = stroke.miterLimit;
            context4.strokeStyle = getCanvasFillStyle(stroke, context4);
          }
          if (style._fill) {
            context4.fillStyle = getCanvasFillStyle(style._fill, context4);
          }
          if (style.dropShadow) {
            const shadowOptions = style.dropShadow;
            const rgb = Color.shared.setValue(shadowOptions.color).toArray();
            const dropShadowBlur = shadowOptions.blur * resolution;
            const dropShadowDistance = shadowOptions.distance * resolution;
            context4.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;
            context4.shadowBlur = dropShadowBlur;
            context4.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;
            context4.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;
          } else {
            context4.shadowColor = "black";
            context4.shadowBlur = 0;
            context4.shadowOffsetX = 0;
            context4.shadowOffsetY = 0;
          }
        }
        _drawGlyph(context4, metrics, x2, y2, fontScale, style) {
          const char = metrics.text;
          const fontProperties = metrics.fontProperties;
          const stroke = style._stroke;
          const strokeThickness = (stroke?.width ?? 0) * fontScale;
          const tx = x2 + strokeThickness / 2;
          const ty = y2 - strokeThickness / 2;
          const descent = fontProperties.descent * fontScale;
          const lineHeight = metrics.lineHeight * fontScale;
          if (style.stroke && strokeThickness) {
            context4.strokeText(char, tx, ty + lineHeight - descent);
          }
          if (style._fill) {
            context4.fillText(char, tx, ty + lineHeight - descent);
          }
        }
        destroy() {
          super.destroy();
          for (let i2 = 0; i2 < this.pages.length; i2++) {
            const { canvasAndContext, texture } = this.pages[i2];
            CanvasPool.returnCanvasAndContext(canvasAndContext);
            texture.destroy(true);
          }
          this.pages = null;
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.mjs
  function getBitmapTextLayout(chars, style, font) {
    const layoutData = {
      width: 0,
      height: 0,
      offsetY: 0,
      scale: style.fontSize / font.baseMeasurementFontSize,
      lines: [{
        width: 0,
        charPositions: [],
        spaceWidth: 0,
        spacesIndex: [],
        chars: []
      }]
    };
    layoutData.offsetY = font.baseLineOffset;
    let currentLine = layoutData.lines[0];
    let previousChar = null;
    let firstWord = true;
    const currentWord = {
      spaceWord: false,
      width: 0,
      start: 0,
      index: 0,
      // use index to not modify the array as we use it a lot!
      positions: [],
      chars: []
    };
    const nextWord = (word) => {
      const start = currentLine.width;
      for (let j2 = 0; j2 < currentWord.index; j2++) {
        const position = word.positions[j2];
        currentLine.chars.push(word.chars[j2]);
        currentLine.charPositions.push(position + start);
      }
      currentLine.width += word.width;
      firstWord = false;
      currentWord.width = 0;
      currentWord.index = 0;
      currentWord.chars.length = 0;
    };
    const nextLine = () => {
      let index = currentLine.chars.length - 1;
      let lastChar = currentLine.chars[index];
      while (lastChar === " ") {
        currentLine.width -= font.chars[lastChar].xAdvance;
        lastChar = currentLine.chars[--index];
      }
      layoutData.width = Math.max(layoutData.width, currentLine.width);
      currentLine = {
        width: 0,
        charPositions: [],
        chars: [],
        spaceWidth: 0,
        spacesIndex: []
      };
      firstWord = true;
      layoutData.lines.push(currentLine);
      layoutData.height += font.lineHeight;
    };
    const scale = font.baseMeasurementFontSize / style.fontSize;
    const adjustedLetterSpacing = style.letterSpacing * scale;
    const adjustedWordWrapWidth = style.wordWrapWidth * scale;
    for (let i2 = 0; i2 < chars.length + 1; i2++) {
      let char;
      const isEnd = i2 === chars.length;
      if (!isEnd) {
        char = chars[i2];
      }
      const charData = font.chars[char] || font.chars[" "];
      const isSpace = /(?:\s)/.test(char);
      const isWordBreak = isSpace || char === "\r" || char === "\n" || isEnd;
      if (isWordBreak) {
        const addWordToNextLine = !firstWord && style.wordWrap && currentLine.width + currentWord.width - adjustedLetterSpacing > adjustedWordWrapWidth;
        if (addWordToNextLine) {
          nextLine();
          nextWord(currentWord);
          if (!isEnd) {
            currentLine.charPositions.push(0);
          }
        } else {
          currentWord.start = currentLine.width;
          nextWord(currentWord);
          if (!isEnd) {
            currentLine.charPositions.push(0);
          }
        }
        if (char === "\r" || char === "\n") {
          if (currentLine.width !== 0) {
            nextLine();
          }
        } else if (!isEnd) {
          const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;
          currentLine.width += spaceWidth;
          currentLine.spaceWidth = spaceWidth;
          currentLine.spacesIndex.push(currentLine.charPositions.length);
          currentLine.chars.push(char);
        }
      } else {
        const kerning = charData.kerning[previousChar] || 0;
        const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;
        currentWord.positions[currentWord.index++] = currentWord.width + kerning;
        currentWord.chars.push(char);
        currentWord.width += nextCharWidth;
      }
      previousChar = char;
    }
    nextLine();
    if (style.align === "center") {
      alignCenter(layoutData);
    } else if (style.align === "right") {
      alignRight(layoutData);
    } else if (style.align === "justify") {
      alignJustify(layoutData);
    }
    return layoutData;
  }
  function alignCenter(measurementData) {
    for (let i2 = 0; i2 < measurementData.lines.length; i2++) {
      const line = measurementData.lines[i2];
      const offset = measurementData.width / 2 - line.width / 2;
      for (let j2 = 0; j2 < line.charPositions.length; j2++) {
        line.charPositions[j2] += offset;
      }
    }
  }
  function alignRight(measurementData) {
    for (let i2 = 0; i2 < measurementData.lines.length; i2++) {
      const line = measurementData.lines[i2];
      const offset = measurementData.width - line.width;
      for (let j2 = 0; j2 < line.charPositions.length; j2++) {
        line.charPositions[j2] += offset;
      }
    }
  }
  function alignJustify(measurementData) {
    const width = measurementData.width;
    for (let i2 = 0; i2 < measurementData.lines.length; i2++) {
      const line = measurementData.lines[i2];
      let indy = 0;
      let spaceIndex = line.spacesIndex[indy++];
      let offset = 0;
      const totalSpaces = line.spacesIndex.length;
      const newSpaceWidth = (width - line.width) / totalSpaces;
      const spaceWidth = newSpaceWidth;
      for (let j2 = 0; j2 < line.charPositions.length; j2++) {
        if (j2 === spaceIndex) {
          spaceIndex = line.spacesIndex[indy++];
          offset += spaceWidth;
        }
        line.charPositions[j2] += offset;
      }
    }
  }
  var init_getBitmapTextLayout = __esm({
    "../core/node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs
  var BitmapFontManagerClass, BitmapFontManager;
  var init_BitmapFontManager = __esm({
    "../core/node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs"() {
      init_Cache();
      init_deprecation();
      init_TextStyle();
      init_DynamicBitmapFont();
      init_getBitmapTextLayout();
      init_resolveCharacters();
      BitmapFontManagerClass = class {
        constructor() {
          this.ALPHA = [["a", "z"], ["A", "Z"], " "];
          this.NUMERIC = [["0", "9"]];
          this.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];
          this.ASCII = [[" ", "~"]];
          this.defaultOptions = {
            chars: this.ALPHANUMERIC,
            resolution: 1,
            padding: 4,
            skipKerning: false
          };
        }
        /**
         * Get a font for the specified text and style.
         * @param text - The text to get the font for
         * @param style - The style to use
         */
        getFont(text2, style) {
          let fontFamilyKey = `${style.fontFamily}-bitmap`;
          let overrideFill = true;
          if (style._fill.fill) {
            fontFamilyKey += style._fill.fill.uid;
            overrideFill = false;
          }
          if (!Cache.has(fontFamilyKey)) {
            const fnt = new DynamicBitmapFont({
              style,
              overrideFill,
              overrideSize: true,
              ...this.defaultOptions
            });
            fnt.once("destroy", () => Cache.remove(fontFamilyKey));
            Cache.set(
              fontFamilyKey,
              fnt
            );
          }
          const dynamicFont = Cache.get(fontFamilyKey);
          dynamicFont.ensureCharacters?.(text2);
          return dynamicFont;
        }
        /**
         * Get the layout of a text for the specified style.
         * @param text - The text to get the layout for
         * @param style - The style to use
         */
        getLayout(text2, style) {
          const bitmapFont = this.getFont(text2, style);
          return getBitmapTextLayout([...text2], style, bitmapFont);
        }
        /**
         * Measure the text using the specified style.
         * @param text - The text to measure
         * @param style - The style to use
         */
        measureText(text2, style) {
          return this.getLayout(text2, style);
        }
        // eslint-disable-next-line max-len
        install(...args) {
          let options = args[0];
          if (typeof options === "string") {
            options = {
              name: options,
              style: args[1],
              chars: args[2]?.chars,
              resolution: args[2]?.resolution,
              padding: args[2]?.padding,
              skipKerning: args[2]?.skipKerning
            };
            deprecation(v8_0_0, "BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})");
          }
          const name = options?.name;
          if (!name) {
            throw new Error("[BitmapFontManager] Property `name` is required.");
          }
          options = { ...this.defaultOptions, ...options };
          const textStyle = options.style;
          const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);
          const overrideFill = style._fill.fill !== null && style._fill.fill !== void 0;
          const font = new DynamicBitmapFont({
            style,
            overrideFill,
            skipKerning: options.skipKerning,
            padding: options.padding,
            resolution: options.resolution,
            overrideSize: false
          });
          const flatChars = resolveCharacters(options.chars);
          font.ensureCharacters(flatChars.join(""));
          Cache.set(`${name}-bitmap`, font);
          font.once("destroy", () => Cache.remove(`${name}-bitmap`));
          return font;
        }
        /**
         * Uninstalls a bitmap font from the cache.
         * @param {string} name - The name of the bitmap font to uninstall.
         */
        uninstall(name) {
          const cacheKey = `${name}-bitmap`;
          const font = Cache.get(cacheKey);
          if (font) {
            Cache.remove(cacheKey);
            font.destroy();
          }
        }
      };
      BitmapFontManager = new BitmapFontManagerClass();
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/text-bitmap/BitmapFont.mjs
  var BitmapFont;
  var init_BitmapFont = __esm({
    "../core/node_modules/pixi.js/lib/scene/text-bitmap/BitmapFont.mjs"() {
      init_Rectangle();
      init_Texture();
      init_AbstractBitmapFont();
      init_BitmapFontManager();
      BitmapFont = class extends AbstractBitmapFont {
        constructor(options, url) {
          super();
          const { textures, data } = options;
          Object.keys(data.pages).forEach((key) => {
            const pageData = data.pages[parseInt(key, 10)];
            const texture = textures[pageData.id];
            this.pages.push({ texture });
          });
          Object.keys(data.chars).forEach((key) => {
            const charData = data.chars[key];
            const {
              frame: textureFrame,
              source: textureSource
            } = textures[charData.page];
            const frameReal = new Rectangle(
              charData.x + textureFrame.x,
              charData.y + textureFrame.y,
              charData.width,
              charData.height
            );
            const texture = new Texture({
              source: textureSource,
              frame: frameReal
            });
            this.chars[key] = {
              id: key.codePointAt(0),
              xOffset: charData.xOffset,
              yOffset: charData.yOffset,
              xAdvance: charData.xAdvance,
              kerning: charData.kerning ?? {},
              texture
            };
          });
          this.baseRenderedFontSize = data.fontSize;
          this.baseMeasurementFontSize = data.fontSize;
          this.fontMetrics = {
            ascent: 0,
            descent: 0,
            fontSize: data.fontSize
          };
          this.baseLineOffset = data.baseLineOffset;
          this.lineHeight = data.lineHeight;
          this.fontFamily = data.fontFamily;
          this.distanceField = data.distanceField ?? {
            type: "none",
            range: 0
          };
          this.url = url;
        }
        /** Destroys the BitmapFont object. */
        destroy() {
          super.destroy();
          for (let i2 = 0; i2 < this.pages.length; i2++) {
            const { texture } = this.pages[i2];
            texture.destroy(true);
          }
          this.pages = null;
        }
        /**
         * Generates a bitmap-font for the given style and character set
         * @param options - Setup options for font generation.
         * @returns Font generated by style options.
         * @example
         * import { BitmapFont, BitmapText } from 'pixi.js';
         *
         * BitmapFont.install('TitleFont', {
         *     fontFamily: 'Arial',
         *     fontSize: 12,
         *     strokeThickness: 2,
         *     fill: 'purple',
         * });
         *
         * const title = new BitmapText({ text: 'This is the title', fontFamily: 'TitleFont' });
         */
        static install(options) {
          BitmapFontManager.install(options);
        }
        /**
         * Uninstalls a bitmap font from the cache.
         * @param {string} name - The name of the bitmap font to uninstall.
         */
        static uninstall(name) {
          BitmapFontManager.uninstall(name);
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontTextParser.mjs
  var bitmapFontTextParser;
  var init_bitmapFontTextParser = __esm({
    "../core/node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontTextParser.mjs"() {
      "use strict";
      bitmapFontTextParser = {
        test(data) {
          return typeof data === "string" && data.startsWith("info face=");
        },
        parse(txt) {
          const items = txt.match(/^[a-z]+\s+.+$/gm);
          const rawData = {
            info: [],
            common: [],
            page: [],
            char: [],
            chars: [],
            kerning: [],
            kernings: [],
            distanceField: []
          };
          for (const i2 in items) {
            const name = items[i2].match(/^[a-z]+/gm)[0];
            const attributeList = items[i2].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm);
            const itemData = {};
            for (const i22 in attributeList) {
              const split = attributeList[i22].split("=");
              const key = split[0];
              const strValue = split[1].replace(/"/gm, "");
              const floatValue = parseFloat(strValue);
              const value = isNaN(floatValue) ? strValue : floatValue;
              itemData[key] = value;
            }
            rawData[name].push(itemData);
          }
          const font = {
            chars: {},
            pages: [],
            lineHeight: 0,
            fontSize: 0,
            fontFamily: "",
            distanceField: null,
            baseLineOffset: 0
          };
          const [info] = rawData.info;
          const [common] = rawData.common;
          const [distanceField] = rawData.distanceField ?? [];
          if (distanceField) {
            font.distanceField = {
              range: parseInt(distanceField.distanceRange, 10),
              type: distanceField.fieldType
            };
          }
          font.fontSize = parseInt(info.size, 10);
          font.fontFamily = info.face;
          font.lineHeight = parseInt(common.lineHeight, 10);
          const page = rawData.page;
          for (let i2 = 0; i2 < page.length; i2++) {
            font.pages.push({
              id: parseInt(page[i2].id, 10) || 0,
              file: page[i2].file
            });
          }
          const map3 = {};
          font.baseLineOffset = font.lineHeight - parseInt(common.base, 10);
          const char = rawData.char;
          for (let i2 = 0; i2 < char.length; i2++) {
            const charNode = char[i2];
            const id = parseInt(charNode.id, 10);
            let letter = charNode.letter ?? charNode.char ?? String.fromCharCode(id);
            if (letter === "space")
              letter = " ";
            map3[id] = letter;
            font.chars[letter] = {
              id,
              // texture deets..
              page: parseInt(charNode.page, 10) || 0,
              x: parseInt(charNode.x, 10),
              y: parseInt(charNode.y, 10),
              width: parseInt(charNode.width, 10),
              height: parseInt(charNode.height, 10),
              xOffset: parseInt(charNode.xoffset, 10),
              yOffset: parseInt(charNode.yoffset, 10),
              xAdvance: parseInt(charNode.xadvance, 10),
              kerning: {}
            };
          }
          const kerning = rawData.kerning || [];
          for (let i2 = 0; i2 < kerning.length; i2++) {
            const first2 = parseInt(kerning[i2].first, 10);
            const second = parseInt(kerning[i2].second, 10);
            const amount = parseInt(kerning[i2].amount, 10);
            font.chars[map3[second]].kerning[map3[first2]] = amount;
          }
          return font;
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLParser.mjs
  var bitmapFontXMLParser;
  var init_bitmapFontXMLParser = __esm({
    "../core/node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLParser.mjs"() {
      "use strict";
      bitmapFontXMLParser = {
        test(data) {
          const xml = data;
          return typeof xml !== "string" && "getElementsByTagName" in xml && xml.getElementsByTagName("page").length && xml.getElementsByTagName("info")[0].getAttribute("face") !== null;
        },
        parse(xml) {
          const data = {
            chars: {},
            pages: [],
            lineHeight: 0,
            fontSize: 0,
            fontFamily: "",
            distanceField: null,
            baseLineOffset: 0
          };
          const info = xml.getElementsByTagName("info")[0];
          const common = xml.getElementsByTagName("common")[0];
          const distanceField = xml.getElementsByTagName("distanceField")[0];
          if (distanceField) {
            data.distanceField = {
              type: distanceField.getAttribute("fieldType"),
              range: parseInt(distanceField.getAttribute("distanceRange"), 10)
            };
          }
          const page = xml.getElementsByTagName("page");
          const char = xml.getElementsByTagName("char");
          const kerning = xml.getElementsByTagName("kerning");
          data.fontSize = parseInt(info.getAttribute("size"), 10);
          data.fontFamily = info.getAttribute("face");
          data.lineHeight = parseInt(common.getAttribute("lineHeight"), 10);
          for (let i2 = 0; i2 < page.length; i2++) {
            data.pages.push({
              id: parseInt(page[i2].getAttribute("id"), 10) || 0,
              file: page[i2].getAttribute("file")
            });
          }
          const map3 = {};
          data.baseLineOffset = data.lineHeight - parseInt(common.getAttribute("base"), 10);
          for (let i2 = 0; i2 < char.length; i2++) {
            const charNode = char[i2];
            const id = parseInt(charNode.getAttribute("id"), 10);
            let letter = charNode.getAttribute("letter") ?? charNode.getAttribute("char") ?? String.fromCharCode(id);
            if (letter === "space")
              letter = " ";
            map3[id] = letter;
            data.chars[letter] = {
              id,
              // texture deets..
              page: parseInt(charNode.getAttribute("page"), 10) || 0,
              x: parseInt(charNode.getAttribute("x"), 10),
              y: parseInt(charNode.getAttribute("y"), 10),
              width: parseInt(charNode.getAttribute("width"), 10),
              height: parseInt(charNode.getAttribute("height"), 10),
              // render deets..
              xOffset: parseInt(charNode.getAttribute("xoffset"), 10),
              yOffset: parseInt(charNode.getAttribute("yoffset"), 10),
              // + baseLineOffset,
              xAdvance: parseInt(charNode.getAttribute("xadvance"), 10),
              kerning: {}
            };
          }
          for (let i2 = 0; i2 < kerning.length; i2++) {
            const first2 = parseInt(kerning[i2].getAttribute("first"), 10);
            const second = parseInt(kerning[i2].getAttribute("second"), 10);
            const amount = parseInt(kerning[i2].getAttribute("amount"), 10);
            data.chars[map3[second]].kerning[map3[first2]] = amount;
          }
          return data;
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLStringParser.mjs
  var bitmapFontXMLStringParser;
  var init_bitmapFontXMLStringParser = __esm({
    "../core/node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLStringParser.mjs"() {
      init_adapter();
      init_bitmapFontXMLParser();
      bitmapFontXMLStringParser = {
        test(data) {
          if (typeof data === "string" && data.includes("<font>")) {
            return bitmapFontXMLParser.test(DOMAdapter.get().parseXML(data));
          }
          return false;
        },
        parse(data) {
          return bitmapFontXMLParser.parse(DOMAdapter.get().parseXML(data));
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/text-bitmap/asset/loadBitmapFont.mjs
  var validExtensions, bitmapFontCachePlugin, loadBitmapFont;
  var init_loadBitmapFont = __esm({
    "../core/node_modules/pixi.js/lib/scene/text-bitmap/asset/loadBitmapFont.mjs"() {
      init_LoaderParser();
      init_copySearchParams();
      init_adapter();
      init_Extensions();
      init_path();
      init_BitmapFont();
      init_bitmapFontTextParser();
      init_bitmapFontXMLStringParser();
      validExtensions = [".xml", ".fnt"];
      bitmapFontCachePlugin = {
        extension: ExtensionType.CacheParser,
        test: (asset) => asset instanceof BitmapFont,
        getCacheableAssets(keys, asset) {
          const out2 = {};
          keys.forEach((key) => {
            out2[key] = asset;
          });
          out2[`${asset.fontFamily}-bitmap`] = asset;
          return out2;
        }
      };
      loadBitmapFont = {
        extension: {
          type: ExtensionType.LoadParser,
          priority: LoaderParserPriority.Normal
        },
        test(url) {
          return validExtensions.includes(path.extname(url).toLowerCase());
        },
        async testParse(data) {
          return bitmapFontTextParser.test(data) || bitmapFontXMLStringParser.test(data);
        },
        async parse(asset, data, loader) {
          const bitmapFontData = bitmapFontTextParser.test(asset) ? bitmapFontTextParser.parse(asset) : bitmapFontXMLStringParser.parse(asset);
          const { src } = data;
          const { pages } = bitmapFontData;
          const textureUrls = [];
          for (let i2 = 0; i2 < pages.length; ++i2) {
            const pageFile = pages[i2].file;
            let imagePath = path.join(path.dirname(src), pageFile);
            imagePath = copySearchParams(imagePath, src);
            textureUrls.push(imagePath);
          }
          const loadedTextures = await loader.load(textureUrls);
          const textures = textureUrls.map((url) => loadedTextures[url]);
          const bitmapFont = new BitmapFont({
            data: bitmapFontData,
            textures
          }, src);
          return bitmapFont;
        },
        async load(url, _options) {
          const response = await DOMAdapter.get().fetch(url);
          return await response.text();
        },
        async unload(bitmapFont, _resolvedAsset, loader) {
          await Promise.all(bitmapFont.pages.map((page) => loader.unload(page.texture.source._sourceOrigin)));
          bitmapFont.destroy();
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs
  var Graphics;
  var init_Graphics = __esm({
    "../core/node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs"() {
      init_deprecation();
      init_Container();
      init_GraphicsContext();
      Graphics = class extends Container {
        /**
         * @param options - Options for the Graphics.
         */
        constructor(options) {
          if (options instanceof GraphicsContext) {
            options = { context: options };
          }
          const { context: context4, roundPixels, ...rest } = options || {};
          super({
            label: "Graphics",
            ...rest
          });
          this.canBundle = true;
          this.renderPipeId = "graphics";
          this._roundPixels = 0;
          if (!context4) {
            this._context = this._ownedContext = new GraphicsContext();
          } else {
            this._context = context4;
          }
          this._context.on("update", this.onViewUpdate, this);
          this.allowChildren = false;
          this.roundPixels = roundPixels ?? false;
        }
        set context(context4) {
          if (context4 === this._context)
            return;
          this._context.off("update", this.onViewUpdate, this);
          this._context = context4;
          this._context.on("update", this.onViewUpdate, this);
          this.onViewUpdate();
        }
        get context() {
          return this._context;
        }
        /**
         * The local bounds of the graphic.
         * @type {rendering.Bounds}
         */
        get bounds() {
          return this._context.bounds;
        }
        /**
         * Adds the bounds of this object to the bounds object.
         * @param bounds - The output bounds object.
         */
        addBounds(bounds) {
          bounds.addBounds(this._context.bounds);
        }
        /**
         * Checks if the object contains the given point.
         * @param point - The point to check
         */
        containsPoint(point) {
          return this._context.containsPoint(point);
        }
        /**
         *  Whether or not to round the x/y position of the graphic.
         * @type {boolean}
         */
        get roundPixels() {
          return !!this._roundPixels;
        }
        set roundPixels(value) {
          this._roundPixels = value ? 1 : 0;
        }
        onViewUpdate() {
          this._didChangeId += 1 << 12;
          this._didGraphicsUpdate = true;
          if (this.didViewUpdate)
            return;
          this.didViewUpdate = true;
          const renderGroup = this.renderGroup || this.parentRenderGroup;
          if (renderGroup) {
            renderGroup.onChildViewUpdate(this);
          }
        }
        /**
         * Destroys this graphics renderable and optionally its context.
         * @param options - Options parameter. A boolean will act as if all options
         *
         * If the context was created by this graphics and `destroy(false)` or `destroy()` is called
         * then the context will still be destroyed.
         *
         * If you want to explicitly not destroy this context that this graphics created,
         * then you should pass destroy({ context: false })
         *
         * If the context was passed in as an argument to the constructor then it will not be destroyed
         * @param {boolean} [options.texture=false] - Should destroy the texture of the graphics context
         * @param {boolean} [options.textureSource=false] - Should destroy the texture source of the graphics context
         * @param {boolean} [options.context=false] - Should destroy the context
         */
        destroy(options) {
          if (this._ownedContext && !options) {
            this._ownedContext.destroy(options);
          } else if (options === true || options?.context === true) {
            this._context.destroy(options);
          }
          this._ownedContext = null;
          this._context = null;
          super.destroy(options);
        }
        _callContextMethod(method, args) {
          this.context[method](...args);
          return this;
        }
        // --------------------------------------- GraphicsContext methods ---------------------------------------
        /**
         * Sets the current fill style of the graphics context. The fill style can be a color, gradient,
         * pattern, or a more complex style defined by a FillStyle object.
         * @param {FillStyleInputs} args - The fill style to apply. This can be a simple color, a gradient or
         * pattern object, or a FillStyle or ConvertedFillStyle object.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        setFillStyle(...args) {
          return this._callContextMethod("setFillStyle", args);
        }
        /**
         * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can
         * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
         * @param {FillStyleInputs} args - The stroke style to apply. Can be defined as a color, a gradient or pattern,
         * or a StrokeStyle or ConvertedStrokeStyle object.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        setStrokeStyle(...args) {
          return this._callContextMethod("setStrokeStyle", args);
        }
        fill(...args) {
          return this._callContextMethod("fill", args);
        }
        /**
         * Strokes the current path with the current stroke style. This method can take an optional
         * FillStyleInputs parameter to define the stroke's appearance, including its color, width, and other properties.
         * @param {FillStyleInputs} args - (Optional) The stroke style to apply. Can be defined as a simple color or a more
         * complex style object. If omitted, uses the current stroke style.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        stroke(...args) {
          return this._callContextMethod("stroke", args);
        }
        texture(...args) {
          return this._callContextMethod("texture", args);
        }
        /**
         * Resets the current path. Any previous path and its commands are discarded and a new path is
         * started. This is typically called before beginning a new shape or series of drawing commands.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        beginPath() {
          return this._callContextMethod("beginPath", []);
        }
        /**
         * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by
         * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will
         * fail to cut correctly!
         */
        cut() {
          return this._callContextMethod("cut", []);
        }
        arc(...args) {
          return this._callContextMethod("arc", args);
        }
        arcTo(...args) {
          return this._callContextMethod("arcTo", args);
        }
        arcToSvg(...args) {
          return this._callContextMethod("arcToSvg", args);
        }
        bezierCurveTo(...args) {
          return this._callContextMethod("bezierCurveTo", args);
        }
        /**
         * Closes the current path by drawing a straight line back to the start.
         * If the shape is already closed or there are no points in the path, this method does nothing.
         * @returns The instance of the current object for chaining.
         */
        closePath() {
          return this._callContextMethod("closePath", []);
        }
        ellipse(...args) {
          return this._callContextMethod("ellipse", args);
        }
        circle(...args) {
          return this._callContextMethod("circle", args);
        }
        path(...args) {
          return this._callContextMethod("path", args);
        }
        lineTo(...args) {
          return this._callContextMethod("lineTo", args);
        }
        moveTo(...args) {
          return this._callContextMethod("moveTo", args);
        }
        quadraticCurveTo(...args) {
          return this._callContextMethod("quadraticCurveTo", args);
        }
        rect(...args) {
          return this._callContextMethod("rect", args);
        }
        roundRect(...args) {
          return this._callContextMethod("roundRect", args);
        }
        poly(...args) {
          return this._callContextMethod("poly", args);
        }
        regularPoly(...args) {
          return this._callContextMethod("regularPoly", args);
        }
        roundPoly(...args) {
          return this._callContextMethod("roundPoly", args);
        }
        roundShape(...args) {
          return this._callContextMethod("roundShape", args);
        }
        filletRect(...args) {
          return this._callContextMethod("filletRect", args);
        }
        chamferRect(...args) {
          return this._callContextMethod("chamferRect", args);
        }
        star(...args) {
          return this._callContextMethod("star", args);
        }
        svg(...args) {
          return this._callContextMethod("svg", args);
        }
        restore(...args) {
          return this._callContextMethod("restore", args);
        }
        /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */
        save() {
          return this._callContextMethod("save", []);
        }
        /**
         * Returns the current transformation matrix of the graphics context.
         * @returns The current transformation matrix.
         */
        getTransform() {
          return this.context.getTransform();
        }
        /**
         * Resets the current transformation matrix to the identity matrix, effectively removing
         * any transformations (rotation, scaling, translation) previously applied.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        resetTransform() {
          return this._callContextMethod("resetTransform", []);
        }
        rotateTransform(...args) {
          return this._callContextMethod("rotate", args);
        }
        scaleTransform(...args) {
          return this._callContextMethod("scale", args);
        }
        setTransform(...args) {
          return this._callContextMethod("setTransform", args);
        }
        transform(...args) {
          return this._callContextMethod("transform", args);
        }
        translateTransform(...args) {
          return this._callContextMethod("translate", args);
        }
        /**
         * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,
         * and optionally resetting transformations to the identity matrix.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        clear() {
          return this._callContextMethod("clear", []);
        }
        /**
         * The fill style to use.
         * @type {ConvertedFillStyle}
         */
        get fillStyle() {
          return this._context.fillStyle;
        }
        set fillStyle(value) {
          this._context.fillStyle = value;
        }
        /**
         * The stroke style to use.
         * @type {ConvertedStrokeStyle}
         */
        get strokeStyle() {
          return this._context.strokeStyle;
        }
        set strokeStyle(value) {
          this._context.strokeStyle = value;
        }
        /**
         * Creates a new Graphics object.
         * Note that only the context of the object is cloned, not its transform (position,scale,etc)
         * @param deep - Whether to create a deep clone of the graphics object. If false, the context
         * will be shared between the two objects (default false). If true, the context will be
         * cloned (recommended if you need to modify the context in any way).
         * @returns - A clone of the graphics object
         */
        clone(deep = false) {
          if (deep) {
            return new Graphics(this._context.clone());
          }
          this._ownedContext = null;
          const clone = new Graphics(this._context);
          return clone;
        }
        // -------- v7 deprecations ---------
        /**
         * @param width
         * @param color
         * @param alpha
         * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead
         */
        lineStyle(width, color3, alpha) {
          deprecation(v8_0_0, "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");
          const strokeStyle = {};
          width && (strokeStyle.width = width);
          color3 && (strokeStyle.color = color3);
          alpha && (strokeStyle.alpha = alpha);
          this.context.strokeStyle = strokeStyle;
          return this;
        }
        /**
         * @param color
         * @param alpha
         * @deprecated since 8.0.0 Use {@link Graphics#fill} instead
         */
        beginFill(color3, alpha) {
          deprecation(v8_0_0, "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
          const fillStyle = {};
          color3 && (fillStyle.color = color3);
          alpha && (fillStyle.alpha = alpha);
          this.context.fillStyle = fillStyle;
          return this;
        }
        /**
         * @deprecated since 8.0.0 Use {@link Graphics#fill} instead
         */
        endFill() {
          deprecation(v8_0_0, "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
          this.context.fill();
          const strokeStyle = this.context.strokeStyle;
          if (strokeStyle.width !== GraphicsContext.defaultStrokeStyle.width || strokeStyle.color !== GraphicsContext.defaultStrokeStyle.color || strokeStyle.alpha !== GraphicsContext.defaultStrokeStyle.alpha) {
            this.context.stroke();
          }
          return this;
        }
        /**
         * @param {...any} args
         * @deprecated since 8.0.0 Use {@link Graphics#circle} instead
         */
        drawCircle(...args) {
          deprecation(v8_0_0, "Graphics#drawCircle has been renamed to Graphics#circle");
          return this._callContextMethod("circle", args);
        }
        /**
         * @param {...any} args
         * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead
         */
        drawEllipse(...args) {
          deprecation(v8_0_0, "Graphics#drawEllipse has been renamed to Graphics#ellipse");
          return this._callContextMethod("ellipse", args);
        }
        /**
         * @param {...any} args
         * @deprecated since 8.0.0 Use {@link Graphics#poly} instead
         */
        drawPolygon(...args) {
          deprecation(v8_0_0, "Graphics#drawPolygon has been renamed to Graphics#poly");
          return this._callContextMethod("poly", args);
        }
        /**
         * @param {...any} args
         * @deprecated since 8.0.0 Use {@link Graphics#rect} instead
         */
        drawRect(...args) {
          deprecation(v8_0_0, "Graphics#drawRect has been renamed to Graphics#rect");
          return this._callContextMethod("rect", args);
        }
        /**
         * @param {...any} args
         * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead
         */
        drawRoundedRect(...args) {
          deprecation(v8_0_0, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect");
          return this._callContextMethod("roundRect", args);
        }
        /**
         * @param {...any} args
         * @deprecated since 8.0.0 Use {@link Graphics#star} instead
         */
        drawStar(...args) {
          deprecation(v8_0_0, "Graphics#drawStar has been renamed to Graphics#star");
          return this._callContextMethod("star", args);
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.mjs
  function getTestContext() {
    if (!context || context?.isContextLost()) {
      const canvas = DOMAdapter.get().createCanvas();
      context = canvas.getContext("webgl", {});
    }
    return context;
  }
  var context;
  var init_getTestContext = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.mjs"() {
      init_adapter();
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs
  function getMaxFragmentPrecision() {
    if (!maxFragmentPrecision) {
      maxFragmentPrecision = "mediump";
      const gl = getTestContext();
      if (gl) {
        if (gl.getShaderPrecisionFormat) {
          const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
          maxFragmentPrecision = shaderFragment.precision ? "highp" : "mediump";
        }
      }
    }
    return maxFragmentPrecision;
  }
  var maxFragmentPrecision;
  var init_getMaxFragmentPrecision = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs"() {
      init_getTestContext();
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.mjs
  function addProgramDefines(src, isES300, isFragment) {
    if (isES300)
      return src;
    if (isFragment) {
      src = src.replace("out vec4 finalColor;", "");
      return `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${src}
        `;
    }
    return `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${src}
        `;
  }
  var init_addProgramDefines = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.mjs
  function ensurePrecision(src, options, isFragment) {
    const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;
    if (src.substring(0, 9) !== "precision") {
      let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;
      if (precision === "highp" && maxSupportedPrecision !== "highp") {
        precision = "mediump";
      }
      return `precision ${precision} float;
${src}`;
    } else if (maxSupportedPrecision !== "highp" && src.substring(0, 15) === "precision highp") {
      return src.replace("precision highp", "precision mediump");
    }
    return src;
  }
  var init_ensurePrecision = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/insertVersion.mjs
  function insertVersion(src, isES300) {
    if (!isES300)
      return src;
    return `#version 300 es
${src}`;
  }
  var init_insertVersion = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/insertVersion.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/setProgramName.mjs
  function setProgramName(src, { name = `pixi-program` }, isFragment = true) {
    name = name.replace(/\s+/g, "-");
    name += isFragment ? "-fragment" : "-vertex";
    const nameCache = isFragment ? fragmentNameCache : VertexNameCache;
    if (nameCache[name]) {
      nameCache[name]++;
      name += `-${nameCache[name]}`;
    } else {
      nameCache[name] = 1;
    }
    if (src.indexOf("#define SHADER_NAME") !== -1)
      return src;
    const shaderName = `#define SHADER_NAME ${name}`;
    return `${shaderName}
${src}`;
  }
  var fragmentNameCache, VertexNameCache;
  var init_setProgramName = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/setProgramName.mjs"() {
      "use strict";
      fragmentNameCache = {};
      VertexNameCache = {};
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/stripVersion.mjs
  function stripVersion(src, isES300) {
    if (!isES300)
      return src;
    return src.replace("#version 300 es", "");
  }
  var init_stripVersion = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/stripVersion.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs
  var processes, programCache, _GlProgram, GlProgram;
  var init_GlProgram = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs"() {
      init_createIdFromString();
      init_getMaxFragmentPrecision();
      init_addProgramDefines();
      init_ensurePrecision();
      init_insertVersion();
      init_setProgramName();
      init_stripVersion();
      processes = {
        // strips any version headers..
        stripVersion,
        // adds precision string if not already present
        ensurePrecision,
        // add some defines if WebGL1 to make it more compatible with WebGL2 shaders
        addProgramDefines,
        // add the program name to the shader
        setProgramName,
        // add the version string to the shader header
        insertVersion
      };
      programCache = /* @__PURE__ */ Object.create(null);
      _GlProgram = class _GlProgram2 {
        /**
         * Creates a shiny new GlProgram. Used by WebGL renderer.
         * @param options - The options for the program.
         */
        constructor(options) {
          options = { ..._GlProgram2.defaultOptions, ...options };
          const isES300 = options.fragment.indexOf("#version 300 es") !== -1;
          const preprocessorOptions = {
            stripVersion: isES300,
            ensurePrecision: {
              requestedFragmentPrecision: options.preferredFragmentPrecision,
              requestedVertexPrecision: options.preferredVertexPrecision,
              maxSupportedVertexPrecision: "highp",
              maxSupportedFragmentPrecision: getMaxFragmentPrecision()
            },
            setProgramName: {
              name: options.name
            },
            addProgramDefines: isES300,
            insertVersion: isES300
          };
          let fragment2 = options.fragment;
          let vertex2 = options.vertex;
          Object.keys(processes).forEach((processKey) => {
            const processOptions = preprocessorOptions[processKey];
            fragment2 = processes[processKey](fragment2, processOptions, true);
            vertex2 = processes[processKey](vertex2, processOptions, false);
          });
          this.fragment = fragment2;
          this.vertex = vertex2;
          this._key = createIdFromString(`${this.vertex}:${this.fragment}`, "gl-program");
        }
        /** destroys the program */
        destroy() {
          this.fragment = null;
          this.vertex = null;
          this._attributeData = null;
          this._uniformData = null;
          this._uniformBlockData = null;
          this.transformFeedbackVaryings = null;
        }
        /**
         * Helper function that creates a program for a given source.
         * It will check the program cache if the program has already been created.
         * If it has that one will be returned, if not a new one will be created and cached.
         * @param options - The options for the program.
         * @returns A program using the same source
         */
        static from(options) {
          const key = `${options.vertex}:${options.fragment}`;
          if (!programCache[key]) {
            programCache[key] = new _GlProgram2(options);
          }
          return programCache[key];
        }
      };
      _GlProgram.defaultOptions = {
        preferredVertexPrecision: "highp",
        preferredFragmentPrecision: "mediump"
      };
      GlProgram = _GlProgram;
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs
  function getAttributeInfoFromFormat(format) {
    return attributeFormatData[format] ?? attributeFormatData.float32;
  }
  var attributeFormatData;
  var init_getAttributeInfoFromFormat = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs"() {
      "use strict";
      attributeFormatData = {
        uint8x2: { size: 2, stride: 2, normalised: false },
        uint8x4: { size: 4, stride: 4, normalised: false },
        sint8x2: { size: 2, stride: 2, normalised: false },
        sint8x4: { size: 4, stride: 4, normalised: false },
        unorm8x2: { size: 2, stride: 2, normalised: true },
        unorm8x4: { size: 4, stride: 4, normalised: true },
        snorm8x2: { size: 2, stride: 2, normalised: true },
        snorm8x4: { size: 4, stride: 4, normalised: true },
        uint16x2: { size: 2, stride: 4, normalised: false },
        uint16x4: { size: 4, stride: 8, normalised: false },
        sint16x2: { size: 2, stride: 4, normalised: false },
        sint16x4: { size: 4, stride: 8, normalised: false },
        unorm16x2: { size: 2, stride: 4, normalised: true },
        unorm16x4: { size: 4, stride: 8, normalised: true },
        snorm16x2: { size: 2, stride: 4, normalised: true },
        snorm16x4: { size: 4, stride: 8, normalised: true },
        float16x2: { size: 2, stride: 4, normalised: false },
        float16x4: { size: 4, stride: 8, normalised: false },
        float32: { size: 1, stride: 4, normalised: false },
        float32x2: { size: 2, stride: 8, normalised: false },
        float32x3: { size: 3, stride: 12, normalised: false },
        float32x4: { size: 4, stride: 16, normalised: false },
        uint32: { size: 1, stride: 4, normalised: false },
        uint32x2: { size: 2, stride: 8, normalised: false },
        uint32x3: { size: 3, stride: 12, normalised: false },
        uint32x4: { size: 4, stride: 16, normalised: false },
        sint32: { size: 1, stride: 4, normalised: false },
        sint32x2: { size: 2, stride: 8, normalised: false },
        sint32x3: { size: 3, stride: 12, normalised: false },
        sint32x4: { size: 4, stride: 16, normalised: false }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.mjs
  function extractAttributesFromGpuProgram({ source: source2, entryPoint }) {
    const results = {};
    const mainVertStart = source2.indexOf(`fn ${entryPoint}`);
    if (mainVertStart !== -1) {
      const arrowFunctionStart = source2.indexOf("->", mainVertStart);
      if (arrowFunctionStart !== -1) {
        const functionArgsSubstring = source2.substring(mainVertStart, arrowFunctionStart);
        const inputsRegex = /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;
        let match;
        while ((match = inputsRegex.exec(functionArgsSubstring)) !== null) {
          const format = WGSL_TO_VERTEX_TYPES[match[3]] ?? "float32";
          results[match[2]] = {
            location: parseInt(match[1], 10),
            format,
            stride: getAttributeInfoFromFormat(format).stride,
            offset: 0,
            instance: false,
            start: 0
          };
        }
      }
    }
    return results;
  }
  var WGSL_TO_VERTEX_TYPES;
  var init_extractAttributesFromGpuProgram = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.mjs"() {
      init_getAttributeInfoFromFormat();
      WGSL_TO_VERTEX_TYPES = {
        f32: "float32",
        "vec2<f32>": "float32x2",
        "vec3<f32>": "float32x3",
        "vec4<f32>": "float32x4",
        vec2f: "float32x2",
        vec3f: "float32x3",
        vec4f: "float32x4",
        i32: "sint32",
        "vec2<i32>": "sint32x2",
        "vec3<i32>": "sint32x3",
        "vec4<i32>": "sint32x4",
        u32: "uint32",
        "vec2<u32>": "uint32x2",
        "vec3<u32>": "uint32x3",
        "vec4<u32>": "uint32x4",
        bool: "uint32",
        "vec2<bool>": "uint32x2",
        "vec3<bool>": "uint32x3",
        "vec4<bool>": "uint32x4"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractStructAndGroups.mjs
  function extractStructAndGroups(wgsl) {
    const linePattern = /(^|[^/])@(group|binding)\(\d+\)[^;]+;/g;
    const groupPattern = /@group\((\d+)\)/;
    const bindingPattern = /@binding\((\d+)\)/;
    const namePattern = /var(<[^>]+>)? (\w+)/;
    const typePattern = /:\s*(\w+)/;
    const structPattern = /struct\s+(\w+)\s*{([^}]+)}/g;
    const structMemberPattern = /(\w+)\s*:\s*([\w\<\>]+)/g;
    const structName = /struct\s+(\w+)/;
    const groups = wgsl.match(linePattern)?.map((item) => ({
      group: parseInt(item.match(groupPattern)[1], 10),
      binding: parseInt(item.match(bindingPattern)[1], 10),
      name: item.match(namePattern)[2],
      isUniform: item.match(namePattern)[1] === "<uniform>",
      type: item.match(typePattern)[1]
    }));
    if (!groups) {
      return {
        groups: [],
        structs: []
      };
    }
    const structs = wgsl.match(structPattern)?.map((struct) => {
      const name = struct.match(structName)[1];
      const members = struct.match(structMemberPattern).reduce((acc, member) => {
        const [name2, type] = member.split(":");
        acc[name2.trim()] = type.trim();
        return acc;
      }, {});
      if (!members) {
        return null;
      }
      return { name, members };
    }).filter(({ name }) => groups.some((group) => group.type === name)) ?? [];
    return {
      groups,
      structs
    };
  }
  var init_extractStructAndGroups = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractStructAndGroups.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.mjs
  var ShaderStage;
  var init_const7 = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.mjs"() {
      "use strict";
      ShaderStage = /* @__PURE__ */ ((ShaderStage2) => {
        ShaderStage2[ShaderStage2["VERTEX"] = 1] = "VERTEX";
        ShaderStage2[ShaderStage2["FRAGMENT"] = 2] = "FRAGMENT";
        ShaderStage2[ShaderStage2["COMPUTE"] = 4] = "COMPUTE";
        return ShaderStage2;
      })(ShaderStage || {});
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.mjs
  function generateGpuLayoutGroups({ groups }) {
    const layout = [];
    for (let i2 = 0; i2 < groups.length; i2++) {
      const group = groups[i2];
      if (!layout[group.group]) {
        layout[group.group] = [];
      }
      if (group.isUniform) {
        layout[group.group].push({
          binding: group.binding,
          visibility: ShaderStage.VERTEX | ShaderStage.FRAGMENT,
          buffer: {
            type: "uniform"
          }
        });
      } else if (group.type === "sampler") {
        layout[group.group].push({
          binding: group.binding,
          visibility: ShaderStage.FRAGMENT,
          sampler: {
            type: "filtering"
          }
        });
      } else if (group.type === "texture_2d") {
        layout[group.group].push({
          binding: group.binding,
          visibility: ShaderStage.FRAGMENT,
          texture: {
            sampleType: "float",
            viewDimension: "2d",
            multisampled: false
          }
        });
      }
    }
    return layout;
  }
  var init_generateGpuLayoutGroups = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.mjs"() {
      init_const7();
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateLayoutHash.mjs
  function generateLayoutHash({ groups }) {
    const layout = [];
    for (let i2 = 0; i2 < groups.length; i2++) {
      const group = groups[i2];
      if (!layout[group.group]) {
        layout[group.group] = {};
      }
      layout[group.group][group.name] = group.binding;
    }
    return layout;
  }
  var init_generateLayoutHash = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateLayoutHash.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.mjs
  function removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups) {
    const structNameSet = /* @__PURE__ */ new Set();
    const dupeGroupKeySet = /* @__PURE__ */ new Set();
    const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs].filter((struct) => {
      if (structNameSet.has(struct.name)) {
        return false;
      }
      structNameSet.add(struct.name);
      return true;
    });
    const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups].filter((group) => {
      const key = `${group.name}-${group.binding}`;
      if (dupeGroupKeySet.has(key)) {
        return false;
      }
      dupeGroupKeySet.add(key);
      return true;
    });
    return { structs, groups };
  }
  var init_removeStructAndGroupDuplicates = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs
  var programCache2, GpuProgram;
  var init_GpuProgram = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs"() {
      init_createIdFromString();
      init_extractAttributesFromGpuProgram();
      init_extractStructAndGroups();
      init_generateGpuLayoutGroups();
      init_generateLayoutHash();
      init_removeStructAndGroupDuplicates();
      programCache2 = /* @__PURE__ */ Object.create(null);
      GpuProgram = class {
        /**
         * Create a new GpuProgram
         * @param options - The options for the gpu program
         */
        constructor(options) {
          this._layoutKey = 0;
          const { fragment: fragment2, vertex: vertex2, layout, gpuLayout, name } = options;
          this.name = name;
          this.fragment = fragment2;
          this.vertex = vertex2;
          if (fragment2.source === vertex2.source) {
            const structsAndGroups = extractStructAndGroups(fragment2.source);
            this.structsAndGroups = structsAndGroups;
          } else {
            const vertexStructsAndGroups = extractStructAndGroups(vertex2.source);
            const fragmentStructsAndGroups = extractStructAndGroups(fragment2.source);
            this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);
          }
          this.layout = layout ?? generateLayoutHash(this.structsAndGroups);
          this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups(this.structsAndGroups);
          this.autoAssignGlobalUniforms = !!(this.layout[0]?.globalUniforms !== void 0);
          this.autoAssignLocalUniforms = !!(this.layout[1]?.localUniforms !== void 0);
          this._generateProgramKey();
        }
        // TODO maker this pure
        _generateProgramKey() {
          const { vertex: vertex2, fragment: fragment2 } = this;
          const bigKey = vertex2.source + fragment2.source + vertex2.entryPoint + fragment2.entryPoint;
          this._layoutKey = createIdFromString(bigKey, "program");
        }
        get attributeData() {
          this._attributeData ?? (this._attributeData = extractAttributesFromGpuProgram(this.vertex));
          return this._attributeData;
        }
        /** destroys the program */
        destroy() {
          this.gpuLayout = null;
          this.layout = null;
          this.structsAndGroups = null;
          this.fragment = null;
          this.vertex = null;
        }
        /**
         * Helper function that creates a program for a given source.
         * It will check the program cache if the program has already been created.
         * If it has that one will be returned, if not a new one will be created and cached.
         * @param options - The options for the program.
         * @returns A program using the same source
         */
        static from(options) {
          const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;
          if (!programCache2[key]) {
            programCache2[key] = new GpuProgram(options);
          }
          return programCache2[key];
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.mjs
  function addBits(srcParts, parts, name) {
    if (srcParts) {
      for (const i2 in srcParts) {
        const id = i2.toLocaleLowerCase();
        const part = parts[id];
        if (part) {
          let sanitisedPart = srcParts[i2];
          if (i2 === "header") {
            sanitisedPart = sanitisedPart.replace(/@in\s+[^;]+;\s*/g, "").replace(/@out\s+[^;]+;\s*/g, "");
          }
          if (name) {
            part.push(`//----${name}----//`);
          }
          part.push(sanitisedPart);
        } else {
          warn(`${i2} placement hook does not exist in shader`);
        }
      }
    }
  }
  var init_addBits = __esm({
    "../core/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.mjs"() {
      init_warn();
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.mjs
  function compileHooks(programSrc) {
    const parts = {};
    const partMatches = programSrc.match(findHooksRx)?.map((hook) => hook.replace(/[{()}]/g, "")) ?? [];
    partMatches.forEach((hook) => {
      parts[hook] = [];
    });
    return parts;
  }
  var findHooksRx;
  var init_compileHooks = __esm({
    "../core/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.mjs"() {
      "use strict";
      findHooksRx = /\{\{(.*?)\}\}/g;
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.mjs
  function extractInputs(fragmentSource, out2) {
    let match;
    const regex = /@in\s+([^;]+);/g;
    while ((match = regex.exec(fragmentSource)) !== null) {
      out2.push(match[1]);
    }
  }
  function compileInputs(fragments, template, sort = false) {
    const results = [];
    extractInputs(template, results);
    fragments.forEach((fragment2) => {
      if (fragment2.header) {
        extractInputs(fragment2.header, results);
      }
    });
    const mainInput = results;
    if (sort) {
      mainInput.sort();
    }
    const finalString = mainInput.map((inValue, i2) => `       @location(${i2}) ${inValue},`).join("\n");
    let cleanedString = template.replace(/@in\s+[^;]+;\s*/g, "");
    cleanedString = cleanedString.replace("{{in}}", `
${finalString}
`);
    return cleanedString;
  }
  var init_compileInputs = __esm({
    "../core/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs
  function extractOutputs(fragmentSource, out2) {
    let match;
    const regex = /@out\s+([^;]+);/g;
    while ((match = regex.exec(fragmentSource)) !== null) {
      out2.push(match[1]);
    }
  }
  function extractVariableName(value) {
    const regex = /\b(\w+)\s*:/g;
    const match = regex.exec(value);
    return match ? match[1] : "";
  }
  function stripVariable(value) {
    const regex = /@.*?\s+/g;
    return value.replace(regex, "");
  }
  function compileOutputs(fragments, template) {
    const results = [];
    extractOutputs(template, results);
    fragments.forEach((fragment2) => {
      if (fragment2.header) {
        extractOutputs(fragment2.header, results);
      }
    });
    let index = 0;
    const mainStruct = results.sort().map((inValue) => {
      if (inValue.indexOf("builtin") > -1) {
        return inValue;
      }
      return `@location(${index++}) ${inValue}`;
    }).join(",\n");
    const mainStart = results.sort().map((inValue) => `       var ${stripVariable(inValue)};`).join("\n");
    const mainEnd = `return VSOutput(
                ${results.sort().map((inValue) => ` ${extractVariableName(inValue)}`).join(",\n")});`;
    let compiledCode = template.replace(/@out\s+[^;]+;\s*/g, "");
    compiledCode = compiledCode.replace("{{struct}}", `
${mainStruct}
`);
    compiledCode = compiledCode.replace("{{start}}", `
${mainStart}
`);
    compiledCode = compiledCode.replace("{{return}}", `
${mainEnd}
`);
    return compiledCode;
  }
  var init_compileOutputs = __esm({
    "../core/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.mjs
  function injectBits(templateSrc, fragmentParts) {
    let out2 = templateSrc;
    for (const i2 in fragmentParts) {
      const parts = fragmentParts[i2];
      const toInject = parts.join("\n");
      if (toInject.length) {
        out2 = out2.replace(`{{${i2}}}`, `//-----${i2} START-----//
${parts.join("\n")}
//----${i2} FINISH----//`);
      } else {
        out2 = out2.replace(`{{${i2}}}`, "");
      }
    }
    return out2;
  }
  var init_injectBits = __esm({
    "../core/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.mjs
  function compileHighShader({
    template,
    bits
  }) {
    const cacheId = generateCacheId(template, bits);
    if (cacheMap[cacheId])
      return cacheMap[cacheId];
    const { vertex: vertex2, fragment: fragment2 } = compileInputsAndOutputs(template, bits);
    cacheMap[cacheId] = compileBits(vertex2, fragment2, bits);
    return cacheMap[cacheId];
  }
  function compileHighShaderGl({
    template,
    bits
  }) {
    const cacheId = generateCacheId(template, bits);
    if (cacheMap[cacheId])
      return cacheMap[cacheId];
    cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);
    return cacheMap[cacheId];
  }
  function compileInputsAndOutputs(template, bits) {
    const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v2) => !!v2);
    const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v2) => !!v2);
    let compiledVertex = compileInputs(vertexFragments, template.vertex, true);
    compiledVertex = compileOutputs(vertexFragments, compiledVertex);
    const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);
    return {
      vertex: compiledVertex,
      fragment: compiledFragment
    };
  }
  function generateCacheId(template, bits) {
    return bits.map((highFragment) => {
      if (!bitCacheMap.has(highFragment)) {
        bitCacheMap.set(highFragment, CACHE_UID++);
      }
      return bitCacheMap.get(highFragment);
    }).sort((a2, b2) => a2 - b2).join("-") + template.vertex + template.fragment;
  }
  function compileBits(vertex2, fragment2, bits) {
    const vertexParts = compileHooks(vertex2);
    const fragmentParts = compileHooks(fragment2);
    bits.forEach((shaderBit) => {
      addBits(shaderBit.vertex, vertexParts, shaderBit.name);
      addBits(shaderBit.fragment, fragmentParts, shaderBit.name);
    });
    return {
      vertex: injectBits(vertex2, vertexParts),
      fragment: injectBits(fragment2, fragmentParts)
    };
  }
  var cacheMap, bitCacheMap, CACHE_UID;
  var init_compileHighShader = __esm({
    "../core/node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.mjs"() {
      init_addBits();
      init_compileHooks();
      init_compileInputs();
      init_compileOutputs();
      init_injectBits();
      cacheMap = /* @__PURE__ */ Object.create(null);
      bitCacheMap = /* @__PURE__ */ new Map();
      CACHE_UID = 0;
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.mjs
  var vertexGPUTemplate, fragmentGPUTemplate, vertexGlTemplate, fragmentGlTemplate;
  var init_defaultProgramTemplate = __esm({
    "../core/node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.mjs"() {
      "use strict";
      vertexGPUTemplate = /* wgsl */
      `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}
        
        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);
       
        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`;
      fragmentGPUTemplate = /* wgsl */
      `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;
   
    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {
        
        {{start}}

        var outColor:vec4<f32>;
      
        {{main}}
        
        return outColor * vColor;
      };
`;
      vertexGlTemplate = /* glsl */
      `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;
        
        {{start}}
        
        vColor = vec4(1.);
        
        {{main}}
        
        vUV = uv;
        
        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`;
      fragmentGlTemplate = /* glsl */
      `
   
    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {
        
        {{start}}

        vec4 outColor;
      
        {{main}}
        
        finalColor = outColor * vColor;
    }
`;
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs
  var globalUniformsBit, globalUniformsBitGl;
  var init_globalUniformsBit = __esm({
    "../core/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs"() {
      "use strict";
      globalUniformsBit = {
        name: "global-uniforms-bit",
        vertex: {
          header: (
            /* wgsl */
            `
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `
          )
        }
      };
      globalUniformsBitGl = {
        name: "global-uniforms-bit",
        vertex: {
          header: (
            /* glsl */
            `
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `
          )
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs
  function compileHighShaderGpuProgram({ bits, name }) {
    const source2 = compileHighShader({
      template: {
        fragment: fragmentGPUTemplate,
        vertex: vertexGPUTemplate
      },
      bits: [
        globalUniformsBit,
        ...bits
      ]
    });
    return GpuProgram.from({
      name,
      vertex: {
        source: source2.vertex,
        entryPoint: "main"
      },
      fragment: {
        source: source2.fragment,
        entryPoint: "main"
      }
    });
  }
  function compileHighShaderGlProgram({ bits, name }) {
    return new GlProgram({
      name,
      ...compileHighShaderGl({
        template: {
          vertex: vertexGlTemplate,
          fragment: fragmentGlTemplate
        },
        bits: [
          globalUniformsBitGl,
          ...bits
        ]
      })
    });
  }
  var init_compileHighShaderToProgram = __esm({
    "../core/node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs"() {
      init_GlProgram();
      init_GpuProgram();
      init_compileHighShader();
      init_defaultProgramTemplate();
      init_globalUniformsBit();
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs
  var colorBit, colorBitGl;
  var init_colorBit = __esm({
    "../core/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs"() {
      "use strict";
      colorBit = {
        name: "color-bit",
        vertex: {
          header: (
            /* wgsl */
            `
            @in aColor: vec4<f32>;
        `
          ),
          main: (
            /* wgsl */
            `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `
          )
        }
      };
      colorBitGl = {
        name: "color-bit",
        vertex: {
          header: (
            /* glsl */
            `
            in vec4 aColor;
        `
          ),
          main: (
            /* glsl */
            `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `
          )
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs
  function generateBindingSrc(maxTextures) {
    const src = [];
    if (maxTextures === 1) {
      src.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;");
      src.push("@group(1) @binding(1) var textureSampler1: sampler;");
    } else {
      let bindingIndex = 0;
      for (let i2 = 0; i2 < maxTextures; i2++) {
        src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i2 + 1}: texture_2d<f32>;`);
        src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i2 + 1}: sampler;`);
      }
    }
    return src.join("\n");
  }
  function generateSampleSrc(maxTextures) {
    const src = [];
    if (maxTextures === 1) {
      src.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");
    } else {
      src.push("switch vTextureId {");
      for (let i2 = 0; i2 < maxTextures; i2++) {
        if (i2 === maxTextures - 1) {
          src.push(`  default:{`);
        } else {
          src.push(`  case ${i2}:{`);
        }
        src.push(`      outColor = textureSampleGrad(textureSource${i2 + 1}, textureSampler${i2 + 1}, vUV, uvDx, uvDy);`);
        src.push(`      break;}`);
      }
      src.push(`}`);
    }
    return src.join("\n");
  }
  function generateTextureBatchBit(maxTextures) {
    if (!textureBatchBitGpuCache[maxTextures]) {
      textureBatchBitGpuCache[maxTextures] = {
        name: "texture-batch-bit",
        vertex: {
          header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,
          main: `
                vTextureId = aTextureIdAndRound.y;
            `,
          end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `
        },
        fragment: {
          header: `
                @in @interpolate(flat) vTextureId: u32;
    
                ${generateBindingSrc(16)}
            `,
          main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);
    
                ${generateSampleSrc(16)}
            `
        }
      };
    }
    return textureBatchBitGpuCache[maxTextures];
  }
  function generateSampleGlSrc(maxTextures) {
    const src = [];
    for (let i2 = 0; i2 < maxTextures; i2++) {
      if (i2 > 0) {
        src.push("else");
      }
      if (i2 < maxTextures - 1) {
        src.push(`if(vTextureId < ${i2}.5)`);
      }
      src.push("{");
      src.push(`	outColor = texture(uTextures[${i2}], vUV);`);
      src.push("}");
    }
    return src.join("\n");
  }
  function generateTextureBatchBitGl(maxTextures) {
    if (!textureBatchBitGlCache[maxTextures]) {
      textureBatchBitGlCache[maxTextures] = {
        name: "texture-batch-bit",
        vertex: {
          header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;
              
            `,
          main: `
                vTextureId = aTextureIdAndRound.y;
            `,
          end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `
        },
        fragment: {
          header: `
                in float vTextureId;
    
                uniform sampler2D uTextures[${maxTextures}];
              
            `,
          main: `
    
                ${generateSampleGlSrc(16)}
            `
        }
      };
    }
    return textureBatchBitGlCache[maxTextures];
  }
  var textureBatchBitGpuCache, textureBatchBitGlCache;
  var init_generateTextureBatchBit = __esm({
    "../core/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs"() {
      "use strict";
      textureBatchBitGpuCache = {};
      textureBatchBitGlCache = {};
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs
  var roundPixelsBit, roundPixelsBitGl;
  var init_roundPixelsBit = __esm({
    "../core/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs"() {
      "use strict";
      roundPixelsBit = {
        name: "round-pixels-bit",
        vertex: {
          header: (
            /* wgsl */
            `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> 
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
          )
        }
      };
      roundPixelsBitGl = {
        name: "round-pixels-bit",
        vertex: {
          header: (
            /* glsl */
            `   
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {       
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
          )
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/batchSamplersUniformGroup.mjs
  var sampleValues, batchSamplersUniformGroup;
  var init_batchSamplersUniformGroup = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/batchSamplersUniformGroup.mjs"() {
      init_const4();
      init_UniformGroup();
      sampleValues = new Int32Array(MAX_TEXTURES);
      for (let i2 = 0; i2 < MAX_TEXTURES; i2++) {
        sampleValues[i2] = i2;
      }
      batchSamplersUniformGroup = new UniformGroup({
        uTextures: { value: sampleValues, type: `i32`, size: MAX_TEXTURES }
      }, { isStatic: true });
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/types.mjs
  var RendererType;
  var init_types = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/types.mjs"() {
      "use strict";
      RendererType = /* @__PURE__ */ ((RendererType2) => {
        RendererType2[RendererType2["WEBGL"] = 1] = "WEBGL";
        RendererType2[RendererType2["WEBGPU"] = 2] = "WEBGPU";
        RendererType2[RendererType2["BOTH"] = 3] = "BOTH";
        return RendererType2;
      })(RendererType || {});
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs
  var Shader;
  var init_Shader = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs"() {
      init_eventemitter3();
      init_GlProgram();
      init_BindGroup();
      init_GpuProgram();
      init_types();
      init_UniformGroup();
      Shader = class extends eventemitter3_default {
        constructor(options) {
          super();
          this._uniformBindMap = /* @__PURE__ */ Object.create(null);
          this._ownedBindGroups = [];
          let {
            gpuProgram: gpuProgram2,
            glProgram: glProgram2,
            groups,
            resources,
            compatibleRenderers,
            groupMap
          } = options;
          this.gpuProgram = gpuProgram2;
          this.glProgram = glProgram2;
          if (compatibleRenderers === void 0) {
            compatibleRenderers = 0;
            if (gpuProgram2)
              compatibleRenderers |= RendererType.WEBGPU;
            if (glProgram2)
              compatibleRenderers |= RendererType.WEBGL;
          }
          this.compatibleRenderers = compatibleRenderers;
          const nameHash = {};
          if (!resources && !groups) {
            resources = {};
          }
          if (resources && groups) {
            throw new Error("[Shader] Cannot have both resources and groups");
          } else if (!gpuProgram2 && groups && !groupMap) {
            throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");
          } else if (!gpuProgram2 && groups && groupMap) {
            for (const i2 in groupMap) {
              for (const j2 in groupMap[i2]) {
                const uniformName = groupMap[i2][j2];
                nameHash[uniformName] = {
                  group: i2,
                  binding: j2,
                  name: uniformName
                };
              }
            }
          } else if (gpuProgram2 && groups && !groupMap) {
            const groupData = gpuProgram2.structsAndGroups.groups;
            groupMap = {};
            groupData.forEach((data) => {
              groupMap[data.group] = groupMap[data.group] || {};
              groupMap[data.group][data.binding] = data.name;
              nameHash[data.name] = data;
            });
          } else if (resources) {
            if (!gpuProgram2) {
              groupMap = {};
              groups = {
                99: new BindGroup()
              };
              this._ownedBindGroups.push(groups[99]);
              let bindTick = 0;
              for (const i2 in resources) {
                nameHash[i2] = { group: 99, binding: bindTick, name: i2 };
                groupMap[99] = groupMap[99] || {};
                groupMap[99][bindTick] = i2;
                bindTick++;
              }
            } else {
              const groupData = gpuProgram2.structsAndGroups.groups;
              groupMap = {};
              groupData.forEach((data) => {
                groupMap[data.group] = groupMap[data.group] || {};
                groupMap[data.group][data.binding] = data.name;
                nameHash[data.name] = data;
              });
            }
            groups = {};
            for (const i2 in resources) {
              const name = i2;
              let value = resources[i2];
              if (!value.source && !value._resourceType) {
                value = new UniformGroup(value);
              }
              const data = nameHash[name];
              if (data) {
                if (!groups[data.group]) {
                  groups[data.group] = new BindGroup();
                  this._ownedBindGroups.push(groups[data.group]);
                }
                groups[data.group].setResource(value, data.binding);
              }
            }
          }
          this.groups = groups;
          this._uniformBindMap = groupMap;
          this.resources = this._buildResourceAccessor(groups, nameHash);
        }
        /**
         * Sometimes a resource group will be provided later (for example global uniforms)
         * In such cases, this method can be used to let the shader know about the group.
         * @param name - the name of the resource group
         * @param groupIndex - the index of the group (should match the webGPU shader group location)
         * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)
         */
        addResource(name, groupIndex, bindIndex) {
          var _a, _b;
          (_a = this._uniformBindMap)[groupIndex] || (_a[groupIndex] = {});
          (_b = this._uniformBindMap[groupIndex])[bindIndex] || (_b[bindIndex] = name);
          if (!this.groups[groupIndex]) {
            this.groups[groupIndex] = new BindGroup();
            this._ownedBindGroups.push(this.groups[groupIndex]);
          }
        }
        _buildResourceAccessor(groups, nameHash) {
          const uniformsOut = {};
          for (const i2 in nameHash) {
            const data = nameHash[i2];
            Object.defineProperty(uniformsOut, data.name, {
              get() {
                return groups[data.group].getResource(data.binding);
              },
              set(value) {
                groups[data.group].setResource(value, data.binding);
              }
            });
          }
          return uniformsOut;
        }
        /**
         * Use to destroy the shader when its not longer needed.
         * It will destroy the resources and remove listeners.
         * @param destroyPrograms - if the programs should be destroyed as well.
         * Make sure its not being used by other shaders!
         */
        destroy(destroyPrograms = false) {
          this.emit("destroy", this);
          if (destroyPrograms) {
            this.gpuProgram?.destroy();
            this.glProgram?.destroy();
          }
          this.gpuProgram = null;
          this.glProgram = null;
          this.removeAllListeners();
          this._uniformBindMap = null;
          this._ownedBindGroups.forEach((bindGroup) => {
            bindGroup.destroy();
          });
          this._ownedBindGroups = null;
          this.resources = null;
          this.groups = null;
        }
        static from(options) {
          const { gpu, gl, ...rest } = options;
          let gpuProgram2;
          let glProgram2;
          if (gpu) {
            gpuProgram2 = GpuProgram.from(gpu);
          }
          if (gl) {
            glProgram2 = GlProgram.from(gl);
          }
          return new Shader({
            gpuProgram: gpuProgram2,
            glProgram: glProgram2,
            ...rest
          });
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs
  var localUniformMSDFBit, localUniformMSDFBitGl;
  var init_localUniformMSDFBit = __esm({
    "../core/node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs"() {
      "use strict";
      localUniformMSDFBit = {
        name: "local-uniform-msdf-bit",
        vertex: {
          header: (
            /* wgsl */
            `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32,
                uRound:f32,
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `
          ),
          main: (
            /* wgsl */
            `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `
          ),
          end: (
            /* wgsl */
            `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
          )
        },
        fragment: {
          header: (
            /* wgsl */
            `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
         `
          ),
          main: (
            /* wgsl */
            ` 
            outColor = vColor * calculateMSDFAlpha(outColor, localUniforms.uDistance);
        `
          )
        }
      };
      localUniformMSDFBitGl = {
        name: "local-uniform-msdf-bit",
        vertex: {
          header: (
            /* glsl */
            `
            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `
          ),
          main: (
            /* glsl */
            `
            vColor *= uColor;
            modelMatrix *= uTransformMatrix;
        `
          ),
          end: (
            /* glsl */
            `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
          )
        },
        fragment: {
          header: (
            /* glsl */
            `
            uniform float uDistance;
         `
          ),
          main: (
            /* glsl */
            ` 
            outColor = vColor * calculateMSDFAlpha(outColor, uDistance);
        `
          )
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs
  var mSDFBit, mSDFBitGl;
  var init_mSDFBit = __esm({
    "../core/node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs"() {
      "use strict";
      mSDFBit = {
        name: "msdf-bit",
        fragment: {
          header: (
            /* wgsl */
            `
            fn calculateMSDFAlpha(msdfColor:vec4<f32>, distance:f32) -> f32 {
                
                // MSDF
                var median = msdfColor.r + msdfColor.g + msdfColor.b -
                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));
            
                // SDF
                median = min(median, msdfColor.a);

                var screenPxDistance = distance * (median - 0.5);
                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                return alpha;
            }
        `
          )
        }
      };
      mSDFBitGl = {
        name: "msdf-bit",
        fragment: {
          header: (
            /* glsl */
            `
            float calculateMSDFAlpha(vec4 msdfColor, float distance) {
                
                // MSDF
                float median = msdfColor.r + msdfColor.g + msdfColor.b -
                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));
               
                // SDF
                median = min(median, msdfColor.a);
            
                float screenPxDistance = distance * (median - 0.5);
                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
           
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                return alpha;
            }
        `
          )
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.mjs
  var SdfShader;
  var init_SdfShader = __esm({
    "../core/node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.mjs"() {
      init_Matrix();
      init_const4();
      init_compileHighShaderToProgram();
      init_colorBit();
      init_generateTextureBatchBit();
      init_roundPixelsBit();
      init_batchSamplersUniformGroup();
      init_Shader();
      init_UniformGroup();
      init_localUniformMSDFBit();
      init_mSDFBit();
      SdfShader = class extends Shader {
        constructor() {
          const uniforms = new UniformGroup({
            uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
            uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
            uDistance: { value: 4, type: "f32" },
            uRound: { value: 0, type: "f32" }
          });
          const gpuProgram2 = compileHighShaderGpuProgram({
            name: "sdf-shader",
            bits: [
              colorBit,
              generateTextureBatchBit(MAX_TEXTURES),
              localUniformMSDFBit,
              mSDFBit,
              roundPixelsBit
            ]
          });
          const glProgram2 = compileHighShaderGlProgram({
            name: "sdf-shader",
            bits: [
              colorBitGl,
              generateTextureBatchBitGl(MAX_TEXTURES),
              localUniformMSDFBitGl,
              mSDFBitGl,
              roundPixelsBitGl
            ]
          });
          super({
            glProgram: glProgram2,
            gpuProgram: gpuProgram2,
            resources: {
              localUniforms: uniforms,
              batchSamplers: batchSamplersUniformGroup
            }
          });
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/text-bitmap/BitmapTextPipe.mjs
  function syncWithProxy(container, proxy) {
    proxy.groupTransform = container.groupTransform;
    proxy.groupColorAlpha = container.groupColorAlpha;
    proxy.groupColor = container.groupColor;
    proxy.groupBlendMode = container.groupBlendMode;
    proxy.globalDisplayStatus = container.globalDisplayStatus;
    proxy.groupTransform = container.groupTransform;
    proxy.localDisplayStatus = container.localDisplayStatus;
    proxy.groupAlpha = container.groupAlpha;
    proxy._roundPixels = container._roundPixels;
  }
  var BitmapTextPipe;
  var init_BitmapTextPipe = __esm({
    "../core/node_modules/pixi.js/lib/scene/text-bitmap/BitmapTextPipe.mjs"() {
      init_Cache();
      init_Extensions();
      init_PoolGroup();
      init_Graphics();
      init_SdfShader();
      init_BitmapFontManager();
      init_getBitmapTextLayout();
      BitmapTextPipe = class {
        constructor(renderer) {
          this._gpuBitmapText = {};
          this._renderer = renderer;
        }
        validateRenderable(bitmapText) {
          const graphicsRenderable = this._getGpuBitmapText(bitmapText);
          if (bitmapText._didTextUpdate) {
            bitmapText._didTextUpdate = false;
            this._updateContext(bitmapText, graphicsRenderable);
          }
          return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);
        }
        addRenderable(bitmapText, instructionSet) {
          const graphicsRenderable = this._getGpuBitmapText(bitmapText);
          syncWithProxy(bitmapText, graphicsRenderable);
          if (bitmapText._didTextUpdate) {
            bitmapText._didTextUpdate = false;
            this._updateContext(bitmapText, graphicsRenderable);
          }
          this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);
          if (graphicsRenderable.context.customShader) {
            this._updateDistanceField(bitmapText);
          }
        }
        destroyRenderable(bitmapText) {
          this._destroyRenderableByUid(bitmapText.uid);
        }
        _destroyRenderableByUid(renderableUid) {
          BigPool.return(this._gpuBitmapText[renderableUid]);
          this._gpuBitmapText[renderableUid] = null;
        }
        updateRenderable(bitmapText) {
          const graphicsRenderable = this._getGpuBitmapText(bitmapText);
          syncWithProxy(bitmapText, graphicsRenderable);
          this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);
          if (graphicsRenderable.context.customShader) {
            this._updateDistanceField(bitmapText);
          }
        }
        _updateContext(bitmapText, proxyGraphics) {
          const { context: context4 } = proxyGraphics;
          const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);
          context4.clear();
          if (bitmapFont.distanceField.type !== "none") {
            if (!context4.customShader) {
              if (!this._sdfShader) {
                this._sdfShader = new SdfShader();
              }
              context4.customShader = this._sdfShader;
            }
          }
          const chars = Array.from(bitmapText.text);
          const style = bitmapText._style;
          let currentY = (style._stroke?.width || 0) / 2;
          currentY += bitmapFont.baseLineOffset;
          const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont);
          let index = 0;
          const padding = style.padding;
          const scale = bitmapTextLayout.scale;
          context4.translate(
            -bitmapText._anchor._x * bitmapTextLayout.width - padding,
            -bitmapText._anchor._y * (bitmapTextLayout.height + bitmapTextLayout.offsetY) - padding
          ).scale(scale, scale);
          const tint = style._fill.color;
          for (let i2 = 0; i2 < bitmapTextLayout.lines.length; i2++) {
            const line = bitmapTextLayout.lines[i2];
            for (let j2 = 0; j2 < line.charPositions.length; j2++) {
              const char = chars[index++];
              const charData = bitmapFont.chars[char];
              if (charData?.texture) {
                context4.texture(
                  charData.texture,
                  tint ? tint : "black",
                  Math.round(line.charPositions[j2] + charData.xOffset),
                  Math.round(currentY + charData.yOffset)
                );
              }
            }
            currentY += bitmapFont.lineHeight;
          }
        }
        _getGpuBitmapText(bitmapText) {
          return this._gpuBitmapText[bitmapText.uid] || this.initGpuText(bitmapText);
        }
        initGpuText(bitmapText) {
          const proxyRenderable = BigPool.get(Graphics);
          this._gpuBitmapText[bitmapText.uid] = proxyRenderable;
          this._updateContext(bitmapText, proxyRenderable);
          bitmapText.on("destroyed", () => {
            this.destroyRenderable(bitmapText);
          });
          return this._gpuBitmapText[bitmapText.uid];
        }
        _updateDistanceField(bitmapText) {
          const context4 = this._getGpuBitmapText(bitmapText).context;
          const fontFamily = bitmapText._style.fontFamily;
          const dynamicFont = Cache.get(`${fontFamily}-bitmap`);
          const { a: a2, b: b2, c: c2, d: d2 } = bitmapText.groupTransform;
          const dx = Math.sqrt(a2 * a2 + b2 * b2);
          const dy = Math.sqrt(c2 * c2 + d2 * d2);
          const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;
          const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;
          const resolution = bitmapText.resolution ?? this._renderer.resolution;
          const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale) * resolution;
          context4.customShader.resources.localUniforms.uniforms.uDistance = distance;
        }
        destroy() {
          for (const uid3 in this._gpuBitmapText) {
            this._destroyRenderableByUid(uid3);
          }
          this._gpuBitmapText = null;
          this._sdfShader?.destroy(true);
          this._sdfShader = null;
          this._renderer = null;
        }
      };
      BitmapTextPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "bitmapText"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/text-bitmap/init.mjs
  var init_init9 = __esm({
    "../core/node_modules/pixi.js/lib/scene/text-bitmap/init.mjs"() {
      init_Extensions();
      init_loadBitmapFont();
      init_BitmapTextPipe();
      extensions.add(BitmapTextPipe, loadBitmapFont, bitmapFontCachePlugin);
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/text-html/HTMLTextPipe.mjs
  var HTMLTextPipe;
  var init_HTMLTextPipe = __esm({
    "../core/node_modules/pixi.js/lib/scene/text-html/HTMLTextPipe.mjs"() {
      init_Extensions();
      init_Texture();
      init_updateQuadBounds();
      init_PoolGroup();
      init_BatchableSprite();
      HTMLTextPipe = class {
        constructor(renderer) {
          this._gpuText = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
        }
        validateRenderable(htmlText) {
          const gpuText = this._getGpuText(htmlText);
          const newKey = htmlText._getKey();
          if (gpuText.textureNeedsUploading) {
            gpuText.textureNeedsUploading = false;
            return true;
          }
          if (gpuText.currentKey !== newKey) {
            return true;
          }
          return false;
        }
        addRenderable(htmlText) {
          const gpuText = this._getGpuText(htmlText);
          const batchableSprite = gpuText.batchableSprite;
          if (htmlText._didTextUpdate) {
            this._updateText(htmlText);
          }
          this._renderer.renderPipes.batch.addToBatch(batchableSprite);
        }
        updateRenderable(htmlText) {
          const gpuText = this._getGpuText(htmlText);
          const batchableSprite = gpuText.batchableSprite;
          if (htmlText._didTextUpdate) {
            this._updateText(htmlText);
          }
          batchableSprite.batcher.updateElement(batchableSprite);
        }
        destroyRenderable(htmlText) {
          this._destroyRenderableById(htmlText.uid);
        }
        _destroyRenderableById(htmlTextUid) {
          const gpuText = this._gpuText[htmlTextUid];
          this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);
          BigPool.return(gpuText.batchableSprite);
          this._gpuText[htmlTextUid] = null;
        }
        _updateText(htmlText) {
          const newKey = htmlText._getKey();
          const gpuText = this._getGpuText(htmlText);
          const batchableSprite = gpuText.batchableSprite;
          if (gpuText.currentKey !== newKey) {
            this._updateGpuText(htmlText).catch((e2) => {
              console.error(e2);
            });
          }
          htmlText._didTextUpdate = false;
          const padding = htmlText._style.padding;
          updateQuadBounds(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);
        }
        async _updateGpuText(htmlText) {
          htmlText._didTextUpdate = false;
          const gpuText = this._getGpuText(htmlText);
          if (gpuText.generatingTexture)
            return;
          const newKey = htmlText._getKey();
          this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);
          gpuText.generatingTexture = true;
          gpuText.currentKey = newKey;
          const resolution = htmlText.resolution ?? this._renderer.resolution;
          const texture = await this._renderer.htmlText.getManagedTexture(
            htmlText.text,
            resolution,
            htmlText._style,
            htmlText._getKey()
          );
          const batchableSprite = gpuText.batchableSprite;
          batchableSprite.texture = gpuText.texture = texture;
          gpuText.generatingTexture = false;
          gpuText.textureNeedsUploading = true;
          htmlText.onViewUpdate();
          const padding = htmlText._style.padding;
          updateQuadBounds(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);
        }
        _getGpuText(htmlText) {
          return this._gpuText[htmlText.uid] || this.initGpuText(htmlText);
        }
        initGpuText(htmlText) {
          const gpuTextData = {
            texture: Texture.EMPTY,
            currentKey: "--",
            batchableSprite: BigPool.get(BatchableSprite),
            textureNeedsUploading: false,
            generatingTexture: false
          };
          const batchableSprite = gpuTextData.batchableSprite;
          batchableSprite.renderable = htmlText;
          batchableSprite.texture = Texture.EMPTY;
          batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };
          batchableSprite.roundPixels = this._renderer._roundPixels | htmlText._roundPixels;
          this._gpuText[htmlText.uid] = gpuTextData;
          htmlText.on("destroyed", () => {
            this.destroyRenderable(htmlText);
          });
          return gpuTextData;
        }
        destroy() {
          for (const i2 in this._gpuText) {
            this._destroyRenderableById(i2);
          }
          this._gpuText = null;
          this._renderer = null;
        }
      };
      HTMLTextPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "htmlText"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/utils/browser/isSafari.mjs
  function isSafari() {
    const { userAgent } = DOMAdapter.get().getNavigator();
    return /^((?!chrome|android).)*safari/i.test(userAgent);
  }
  var init_isSafari = __esm({
    "../core/node_modules/pixi.js/lib/utils/browser/isSafari.mjs"() {
      init_adapter();
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.mjs
  var nssvg, nsxhtml, HTMLTextRenderData;
  var init_HTMLTextRenderData = __esm({
    "../core/node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.mjs"() {
      "use strict";
      nssvg = "http://www.w3.org/2000/svg";
      nsxhtml = "http://www.w3.org/1999/xhtml";
      HTMLTextRenderData = class {
        constructor() {
          this.svgRoot = document.createElementNS(nssvg, "svg");
          this.foreignObject = document.createElementNS(nssvg, "foreignObject");
          this.domElement = document.createElementNS(nsxhtml, "div");
          this.styleElement = document.createElementNS(nsxhtml, "style");
          this.image = new Image();
          const { foreignObject, svgRoot, styleElement, domElement } = this;
          foreignObject.setAttribute("width", "10000");
          foreignObject.setAttribute("height", "10000");
          foreignObject.style.overflow = "hidden";
          svgRoot.appendChild(foreignObject);
          foreignObject.appendChild(styleElement);
          foreignObject.appendChild(domElement);
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/text-html/utils/textStyleToCSS.mjs
  function textStyleToCSS(style) {
    const stroke = style._stroke;
    const fill = style._fill;
    const cssStyleString = [
      `color: ${Color.shared.setValue(fill.color).toHex()}`,
      `font-size: ${style.fontSize}px`,
      `font-family: ${style.fontFamily}`,
      `font-weight: ${style.fontWeight}`,
      `font-style: ${style.fontStyle}`,
      `font-variant: ${style.fontVariant}`,
      `letter-spacing: ${style.letterSpacing}px`,
      `text-align: ${style.align}`,
      `padding: ${style.padding}px`,
      `white-space: ${style.whiteSpace === "pre" && style.wordWrap ? "pre-wrap" : style.whiteSpace}`,
      ...style.lineHeight ? [`line-height: ${style.lineHeight}px`] : [],
      ...style.wordWrap ? [
        `word-wrap: ${style.breakWords ? "break-all" : "break-word"}`,
        `max-width: ${style.wordWrapWidth}px`
      ] : [],
      ...stroke ? [strokeToCSS(stroke)] : [],
      ...style.dropShadow ? [dropShadowToCSS(style.dropShadow)] : [],
      ...style.cssOverrides
    ].join(";");
    const cssStyles = [`div { ${cssStyleString} }`];
    tagStyleToCSS(style.tagStyles, cssStyles);
    return cssStyles.join(" ");
  }
  function dropShadowToCSS(dropShadowStyle) {
    const color3 = Color.shared.setValue(dropShadowStyle.color).setAlpha(dropShadowStyle.alpha).toHexa();
    const x2 = Math.round(Math.cos(dropShadowStyle.angle) * dropShadowStyle.distance);
    const y2 = Math.round(Math.sin(dropShadowStyle.angle) * dropShadowStyle.distance);
    const position = `${x2}px ${y2}px`;
    if (dropShadowStyle.blur > 0) {
      return `text-shadow: ${position} ${dropShadowStyle.blur}px ${color3}`;
    }
    return `text-shadow: ${position} ${color3}`;
  }
  function strokeToCSS(stroke) {
    return [
      `-webkit-text-stroke-width: ${stroke.width}px`,
      `-webkit-text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,
      `text-stroke-width: ${stroke.width}px`,
      `text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,
      "paint-order: stroke"
    ].join(";");
  }
  function tagStyleToCSS(tagStyles, out2) {
    for (const i2 in tagStyles) {
      const tagStyle = tagStyles[i2];
      const cssTagStyle = [];
      for (const j2 in tagStyle) {
        if (transform[j2]) {
          cssTagStyle.push(transform[j2](tagStyle[j2]));
        } else if (templates[j2]) {
          cssTagStyle.push(templates[j2].replace("{{VALUE}}", tagStyle[j2]));
        }
      }
      out2.push(`${i2} { ${cssTagStyle.join(";")} }`);
    }
  }
  var templates, transform;
  var init_textStyleToCSS = __esm({
    "../core/node_modules/pixi.js/lib/scene/text-html/utils/textStyleToCSS.mjs"() {
      init_Color();
      templates = {
        fontSize: `font-size: {{VALUE}}px`,
        fontFamily: `font-family: {{VALUE}}`,
        fontWeight: `font-weight: {{VALUE}}`,
        fontStyle: `font-style: {{VALUE}}`,
        fontVariant: `font-variant: {{VALUE}}`,
        letterSpacing: `letter-spacing: {{VALUE}}px`,
        align: `text-align: {{VALUE}}`,
        padding: `padding: {{VALUE}}px`,
        whiteSpace: `white-space: {{VALUE}}`,
        lineHeight: `line-height: {{VALUE}}px`,
        wordWrapWidth: `max-width: {{VALUE}}px`
      };
      transform = {
        fill: (value) => `color: ${Color.shared.setValue(value).toHex()}`,
        breakWords: (value) => `word-wrap: ${value ? "break-all" : "break-word"}`,
        stroke: strokeToCSS,
        dropShadow: dropShadowToCSS
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/text-html/HtmlTextStyle.mjs
  var HTMLTextStyle;
  var init_HtmlTextStyle = __esm({
    "../core/node_modules/pixi.js/lib/scene/text-html/HtmlTextStyle.mjs"() {
      init_warn();
      init_TextStyle();
      init_generateTextStyleKey();
      init_textStyleToCSS();
      HTMLTextStyle = class extends TextStyle {
        constructor(options = {}) {
          super(options);
          this._cssOverrides = [];
          this.cssOverrides ?? (this.cssOverrides = options.cssOverrides);
          this.tagStyles = options.tagStyles ?? {};
        }
        /** List of style overrides that will be applied to the HTML text. */
        set cssOverrides(value) {
          this._cssOverrides = value instanceof Array ? value : [value];
          this.update();
        }
        get cssOverrides() {
          return this._cssOverrides;
        }
        _generateKey() {
          this._styleKey = generateTextStyleKey(this) + this._cssOverrides.join("-");
          return this._styleKey;
        }
        update() {
          this._cssStyle = null;
          super.update();
        }
        /**
         * Creates a new HTMLTextStyle object with the same values as this one.
         * @returns New cloned HTMLTextStyle object
         */
        clone() {
          return new HTMLTextStyle({
            align: this.align,
            breakWords: this.breakWords,
            dropShadow: this.dropShadow,
            fill: this._fill,
            fontFamily: this.fontFamily,
            fontSize: this.fontSize,
            fontStyle: this.fontStyle,
            fontVariant: this.fontVariant,
            fontWeight: this.fontWeight,
            letterSpacing: this.letterSpacing,
            lineHeight: this.lineHeight,
            padding: this.padding,
            stroke: this._stroke,
            whiteSpace: this.whiteSpace,
            wordWrap: this.wordWrap,
            wordWrapWidth: this.wordWrapWidth,
            cssOverrides: this.cssOverrides
          });
        }
        get cssStyle() {
          if (!this._cssStyle) {
            this._cssStyle = textStyleToCSS(this);
          }
          return this._cssStyle;
        }
        /**
         * Add a style override, this can be any CSS property
         * it will override any built-in style. This is the
         * property and the value as a string (e.g., `color: red`).
         * This will override any other internal style.
         * @param {string} value - CSS style(s) to add.
         * @example
         * style.addOverride('background-color: red');
         */
        addOverride(...value) {
          const toAdd = value.filter((v2) => !this.cssOverrides.includes(v2));
          if (toAdd.length > 0) {
            this.cssOverrides.push(...toAdd);
            this.update();
          }
        }
        /**
         * Remove any overrides that match the value.
         * @param {string} value - CSS style to remove.
         * @example
         * style.removeOverride('background-color: red');
         */
        removeOverride(...value) {
          const toRemove = value.filter((v2) => this.cssOverrides.includes(v2));
          if (toRemove.length > 0) {
            this.cssOverrides = this.cssOverrides.filter((v2) => !toRemove.includes(v2));
            this.update();
          }
        }
        set fill(value) {
          if (typeof value !== "string" && typeof value !== "number") {
            warn("[HTMLTextStyle] only color fill is not supported by HTMLText");
          }
          super.fill = value;
        }
        set stroke(value) {
          if (value && typeof value !== "string" && typeof value !== "number") {
            warn("[HTMLTextStyle] only color stroke is not supported by HTMLText");
          }
          super.stroke = value;
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/text-html/utils/extractFontFamilies.mjs
  function extractFontFamilies(text2, style) {
    const fontFamily = style.fontFamily;
    const fontFamilies = [];
    const dedupe = {};
    const regex = /font-family:([^;"\s]+)/g;
    const matches = text2.match(regex);
    function addFontFamily(fontFamily2) {
      if (!dedupe[fontFamily2]) {
        fontFamilies.push(fontFamily2);
        dedupe[fontFamily2] = true;
      }
    }
    if (Array.isArray(fontFamily)) {
      for (let i2 = 0; i2 < fontFamily.length; i2++) {
        addFontFamily(fontFamily[i2]);
      }
    } else {
      addFontFamily(fontFamily);
    }
    if (matches) {
      matches.forEach((match) => {
        const fontFamily2 = match.split(":")[1].trim();
        addFontFamily(fontFamily2);
      });
    }
    for (const i2 in style.tagStyles) {
      const fontFamily2 = style.tagStyles[i2].fontFamily;
      addFontFamily(fontFamily2);
    }
    return fontFamilies;
  }
  var init_extractFontFamilies = __esm({
    "../core/node_modules/pixi.js/lib/scene/text-html/utils/extractFontFamilies.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/text-html/utils/loadFontAsBase64.mjs
  async function loadFontAsBase64(url) {
    const response = await DOMAdapter.get().fetch(url);
    const blob = await response.blob();
    const reader = new FileReader();
    const dataSrc = await new Promise((resolve, reject) => {
      reader.onloadend = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
    return dataSrc;
  }
  var init_loadFontAsBase64 = __esm({
    "../core/node_modules/pixi.js/lib/scene/text-html/utils/loadFontAsBase64.mjs"() {
      init_adapter();
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/text-html/utils/loadFontCSS.mjs
  async function loadFontCSS(style, url) {
    const dataSrc = await loadFontAsBase64(url);
    return `@font-face {
        font-family: "${style.fontFamily}";
        src: url('${dataSrc}');
        font-weight: ${style.fontWeight};
        font-style: ${style.fontStyle};
    }`;
  }
  var init_loadFontCSS = __esm({
    "../core/node_modules/pixi.js/lib/scene/text-html/utils/loadFontCSS.mjs"() {
      init_loadFontAsBase64();
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/text-html/utils/getFontCss.mjs
  async function getFontCss(fontFamilies, style, defaultOptions) {
    const fontPromises = fontFamilies.filter((fontFamily) => Cache.has(`${fontFamily}-and-url`)).map((fontFamily, i2) => {
      if (!FontStylePromiseCache.has(fontFamily)) {
        const { url } = Cache.get(`${fontFamily}-and-url`);
        if (i2 === 0) {
          FontStylePromiseCache.set(fontFamily, loadFontCSS(style, url));
        } else {
          FontStylePromiseCache.set(fontFamily, loadFontCSS({
            fontWeight: defaultOptions.fontWeight,
            fontStyle: defaultOptions.fontStyle,
            fontFamily
          }, url));
        }
      }
      return FontStylePromiseCache.get(fontFamily);
    });
    return (await Promise.all(fontPromises)).join("\n");
  }
  var FontStylePromiseCache;
  var init_getFontCss = __esm({
    "../core/node_modules/pixi.js/lib/scene/text-html/utils/getFontCss.mjs"() {
      init_Cache();
      init_loadFontCSS();
      FontStylePromiseCache = /* @__PURE__ */ new Map();
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/text-html/utils/getSVGUrl.mjs
  function getSVGUrl(text2, style, resolution, fontCSS, htmlTextData) {
    const { domElement, styleElement, svgRoot } = htmlTextData;
    domElement.innerHTML = `<style>${style.cssStyle}</style><div>${text2}</div>`;
    domElement.setAttribute("style", `transform: scale(${resolution});transform-origin: top left; display: inline-block`);
    styleElement.textContent = fontCSS;
    const { width, height } = htmlTextData.image;
    svgRoot.setAttribute("width", width.toString());
    svgRoot.setAttribute("height", height.toString());
    return new XMLSerializer().serializeToString(svgRoot);
  }
  var init_getSVGUrl = __esm({
    "../core/node_modules/pixi.js/lib/scene/text-html/utils/getSVGUrl.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/text-html/utils/getTemporaryCanvasFromImage.mjs
  function getTemporaryCanvasFromImage(image, resolution) {
    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(
      image.width,
      image.height,
      resolution
    );
    const { context: context4 } = canvasAndContext;
    context4.clearRect(0, 0, image.width, image.height);
    context4.drawImage(image, 0, 0);
    CanvasPool.returnCanvasAndContext(canvasAndContext);
    return canvasAndContext.canvas;
  }
  var init_getTemporaryCanvasFromImage = __esm({
    "../core/node_modules/pixi.js/lib/scene/text-html/utils/getTemporaryCanvasFromImage.mjs"() {
      init_CanvasPool();
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/text-html/utils/loadSVGImage.mjs
  function loadSVGImage(image, url, delay) {
    return new Promise(async (resolve) => {
      if (delay) {
        await new Promise((resolve2) => setTimeout(resolve2, 100));
      }
      image.onload = () => {
        resolve();
      };
      image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;
      image.crossOrigin = "anonymous";
    });
  }
  var init_loadSVGImage = __esm({
    "../core/node_modules/pixi.js/lib/scene/text-html/utils/loadSVGImage.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.mjs
  function measureHtmlText(text2, style, fontStyleCSS, htmlTextRenderData) {
    htmlTextRenderData = htmlTextRenderData || tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData());
    const { domElement, styleElement, svgRoot } = htmlTextRenderData;
    domElement.innerHTML = `<style>${style.cssStyle}</style><div>${text2}</div>`;
    domElement.setAttribute("style", "transform-origin: top left; display: inline-block");
    if (fontStyleCSS) {
      styleElement.textContent = fontStyleCSS;
    }
    document.body.appendChild(svgRoot);
    const contentBounds = domElement.getBoundingClientRect();
    svgRoot.remove();
    const descenderPadding = CanvasTextMetrics.measureFont(style.fontStyle).descent;
    return {
      width: contentBounds.width,
      height: contentBounds.height + descenderPadding
    };
  }
  var tempHTMLTextRenderData;
  var init_measureHtmlText = __esm({
    "../core/node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.mjs"() {
      init_CanvasTextMetrics();
      init_HTMLTextRenderData();
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/text-html/HTMLTextSystem.mjs
  var HTMLTextSystem;
  var init_HTMLTextSystem = __esm({
    "../core/node_modules/pixi.js/lib/scene/text-html/HTMLTextSystem.mjs"() {
      init_Extensions();
      init_TexturePool();
      init_types();
      init_isSafari();
      init_warn();
      init_PoolGroup();
      init_getPo2TextureFromSource();
      init_HTMLTextRenderData();
      init_HtmlTextStyle();
      init_extractFontFamilies();
      init_getFontCss();
      init_getSVGUrl();
      init_getTemporaryCanvasFromImage();
      init_loadSVGImage();
      init_measureHtmlText();
      HTMLTextSystem = class {
        constructor(renderer) {
          this._activeTextures = {};
          this._renderer = renderer;
          this._createCanvas = renderer.type === RendererType.WEBGPU;
        }
        getTexture(options) {
          return this._buildTexturePromise(
            options.text,
            options.resolution,
            options.style
          );
        }
        getManagedTexture(text2, resolution, style, textKey) {
          if (this._activeTextures[textKey]) {
            this._increaseReferenceCount(textKey);
            return this._activeTextures[textKey].promise;
          }
          const promise2 = this._buildTexturePromise(text2, resolution, style).then((texture) => {
            this._activeTextures[textKey].texture = texture;
            return texture;
          });
          this._activeTextures[textKey] = {
            texture: null,
            promise: promise2,
            usageCount: 1
          };
          return promise2;
        }
        async _buildTexturePromise(text2, resolution, style) {
          const htmlTextData = BigPool.get(HTMLTextRenderData);
          const fontFamilies = extractFontFamilies(text2, style);
          const fontCSS = await getFontCss(
            fontFamilies,
            style,
            HTMLTextStyle.defaultTextStyle
          );
          const measured = measureHtmlText(text2, style, fontCSS, htmlTextData);
          const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);
          const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);
          const image = htmlTextData.image;
          image.width = width | 0;
          image.height = height | 0;
          const svgURL = getSVGUrl(text2, style, resolution, fontCSS, htmlTextData);
          await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);
          let resource = image;
          if (this._createCanvas) {
            resource = getTemporaryCanvasFromImage(image, resolution);
          }
          const texture = getPo2TextureFromSource(resource, image.width, image.height, resolution);
          if (this._createCanvas) {
            this._renderer.texture.initSource(texture.source);
          }
          BigPool.return(htmlTextData);
          return texture;
        }
        _increaseReferenceCount(textKey) {
          this._activeTextures[textKey].usageCount++;
        }
        decreaseReferenceCount(textKey) {
          const activeTexture = this._activeTextures[textKey];
          if (!activeTexture)
            return;
          activeTexture.usageCount--;
          if (activeTexture.usageCount === 0) {
            if (activeTexture.texture) {
              this._cleanUp(activeTexture);
            } else {
              activeTexture.promise.then((texture) => {
                activeTexture.texture = texture;
                this._cleanUp(activeTexture);
              }).catch(() => {
                warn("HTMLTextSystem: Failed to clean texture");
              });
            }
            this._activeTextures[textKey] = null;
          }
        }
        _cleanUp(activeTexture) {
          TexturePool.returnTexture(activeTexture.texture);
          activeTexture.texture.source.resource = null;
          activeTexture.texture.source.uploadMethodId = "unknown";
        }
        getReferenceCount(textKey) {
          return this._activeTextures[textKey].usageCount;
        }
        destroy() {
          this._activeTextures = null;
        }
      };
      HTMLTextSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "htmlText"
      };
      HTMLTextSystem.defaultFontOptions = {
        fontFamily: "Arial",
        fontStyle: "normal",
        fontWeight: "normal"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/text-html/init.mjs
  var init_init10 = __esm({
    "../core/node_modules/pixi.js/lib/scene/text-html/init.mjs"() {
      init_Extensions();
      init_HTMLTextPipe();
      init_HTMLTextSystem();
      extensions.add(HTMLTextSystem);
      extensions.add(HTMLTextPipe);
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs
  var _MeshGeometry, MeshGeometry;
  var init_MeshGeometry = __esm({
    "../core/node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs"() {
      init_Buffer();
      init_const3();
      init_Geometry();
      init_deprecation();
      _MeshGeometry = class _MeshGeometry2 extends Geometry {
        constructor(...args) {
          let options = args[0] ?? {};
          if (options instanceof Float32Array) {
            deprecation(v8_0_0, "use new MeshGeometry({ positions, uvs, indices }) instead");
            options = {
              positions: options,
              uvs: args[1],
              indices: args[2]
            };
          }
          options = { ..._MeshGeometry2.defaultOptions, ...options };
          const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
          const uvs = options.uvs || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
          const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);
          const shrinkToFit = options.shrinkBuffersToFit;
          const positionBuffer = new Buffer2({
            data: positions,
            label: "attribute-mesh-positions",
            shrinkToFit,
            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
          });
          const uvBuffer = new Buffer2({
            data: uvs,
            label: "attribute-mesh-uvs",
            shrinkToFit,
            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
          });
          const indexBuffer = new Buffer2({
            data: indices,
            label: "index-mesh-buffer",
            shrinkToFit,
            usage: BufferUsage.INDEX | BufferUsage.COPY_DST
          });
          super({
            attributes: {
              aPosition: {
                buffer: positionBuffer,
                format: "float32x2",
                stride: 2 * 4,
                offset: 0
              },
              aUV: {
                buffer: uvBuffer,
                format: "float32x2",
                stride: 2 * 4,
                offset: 0
              }
            },
            indexBuffer,
            topology: options.topology
          });
          this.batchMode = "auto";
        }
        /** The positions of the mesh. */
        get positions() {
          return this.attributes.aPosition.buffer.data;
        }
        set positions(value) {
          this.attributes.aPosition.buffer.data = value;
        }
        /** The UVs of the mesh. */
        get uvs() {
          return this.attributes.aUV.buffer.data;
        }
        set uvs(value) {
          this.attributes.aUV.buffer.data = value;
        }
        /** The indices of the mesh. */
        get indices() {
          return this.indexBuffer.data;
        }
        set indices(value) {
          this.indexBuffer.data = value;
        }
      };
      _MeshGeometry.defaultOptions = {
        topology: "triangle-list",
        shrinkBuffersToFit: false
      };
      MeshGeometry = _MeshGeometry;
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs
  var localUniformBit, localUniformBitGroup2, localUniformBitGl;
  var init_localUniformBit = __esm({
    "../core/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs"() {
      "use strict";
      localUniformBit = {
        name: "local-uniform-bit",
        vertex: {
          header: (
            /* wgsl */
            `

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `
          ),
          main: (
            /* wgsl */
            `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `
          ),
          end: (
            /* wgsl */
            `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
          )
        }
      };
      localUniformBitGroup2 = {
        ...localUniformBit,
        vertex: {
          ...localUniformBit.vertex,
          // replace the group!
          header: localUniformBit.vertex.header.replace("group(1)", "group(2)")
        }
      };
      localUniformBitGl = {
        name: "local-uniform-bit",
        vertex: {
          header: (
            /* glsl */
            `

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `
          ),
          main: (
            /* glsl */
            `
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `
          ),
          end: (
            /* glsl */
            `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
          )
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.mjs
  var tilingBit, tilingBitGl;
  var init_tilingBit = __esm({
    "../core/node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.mjs"() {
      "use strict";
      tilingBit = {
        name: "tiling-bit",
        vertex: {
          header: (
            /* wgsl */
            `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `
          ),
          main: (
            /* wgsl */
            `
            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;

            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;
        `
          )
        },
        fragment: {
          header: (
            /* wgsl */
            `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `
          ),
          main: (
            /* wgsl */
            `

            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);
            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;
            var unclamped = coord;
            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);

            var bias = 0.;

            if(unclamped.x == coord.x && unclamped.y == coord.y)
            {
                bias = -32.;
            } 

            outColor = textureSampleBias(uTexture, uSampler, coord, bias);
        `
          )
        }
      };
      tilingBitGl = {
        name: "tiling-bit",
        vertex: {
          header: (
            /* glsl */
            `
            uniform mat3 uTextureTransform;
            uniform vec4 uSizeAnchor;
        
        `
          ),
          main: (
            /* glsl */
            `
            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;
        `
          )
        },
        fragment: {
          header: (
            /* glsl */
            `
            uniform sampler2D uTexture;
            uniform mat3 uMapCoord;
            uniform vec4 uClampFrame;
            uniform vec2 uClampOffset;
        `
          ),
          main: (
            /* glsl */
            `

        vec2 coord = vUV + ceil(uClampOffset - vUV);
        coord = (uMapCoord * vec3(coord, 1.0)).xy;
        vec2 unclamped = coord;
        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);
        
        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0
    
        `
          )
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs
  var gpuProgram, glProgram, TilingSpriteShader;
  var init_TilingSpriteShader = __esm({
    "../core/node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs"() {
      init_Matrix();
      init_compileHighShaderToProgram();
      init_localUniformBit();
      init_roundPixelsBit();
      init_Shader();
      init_UniformGroup();
      init_Texture();
      init_tilingBit();
      TilingSpriteShader = class extends Shader {
        constructor() {
          gpuProgram ?? (gpuProgram = compileHighShaderGpuProgram({
            name: "tiling-sprite-shader",
            bits: [
              localUniformBit,
              tilingBit,
              roundPixelsBit
            ]
          }));
          glProgram ?? (glProgram = compileHighShaderGlProgram({
            name: "tiling-sprite-shader",
            bits: [
              localUniformBitGl,
              tilingBitGl,
              roundPixelsBitGl
            ]
          }));
          const tilingUniforms = new UniformGroup({
            uMapCoord: { value: new Matrix(), type: "mat3x3<f32>" },
            uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: "vec4<f32>" },
            uClampOffset: { value: new Float32Array([0, 0]), type: "vec2<f32>" },
            uTextureTransform: { value: new Matrix(), type: "mat3x3<f32>" },
            uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: "vec4<f32>" }
          });
          super({
            glProgram,
            gpuProgram,
            resources: {
              localUniforms: new UniformGroup({
                uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
                uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
                uRound: { value: 0, type: "f32" }
              }),
              tilingUniforms,
              uTexture: Texture.EMPTY.source,
              uSampler: Texture.EMPTY.source.style
            }
          });
        }
        updateUniforms(width, height, matrix, anchorX, anchorY, texture) {
          const tilingUniforms = this.resources.tilingUniforms;
          const textureWidth = texture.width;
          const textureHeight = texture.height;
          const textureMatrix = texture.textureMatrix;
          const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;
          uTextureTransform.set(
            matrix.a * textureWidth / width,
            matrix.b * textureWidth / height,
            matrix.c * textureHeight / width,
            matrix.d * textureHeight / height,
            matrix.tx / width,
            matrix.ty / height
          );
          uTextureTransform.invert();
          tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;
          tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;
          tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;
          tilingUniforms.uniforms.uTextureTransform = uTextureTransform;
          tilingUniforms.uniforms.uSizeAnchor[0] = width;
          tilingUniforms.uniforms.uSizeAnchor[1] = height;
          tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;
          tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;
          if (texture) {
            this.resources.uTexture = texture.source;
            this.resources.uSampler = texture.source.style;
          }
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.mjs
  var QuadGeometry;
  var init_QuadGeometry = __esm({
    "../core/node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.mjs"() {
      init_MeshGeometry();
      QuadGeometry = class extends MeshGeometry {
        constructor() {
          super({
            positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
            uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
            indices: new Uint32Array([0, 1, 2, 0, 2, 3])
          });
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.mjs
  function setPositions(tilingSprite, positions) {
    const anchorX = tilingSprite.anchor.x;
    const anchorY = tilingSprite.anchor.y;
    positions[0] = -anchorX * tilingSprite.width;
    positions[1] = -anchorY * tilingSprite.height;
    positions[2] = (1 - anchorX) * tilingSprite.width;
    positions[3] = -anchorY * tilingSprite.height;
    positions[4] = (1 - anchorX) * tilingSprite.width;
    positions[5] = (1 - anchorY) * tilingSprite.height;
    positions[6] = -anchorX * tilingSprite.width;
    positions[7] = (1 - anchorY) * tilingSprite.height;
  }
  var init_setPositions = __esm({
    "../core/node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.mjs
  function applyMatrix(array, stride, offset, matrix) {
    let index = 0;
    const size = array.length / (stride || 2);
    const a2 = matrix.a;
    const b2 = matrix.b;
    const c2 = matrix.c;
    const d2 = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    offset *= stride;
    while (index < size) {
      const x2 = array[offset];
      const y2 = array[offset + 1];
      array[offset] = a2 * x2 + c2 * y2 + tx;
      array[offset + 1] = b2 * x2 + d2 * y2 + ty;
      offset += stride;
      index++;
    }
  }
  var init_applyMatrix = __esm({
    "../core/node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.mjs
  function setUvs(tilingSprite, uvs) {
    const texture = tilingSprite.texture;
    const width = texture.frame.width;
    const height = texture.frame.height;
    let anchorX = 0;
    let anchorY = 0;
    if (tilingSprite._applyAnchorToTexture) {
      anchorX = tilingSprite.anchor.x;
      anchorY = tilingSprite.anchor.y;
    }
    uvs[0] = uvs[6] = -anchorX;
    uvs[2] = uvs[4] = 1 - anchorX;
    uvs[1] = uvs[3] = -anchorY;
    uvs[5] = uvs[7] = 1 - anchorY;
    const textureMatrix = Matrix.shared;
    textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);
    textureMatrix.tx /= tilingSprite.width;
    textureMatrix.ty /= tilingSprite.height;
    textureMatrix.invert();
    textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);
    applyMatrix(uvs, 2, 0, textureMatrix);
  }
  var init_setUvs = __esm({
    "../core/node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.mjs"() {
      init_Matrix();
      init_applyMatrix();
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.mjs
  var sharedQuad, TilingSpritePipe;
  var init_TilingSpritePipe = __esm({
    "../core/node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.mjs"() {
      init_Extensions();
      init_State();
      init_types();
      init_colorToUniform();
      init_BatchableMesh();
      init_MeshGeometry();
      init_TilingSpriteShader();
      init_QuadGeometry();
      init_setPositions();
      init_setUvs();
      sharedQuad = new QuadGeometry();
      TilingSpritePipe = class {
        constructor(renderer) {
          this._tilingSpriteDataHash = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
        }
        validateRenderable(renderable) {
          const tilingSpriteData = this._getTilingSpriteData(renderable);
          const couldBatch = tilingSpriteData.canBatch;
          this._updateCanBatch(renderable);
          const canBatch = tilingSpriteData.canBatch;
          if (canBatch && canBatch === couldBatch) {
            const { batchableMesh } = tilingSpriteData;
            if (batchableMesh.texture._source !== renderable.texture._source) {
              return !batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, renderable.texture);
            }
          }
          return couldBatch !== canBatch;
        }
        addRenderable(tilingSprite, instructionSet) {
          const batcher = this._renderer.renderPipes.batch;
          this._updateCanBatch(tilingSprite);
          const tilingSpriteData = this._getTilingSpriteData(tilingSprite);
          const { geometry, canBatch } = tilingSpriteData;
          if (canBatch) {
            tilingSpriteData.batchableMesh || (tilingSpriteData.batchableMesh = new BatchableMesh());
            const batchableMesh = tilingSpriteData.batchableMesh;
            if (tilingSprite._didTilingSpriteUpdate) {
              tilingSprite._didTilingSpriteUpdate = false;
              this._updateBatchableMesh(tilingSprite);
              batchableMesh.geometry = geometry;
              batchableMesh.mesh = tilingSprite;
              batchableMesh.texture = tilingSprite._texture;
            }
            batchableMesh.roundPixels = this._renderer._roundPixels | tilingSprite._roundPixels;
            batcher.addToBatch(batchableMesh);
          } else {
            batcher.break(instructionSet);
            tilingSpriteData.shader || (tilingSpriteData.shader = new TilingSpriteShader());
            this.updateRenderable(tilingSprite);
            instructionSet.add(tilingSprite);
          }
        }
        execute(tilingSprite) {
          const { shader } = this._tilingSpriteDataHash[tilingSprite.uid];
          shader.groups[0] = this._renderer.globalUniforms.bindGroup;
          const localUniforms = shader.resources.localUniforms.uniforms;
          localUniforms.uTransformMatrix = tilingSprite.groupTransform;
          localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;
          color32BitToUniform(
            tilingSprite.groupColorAlpha,
            localUniforms.uColor,
            0
          );
          this._renderer.encoder.draw({
            geometry: sharedQuad,
            shader,
            state: State.default2d
          });
        }
        updateRenderable(tilingSprite) {
          const tilingSpriteData = this._getTilingSpriteData(tilingSprite);
          const { canBatch } = tilingSpriteData;
          if (canBatch) {
            const { batchableMesh } = tilingSpriteData;
            if (tilingSprite._didTilingSpriteUpdate)
              this._updateBatchableMesh(tilingSprite);
            batchableMesh.batcher.updateElement(batchableMesh);
          } else if (tilingSprite._didTilingSpriteUpdate) {
            const { shader } = tilingSpriteData;
            shader.updateUniforms(
              tilingSprite.width,
              tilingSprite.height,
              tilingSprite._tileTransform.matrix,
              tilingSprite.anchor.x,
              tilingSprite.anchor.y,
              tilingSprite.texture
            );
          }
          tilingSprite._didTilingSpriteUpdate = false;
        }
        destroyRenderable(tilingSprite) {
          const tilingSpriteData = this._getTilingSpriteData(tilingSprite);
          tilingSpriteData.batchableMesh = null;
          tilingSpriteData.shader?.destroy();
          this._tilingSpriteDataHash[tilingSprite.uid] = null;
        }
        _getTilingSpriteData(renderable) {
          return this._tilingSpriteDataHash[renderable.uid] || this._initTilingSpriteData(renderable);
        }
        _initTilingSpriteData(tilingSprite) {
          const geometry = new MeshGeometry({
            indices: sharedQuad.indices,
            positions: sharedQuad.positions.slice(),
            uvs: sharedQuad.uvs.slice()
          });
          this._tilingSpriteDataHash[tilingSprite.uid] = {
            canBatch: true,
            renderable: tilingSprite,
            geometry
          };
          tilingSprite.on("destroyed", () => {
            this.destroyRenderable(tilingSprite);
          });
          return this._tilingSpriteDataHash[tilingSprite.uid];
        }
        _updateBatchableMesh(tilingSprite) {
          const renderableData = this._getTilingSpriteData(tilingSprite);
          const { geometry } = renderableData;
          const style = tilingSprite.texture.source.style;
          if (style.addressMode !== "repeat") {
            style.addressMode = "repeat";
            style.update();
          }
          setUvs(tilingSprite, geometry.uvs);
          setPositions(tilingSprite, geometry.positions);
        }
        destroy() {
          for (const i2 in this._tilingSpriteDataHash) {
            this.destroyRenderable(this._tilingSpriteDataHash[i2].renderable);
          }
          this._tilingSpriteDataHash = null;
          this._renderer = null;
        }
        _updateCanBatch(tilingSprite) {
          const renderableData = this._getTilingSpriteData(tilingSprite);
          const texture = tilingSprite.texture;
          let _nonPowOf2wrapping = true;
          if (this._renderer.type === RendererType.WEBGL) {
            _nonPowOf2wrapping = this._renderer.context.supports.nonPowOf2wrapping;
          }
          renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);
          return renderableData.canBatch;
        }
      };
      TilingSpritePipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "tilingSprite"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/sprite-tiling/init.mjs
  var init_init11 = __esm({
    "../core/node_modules/pixi.js/lib/scene/sprite-tiling/init.mjs"() {
      init_Extensions();
      init_TilingSpritePipe();
      extensions.add(TilingSpritePipe);
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.mjs
  var _PlaneGeometry, PlaneGeometry;
  var init_PlaneGeometry = __esm({
    "../core/node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.mjs"() {
      init_deprecation();
      init_MeshGeometry();
      _PlaneGeometry = class _PlaneGeometry2 extends MeshGeometry {
        constructor(...args) {
          super({});
          let options = args[0] ?? {};
          if (typeof options === "number") {
            deprecation(v8_0_0, "PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead");
            options = {
              width: options,
              height: args[1],
              verticesX: args[2],
              verticesY: args[3]
            };
          }
          this.build(options);
        }
        /**
         * Refreshes plane coordinates
         * @param options - Options to be applied to plane geometry
         */
        build(options) {
          options = { ..._PlaneGeometry2.defaultOptions, ...options };
          this.verticesX = this.verticesX ?? options.verticesX;
          this.verticesY = this.verticesY ?? options.verticesY;
          this.width = this.width ?? options.width;
          this.height = this.height ?? options.height;
          const total = this.verticesX * this.verticesY;
          const verts = [];
          const uvs = [];
          const indices = [];
          const verticesX = this.verticesX - 1;
          const verticesY = this.verticesY - 1;
          const sizeX = this.width / verticesX;
          const sizeY = this.height / verticesY;
          for (let i2 = 0; i2 < total; i2++) {
            const x2 = i2 % this.verticesX;
            const y2 = i2 / this.verticesX | 0;
            verts.push(x2 * sizeX, y2 * sizeY);
            uvs.push(x2 / verticesX, y2 / verticesY);
          }
          const totalSub = verticesX * verticesY;
          for (let i2 = 0; i2 < totalSub; i2++) {
            const xpos = i2 % verticesX;
            const ypos = i2 / verticesX | 0;
            const value = ypos * this.verticesX + xpos;
            const value2 = ypos * this.verticesX + xpos + 1;
            const value3 = (ypos + 1) * this.verticesX + xpos;
            const value4 = (ypos + 1) * this.verticesX + xpos + 1;
            indices.push(
              value,
              value2,
              value3,
              value2,
              value4,
              value3
            );
          }
          this.buffers[0].data = new Float32Array(verts);
          this.buffers[1].data = new Float32Array(uvs);
          this.indexBuffer.data = new Uint32Array(indices);
          this.buffers[0].update();
          this.buffers[1].update();
          this.indexBuffer.update();
        }
      };
      _PlaneGeometry.defaultOptions = {
        width: 100,
        height: 100,
        verticesX: 10,
        verticesY: 10
      };
      PlaneGeometry = _PlaneGeometry;
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.mjs
  var _NineSliceGeometry, NineSliceGeometry;
  var init_NineSliceGeometry = __esm({
    "../core/node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.mjs"() {
      init_PlaneGeometry();
      _NineSliceGeometry = class _NineSliceGeometry2 extends PlaneGeometry {
        constructor(options = {}) {
          options = { ..._NineSliceGeometry2.defaultOptions, ...options };
          super({
            width: options.width,
            height: options.height,
            verticesX: 4,
            verticesY: 4
          });
          this.update(options);
        }
        /**
         * Updates the NineSliceGeometry with the options.
         * @param options - The options of the NineSliceGeometry.
         */
        update(options) {
          this.width = options.width ?? this.width;
          this.height = options.height ?? this.height;
          this._originalWidth = options.originalWidth ?? this._originalWidth;
          this._originalHeight = options.originalHeight ?? this._originalHeight;
          this._leftWidth = options.leftWidth ?? this._leftWidth;
          this._rightWidth = options.rightWidth ?? this._rightWidth;
          this._topHeight = options.topHeight ?? this._topHeight;
          this._bottomHeight = options.bottomHeight ?? this._bottomHeight;
          this.updateUvs();
          this.updatePositions();
        }
        /** Updates the positions of the vertices. */
        updatePositions() {
          const positions = this.positions;
          const w2 = this._leftWidth + this._rightWidth;
          const scaleW = this.width > w2 ? 1 : this.width / w2;
          const h2 = this._topHeight + this._bottomHeight;
          const scaleH = this.height > h2 ? 1 : this.height / h2;
          const scale = Math.min(scaleW, scaleH);
          positions[9] = positions[11] = positions[13] = positions[15] = this._topHeight * scale;
          positions[17] = positions[19] = positions[21] = positions[23] = this.height - this._bottomHeight * scale;
          positions[25] = positions[27] = positions[29] = positions[31] = this.height;
          positions[2] = positions[10] = positions[18] = positions[26] = this._leftWidth * scale;
          positions[4] = positions[12] = positions[20] = positions[28] = this.width - this._rightWidth * scale;
          positions[6] = positions[14] = positions[22] = positions[30] = this.width;
          this.getBuffer("aPosition").update();
        }
        /** Updates the UVs of the vertices. */
        updateUvs() {
          const uvs = this.uvs;
          uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;
          uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;
          uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;
          uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;
          const _uvw = 1 / this._originalWidth;
          const _uvh = 1 / this._originalHeight;
          uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;
          uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;
          uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;
          uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;
          this.getBuffer("aUV").update();
        }
      };
      _NineSliceGeometry.defaultOptions = {
        /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
        width: 100,
        /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
        height: 100,
        /** The width of the left column. */
        leftWidth: 10,
        /** The height of the top row. */
        topHeight: 10,
        /** The width of the right column. */
        rightWidth: 10,
        /** The height of the bottom row. */
        bottomHeight: 10,
        /** The original width of the texture */
        originalWidth: 100,
        /** The original height of the texture */
        originalHeight: 100
      };
      NineSliceGeometry = _NineSliceGeometry;
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSpritePipe.mjs
  var NineSliceSpritePipe;
  var init_NineSliceSpritePipe = __esm({
    "../core/node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSpritePipe.mjs"() {
      init_Extensions();
      init_PoolGroup();
      init_BatchableMesh();
      init_NineSliceGeometry();
      NineSliceSpritePipe = class {
        constructor(renderer) {
          this._gpuSpriteHash = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
        }
        addRenderable(sprite, _instructionSet) {
          const gpuSprite = this._getGpuSprite(sprite);
          if (sprite._didSpriteUpdate)
            this._updateBatchableSprite(sprite, gpuSprite);
          this._renderer.renderPipes.batch.addToBatch(gpuSprite);
        }
        updateRenderable(sprite) {
          const gpuSprite = this._gpuSpriteHash[sprite.uid];
          if (sprite._didSpriteUpdate)
            this._updateBatchableSprite(sprite, gpuSprite);
          gpuSprite.batcher.updateElement(gpuSprite);
        }
        validateRenderable(sprite) {
          const texture = sprite._texture;
          const gpuSprite = this._getGpuSprite(sprite);
          if (gpuSprite.texture._source !== texture._source) {
            return !gpuSprite.batcher.checkAndUpdateTexture(gpuSprite, texture);
          }
          return false;
        }
        destroyRenderable(sprite) {
          const batchableSprite = this._gpuSpriteHash[sprite.uid];
          BigPool.return(batchableSprite);
          this._gpuSpriteHash[sprite.uid] = null;
        }
        _updateBatchableSprite(sprite, batchableSprite) {
          sprite._didSpriteUpdate = false;
          batchableSprite.geometry.update(sprite);
          batchableSprite.texture = sprite._texture;
        }
        _getGpuSprite(sprite) {
          return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);
        }
        _initGPUSprite(sprite) {
          const batchableMesh = new BatchableMesh();
          batchableMesh.geometry = new NineSliceGeometry();
          batchableMesh.mesh = sprite;
          batchableMesh.texture = sprite._texture;
          batchableMesh.roundPixels = this._renderer._roundPixels | sprite._roundPixels;
          this._gpuSpriteHash[sprite.uid] = batchableMesh;
          sprite.on("destroyed", () => {
            this.destroyRenderable(sprite);
          });
          return batchableMesh;
        }
        destroy() {
          for (const i2 in this._gpuSpriteHash) {
            const batchableMesh = this._gpuSpriteHash[i2];
            batchableMesh.geometry.destroy();
          }
          this._gpuSpriteHash = null;
          this._renderer = null;
        }
      };
      NineSliceSpritePipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "nineSliceSprite"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/sprite-nine-slice/init.mjs
  var init_init12 = __esm({
    "../core/node_modules/pixi.js/lib/scene/sprite-nine-slice/init.mjs"() {
      init_Extensions();
      init_NineSliceSpritePipe();
      extensions.add(NineSliceSpritePipe);
    }
  });

  // ../core/node_modules/pixi.js/lib/filters/FilterPipe.mjs
  var FilterPipe;
  var init_FilterPipe = __esm({
    "../core/node_modules/pixi.js/lib/filters/FilterPipe.mjs"() {
      init_Extensions();
      FilterPipe = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        push(filterEffect, container, instructionSet) {
          const renderPipes3 = this._renderer.renderPipes;
          renderPipes3.batch.break(instructionSet);
          instructionSet.add({
            renderPipeId: "filter",
            canBundle: false,
            action: "pushFilter",
            container,
            filterEffect
          });
        }
        pop(_filterEffect, _container, instructionSet) {
          this._renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add({
            renderPipeId: "filter",
            action: "popFilter",
            canBundle: false
          });
        }
        execute(instruction) {
          if (instruction.action === "pushFilter") {
            this._renderer.filter.push(instruction);
          } else if (instruction.action === "popFilter") {
            this._renderer.filter.pop();
          }
        }
        destroy() {
          this._renderer = null;
        }
      };
      FilterPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "filter"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/container/bounds/getFastGlobalBounds.mjs
  function getFastGlobalBounds(target, bounds) {
    bounds.clear();
    _getGlobalBoundsRecursive(target, bounds);
    if (!bounds.isValid) {
      bounds.set(0, 0, 0, 0);
    }
    if (!target.renderGroup) {
      bounds.applyMatrix(target.parentRenderGroup.worldTransform);
    } else {
      bounds.applyMatrix(target.renderGroup.localTransform);
    }
    return bounds;
  }
  function _getGlobalBoundsRecursive(target, bounds) {
    if (target.localDisplayStatus !== 7 || !target.measurable) {
      return;
    }
    const manageEffects = !!target.effects.length;
    let localBounds = bounds;
    if (target.renderGroup || manageEffects) {
      localBounds = boundsPool.get().clear();
    }
    if (target.boundsArea) {
      bounds.addRect(target.boundsArea, target.worldTransform);
    } else {
      if (target.renderPipeId) {
        const viewBounds = target.bounds;
        localBounds.addFrame(
          viewBounds.minX,
          viewBounds.minY,
          viewBounds.maxX,
          viewBounds.maxY,
          target.groupTransform
        );
      }
      const children2 = target.children;
      for (let i2 = 0; i2 < children2.length; i2++) {
        _getGlobalBoundsRecursive(children2[i2], localBounds);
      }
    }
    if (manageEffects) {
      let advanced = false;
      for (let i2 = 0; i2 < target.effects.length; i2++) {
        if (target.effects[i2].addBounds) {
          if (!advanced) {
            advanced = true;
            localBounds.applyMatrix(target.parentRenderGroup.worldTransform);
          }
          target.effects[i2].addBounds(localBounds, true);
        }
      }
      if (advanced) {
        localBounds.applyMatrix(target.parentRenderGroup.worldTransform.copyTo(tempMatrix4).invert());
        bounds.addBounds(localBounds, target.relativeGroupTransform);
      }
      bounds.addBounds(localBounds);
      boundsPool.return(localBounds);
    } else if (target.renderGroup) {
      bounds.addBounds(localBounds, target.relativeGroupTransform);
      boundsPool.return(localBounds);
    }
  }
  var tempMatrix4;
  var init_getFastGlobalBounds = __esm({
    "../core/node_modules/pixi.js/lib/scene/container/bounds/getFastGlobalBounds.mjs"() {
      init_Matrix();
      init_matrixAndBoundsPool();
      tempMatrix4 = new Matrix();
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.mjs
  function getGlobalRenderableBounds(renderables, bounds) {
    bounds.clear();
    const tempMatrix6 = bounds.matrix;
    for (let i2 = 0; i2 < renderables.length; i2++) {
      const renderable = renderables[i2];
      if (renderable.globalDisplayStatus < 7) {
        continue;
      }
      bounds.matrix = renderable.worldTransform;
      renderable.addBounds(bounds);
    }
    bounds.matrix = tempMatrix6;
    return bounds;
  }
  var init_getRenderableBounds = __esm({
    "../core/node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/filters/FilterSystem.mjs
  var quadGeometry, FilterSystem;
  var init_FilterSystem = __esm({
    "../core/node_modules/pixi.js/lib/filters/FilterSystem.mjs"() {
      init_Extensions();
      init_Matrix();
      init_Point();
      init_BindGroup();
      init_Geometry();
      init_UniformGroup();
      init_Texture();
      init_TexturePool();
      init_types();
      init_Bounds();
      init_getFastGlobalBounds();
      init_getRenderableBounds();
      init_warn();
      quadGeometry = new Geometry({
        attributes: {
          aPosition: {
            buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
            location: 0,
            format: "float32x2",
            stride: 2 * 4,
            offset: 0
          }
        },
        indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3])
      });
      FilterSystem = class {
        constructor(renderer) {
          this._filterStackIndex = 0;
          this._filterStack = [];
          this._filterGlobalUniforms = new UniformGroup({
            uInputSize: { value: new Float32Array(4), type: "vec4<f32>" },
            uInputPixel: { value: new Float32Array(4), type: "vec4<f32>" },
            uInputClamp: { value: new Float32Array(4), type: "vec4<f32>" },
            uOutputFrame: { value: new Float32Array(4), type: "vec4<f32>" },
            uGlobalFrame: { value: new Float32Array(4), type: "vec4<f32>" },
            uOutputTexture: { value: new Float32Array(4), type: "vec4<f32>" }
          });
          this._globalFilterBindGroup = new BindGroup({});
          this.renderer = renderer;
        }
        /**
         * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.
         * @readonly
         */
        get activeBackTexture() {
          return this._activeFilterData?.backTexture;
        }
        push(instruction) {
          const renderer = this.renderer;
          const filters = instruction.filterEffect.filters;
          if (!this._filterStack[this._filterStackIndex]) {
            this._filterStack[this._filterStackIndex] = this._getFilterData();
          }
          const filterData = this._filterStack[this._filterStackIndex];
          this._filterStackIndex++;
          if (filters.length === 0) {
            filterData.skip = true;
            return;
          }
          const bounds = filterData.bounds;
          if (instruction.renderables) {
            getGlobalRenderableBounds(instruction.renderables, bounds);
          } else if (instruction.filterEffect.filterArea) {
            bounds.clear();
            bounds.addRect(instruction.filterEffect.filterArea);
            bounds.applyMatrix(instruction.container.worldTransform);
          } else {
            getFastGlobalBounds(instruction.container, bounds);
          }
          const colorTextureSource = renderer.renderTarget.rootRenderTarget.colorTexture.source;
          let resolution = colorTextureSource._resolution;
          let padding = 0;
          let antialias = colorTextureSource.antialias;
          let blendRequired = false;
          let enabled = false;
          for (let i2 = 0; i2 < filters.length; i2++) {
            const filter2 = filters[i2];
            resolution = Math.min(resolution, filter2.resolution);
            padding += filter2.padding;
            if (filter2.antialias !== "inherit") {
              if (filter2.antialias === "on") {
                antialias = true;
              } else {
                antialias = false;
              }
            }
            const isCompatible = !!(filter2.compatibleRenderers & renderer.type);
            if (!isCompatible) {
              enabled = false;
              break;
            }
            if (filter2.blendRequired && !(renderer.backBuffer?.useBackBuffer ?? true)) {
              warn("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.");
              enabled = false;
              break;
            }
            enabled = filter2.enabled || enabled;
            blendRequired = blendRequired || filter2.blendRequired;
          }
          if (!enabled) {
            filterData.skip = true;
            return;
          }
          const viewPort = renderer.renderTarget.rootViewPort;
          bounds.scale(resolution).fitBounds(0, viewPort.width, 0, viewPort.height).scale(1 / resolution).pad(padding).ceil();
          if (!bounds.isPositive) {
            filterData.skip = true;
            return;
          }
          filterData.skip = false;
          filterData.bounds = bounds;
          filterData.blendRequired = blendRequired;
          filterData.container = instruction.container;
          filterData.filterEffect = instruction.filterEffect;
          filterData.previousRenderSurface = renderer.renderTarget.renderSurface;
          filterData.inputTexture = TexturePool.getOptimalTexture(
            bounds.width,
            bounds.height,
            resolution,
            antialias
          );
          renderer.renderTarget.bind(filterData.inputTexture, true);
          renderer.globalUniforms.push({
            offset: bounds
          });
        }
        pop() {
          const renderer = this.renderer;
          this._filterStackIndex--;
          const filterData = this._filterStack[this._filterStackIndex];
          if (filterData.skip) {
            return;
          }
          this._activeFilterData = filterData;
          const inputTexture = filterData.inputTexture;
          const bounds = filterData.bounds;
          let backTexture = Texture.EMPTY;
          renderer.renderTarget.finishRenderPass();
          if (filterData.blendRequired) {
            const previousBounds = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null;
            const renderTarget = renderer.renderTarget.getRenderTarget(filterData.previousRenderSurface);
            backTexture = this.getBackTexture(renderTarget, bounds, previousBounds);
          }
          filterData.backTexture = backTexture;
          const filters = filterData.filterEffect.filters;
          this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);
          this._globalFilterBindGroup.setResource(backTexture.source, 3);
          renderer.globalUniforms.pop();
          if (filters.length === 1) {
            filters[0].apply(this, inputTexture, filterData.previousRenderSurface, false);
            TexturePool.returnTexture(inputTexture);
          } else {
            let flip = filterData.inputTexture;
            let flop = TexturePool.getOptimalTexture(
              bounds.width,
              bounds.height,
              flip.source._resolution,
              false
            );
            let i2 = 0;
            for (i2 = 0; i2 < filters.length - 1; ++i2) {
              const filter2 = filters[i2];
              filter2.apply(this, flip, flop, true);
              const t2 = flip;
              flip = flop;
              flop = t2;
            }
            filters[i2].apply(this, flip, filterData.previousRenderSurface, false);
            TexturePool.returnTexture(flip);
            TexturePool.returnTexture(flop);
          }
          if (filterData.blendRequired) {
            TexturePool.returnTexture(backTexture);
          }
        }
        getBackTexture(lastRenderSurface, bounds, previousBounds) {
          const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;
          const backTexture = TexturePool.getOptimalTexture(
            bounds.width,
            bounds.height,
            backgroundResolution,
            false
          );
          let x2 = bounds.minX;
          let y2 = bounds.minY;
          if (previousBounds) {
            x2 -= previousBounds.minX;
            y2 -= previousBounds.minY;
          }
          x2 = Math.floor(x2 * backgroundResolution);
          y2 = Math.floor(y2 * backgroundResolution);
          const width = Math.ceil(bounds.width * backgroundResolution);
          const height = Math.ceil(bounds.height * backgroundResolution);
          this.renderer.renderTarget.copyToTexture(
            lastRenderSurface,
            backTexture,
            { x: x2, y: y2 },
            { width, height },
            { x: 0, y: 0 }
          );
          return backTexture;
        }
        applyFilter(filter2, input, output, clear) {
          const renderer = this.renderer;
          const filterData = this._filterStack[this._filterStackIndex];
          const bounds = filterData.bounds;
          const offset = Point.shared;
          const previousRenderSurface = filterData.previousRenderSurface;
          const isFinalTarget = previousRenderSurface === output;
          let resolution = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;
          let currentIndex = this._filterStackIndex - 1;
          while (currentIndex > 0 && this._filterStack[currentIndex].skip) {
            --currentIndex;
          }
          if (currentIndex > 0) {
            resolution = this._filterStack[currentIndex].inputTexture.source._resolution;
          }
          const filterUniforms = this._filterGlobalUniforms;
          const uniforms = filterUniforms.uniforms;
          const outputFrame = uniforms.uOutputFrame;
          const inputSize = uniforms.uInputSize;
          const inputPixel = uniforms.uInputPixel;
          const inputClamp = uniforms.uInputClamp;
          const globalFrame = uniforms.uGlobalFrame;
          const outputTexture = uniforms.uOutputTexture;
          if (isFinalTarget) {
            let lastIndex = this._filterStackIndex;
            while (lastIndex > 0) {
              lastIndex--;
              const filterData2 = this._filterStack[this._filterStackIndex - 1];
              if (!filterData2.skip) {
                offset.x = filterData2.bounds.minX;
                offset.y = filterData2.bounds.minY;
                break;
              }
            }
            outputFrame[0] = bounds.minX - offset.x;
            outputFrame[1] = bounds.minY - offset.y;
          } else {
            outputFrame[0] = 0;
            outputFrame[1] = 0;
          }
          outputFrame[2] = input.frame.width;
          outputFrame[3] = input.frame.height;
          inputSize[0] = input.source.width;
          inputSize[1] = input.source.height;
          inputSize[2] = 1 / inputSize[0];
          inputSize[3] = 1 / inputSize[1];
          inputPixel[0] = input.source.pixelWidth;
          inputPixel[1] = input.source.pixelHeight;
          inputPixel[2] = 1 / inputPixel[0];
          inputPixel[3] = 1 / inputPixel[1];
          inputClamp[0] = 0.5 * inputPixel[2];
          inputClamp[1] = 0.5 * inputPixel[3];
          inputClamp[2] = input.frame.width * inputSize[2] - 0.5 * inputPixel[2];
          inputClamp[3] = input.frame.height * inputSize[3] - 0.5 * inputPixel[3];
          const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;
          globalFrame[0] = offset.x * resolution;
          globalFrame[1] = offset.y * resolution;
          globalFrame[2] = rootTexture.source.width * resolution;
          globalFrame[3] = rootTexture.source.height * resolution;
          const renderTarget = this.renderer.renderTarget.getRenderTarget(output);
          renderer.renderTarget.bind(output, !!clear);
          if (output instanceof Texture) {
            outputTexture[0] = output.frame.width;
            outputTexture[1] = output.frame.height;
          } else {
            outputTexture[0] = renderTarget.width;
            outputTexture[1] = renderTarget.height;
          }
          outputTexture[2] = renderTarget.isRoot ? -1 : 1;
          filterUniforms.update();
          if (renderer.renderPipes.uniformBatch) {
            const batchUniforms = renderer.renderPipes.uniformBatch.getUboResource(filterUniforms);
            this._globalFilterBindGroup.setResource(batchUniforms, 0);
          } else {
            this._globalFilterBindGroup.setResource(filterUniforms, 0);
          }
          this._globalFilterBindGroup.setResource(input.source, 1);
          this._globalFilterBindGroup.setResource(input.source.style, 2);
          filter2.groups[0] = this._globalFilterBindGroup;
          renderer.encoder.draw({
            geometry: quadGeometry,
            shader: filter2,
            state: filter2._state,
            topology: "triangle-list"
          });
          if (renderer.type === RendererType.WEBGL) {
            renderer.renderTarget.finishRenderPass();
          }
        }
        _getFilterData() {
          return {
            skip: false,
            inputTexture: null,
            bounds: new Bounds(),
            container: null,
            filterEffect: null,
            blendRequired: false,
            previousRenderSurface: null
          };
        }
        /**
         * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.
         *
         * Use `outputMatrix * vTextureCoord` in the shader.
         * @param outputMatrix - The matrix to output to.
         * @param {Sprite} sprite - The sprite to map to.
         * @returns The mapped matrix.
         */
        calculateSpriteMatrix(outputMatrix, sprite) {
          const data = this._activeFilterData;
          const mappedMatrix = outputMatrix.set(
            data.inputTexture._source.width,
            0,
            0,
            data.inputTexture._source.height,
            data.bounds.minX,
            data.bounds.minY
          );
          const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);
          worldTransform.invert();
          mappedMatrix.prepend(worldTransform);
          mappedMatrix.scale(
            1 / sprite.texture.frame.width,
            1 / sprite.texture.frame.height
          );
          mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
          return mappedMatrix;
        }
      };
      FilterSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem
        ],
        name: "filter"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/filters/init.mjs
  var init_init13 = __esm({
    "../core/node_modules/pixi.js/lib/filters/init.mjs"() {
      init_Extensions();
      init_FilterPipe();
      init_FilterSystem();
      extensions.add(FilterSystem);
      extensions.add(FilterPipe);
    }
  });

  // ../core/node_modules/pixi.js/lib/environment-browser/browserAll.mjs
  var browserAll_exports = {};
  var init_browserAll = __esm({
    "../core/node_modules/pixi.js/lib/environment-browser/browserAll.mjs"() {
      init_init();
      init_init2();
      init_init3();
      init_init4();
      init_init5();
      init_init6();
      init_init7();
      init_init8();
      init_init9();
      init_init10();
      init_init11();
      init_init12();
      init_init13();
    }
  });

  // ../core/node_modules/pixi.js/lib/environment-webworker/webworkerAll.mjs
  var webworkerAll_exports = {};
  var init_webworkerAll = __esm({
    "../core/node_modules/pixi.js/lib/environment-webworker/webworkerAll.mjs"() {
      init_init2();
      init_init4();
      init_init5();
      init_init6();
      init_init7();
      init_init8();
      init_init9();
      init_init10();
      init_init11();
      init_init12();
      init_init13();
    }
  });

  // ../core/node_modules/pixi.js/lib/filters/Filter.mjs
  var _Filter, Filter;
  var init_Filter = __esm({
    "../core/node_modules/pixi.js/lib/filters/Filter.mjs"() {
      init_GlProgram();
      init_GpuProgram();
      init_Shader();
      init_State();
      _Filter = class _Filter2 extends Shader {
        /**
         * @param options - The optional parameters of this filter.
         */
        constructor(options) {
          options = { ..._Filter2.defaultOptions, ...options };
          super(options);
          this.enabled = true;
          this._state = State.for2d();
          this.padding = options.padding;
          if (typeof options.antialias === "boolean") {
            this.antialias = options.antialias ? "on" : "off";
          } else {
            this.antialias = options.antialias;
          }
          this.resolution = options.resolution;
          this.blendRequired = options.blendRequired;
          this.addResource("uTexture", 0, 1);
        }
        /**
         * Applies the filter
         * @param filterManager - The renderer to retrieve the filter from
         * @param input - The input render target.
         * @param output - The target to output to.
         * @param clearMode - Should the output be cleared before rendering to it
         */
        apply(filterManager, input, output, clearMode) {
          filterManager.applyFilter(this, input, output, clearMode);
        }
        /**
         * Get the blend mode of the filter.
         * @default "normal"
         */
        get blendMode() {
          return this._state.blendMode;
        }
        /** Sets the blend mode of the filter. */
        set blendMode(value) {
          this._state.blendMode = value;
        }
        /**
         * A short hand function to create a filter based of a vertex and fragment shader src.
         * @param options
         * @returns A shiny new PixiJS filter!
         */
        static from(options) {
          const { gpu, gl, ...rest } = options;
          let gpuProgram2;
          let glProgram2;
          if (gpu) {
            gpuProgram2 = GpuProgram.from(gpu);
          }
          if (gl) {
            glProgram2 = GlProgram.from(gl);
          }
          return new _Filter2({
            gpuProgram: gpuProgram2,
            glProgram: glProgram2,
            ...rest
          });
        }
      };
      _Filter.defaultOptions = {
        blendMode: "normal",
        resolution: 1,
        padding: 0,
        antialias: "off",
        blendRequired: false
      };
      Filter = _Filter;
    }
  });

  // ../core/node_modules/pixi.js/lib/utils/browser/unsafeEvalSupported.mjs
  function unsafeEvalSupported() {
    if (typeof unsafeEval === "boolean") {
      return unsafeEval;
    }
    try {
      const func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
      unsafeEval = func({ a: "b" }, "a", "b") === true;
    } catch (e2) {
      unsafeEval = false;
    }
    return unsafeEval;
  }
  var unsafeEval;
  var init_unsafeEvalSupported = __esm({
    "../core/node_modules/pixi.js/lib/utils/browser/unsafeEvalSupported.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs
  var CLEAR;
  var init_const8 = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs"() {
      "use strict";
      CLEAR = /* @__PURE__ */ ((CLEAR2) => {
        CLEAR2[CLEAR2["NONE"] = 0] = "NONE";
        CLEAR2[CLEAR2["COLOR"] = 16384] = "COLOR";
        CLEAR2[CLEAR2["STENCIL"] = 1024] = "STENCIL";
        CLEAR2[CLEAR2["DEPTH"] = 256] = "DEPTH";
        CLEAR2[CLEAR2["COLOR_DEPTH"] = 16640] = "COLOR_DEPTH";
        CLEAR2[CLEAR2["COLOR_STENCIL"] = 17408] = "COLOR_STENCIL";
        CLEAR2[CLEAR2["DEPTH_STENCIL"] = 1280] = "DEPTH_STENCIL";
        CLEAR2[CLEAR2["ALL"] = 17664] = "ALL";
        return CLEAR2;
      })(CLEAR || {});
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.mjs
  var SystemRunner;
  var init_SystemRunner = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.mjs"() {
      "use strict";
      SystemRunner = class {
        /**
         * @param name - The function name that will be executed on the listeners added to this Runner.
         */
        constructor(name) {
          this.items = [];
          this._name = name;
        }
        /* eslint-disable jsdoc/require-param, jsdoc/check-param-names */
        /**
         * Dispatch/Broadcast Runner to all listeners added to the queue.
         * @param {...any} params - (optional) parameters to pass to each listener
         */
        /*  eslint-enable jsdoc/require-param, jsdoc/check-param-names */
        emit(a0, a1, a2, a3, a4, a5, a6, a7) {
          const { name, items } = this;
          for (let i2 = 0, len = items.length; i2 < len; i2++) {
            items[i2][name](a0, a1, a2, a3, a4, a5, a6, a7);
          }
          return this;
        }
        /**
         * Add a listener to the Runner
         *
         * Runners do not need to have scope or functions passed to them.
         * All that is required is to pass the listening object and ensure that it has contains a function that has the same name
         * as the name provided to the Runner when it was created.
         *
         * Eg A listener passed to this Runner will require a 'complete' function.
         *
         * ```
         * import { Runner } from 'pixi.js';
         *
         * const complete = new Runner('complete');
         * ```
         *
         * The scope used will be the object itself.
         * @param {any} item - The object that will be listening.
         */
        add(item) {
          if (item[this._name]) {
            this.remove(item);
            this.items.push(item);
          }
          return this;
        }
        /**
         * Remove a single listener from the dispatch queue.
         * @param {any} item - The listener that you would like to remove.
         */
        remove(item) {
          const index = this.items.indexOf(item);
          if (index !== -1) {
            this.items.splice(index, 1);
          }
          return this;
        }
        /**
         * Check to see if the listener is already in the Runner
         * @param {any} item - The listener that you would like to check.
         */
        contains(item) {
          return this.items.indexOf(item) !== -1;
        }
        /** Remove all listeners from the Runner */
        removeAll() {
          this.items.length = 0;
          return this;
        }
        /** Remove all references, don't use after this. */
        destroy() {
          this.removeAll();
          this.items = null;
          this._name = null;
        }
        /**
         * `true` if there are no this Runner contains no listeners
         * @readonly
         */
        get empty() {
          return this.items.length === 0;
        }
        /**
         * The name of the runner.
         * @readonly
         */
        get name() {
          return this._name;
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs
  var defaultRunners, _AbstractRenderer, AbstractRenderer;
  var init_AbstractRenderer = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs"() {
      init_Color();
      init_Container();
      init_unsafeEvalSupported();
      init_deprecation();
      init_const8();
      init_SystemRunner();
      init_eventemitter3();
      defaultRunners = [
        "init",
        "destroy",
        "contextChange",
        "resolutionChange",
        "reset",
        "renderEnd",
        "renderStart",
        "render",
        "update",
        "postrender",
        "prerender"
      ];
      _AbstractRenderer = class _AbstractRenderer2 extends eventemitter3_default {
        /**
         * Set up a system with a collection of SystemClasses and runners.
         * Systems are attached dynamically to this class when added.
         * @param config - the config for the system manager
         */
        constructor(config4) {
          super();
          this.runners = /* @__PURE__ */ Object.create(null);
          this.renderPipes = /* @__PURE__ */ Object.create(null);
          this._initOptions = {};
          this._systemsHash = /* @__PURE__ */ Object.create(null);
          this.type = config4.type;
          this.name = config4.name;
          const combinedRunners = [...defaultRunners, ...config4.runners ?? []];
          this._addRunners(...combinedRunners);
          this._addSystems(config4.systems);
          this._addPipes(config4.renderPipes, config4.renderPipeAdaptors);
          this._unsafeEvalCheck();
        }
        /**
         * Initialize the renderer.
         * @param options - The options to use to create the renderer.
         */
        async init(options = {}) {
          for (const systemName in this._systemsHash) {
            const system = this._systemsHash[systemName];
            const defaultSystemOptions = system.constructor.defaultOptions;
            options = { ...defaultSystemOptions, ...options };
          }
          options = { ..._AbstractRenderer2.defaultOptions, ...options };
          this._roundPixels = options.roundPixels ? 1 : 0;
          for (let i2 = 0; i2 < this.runners.init.items.length; i2++) {
            await this.runners.init.items[i2].init(options);
          }
          this._initOptions = options;
        }
        render(args, deprecated) {
          let options = args;
          if (options instanceof Container) {
            options = { container: options };
            if (deprecated) {
              deprecation(v8_0_0, "passing a second argument is deprecated, please use render options instead");
              options.target = deprecated.renderTexture;
            }
          }
          options.target || (options.target = this.view.renderTarget);
          if (options.target === this.view.renderTarget) {
            this._lastObjectRendered = options.container;
            options.clearColor = this.background.colorRgba;
          }
          if (options.clearColor) {
            const isRGBAArray = Array.isArray(options.clearColor) && options.clearColor.length === 4;
            options.clearColor = isRGBAArray ? options.clearColor : Color.shared.setValue(options.clearColor).toArray();
          }
          if (!options.transform) {
            options.container.updateLocalTransform();
            options.transform = options.container.localTransform;
          }
          this.runners.prerender.emit(options);
          this.runners.renderStart.emit(options);
          this.runners.render.emit(options);
          this.runners.renderEnd.emit(options);
          this.runners.postrender.emit(options);
        }
        /**
         * Resizes the WebGL view to the specified width and height.
         * @param desiredScreenWidth - The desired width of the screen.
         * @param desiredScreenHeight - The desired height of the screen.
         * @param resolution - The resolution / device pixel ratio of the renderer.
         */
        resize(desiredScreenWidth, desiredScreenHeight, resolution) {
          this.view.resize(desiredScreenWidth, desiredScreenHeight, resolution);
          this.emit("resize", this.view.screen.width, this.view.screen.height);
        }
        clear(options = {}) {
          const renderer = this;
          options.target || (options.target = renderer.renderTarget.renderTarget);
          options.clearColor || (options.clearColor = this.background.colorRgba);
          options.clear ?? (options.clear = CLEAR.ALL);
          const { clear, clearColor, target } = options;
          Color.shared.setValue(clearColor ?? this.background.colorRgba);
          renderer.renderTarget.clear(target, clear, Color.shared.toArray());
        }
        /** The resolution / device pixel ratio of the renderer. */
        get resolution() {
          return this.view.resolution;
        }
        set resolution(value) {
          this.view.resolution = value;
          this.runners.resolutionChange.emit(value);
        }
        /**
         * Same as view.width, actual number of pixels in the canvas by horizontal.
         * @member {number}
         * @readonly
         * @default 800
         */
        get width() {
          return this.view.texture.frame.width;
        }
        /**
         * Same as view.height, actual number of pixels in the canvas by vertical.
         * @default 600
         */
        get height() {
          return this.view.texture.frame.height;
        }
        // NOTE: this was `view` in v7
        /**
         * The canvas element that everything is drawn to.
         * @type {environment.ICanvas}
         */
        get canvas() {
          return this.view.canvas;
        }
        /**
         * the last object rendered by the renderer. Useful for other plugins like interaction managers
         * @readonly
         */
        get lastObjectRendered() {
          return this._lastObjectRendered;
        }
        /**
         * Flag if we are rendering to the screen vs renderTexture
         * @readonly
         * @default true
         */
        get renderingToScreen() {
          const renderer = this;
          return renderer.renderTarget.renderingToScreen;
        }
        /**
         * Measurements of the screen. (0, 0, screenWidth, screenHeight).
         *
         * Its safe to use as filterArea or hitArea for the whole stage.
         */
        get screen() {
          return this.view.screen;
        }
        /**
         * Create a bunch of runners based of a collection of ids
         * @param runnerIds - the runner ids to add
         */
        _addRunners(...runnerIds) {
          runnerIds.forEach((runnerId) => {
            this.runners[runnerId] = new SystemRunner(runnerId);
          });
        }
        _addSystems(systems3) {
          let i2;
          for (i2 in systems3) {
            const val = systems3[i2];
            this._addSystem(val.value, val.name);
          }
        }
        /**
         * Add a new system to the renderer.
         * @param ClassRef - Class reference
         * @param name - Property name for system, if not specified
         *        will use a static `name` property on the class itself. This
         *        name will be assigned as s property on the Renderer so make
         *        sure it doesn't collide with properties on Renderer.
         * @returns Return instance of renderer
         */
        _addSystem(ClassRef, name) {
          const system = new ClassRef(this);
          if (this[name]) {
            throw new Error(`Whoops! The name "${name}" is already in use`);
          }
          this[name] = system;
          this._systemsHash[name] = system;
          for (const i2 in this.runners) {
            this.runners[i2].add(system);
          }
          return this;
        }
        _addPipes(pipes, pipeAdaptors) {
          const adaptors = pipeAdaptors.reduce((acc, adaptor) => {
            acc[adaptor.name] = adaptor.value;
            return acc;
          }, {});
          pipes.forEach((pipe) => {
            const PipeClass = pipe.value;
            const name = pipe.name;
            const Adaptor = adaptors[name];
            this.renderPipes[name] = new PipeClass(
              this,
              Adaptor ? new Adaptor() : null
            );
          });
        }
        destroy(options = false) {
          this.runners.destroy.items.reverse();
          this.runners.destroy.emit(options);
          Object.values(this.runners).forEach((runner) => {
            runner.destroy();
          });
          this._systemsHash = null;
          this.renderPipes = null;
        }
        /**
         * Generate a texture from a container.
         * @param options - options or container target to use when generating the texture
         * @returns a texture
         */
        generateTexture(options) {
          return this.textureGenerator.generateTexture(options);
        }
        /**
         * Whether the renderer will round coordinates to whole pixels when rendering.
         * Can be overridden on a per scene item basis.
         */
        get roundPixels() {
          return !!this._roundPixels;
        }
        /**
         * Overrideable function by `pixi.js/unsafe-eval` to silence
         * throwing an error if platform doesn't support unsafe-evals.
         * @private
         * @ignore
         */
        _unsafeEvalCheck() {
          if (!unsafeEvalSupported()) {
            throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
          }
        }
      };
      _AbstractRenderer.defaultOptions = {
        /**
         * Default resolution / device pixel ratio of the renderer.
         * @default 1
         */
        resolution: 1,
        /**
         * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported`
         * function. If set to true, a WebGL renderer can fail to be created if the browser thinks there could be
         * performance issues when using WebGL.
         *
         * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many
         * scenarios as possible. However, some users may have a poor experience, for example, if a user has a gpu or
         * driver version blacklisted by the
         * browser.
         *
         * If your application requires high performance rendering, you may wish to set this to false.
         * We recommend one of two options if you decide to set this flag to false:
         *
         * 1: Use the Canvas renderer as a fallback in case high performance WebGL is
         *    not supported.
         *
         * 2: Call `isWebGLSupported` (which if found in the utils package) in your code before attempting to create a
         *    PixiJS renderer, and show an error message to the user if the function returns false, explaining that their
         *    device & browser combination does not support high performance WebGL.
         *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.
         * @default false
         */
        failIfMajorPerformanceCaveat: false,
        /**
         * Should round pixels be forced when rendering?
         * @default false
         */
        roundPixels: false
      };
      AbstractRenderer = _AbstractRenderer;
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/graphics/gpu/GpuGraphicsAdaptor.mjs
  var GpuGraphicsAdaptor;
  var init_GpuGraphicsAdaptor = __esm({
    "../core/node_modules/pixi.js/lib/scene/graphics/gpu/GpuGraphicsAdaptor.mjs"() {
      init_Extensions();
      init_Matrix();
      init_getTextureBatchBindGroup();
      init_const4();
      init_compileHighShaderToProgram();
      init_colorBit();
      init_generateTextureBatchBit();
      init_localUniformBit();
      init_roundPixelsBit();
      init_Shader();
      init_UniformGroup();
      GpuGraphicsAdaptor = class {
        init() {
          const localUniforms = new UniformGroup({
            uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
            uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
            uRound: { value: 0, type: "f32" }
          });
          const gpuProgram2 = compileHighShaderGpuProgram({
            name: "graphics",
            bits: [
              colorBit,
              generateTextureBatchBit(MAX_TEXTURES),
              localUniformBitGroup2,
              roundPixelsBit
            ]
          });
          this.shader = new Shader({
            gpuProgram: gpuProgram2,
            resources: {
              // added on the fly!
              localUniforms
            }
          });
        }
        execute(graphicsPipe, renderable) {
          const context4 = renderable.context;
          const shader = context4.customShader || this.shader;
          const renderer = graphicsPipe.renderer;
          const contextSystem = renderer.graphicsContext;
          const {
            geometry,
            instructions
          } = contextSystem.getContextRenderData(context4);
          const encoder = renderer.encoder;
          encoder.setPipelineFromGeometryProgramAndState(
            geometry,
            shader.gpuProgram,
            graphicsPipe.state
          );
          encoder.setGeometry(geometry);
          const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;
          encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram);
          const localBindGroup = renderer.renderPipes.uniformBatch.getUniformBindGroup(shader.resources.localUniforms, true);
          encoder.setBindGroup(2, localBindGroup, shader.gpuProgram);
          const batches = instructions.instructions;
          for (let i2 = 0; i2 < instructions.instructionSize; i2++) {
            const batch = batches[i2];
            shader.groups[1] = batch.bindGroup;
            if (!batch.gpuBindGroup) {
              const textureBatch = batch.textures;
              batch.bindGroup = getTextureBatchBindGroup(textureBatch.textures, textureBatch.count);
              batch.gpuBindGroup = renderer.bindGroup.getBindGroup(
                batch.bindGroup,
                shader.gpuProgram,
                1
              );
            }
            encoder.setBindGroup(1, batch.bindGroup, shader.gpuProgram);
            encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);
          }
        }
        destroy() {
          this.shader.destroy(true);
          this.shader = null;
        }
      };
      GpuGraphicsAdaptor.extension = {
        type: [
          ExtensionType.WebGPUPipesAdaptor
        ],
        name: "graphics"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs
  var textureBit, textureBitGl;
  var init_textureBit = __esm({
    "../core/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs"() {
      "use strict";
      textureBit = {
        name: "texture-bit",
        vertex: {
          header: (
            /* wgsl */
            `

        struct TextureUniforms {
            uTextureMatrix:mat3x3<f32>,
        }

        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;
        `
          ),
          main: (
            /* wgsl */
            `
            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;
        `
          )
        },
        fragment: {
          header: (
            /* wgsl */
            `
            @group(2) @binding(0) var uTexture: texture_2d<f32>;
            @group(2) @binding(1) var uSampler: sampler;

         
        `
          ),
          main: (
            /* wgsl */
            `
            outColor = textureSample(uTexture, uSampler, vUV);
        `
          )
        }
      };
      textureBitGl = {
        name: "texture-bit",
        vertex: {
          header: (
            /* glsl */
            `
            uniform mat3 uTextureMatrix;
        `
          ),
          main: (
            /* glsl */
            `
            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;
        `
          )
        },
        fragment: {
          header: (
            /* glsl */
            `
        uniform sampler2D uTexture;

         
        `
          ),
          main: (
            /* glsl */
            `
            outColor = texture(uTexture, vUV);
        `
          )
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/mesh/gpu/GpuMeshAdapter.mjs
  var GpuMeshAdapter;
  var init_GpuMeshAdapter = __esm({
    "../core/node_modules/pixi.js/lib/scene/mesh/gpu/GpuMeshAdapter.mjs"() {
      init_Extensions();
      init_Matrix();
      init_compileHighShaderToProgram();
      init_localUniformBit();
      init_roundPixelsBit();
      init_textureBit();
      init_Shader();
      init_Texture();
      init_warn();
      GpuMeshAdapter = class {
        init() {
          const gpuProgram2 = compileHighShaderGpuProgram({
            name: "mesh",
            bits: [
              localUniformBit,
              textureBit,
              roundPixelsBit
            ]
          });
          this._shader = new Shader({
            gpuProgram: gpuProgram2,
            resources: {
              uTexture: Texture.EMPTY._source,
              uSampler: Texture.EMPTY._source.style,
              textureUniforms: {
                uTextureMatrix: { type: "mat3x3<f32>", value: new Matrix() }
              }
            }
          });
        }
        execute(meshPipe, mesh) {
          const renderer = meshPipe.renderer;
          let shader = mesh._shader;
          if (!shader) {
            shader = this._shader;
            shader.resources.uTexture = mesh.texture.source;
            shader.resources.uSampler = mesh.texture.source.style;
            shader.resources.textureUniforms.uniforms.uTextureMatrix = mesh.texture.textureMatrix.mapCoord;
          } else if (!shader.gpuProgram) {
            warn("Mesh shader has no gpuProgram", mesh.shader);
            return;
          }
          const gpuProgram2 = shader.gpuProgram;
          if (gpuProgram2.autoAssignGlobalUniforms) {
            shader.groups[0] = renderer.globalUniforms.bindGroup;
          }
          if (gpuProgram2.autoAssignLocalUniforms) {
            const localUniforms = meshPipe.localUniforms;
            shader.groups[1] = renderer.renderPipes.uniformBatch.getUniformBindGroup(localUniforms, true);
          }
          renderer.encoder.draw({
            geometry: mesh._geometry,
            shader,
            state: mesh.state
          });
        }
        destroy() {
          this._shader.destroy(true);
          this._shader = null;
        }
      };
      GpuMeshAdapter.extension = {
        type: [
          ExtensionType.WebGPUPipesAdaptor
        ],
        name: "mesh"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/batcher/gpu/GpuBatchAdaptor.mjs
  var tempState, GpuBatchAdaptor;
  var init_GpuBatchAdaptor = __esm({
    "../core/node_modules/pixi.js/lib/rendering/batcher/gpu/GpuBatchAdaptor.mjs"() {
      init_Extensions();
      init_compileHighShaderToProgram();
      init_colorBit();
      init_generateTextureBatchBit();
      init_roundPixelsBit();
      init_Shader();
      init_State();
      init_const4();
      init_getTextureBatchBindGroup();
      tempState = State.for2d();
      GpuBatchAdaptor = class {
        init() {
          const gpuProgram2 = compileHighShaderGpuProgram({
            name: "batch",
            bits: [
              colorBit,
              generateTextureBatchBit(MAX_TEXTURES),
              roundPixelsBit
            ]
          });
          this._shader = new Shader({
            gpuProgram: gpuProgram2,
            groups: {
              // these will be dynamically allocated
            }
          });
        }
        start(batchPipe, geometry) {
          const renderer = batchPipe.renderer;
          const encoder = renderer.encoder;
          const program = this._shader.gpuProgram;
          this._geometry = geometry;
          encoder.setGeometry(geometry);
          tempState.blendMode = "normal";
          renderer.pipeline.getPipeline(
            geometry,
            program,
            tempState
          );
          const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;
          encoder.resetBindGroup(1);
          encoder.setBindGroup(0, globalUniformsBindGroup, program);
        }
        execute(batchPipe, batch) {
          const program = this._shader.gpuProgram;
          const renderer = batchPipe.renderer;
          const encoder = renderer.encoder;
          if (!batch.bindGroup) {
            const textureBatch = batch.textures;
            batch.bindGroup = getTextureBatchBindGroup(textureBatch.textures, textureBatch.count);
          }
          tempState.blendMode = batch.blendMode;
          const gpuBindGroup = renderer.bindGroup.getBindGroup(
            batch.bindGroup,
            program,
            1
          );
          const pipeline = renderer.pipeline.getPipeline(
            this._geometry,
            program,
            tempState
          );
          batch.bindGroup._touch(renderer.textureGC.count);
          encoder.setPipeline(pipeline);
          encoder.renderPassEncoder.setBindGroup(1, gpuBindGroup);
          encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);
        }
        destroy() {
          this._shader.destroy(true);
          this._shader = null;
        }
      };
      GpuBatchAdaptor.extension = {
        type: [
          ExtensionType.WebGPUPipesAdaptor
        ],
        name: "batch"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/container/CustomRenderPipe.mjs
  var CustomRenderPipe;
  var init_CustomRenderPipe = __esm({
    "../core/node_modules/pixi.js/lib/scene/container/CustomRenderPipe.mjs"() {
      init_Extensions();
      CustomRenderPipe = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        addRenderable(container, instructionSet) {
          this._renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add(container);
        }
        execute(container) {
          if (!container.isRenderable)
            return;
          container.render(this._renderer);
        }
        destroy() {
          this._renderer = null;
        }
      };
      CustomRenderPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "customRender"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/container/utils/executeInstructions.mjs
  function executeInstructions(renderGroup, renderer) {
    const instructionSet = renderGroup.instructionSet;
    const instructions = instructionSet.instructions;
    for (let i2 = 0; i2 < instructionSet.instructionSize; i2++) {
      const instruction = instructions[i2];
      renderer[instruction.renderPipeId].execute(instruction);
    }
  }
  var init_executeInstructions = __esm({
    "../core/node_modules/pixi.js/lib/scene/container/utils/executeInstructions.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/container/RenderGroupPipe.mjs
  var RenderGroupPipe;
  var init_RenderGroupPipe = __esm({
    "../core/node_modules/pixi.js/lib/scene/container/RenderGroupPipe.mjs"() {
      init_Extensions();
      init_executeInstructions();
      RenderGroupPipe = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        addRenderGroup(renderGroup, instructionSet) {
          this._renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add(renderGroup);
        }
        execute(renderGroup) {
          if (!renderGroup.isRenderable)
            return;
          this._renderer.globalUniforms.push({
            worldTransformMatrix: renderGroup.worldTransform,
            worldColor: renderGroup.worldColorAlpha
          });
          executeInstructions(renderGroup, this._renderer.renderPipes);
          this._renderer.globalUniforms.pop();
        }
        destroy() {
          this._renderer = null;
        }
      };
      RenderGroupPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "renderGroup"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/container/utils/buildInstructions.mjs
  function buildInstructions(renderGroup, renderPipes3) {
    const root = renderGroup.root;
    const instructionSet = renderGroup.instructionSet;
    instructionSet.reset();
    renderPipes3.batch.buildStart(instructionSet);
    renderPipes3.blendMode.buildStart();
    renderPipes3.colorMask.buildStart();
    if (root.sortableChildren) {
      root.sortChildren();
    }
    collectAllRenderablesAdvanced(root, instructionSet, renderPipes3, true);
    renderPipes3.batch.buildEnd(instructionSet);
    renderPipes3.blendMode.buildEnd(instructionSet);
  }
  function collectAllRenderables(container, instructionSet, rendererPipes) {
    if (container.globalDisplayStatus < 7 || !container.includeInBuild)
      return;
    if (container.sortableChildren) {
      container.sortChildren();
    }
    if (container.isSimple) {
      collectAllRenderablesSimple(container, instructionSet, rendererPipes);
    } else {
      collectAllRenderablesAdvanced(container, instructionSet, rendererPipes, false);
    }
  }
  function collectAllRenderablesSimple(container, instructionSet, renderPipes3) {
    if (container.renderPipeId) {
      renderPipes3.blendMode.setBlendMode(container, container.groupBlendMode, instructionSet);
      container.didViewUpdate = false;
      const rp = renderPipes3;
      rp[container.renderPipeId].addRenderable(container, instructionSet);
    }
    if (!container.renderGroup) {
      const children2 = container.children;
      const length = children2.length;
      for (let i2 = 0; i2 < length; i2++) {
        collectAllRenderables(children2[i2], instructionSet, renderPipes3);
      }
    }
  }
  function collectAllRenderablesAdvanced(container, instructionSet, renderPipes3, isRoot) {
    if (!isRoot && container.renderGroup) {
      renderPipes3.renderGroup.addRenderGroup(container.renderGroup, instructionSet);
    } else {
      for (let i2 = 0; i2 < container.effects.length; i2++) {
        const effect = container.effects[i2];
        const pipe = renderPipes3[effect.pipe];
        pipe.push(effect, container, instructionSet);
      }
      const renderPipeId = container.renderPipeId;
      if (renderPipeId) {
        renderPipes3.blendMode.setBlendMode(container, container.groupBlendMode, instructionSet);
        container.didViewUpdate = false;
        const pipe = renderPipes3[renderPipeId];
        pipe.addRenderable(container, instructionSet);
      }
      const children2 = container.children;
      if (children2.length) {
        for (let i2 = 0; i2 < children2.length; i2++) {
          collectAllRenderables(children2[i2], instructionSet, renderPipes3);
        }
      }
      for (let i2 = container.effects.length - 1; i2 >= 0; i2--) {
        const effect = container.effects[i2];
        const pipe = renderPipes3[effect.pipe];
        pipe.pop(effect, container, instructionSet);
      }
    }
  }
  var init_buildInstructions = __esm({
    "../core/node_modules/pixi.js/lib/scene/container/utils/buildInstructions.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/container/utils/collectRenderGroups.mjs
  function collectRenderGroups(renderGroup, out2 = []) {
    out2.push(renderGroup);
    for (let i2 = 0; i2 < renderGroup.renderGroupChildren.length; i2++) {
      collectRenderGroups(renderGroup.renderGroupChildren[i2], out2);
    }
    return out2;
  }
  var init_collectRenderGroups = __esm({
    "../core/node_modules/pixi.js/lib/scene/container/utils/collectRenderGroups.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/container/utils/mixHexColors.mjs
  function mixHexColors(color1, color22, ratio) {
    const r1 = color1 >> 16 & 255;
    const g1 = color1 >> 8 & 255;
    const b1 = color1 & 255;
    const r2 = color22 >> 16 & 255;
    const g2 = color22 >> 8 & 255;
    const b2 = color22 & 255;
    const r3 = r1 + (r2 - r1) * ratio;
    const g3 = g1 + (g2 - g1) * ratio;
    const b3 = b1 + (b2 - b1) * ratio;
    return (r3 << 16) + (g3 << 8) + b3;
  }
  var init_mixHexColors = __esm({
    "../core/node_modules/pixi.js/lib/scene/container/utils/mixHexColors.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/container/utils/mixColors.mjs
  function mixColors(localBGRColor, parentBGRColor) {
    if (localBGRColor === WHITE_BGR || parentBGRColor === WHITE_BGR) {
      return localBGRColor + parentBGRColor - WHITE_BGR;
    }
    return mixHexColors(localBGRColor, parentBGRColor, 0.5);
  }
  var WHITE_BGR;
  var init_mixColors = __esm({
    "../core/node_modules/pixi.js/lib/scene/container/utils/mixColors.mjs"() {
      init_mixHexColors();
      WHITE_BGR = 16777215;
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/container/utils/updateRenderGroupTransforms.mjs
  function updateRenderGroupTransforms(renderGroup, updateChildRenderGroups = false) {
    updateRenderGroupTransform(renderGroup);
    const childrenToUpdate = renderGroup.childrenToUpdate;
    const updateTick = renderGroup.updateTick++;
    for (const j2 in childrenToUpdate) {
      const childrenAtDepth = childrenToUpdate[j2];
      const list = childrenAtDepth.list;
      const index = childrenAtDepth.index;
      for (let i2 = 0; i2 < index; i2++) {
        const child = list[i2];
        if (child.parentRenderGroup === renderGroup) {
          updateTransformAndChildren(child, updateTick, 0);
        }
      }
      childrenAtDepth.index = 0;
    }
    if (updateChildRenderGroups) {
      for (let i2 = 0; i2 < renderGroup.renderGroupChildren.length; i2++) {
        updateRenderGroupTransforms(renderGroup.renderGroupChildren[i2], updateChildRenderGroups);
      }
    }
  }
  function updateRenderGroupTransform(renderGroup) {
    const root = renderGroup.root;
    let worldAlpha;
    if (renderGroup.renderGroupParent) {
      const renderGroupParent = renderGroup.renderGroupParent;
      renderGroup.worldTransform.appendFrom(
        root.relativeGroupTransform,
        renderGroupParent.worldTransform
      );
      renderGroup.worldColor = mixColors(
        root.groupColor,
        renderGroupParent.worldColor
      );
      worldAlpha = root.groupAlpha * renderGroupParent.worldAlpha;
    } else {
      renderGroup.worldTransform.copyFrom(root.localTransform);
      renderGroup.worldColor = root.localColor;
      worldAlpha = root.localAlpha;
    }
    worldAlpha = worldAlpha < 0 ? 0 : worldAlpha > 1 ? 1 : worldAlpha;
    renderGroup.worldAlpha = worldAlpha;
    renderGroup.worldColorAlpha = renderGroup.worldColor + ((worldAlpha * 255 | 0) << 24);
  }
  function updateTransformAndChildren(container, updateTick, updateFlags) {
    if (updateTick === container.updateTick)
      return;
    container.updateTick = updateTick;
    container.didChange = false;
    const localTransform = container.localTransform;
    container.updateLocalTransform();
    const parent = container.parent;
    if (parent && !parent.renderGroup) {
      updateFlags = updateFlags | container._updateFlags;
      container.relativeGroupTransform.appendFrom(
        localTransform,
        parent.relativeGroupTransform
      );
      if (updateFlags) {
        updateColorBlendVisibility(container, parent, updateFlags);
      }
    } else {
      updateFlags = container._updateFlags;
      container.relativeGroupTransform.copyFrom(localTransform);
      if (updateFlags) {
        updateColorBlendVisibility(container, tempContainer, updateFlags);
      }
    }
    if (!container.renderGroup) {
      const children2 = container.children;
      const length = children2.length;
      for (let i2 = 0; i2 < length; i2++) {
        updateTransformAndChildren(children2[i2], updateTick, updateFlags);
      }
      const renderGroup = container.parentRenderGroup;
      if (container.renderPipeId && !renderGroup.structureDidChange) {
        renderGroup.updateRenderable(container);
      }
    }
  }
  function updateColorBlendVisibility(container, parent, updateFlags) {
    if (updateFlags & UPDATE_COLOR) {
      container.groupColor = mixColors(
        container.localColor,
        parent.groupColor
      );
      let groupAlpha = container.localAlpha * parent.groupAlpha;
      groupAlpha = groupAlpha < 0 ? 0 : groupAlpha > 1 ? 1 : groupAlpha;
      container.groupAlpha = groupAlpha;
      container.groupColorAlpha = container.groupColor + ((groupAlpha * 255 | 0) << 24);
    }
    if (updateFlags & UPDATE_BLEND) {
      container.groupBlendMode = container.localBlendMode === "inherit" ? parent.groupBlendMode : container.localBlendMode;
    }
    if (updateFlags & UPDATE_VISIBLE) {
      container.globalDisplayStatus = container.localDisplayStatus & parent.globalDisplayStatus;
    }
    container._updateFlags = 0;
  }
  var tempContainer;
  var init_updateRenderGroupTransforms = __esm({
    "../core/node_modules/pixi.js/lib/scene/container/utils/updateRenderGroupTransforms.mjs"() {
      init_Container();
      init_mixColors();
      tempContainer = new Container();
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/container/utils/validateRenderables.mjs
  function validateRenderables(renderGroup, renderPipes3) {
    const { list, index } = renderGroup.childrenRenderablesToUpdate;
    let rebuildRequired = false;
    for (let i2 = 0; i2 < index; i2++) {
      const container = list[i2];
      const renderable = container;
      const pipe = renderPipes3[renderable.renderPipeId];
      rebuildRequired = pipe.validateRenderable(container);
      if (rebuildRequired) {
        break;
      }
    }
    renderGroup.structureDidChange = rebuildRequired;
    return rebuildRequired;
  }
  var init_validateRenderables = __esm({
    "../core/node_modules/pixi.js/lib/scene/container/utils/validateRenderables.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/container/RenderGroupSystem.mjs
  function updateRenderables(renderGroup) {
    const { list, index } = renderGroup.childrenRenderablesToUpdate;
    for (let i2 = 0; i2 < index; i2++) {
      const container = list[i2];
      if (container.didViewUpdate) {
        renderGroup.updateRenderable(container);
      }
    }
  }
  var tempMatrix5, RenderGroupSystem;
  var init_RenderGroupSystem = __esm({
    "../core/node_modules/pixi.js/lib/scene/container/RenderGroupSystem.mjs"() {
      init_Extensions();
      init_Matrix();
      init_buildInstructions();
      init_collectRenderGroups();
      init_executeInstructions();
      init_updateRenderGroupTransforms();
      init_validateRenderables();
      tempMatrix5 = new Matrix();
      RenderGroupSystem = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        render({ container, transform: transform2 }) {
          container.isRenderGroup = true;
          const parent = container.parent;
          const renderGroupParent = container.renderGroup.renderGroupParent;
          container.parent = null;
          container.renderGroup.renderGroupParent = null;
          const renderer = this._renderer;
          const renderGroups = collectRenderGroups(container.renderGroup, []);
          let originalLocalTransform = tempMatrix5;
          if (transform2) {
            originalLocalTransform = originalLocalTransform.copyFrom(container.renderGroup.localTransform);
            container.renderGroup.localTransform.copyFrom(transform2);
          }
          const renderPipes3 = renderer.renderPipes;
          for (let i2 = 0; i2 < renderGroups.length; i2++) {
            const renderGroup = renderGroups[i2];
            renderGroup.runOnRender();
            renderGroup.instructionSet.renderPipes = renderPipes3;
            if (!renderGroup.structureDidChange) {
              validateRenderables(renderGroup, renderPipes3);
            }
            updateRenderGroupTransforms(renderGroup);
            if (renderGroup.structureDidChange) {
              renderGroup.structureDidChange = false;
              buildInstructions(renderGroup, renderPipes3);
            } else {
              updateRenderables(renderGroup);
            }
            renderGroup.childrenRenderablesToUpdate.index = 0;
            renderer.renderPipes.batch.upload(renderGroup.instructionSet);
          }
          renderer.globalUniforms.start({
            worldTransformMatrix: transform2 ? container.renderGroup.localTransform : container.renderGroup.worldTransform,
            worldColor: container.renderGroup.worldColorAlpha
          });
          executeInstructions(container.renderGroup, renderPipes3);
          if (renderPipes3.uniformBatch) {
            renderPipes3.uniformBatch.renderEnd();
          }
          if (transform2) {
            container.renderGroup.localTransform.copyFrom(originalLocalTransform);
          }
          container.parent = parent;
          container.renderGroup.renderGroupParent = renderGroupParent;
        }
        destroy() {
          this._renderer = null;
        }
      };
      RenderGroupSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "renderGroup"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/sprite/SpritePipe.mjs
  var SpritePipe;
  var init_SpritePipe = __esm({
    "../core/node_modules/pixi.js/lib/scene/sprite/SpritePipe.mjs"() {
      init_Extensions();
      init_PoolGroup();
      init_BatchableSprite();
      SpritePipe = class {
        constructor(renderer) {
          this._gpuSpriteHash = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
        }
        addRenderable(sprite, _instructionSet) {
          const gpuSprite = this._getGpuSprite(sprite);
          if (sprite._didSpriteUpdate)
            this._updateBatchableSprite(sprite, gpuSprite);
          this._renderer.renderPipes.batch.addToBatch(gpuSprite);
        }
        updateRenderable(sprite) {
          const gpuSprite = this._gpuSpriteHash[sprite.uid];
          if (sprite._didSpriteUpdate)
            this._updateBatchableSprite(sprite, gpuSprite);
          gpuSprite.batcher.updateElement(gpuSprite);
        }
        validateRenderable(sprite) {
          const texture = sprite._texture;
          const gpuSprite = this._getGpuSprite(sprite);
          if (gpuSprite.texture._source !== texture._source) {
            return !gpuSprite.batcher.checkAndUpdateTexture(gpuSprite, texture);
          }
          return false;
        }
        destroyRenderable(sprite) {
          const batchableSprite = this._gpuSpriteHash[sprite.uid];
          BigPool.return(batchableSprite);
          this._gpuSpriteHash[sprite.uid] = null;
        }
        _updateBatchableSprite(sprite, batchableSprite) {
          sprite._didSpriteUpdate = false;
          batchableSprite.bounds = sprite.bounds;
          batchableSprite.texture = sprite._texture;
        }
        _getGpuSprite(sprite) {
          return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);
        }
        _initGPUSprite(sprite) {
          const batchableSprite = BigPool.get(BatchableSprite);
          batchableSprite.renderable = sprite;
          batchableSprite.texture = sprite._texture;
          batchableSprite.bounds = sprite.bounds;
          batchableSprite.roundPixels = this._renderer._roundPixels | sprite._roundPixels;
          this._gpuSpriteHash[sprite.uid] = batchableSprite;
          sprite._didSpriteUpdate = false;
          sprite.on("destroyed", () => {
            this.destroyRenderable(sprite);
          });
          return batchableSprite;
        }
        destroy() {
          for (const i2 in this._gpuSpriteHash) {
            BigPool.return(this._gpuSpriteHash[i2]);
          }
          this._gpuSpriteHash = null;
          this._renderer = null;
        }
      };
      SpritePipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "sprite"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.mjs
  var BatcherPipe;
  var init_BatcherPipe = __esm({
    "../core/node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.mjs"() {
      init_Extensions();
      init_State();
      init_BatchGeometry();
      init_Batcher();
      BatcherPipe = class {
        constructor(renderer, adaptor) {
          this.state = State.for2d();
          this._batches = /* @__PURE__ */ Object.create(null);
          this._geometries = /* @__PURE__ */ Object.create(null);
          this.renderer = renderer;
          this._adaptor = adaptor;
          this._adaptor.init(this);
        }
        buildStart(instructionSet) {
          if (!this._batches[instructionSet.uid]) {
            const batcher = new Batcher();
            this._batches[instructionSet.uid] = batcher;
            this._geometries[batcher.uid] = new BatchGeometry();
          }
          this._activeBatch = this._batches[instructionSet.uid];
          this._activeGeometry = this._geometries[this._activeBatch.uid];
          this._activeBatch.begin();
        }
        addToBatch(batchableObject) {
          this._activeBatch.add(batchableObject);
        }
        break(instructionSet) {
          this._activeBatch.break(instructionSet);
        }
        buildEnd(instructionSet) {
          const activeBatch = this._activeBatch;
          const geometry = this._activeGeometry;
          activeBatch.finish(instructionSet);
          geometry.indexBuffer.setDataWithSize(activeBatch.indexBuffer, activeBatch.indexSize, true);
          geometry.buffers[0].setDataWithSize(activeBatch.attributeBuffer.float32View, activeBatch.attributeSize, false);
        }
        upload(instructionSet) {
          const batcher = this._batches[instructionSet.uid];
          const geometry = this._geometries[batcher.uid];
          if (batcher.dirty) {
            batcher.dirty = false;
            geometry.buffers[0].update(batcher.attributeSize * 4);
          }
        }
        execute(batch) {
          if (batch.action === "startBatch") {
            const batcher = batch.batcher;
            const geometry = this._geometries[batcher.uid];
            this._adaptor.start(this, geometry);
          }
          this._adaptor.execute(this, batch);
        }
        destroy() {
          this.state = null;
          this.renderer = null;
          this._adaptor.destroy();
          this._adaptor = null;
          for (const i2 in this._batches) {
            this._batches[i2].destroy();
          }
          this._batches = null;
          for (const i2 in this._geometries) {
            this._geometries[i2].destroy();
          }
          this._geometries = null;
        }
      };
      BatcherPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "batch"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/filters/mask/mask.frag.mjs
  var fragment;
  var init_mask_frag = __esm({
    "../core/node_modules/pixi.js/lib/filters/mask/mask.frag.mjs"() {
      fragment = "in vec2 vMaskCoord;\nin vec2 vTextureCoord;\n\nuniform sampler2D uTexture;\nuniform sampler2D uMaskTexture;\n\nuniform float uAlpha;\nuniform vec4 uMaskClamp;\n\nout vec4 finalColor;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(uMaskClamp.x, vMaskCoord.x) +\n        step(uMaskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, uMaskClamp.z) +\n        step(vMaskCoord.y, uMaskClamp.w));\n\n    // TODO look into why this is needed\n    float npmAlpha = uAlpha; \n    vec4 original = texture(uTexture, vTextureCoord);\n    vec4 masky = texture(uMaskTexture, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * uAlpha * clip);\n\n    finalColor = original;\n}\n";
    }
  });

  // ../core/node_modules/pixi.js/lib/filters/mask/mask.vert.mjs
  var vertex;
  var init_mask_vert = __esm({
    "../core/node_modules/pixi.js/lib/filters/mask/mask.vert.mjs"() {
      vertex = "in vec2 aPosition;\n\nout vec2 vTextureCoord;\nout vec2 vMaskCoord;\n\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\nuniform mat3 uFilterMatrix;\n\nvec4 filterVertexPosition(  vec2 aPosition )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n       \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord(  vec2 aPosition )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvec2 getFilterCoord( vec2 aPosition )\n{\n    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}   \n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition(aPosition);\n    vTextureCoord = filterTextureCoord(aPosition);\n    vMaskCoord = getFilterCoord(aPosition);\n}\n";
    }
  });

  // ../core/node_modules/pixi.js/lib/filters/mask/mask.wgsl.mjs
  var source;
  var init_mask_wgsl = __esm({
    "../core/node_modules/pixi.js/lib/filters/mask/mask.wgsl.mjs"() {
      source = "struct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,  \n};\n\nstruct MaskUniforms {\n  uFilterMatrix:mat3x3<f32>,\n  uMaskClamp:vec4<f32>,\n  uAlpha:f32,\n};\n\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;\n@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) filterUv : vec2<f32>,\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}\n\nfn getSize() -> vec2<f32>\n{\n\n  \n  return gfu.uGlobalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n   getFilterCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) filterUv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n\n    var maskClamp = filterUniforms.uMaskClamp;\n\n     var clip = step(3.5,\n        step(maskClamp.x, filterUv.x) +\n        step(maskClamp.y, filterUv.y) +\n        step(filterUv.x, maskClamp.z) +\n        step(filterUv.y, maskClamp.w));\n\n    var mask = textureSample(uMaskTexture, uSampler, filterUv);\n    var source = textureSample(uTexture, uSampler, uv);\n    \n    var npmAlpha = 0.0;\n\n    var alphaMul = 1.0 - npmAlpha * (1.0 - mask.a);\n\n    var a = (alphaMul * mask.r) * clip;\n\n    return vec4(source.rgb, source.a) * a;\n}";
    }
  });

  // ../core/node_modules/pixi.js/lib/filters/mask/MaskFilter.mjs
  var MaskFilter;
  var init_MaskFilter = __esm({
    "../core/node_modules/pixi.js/lib/filters/mask/MaskFilter.mjs"() {
      init_Matrix();
      init_GlProgram();
      init_GpuProgram();
      init_UniformGroup();
      init_TextureMatrix();
      init_Filter();
      init_mask_frag();
      init_mask_vert();
      init_mask_wgsl();
      MaskFilter = class extends Filter {
        constructor(options) {
          const { sprite, ...rest } = options;
          const textureMatrix = new TextureMatrix(sprite.texture);
          const filterUniforms = new UniformGroup({
            uFilterMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
            uMaskClamp: { value: textureMatrix.uClampFrame, type: "vec4<f32>" },
            uAlpha: { value: 1, type: "f32" }
          });
          const gpuProgram2 = GpuProgram.from({
            vertex: {
              source,
              entryPoint: "mainVertex"
            },
            fragment: {
              source,
              entryPoint: "mainFragment"
            }
          });
          const glProgram2 = GlProgram.from({
            vertex,
            fragment,
            name: "mask-filter"
          });
          super({
            ...rest,
            gpuProgram: gpuProgram2,
            glProgram: glProgram2,
            resources: {
              filterUniforms,
              uMaskTexture: sprite.texture.source
            }
          });
          this.sprite = sprite;
          this._textureMatrix = textureMatrix;
        }
        apply(filterManager, input, output, clearMode) {
          this._textureMatrix.texture = this.sprite.texture;
          filterManager.calculateSpriteMatrix(
            this.resources.filterUniforms.uniforms.uFilterMatrix,
            this.sprite
          ).prepend(this._textureMatrix.mapCoord);
          this.resources.uMaskTexture = this.sprite.texture.source;
          filterManager.applyFilter(this, input, output, clearMode);
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMaskPipe.mjs
  var tempBounds3, AlphaMaskEffect, AlphaMaskPipe;
  var init_AlphaMaskPipe = __esm({
    "../core/node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMaskPipe.mjs"() {
      init_Extensions();
      init_FilterEffect();
      init_MaskFilter();
      init_Bounds();
      init_getGlobalBounds();
      init_buildInstructions();
      init_Sprite();
      init_PoolGroup();
      init_Texture();
      init_TexturePool();
      tempBounds3 = new Bounds();
      AlphaMaskEffect = class extends FilterEffect {
        constructor() {
          super();
          this.filters = [new MaskFilter({
            sprite: new Sprite(Texture.EMPTY)
          })];
        }
        get sprite() {
          return this.filters[0].sprite;
        }
        set sprite(value) {
          this.filters[0].sprite = value;
        }
      };
      AlphaMaskPipe = class {
        constructor(renderer) {
          this._activeMaskStage = [];
          this._renderer = renderer;
        }
        push(mask, maskedContainer, instructionSet) {
          const renderer = this._renderer;
          renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add({
            renderPipeId: "alphaMask",
            action: "pushMaskBegin",
            mask,
            canBundle: false,
            maskedContainer
          });
          if (mask.renderMaskToTexture) {
            const maskContainer = mask.mask;
            maskContainer.includeInBuild = true;
            collectAllRenderables(
              maskContainer,
              instructionSet,
              renderer.renderPipes
            );
            maskContainer.includeInBuild = false;
          }
          renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add({
            renderPipeId: "alphaMask",
            action: "pushMaskEnd",
            mask,
            maskedContainer,
            canBundle: false
          });
        }
        pop(mask, _maskedContainer, instructionSet) {
          const renderer = this._renderer;
          renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add({
            renderPipeId: "alphaMask",
            action: "popMaskEnd",
            mask,
            canBundle: false
          });
        }
        execute(instruction) {
          const renderer = this._renderer;
          const renderMask = instruction.mask.renderMaskToTexture;
          if (instruction.action === "pushMaskBegin") {
            const filterEffect = BigPool.get(AlphaMaskEffect);
            if (renderMask) {
              instruction.mask.mask.measurable = true;
              const bounds = getGlobalBounds(instruction.mask.mask, true, tempBounds3);
              instruction.mask.mask.measurable = false;
              bounds.ceil();
              const filterTexture = TexturePool.getOptimalTexture(
                bounds.width,
                bounds.height,
                1,
                false
              );
              renderer.renderTarget.push(filterTexture, true);
              renderer.globalUniforms.push({
                offset: bounds,
                worldColor: 4294967295
              });
              const sprite = filterEffect.sprite;
              sprite.texture = filterTexture;
              sprite.worldTransform.tx = bounds.minX;
              sprite.worldTransform.ty = bounds.minY;
              this._activeMaskStage.push({
                filterEffect,
                maskedContainer: instruction.maskedContainer,
                filterTexture
              });
            } else {
              filterEffect.sprite = instruction.mask.mask;
              this._activeMaskStage.push({
                filterEffect,
                maskedContainer: instruction.maskedContainer
              });
            }
          } else if (instruction.action === "pushMaskEnd") {
            const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];
            if (renderMask) {
              renderer.renderTarget.pop();
              renderer.globalUniforms.pop();
            }
            renderer.filter.push({
              renderPipeId: "filter",
              action: "pushFilter",
              container: maskData.maskedContainer,
              filterEffect: maskData.filterEffect,
              canBundle: false
            });
          } else if (instruction.action === "popMaskEnd") {
            renderer.filter.pop();
            const maskData = this._activeMaskStage.pop();
            if (renderMask) {
              TexturePool.returnTexture(maskData.filterTexture);
            }
            BigPool.return(maskData.filterEffect);
          }
        }
        destroy() {
          this._renderer = null;
          this._activeMaskStage = null;
        }
      };
      AlphaMaskPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "alphaMask"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/mask/color/ColorMaskPipe.mjs
  var ColorMaskPipe;
  var init_ColorMaskPipe = __esm({
    "../core/node_modules/pixi.js/lib/rendering/mask/color/ColorMaskPipe.mjs"() {
      init_Extensions();
      ColorMaskPipe = class {
        constructor(renderer) {
          this._colorStack = [];
          this._colorStackIndex = 0;
          this._currentColor = 0;
          this._renderer = renderer;
        }
        buildStart() {
          this._colorStack[0] = 15;
          this._colorStackIndex = 1;
          this._currentColor = 15;
        }
        push(mask, _container, instructionSet) {
          const renderer = this._renderer;
          renderer.renderPipes.batch.break(instructionSet);
          const colorStack = this._colorStack;
          colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & mask.mask;
          const currentColor = this._colorStack[this._colorStackIndex];
          if (currentColor !== this._currentColor) {
            this._currentColor = currentColor;
            instructionSet.add({
              renderPipeId: "colorMask",
              colorMask: currentColor,
              canBundle: false
            });
          }
          this._colorStackIndex++;
        }
        pop(_mask, _container, instructionSet) {
          const renderer = this._renderer;
          renderer.renderPipes.batch.break(instructionSet);
          const colorStack = this._colorStack;
          this._colorStackIndex--;
          const currentColor = colorStack[this._colorStackIndex - 1];
          if (currentColor !== this._currentColor) {
            this._currentColor = currentColor;
            instructionSet.add({
              renderPipeId: "colorMask",
              colorMask: currentColor,
              canBundle: false
            });
          }
        }
        execute(instruction) {
          const renderer = this._renderer;
          renderer.colorMask.setMask(instruction.colorMask);
        }
        destroy() {
          this._colorStack = null;
        }
      };
      ColorMaskPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "colorMask"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/mask/stencil/StencilMaskPipe.mjs
  var StencilMaskPipe;
  var init_StencilMaskPipe = __esm({
    "../core/node_modules/pixi.js/lib/rendering/mask/stencil/StencilMaskPipe.mjs"() {
      init_Extensions();
      init_buildInstructions();
      init_const8();
      init_const5();
      StencilMaskPipe = class {
        constructor(renderer) {
          this._maskStackHash = {};
          this._maskHash = /* @__PURE__ */ new WeakMap();
          this._renderer = renderer;
        }
        push(mask, _container, instructionSet) {
          var _a;
          const effect = mask;
          const renderer = this._renderer;
          renderer.renderPipes.batch.break(instructionSet);
          renderer.renderPipes.blendMode.setBlendMode(effect.mask, "none", instructionSet);
          instructionSet.add({
            renderPipeId: "stencilMask",
            action: "pushMaskBegin",
            mask,
            canBundle: false
          });
          const maskContainer = effect.mask;
          maskContainer.includeInBuild = true;
          if (!this._maskHash.has(effect)) {
            this._maskHash.set(effect, {
              instructionsStart: 0,
              instructionsLength: 0
            });
          }
          const maskData = this._maskHash.get(effect);
          maskData.instructionsStart = instructionSet.instructionSize;
          collectAllRenderables(
            maskContainer,
            instructionSet,
            renderer.renderPipes
          );
          maskContainer.includeInBuild = false;
          renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add({
            renderPipeId: "stencilMask",
            action: "pushMaskEnd",
            mask,
            canBundle: false
          });
          const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;
          maskData.instructionsLength = instructionsLength;
          const renderTargetUid = renderer.renderTarget.renderTarget.uid;
          (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);
        }
        pop(mask, _container, instructionSet) {
          const effect = mask;
          const renderer = this._renderer;
          renderer.renderPipes.batch.break(instructionSet);
          renderer.renderPipes.blendMode.setBlendMode(effect.mask, "none", instructionSet);
          instructionSet.add({
            renderPipeId: "stencilMask",
            action: "popMaskBegin",
            canBundle: false
          });
          const maskData = this._maskHash.get(mask);
          for (let i2 = 0; i2 < maskData.instructionsLength; i2++) {
            instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];
          }
          instructionSet.add({
            renderPipeId: "stencilMask",
            action: "popMaskEnd",
            canBundle: false
          });
        }
        execute(instruction) {
          var _a;
          const renderer = this._renderer;
          const renderTargetUid = renderer.renderTarget.renderTarget.uid;
          let maskStackIndex = (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);
          if (instruction.action === "pushMaskBegin") {
            renderer.renderTarget.ensureDepthStencil();
            renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD, maskStackIndex);
            maskStackIndex++;
            renderer.colorMask.setMask(0);
          } else if (instruction.action === "pushMaskEnd") {
            renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);
            renderer.colorMask.setMask(15);
          } else if (instruction.action === "popMaskBegin") {
            renderer.colorMask.setMask(0);
            if (maskStackIndex !== 0) {
              renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE, maskStackIndex);
            } else {
              renderer.renderTarget.clear(null, CLEAR.STENCIL);
              renderer.stencil.setStencilMode(STENCIL_MODES.DISABLED, maskStackIndex);
            }
            maskStackIndex--;
          } else if (instruction.action === "popMaskEnd") {
            renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);
            renderer.colorMask.setMask(15);
          }
          this._maskStackHash[renderTargetUid] = maskStackIndex;
        }
        destroy() {
          this._renderer = null;
          this._maskStackHash = null;
          this._maskHash = null;
        }
      };
      StencilMaskPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "stencilMask"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.mjs
  var _BackgroundSystem, BackgroundSystem;
  var init_BackgroundSystem = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.mjs"() {
      init_Color();
      init_Extensions();
      _BackgroundSystem = class _BackgroundSystem2 {
        constructor() {
          this.clearBeforeRender = true;
          this._backgroundColor = new Color(0);
          this.color = this._backgroundColor;
          this.alpha = 1;
        }
        /**
         * initiates the background system
         * @param options - the options for the background colors
         */
        init(options) {
          options = { ..._BackgroundSystem2.defaultOptions, ...options };
          this.clearBeforeRender = options.clearBeforeRender;
          this.color = options.background || options.backgroundColor || this._backgroundColor;
          this.alpha = options.backgroundAlpha;
          this._backgroundColor.setAlpha(options.backgroundAlpha);
        }
        /** The background color to fill if not transparent */
        get color() {
          return this._backgroundColor;
        }
        set color(value) {
          this._backgroundColor.setValue(value);
        }
        /** The background color alpha. Setting this to 0 will make the canvas transparent. */
        get alpha() {
          return this._backgroundColor.alpha;
        }
        set alpha(value) {
          this._backgroundColor.setAlpha(value);
        }
        /** The background color as an [R, G, B, A] array. */
        get colorRgba() {
          return this._backgroundColor.toArray();
        }
        /**
         * destroys the background system
         * @internal
         * @ignore
         */
        destroy() {
        }
      };
      _BackgroundSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "background",
        priority: 0
      };
      _BackgroundSystem.defaultOptions = {
        /**
         * {@link WebGLOptions.backgroundAlpha}
         * @default 1
         */
        backgroundAlpha: 1,
        /**
         * {@link WebGLOptions.backgroundColor}
         * @default 0x000000
         */
        backgroundColor: 0,
        /**
         * {@link WebGLOptions.clearBeforeRender}
         * @default true
         */
        clearBeforeRender: true
      };
      BackgroundSystem = _BackgroundSystem;
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/blendModes/BlendModePipe.mjs
  var BLEND_MODE_FILTERS, BlendModePipe;
  var init_BlendModePipe = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/blendModes/BlendModePipe.mjs"() {
      init_Extensions();
      init_FilterEffect();
      init_warn();
      BLEND_MODE_FILTERS = {};
      extensions.handle(ExtensionType.BlendMode, (value) => {
        if (!value.name) {
          throw new Error("BlendMode extension must have a name property");
        }
        BLEND_MODE_FILTERS[value.name] = value.ref;
      }, (value) => {
        delete BLEND_MODE_FILTERS[value.name];
      });
      BlendModePipe = class {
        constructor(renderer) {
          this._isAdvanced = false;
          this._filterHash = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
        }
        /**
         * This ensures that a blendMode switch is added to the instruction set if the blend mode has changed.
         * @param renderable - The renderable we are adding to the instruction set
         * @param blendMode - The blend mode of the renderable
         * @param instructionSet - The instruction set we are adding to
         */
        setBlendMode(renderable, blendMode, instructionSet) {
          if (this._activeBlendMode === blendMode) {
            if (this._isAdvanced)
              this._renderableList.push(renderable);
            return;
          }
          this._activeBlendMode = blendMode;
          if (this._isAdvanced) {
            this._endAdvancedBlendMode(instructionSet);
          }
          this._isAdvanced = !!BLEND_MODE_FILTERS[blendMode];
          if (this._isAdvanced) {
            this._beginAdvancedBlendMode(instructionSet);
            this._renderableList.push(renderable);
          }
        }
        _beginAdvancedBlendMode(instructionSet) {
          this._renderer.renderPipes.batch.break(instructionSet);
          const blendMode = this._activeBlendMode;
          if (!BLEND_MODE_FILTERS[blendMode]) {
            warn(`Unable to assign BlendMode: '${blendMode}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);
            return;
          }
          let filterEffect = this._filterHash[blendMode];
          if (!filterEffect) {
            filterEffect = this._filterHash[blendMode] = new FilterEffect();
            filterEffect.filters = [new BLEND_MODE_FILTERS[blendMode]()];
          }
          const instruction = {
            renderPipeId: "filter",
            action: "pushFilter",
            renderables: [],
            filterEffect,
            canBundle: false
          };
          this._renderableList = instruction.renderables;
          instructionSet.add(instruction);
        }
        _endAdvancedBlendMode(instructionSet) {
          this._renderableList = null;
          this._renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add({
            renderPipeId: "filter",
            action: "popFilter",
            canBundle: false
          });
        }
        /**
         * called when the instruction build process is starting this will reset internally to the default blend mode
         * @internal
         * @ignore
         */
        buildStart() {
          this._isAdvanced = false;
        }
        /**
         * called when the instruction build process is finished, ensuring that if there is an advanced blend mode
         * active, we add the final render instructions added to the instruction set
         * @param instructionSet - The instruction set we are adding to
         * @internal
         * @ignore
         */
        buildEnd(instructionSet) {
          if (this._isAdvanced) {
            this._endAdvancedBlendMode(instructionSet);
          }
        }
        /**
         * @internal
         * @ignore
         */
        destroy() {
          this._renderer = null;
          this._renderableList = null;
          for (const i2 in this._filterHash) {
            this._filterHash[i2].destroy();
          }
          this._filterHash = null;
        }
      };
      BlendModePipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "blendMode"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/extract/ExtractSystem.mjs
  var imageTypes, _ExtractSystem, ExtractSystem;
  var init_ExtractSystem = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/extract/ExtractSystem.mjs"() {
      init_Extensions();
      init_Container();
      init_Texture();
      imageTypes = {
        png: "image/png",
        jpg: "image/jpeg",
        webp: "image/webp"
      };
      _ExtractSystem = class _ExtractSystem2 {
        /** @param renderer - The renderer this System works for. */
        constructor(renderer) {
          this._renderer = renderer;
        }
        _normalizeOptions(options, defaults = {}) {
          if (options instanceof Container || options instanceof Texture) {
            return {
              target: options,
              ...defaults
            };
          }
          return {
            ...defaults,
            ...options
          };
        }
        /**
         * Will return a HTML Image of the target
         * @param options - The options for creating the image, or the target to extract
         * @returns - HTML Image of the target
         */
        async image(options) {
          const image = new Image();
          image.src = await this.base64(options);
          return image;
        }
        /**
         * Will return a base64 encoded string of this target. It works by calling
         * `Extract.canvas` and then running toDataURL on that.
         * @param options - The options for creating the image, or the target to extract
         */
        async base64(options) {
          options = this._normalizeOptions(
            options,
            _ExtractSystem2.defaultImageOptions
          );
          const { format, quality } = options;
          const canvas = this.canvas(options);
          if (canvas.toBlob !== void 0) {
            return new Promise((resolve, reject) => {
              canvas.toBlob((blob) => {
                if (!blob) {
                  reject(new Error("ICanvas.toBlob failed!"));
                  return;
                }
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
              }, imageTypes[format], quality);
            });
          }
          if (canvas.toDataURL !== void 0) {
            return canvas.toDataURL(imageTypes[format], quality);
          }
          if (canvas.convertToBlob !== void 0) {
            const blob = await canvas.convertToBlob({ type: imageTypes[format], quality });
            return new Promise((resolve, reject) => {
              const reader = new FileReader();
              reader.onload = () => resolve(reader.result);
              reader.onerror = reject;
              reader.readAsDataURL(blob);
            });
          }
          throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");
        }
        /**
         * Creates a Canvas element, renders this target to it and then returns it.
         * @param options - The options for creating the canvas, or the target to extract
         * @returns - A Canvas element with the texture rendered on.
         */
        canvas(options) {
          options = this._normalizeOptions(options);
          const target = options.target;
          const renderer = this._renderer;
          if (target instanceof Texture) {
            return renderer.texture.generateCanvas(target);
          }
          const texture = renderer.textureGenerator.generateTexture(options);
          const canvas = renderer.texture.generateCanvas(texture);
          texture.destroy();
          return canvas;
        }
        /**
         * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA
         * order, with integer values between 0 and 255 (included).
         * @param options - The options for extracting the image, or the target to extract
         * @returns - One-dimensional array containing the pixel data of the entire texture
         */
        pixels(options) {
          options = this._normalizeOptions(options);
          const target = options.target;
          const renderer = this._renderer;
          const texture = target instanceof Texture ? target : renderer.textureGenerator.generateTexture(options);
          const pixelInfo = renderer.texture.getPixels(texture);
          if (target instanceof Container) {
            texture.destroy();
          }
          return pixelInfo;
        }
        /**
         * Will return a texture of the target
         * @param options - The options for creating the texture, or the target to extract
         * @returns - A texture of the target
         */
        texture(options) {
          options = this._normalizeOptions(options);
          if (options.target instanceof Texture)
            return options.target;
          return this._renderer.textureGenerator.generateTexture(options);
        }
        /**
         * Will extract a HTMLImage of the target and download it
         * @param options - The options for downloading and extracting the image, or the target to extract
         */
        download(options) {
          options = this._normalizeOptions(options);
          const canvas = this.canvas(options);
          const link = document.createElement("a");
          link.download = options.filename ?? "image.png";
          link.href = canvas.toDataURL("image/png");
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        }
        /**
         * Logs the target to the console as an image. This is a useful way to debug what's happening in the renderer.
         * @param options - The options for logging the image, or the target to log
         */
        log(options) {
          const width = options.width ?? 200;
          options = this._normalizeOptions(options);
          const canvas = this.canvas(options);
          const base64 = canvas.toDataURL();
          console.log(`[Pixi Texture] ${canvas.width}px ${canvas.height}px`);
          const style = [
            "font-size: 1px;",
            `padding: ${width}px ${300}px;`,
            `background: url(${base64}) no-repeat;`,
            "background-size: contain;"
          ].join(" ");
          console.log("%c ", style);
        }
        destroy() {
          this._renderer = null;
        }
      };
      _ExtractSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem
        ],
        name: "extract"
      };
      _ExtractSystem.defaultImageOptions = {
        /** The format of the image. */
        format: "png",
        /** The quality of the image. */
        quality: 1
      };
      ExtractSystem = _ExtractSystem;
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderTexture.mjs
  var RenderTexture;
  var init_RenderTexture = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderTexture.mjs"() {
      init_TextureSource();
      init_Texture();
      RenderTexture = class extends Texture {
        static create(options) {
          return new Texture({
            source: new TextureSource(options)
          });
        }
        /**
         * Resizes the render texture.
         * @param width - The new width of the render texture.
         * @param height - The new height of the render texture.
         * @param resolution - The new resolution of the render texture.
         * @returns This texture.
         */
        resize(width, height, resolution) {
          this.source.resize(width, height, resolution);
          return this;
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/extract/GenerateTextureSystem.mjs
  var tempRect2, tempBounds4, noColor, GenerateTextureSystem;
  var init_GenerateTextureSystem = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/extract/GenerateTextureSystem.mjs"() {
      init_Color();
      init_Extensions();
      init_Matrix();
      init_Rectangle();
      init_Bounds();
      init_getLocalBounds();
      init_Container();
      init_RenderTexture();
      tempRect2 = new Rectangle();
      tempBounds4 = new Bounds();
      noColor = [0, 0, 0, 0];
      GenerateTextureSystem = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        /**
         * A Useful function that returns a texture of the display object that can then be used to create sprites
         * This can be quite useful if your container is complicated and needs to be reused multiple times.
         * @param {GenerateTextureOptions | Container} options - Generate texture options.
         * @param {Container} [options.container] - If not given, the renderer's resolution is used.
         * @param {Rectangle} options.region - The region of the container, that shall be rendered,
         * @param {number} [options.resolution] - The resolution of the texture being generated.
         *        if no region is specified, defaults to the local bounds of the container.
         * @param {GenerateTextureSourceOptions} [options.textureSourceOptions] - Texture options for GPU.
         * @returns a shiny new texture of the container passed in
         */
        generateTexture(options) {
          if (options instanceof Container) {
            options = {
              target: options,
              frame: void 0,
              textureSourceOptions: {},
              resolution: void 0
            };
          }
          const resolution = options.resolution || this._renderer.resolution;
          const antialias = options.antialias || this._renderer.view.antialias;
          const container = options.target;
          let clearColor = options.clearColor;
          if (clearColor) {
            const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;
            clearColor = isRGBAArray ? clearColor : Color.shared.setValue(clearColor).toArray();
          } else {
            clearColor = noColor;
          }
          const region = options.frame?.copyTo(tempRect2) || getLocalBounds(container, tempBounds4).rectangle;
          region.width = Math.max(region.width, 1 / resolution) | 0;
          region.height = Math.max(region.height, 1 / resolution) | 0;
          const target = RenderTexture.create({
            ...options.textureSourceOptions,
            width: region.width,
            height: region.height,
            resolution,
            antialias
          });
          const transform2 = Matrix.shared.translate(-region.x, -region.y);
          this._renderer.render({
            container,
            transform: transform2,
            target,
            clearColor
          });
          return target;
        }
        destroy() {
          this._renderer = null;
        }
      };
      GenerateTextureSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem
        ],
        name: "textureGenerator"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs
  var GlobalUniformSystem;
  var init_GlobalUniformSystem = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs"() {
      init_Extensions();
      init_Matrix();
      init_Point();
      init_colorToUniform();
      init_BindGroup();
      init_types();
      init_UniformGroup();
      GlobalUniformSystem = class {
        constructor(renderer) {
          this._stackIndex = 0;
          this._globalUniformDataStack = [];
          this._uniformsPool = [];
          this._activeUniforms = [];
          this._bindGroupPool = [];
          this._activeBindGroups = [];
          this._renderer = renderer;
        }
        reset() {
          this._stackIndex = 0;
          for (let i2 = 0; i2 < this._activeUniforms.length; i2++) {
            this._uniformsPool.push(this._activeUniforms[i2]);
          }
          for (let i2 = 0; i2 < this._activeBindGroups.length; i2++) {
            this._bindGroupPool.push(this._activeBindGroups[i2]);
          }
          this._activeUniforms.length = 0;
          this._activeBindGroups.length = 0;
        }
        start(options) {
          this.reset();
          this.push(options);
        }
        bind({
          size,
          projectionMatrix,
          worldTransformMatrix,
          worldColor,
          offset
        }) {
          const renderTarget = this._renderer.renderTarget.renderTarget;
          const currentGlobalUniformData = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {
            projectionData: renderTarget,
            worldTransformMatrix: new Matrix(),
            worldColor: 4294967295,
            offset: new Point()
          };
          const globalUniformData = {
            projectionMatrix: projectionMatrix || this._renderer.renderTarget.projectionMatrix,
            resolution: size || renderTarget.size,
            worldTransformMatrix: worldTransformMatrix || currentGlobalUniformData.worldTransformMatrix,
            worldColor: worldColor || currentGlobalUniformData.worldColor,
            offset: offset || currentGlobalUniformData.offset,
            bindGroup: null
          };
          const uniformGroup = this._uniformsPool.pop() || this._createUniforms();
          this._activeUniforms.push(uniformGroup);
          const uniforms = uniformGroup.uniforms;
          uniforms.uProjectionMatrix = globalUniformData.projectionMatrix;
          uniforms.uResolution = globalUniformData.resolution;
          uniforms.uWorldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix);
          uniforms.uWorldTransformMatrix.tx -= globalUniformData.offset.x;
          uniforms.uWorldTransformMatrix.ty -= globalUniformData.offset.y;
          color32BitToUniform(
            globalUniformData.worldColor,
            uniforms.uWorldColorAlpha,
            0
          );
          uniformGroup.update();
          let bindGroup;
          if (this._renderer.renderPipes.uniformBatch) {
            bindGroup = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(uniformGroup, false);
          } else {
            bindGroup = this._bindGroupPool.pop() || new BindGroup();
            this._activeBindGroups.push(bindGroup);
            bindGroup.setResource(uniformGroup, 0);
          }
          globalUniformData.bindGroup = bindGroup;
          this._currentGlobalUniformData = globalUniformData;
        }
        push(options) {
          this.bind(options);
          this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;
        }
        pop() {
          this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1];
          if (this._renderer.type === RendererType.WEBGL) {
            this._currentGlobalUniformData.bindGroup.resources[0].update();
          }
        }
        get bindGroup() {
          return this._currentGlobalUniformData.bindGroup;
        }
        get uniformGroup() {
          return this._currentGlobalUniformData.bindGroup.resources[0];
        }
        _createUniforms() {
          const globalUniforms = new UniformGroup({
            uProjectionMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
            uWorldTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
            // TODO - someone smart - set this to be a unorm8x4 rather than a vec4<f32>
            uWorldColorAlpha: { value: new Float32Array(4), type: "vec4<f32>" },
            uResolution: { value: [0, 0], type: "vec2<f32>" }
          }, {
            isStatic: true
          });
          return globalUniforms;
        }
        destroy() {
          this._renderer = null;
        }
      };
      GlobalUniformSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "globalUniforms"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/utils/sayHello.mjs
  function sayHello(type) {
    if (saidHello) {
      return;
    }
    if (DOMAdapter.get().getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
      const args = [
        `%c  %c  %c  %c  %c PixiJS %c v${VERSION2} (${type}) http://www.pixijs.com/

`,
        "background: #E72264; padding:5px 0;",
        "background: #6CA2EA; padding:5px 0;",
        "background: #B5D33D; padding:5px 0;",
        "background: #FED23F; padding:5px 0;",
        "color: #FFFFFF; background: #E72264; padding:5px 0;",
        "color: #E72264; background: #FFFFFF; padding:5px 0;"
      ];
      globalThis.console.log(...args);
    } else if (globalThis.console) {
      globalThis.console.log(`PixiJS ${VERSION2} - ${type} - http://www.pixijs.com/`);
    }
    saidHello = true;
  }
  var saidHello, VERSION2;
  var init_sayHello = __esm({
    "../core/node_modules/pixi.js/lib/utils/sayHello.mjs"() {
      init_adapter();
      saidHello = false;
      VERSION2 = "8.1.3";
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.mjs
  var HelloSystem;
  var init_HelloSystem = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.mjs"() {
      init_Extensions();
      init_sayHello();
      init_types();
      HelloSystem = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        /**
         * It all starts here! This initiates every system, passing in the options for any system by name.
         * @param options - the config for the renderer and all its systems
         */
        init(options) {
          if (options.hello) {
            let name = this._renderer.name;
            if (this._renderer.type === RendererType.WEBGL) {
              name += ` ${this._renderer.context.webGLVersion}`;
            }
            sayHello(name);
          }
        }
      };
      HelloSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "hello",
        priority: -2
      };
      HelloSystem.defaultOptions = {
        /** {@link WebGLOptions.hello} */
        hello: false
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureGCSystem.mjs
  var _TextureGCSystem, TextureGCSystem;
  var init_TextureGCSystem = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureGCSystem.mjs"() {
      init_Extensions();
      _TextureGCSystem = class _TextureGCSystem2 {
        /** @param renderer - The renderer this System works for. */
        constructor(renderer) {
          this._renderer = renderer;
          this.count = 0;
          this.checkCount = 0;
        }
        init(options) {
          options = { ..._TextureGCSystem2.defaultOptions, ...options };
          this.checkCountMax = options.textureGCCheckCountMax;
          this.maxIdle = options.textureGCAMaxIdle;
          this.active = options.textureGCActive;
        }
        /**
         * Checks to see when the last time a texture was used.
         * If the texture has not been used for a specified amount of time, it will be removed from the GPU.
         */
        postrender() {
          if (!this._renderer.renderingToScreen) {
            return;
          }
          this.count++;
          if (!this.active)
            return;
          this.checkCount++;
          if (this.checkCount > this.checkCountMax) {
            this.checkCount = 0;
            this.run();
          }
        }
        /**
         * Checks to see when the last time a texture was used.
         * If the texture has not been used for a specified amount of time, it will be removed from the GPU.
         */
        run() {
          const managedTextures = this._renderer.texture.managedTextures;
          for (let i2 = 0; i2 < managedTextures.length; i2++) {
            const texture = managedTextures[i2];
            if (texture.autoGarbageCollect && texture.resource && texture._touched > -1 && this.count - texture._touched > this.maxIdle) {
              texture._touched = -1;
              texture.unload();
            }
          }
        }
        destroy() {
          this._renderer = null;
        }
      };
      _TextureGCSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem
        ],
        name: "textureGC"
      };
      _TextureGCSystem.defaultOptions = {
        /**
         * If set to true, this will enable the garbage collector on the GPU.
         * @default true
         */
        textureGCActive: true,
        /**
         * The maximum idle frames before a texture is destroyed by garbage collection.
         * @default 60 * 60
         */
        textureGCAMaxIdle: 60 * 60,
        /**
         * Frames between two garbage collections.
         * @default 600
         */
        textureGCCheckCountMax: 600
      };
      TextureGCSystem = _TextureGCSystem;
      extensions.add(TextureGCSystem);
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs
  var _RenderTarget, RenderTarget;
  var init_RenderTarget = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs"() {
      init_uid();
      init_TextureSource();
      init_Texture();
      _RenderTarget = class _RenderTarget2 {
        /**
         * @param [descriptor] - Options for creating a render target.
         */
        constructor(descriptor = {}) {
          this.uid = uid("renderTarget");
          this.colorTextures = [];
          this.dirtyId = 0;
          this.isRoot = false;
          this._size = new Float32Array(2);
          this._managedColorTextures = false;
          descriptor = { ..._RenderTarget2.defaultOptions, ...descriptor };
          this.stencil = descriptor.stencil;
          this.depth = descriptor.depth;
          this.isRoot = descriptor.isRoot;
          if (typeof descriptor.colorTextures === "number") {
            this._managedColorTextures = true;
            for (let i2 = 0; i2 < descriptor.colorTextures; i2++) {
              this.colorTextures.push(
                new TextureSource({
                  width: descriptor.width,
                  height: descriptor.height,
                  resolution: descriptor.resolution,
                  antialias: descriptor.antialias
                })
              );
            }
          } else {
            this.colorTextures = [...descriptor.colorTextures.map((texture) => texture.source)];
            const colorSource = this.colorTexture.source;
            this.resize(colorSource.width, colorSource.height, colorSource._resolution);
          }
          this.colorTexture.source.on("resize", this.onSourceResize, this);
          if (descriptor.depthStencilTexture || this.stencil) {
            if (descriptor.depthStencilTexture instanceof Texture || descriptor.depthStencilTexture instanceof TextureSource) {
              this.depthStencilTexture = descriptor.depthStencilTexture.source;
            } else {
              this.ensureDepthStencilTexture();
            }
          }
        }
        get size() {
          const _size = this._size;
          _size[0] = this.pixelWidth;
          _size[1] = this.pixelHeight;
          return _size;
        }
        get width() {
          return this.colorTexture.source.width;
        }
        get height() {
          return this.colorTexture.source.height;
        }
        get pixelWidth() {
          return this.colorTexture.source.pixelWidth;
        }
        get pixelHeight() {
          return this.colorTexture.source.pixelHeight;
        }
        get resolution() {
          return this.colorTexture.source._resolution;
        }
        get colorTexture() {
          return this.colorTextures[0];
        }
        onSourceResize(source2) {
          this.resize(source2.width, source2.height, source2._resolution, true);
        }
        /**
         * This will ensure a depthStencil texture is created for this render target.
         * Most likely called by the mask system to make sure we have stencil buffer added.
         * @internal
         * @ignore
         */
        ensureDepthStencilTexture() {
          if (!this.depthStencilTexture) {
            this.depthStencilTexture = new TextureSource({
              width: this.width,
              height: this.height,
              resolution: this.resolution,
              format: "depth24plus-stencil8",
              autoGenerateMipmaps: false,
              antialias: false,
              mipLevelCount: 1
              // sampleCount: handled by the render target system..
            });
          }
        }
        resize(width, height, resolution = this.resolution, skipColorTexture = false) {
          this.dirtyId++;
          this.colorTextures.forEach((colorTexture, i2) => {
            if (skipColorTexture && i2 === 0)
              return;
            colorTexture.source.resize(width, height, resolution);
          });
          if (this.depthStencilTexture) {
            this.depthStencilTexture.source.resize(width, height, resolution);
          }
        }
        destroy() {
          this.colorTexture.source.off("resize", this.onSourceResize, this);
          if (this._managedColorTextures) {
            this.colorTextures.forEach((texture) => {
              texture.destroy();
            });
          }
          if (this.depthStencilTexture) {
            this.depthStencilTexture.destroy();
            delete this.depthStencilTexture;
          }
        }
      };
      _RenderTarget.defaultOptions = {
        /** the width of the RenderTarget */
        width: 0,
        /** the height of the RenderTarget */
        height: 0,
        /** the resolution of the RenderTarget */
        resolution: 1,
        /** an array of textures, or a number indicating how many color textures there should be */
        colorTextures: 1,
        /** should this render target have a stencil buffer? */
        stencil: false,
        /** should this render target have a depth buffer? */
        depth: false,
        /** should this render target be antialiased? */
        antialias: false,
        // save on perf by default!
        /** is this a root element, true if this is gl context owners render target */
        isRoot: false
      };
      RenderTarget = _RenderTarget;
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs
  function getCanvasTexture(canvas, options) {
    if (!canvasCache.has(canvas)) {
      const texture = new Texture({
        source: new CanvasSource({
          resource: canvas,
          ...options
        })
      });
      const onDestroy2 = () => {
        if (canvasCache.get(canvas) === texture) {
          canvasCache.delete(canvas);
        }
      };
      texture.once("destroy", onDestroy2);
      texture.source.once("destroy", onDestroy2);
      canvasCache.set(canvas, texture);
    }
    return canvasCache.get(canvas);
  }
  var canvasCache;
  var init_getCanvasTexture = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs"() {
      init_CanvasSource();
      init_Texture();
      canvasCache = /* @__PURE__ */ new Map();
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/view/ViewSystem.mjs
  var _ViewSystem, ViewSystem;
  var init_ViewSystem = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/view/ViewSystem.mjs"() {
      init_adapter();
      init_Extensions();
      init_Rectangle();
      init_deprecation();
      init_RenderTarget();
      init_getCanvasTexture();
      _ViewSystem = class _ViewSystem2 {
        /** The resolution / device pixel ratio of the renderer. */
        get resolution() {
          return this.texture.source._resolution;
        }
        set resolution(value) {
          this.texture.source.resize(
            this.texture.source.width,
            this.texture.source.height,
            value
          );
        }
        /**
         * initiates the view system
         * @param options - the options for the view
         */
        init(options) {
          options = {
            ..._ViewSystem2.defaultOptions,
            ...options
          };
          if (options.view) {
            deprecation(v8_0_0, "ViewSystem.view has been renamed to ViewSystem.canvas");
            options.canvas = options.view;
          }
          this.screen = new Rectangle(0, 0, options.width, options.height);
          this.canvas = options.canvas || DOMAdapter.get().createCanvas();
          this.antialias = !!options.antialias;
          this.texture = getCanvasTexture(this.canvas, options);
          this.renderTarget = new RenderTarget({
            colorTextures: [this.texture],
            depth: !!options.depth,
            isRoot: true
          });
          this.texture.source.transparent = options.backgroundAlpha < 1;
          this.multiView = !!options.multiView;
          if (this.autoDensity) {
            this.canvas.style.width = `${this.texture.width}px`;
            this.canvas.style.height = `${this.texture.height}px`;
          }
          this.resolution = options.resolution;
        }
        /**
         * Resizes the screen and canvas to the specified dimensions.
         * @param desiredScreenWidth - The new width of the screen.
         * @param desiredScreenHeight - The new height of the screen.
         * @param resolution
         */
        resize(desiredScreenWidth, desiredScreenHeight, resolution) {
          this.texture.source.resize(desiredScreenWidth, desiredScreenHeight, resolution);
          this.screen.width = this.texture.frame.width;
          this.screen.height = this.texture.frame.height;
          if (this.autoDensity) {
            this.canvas.style.width = `${desiredScreenWidth}px`;
            this.canvas.style.height = `${desiredScreenHeight}px`;
          }
        }
        /**
         * Destroys this System and optionally removes the canvas from the dom.
         * @param {options | false} options - The options for destroying the view, or "false".
         * @param options.removeView - Whether to remove the view element from the DOM. Defaults to `false`.
         */
        destroy(options = false) {
          const removeView = typeof options === "boolean" ? options : !!options?.removeView;
          if (removeView && this.canvas.parentNode) {
            this.canvas.parentNode.removeChild(this.canvas);
          }
        }
      };
      _ViewSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "view",
        priority: 0
      };
      _ViewSystem.defaultOptions = {
        /**
         * {@link WebGLOptions.width}
         * @default 800
         */
        width: 800,
        /**
         * {@link WebGLOptions.height}
         * @default 600
         */
        height: 600,
        /**
         * {@link WebGLOptions.autoDensity}
         * @default false
         */
        autoDensity: false,
        /**
         * {@link WebGLOptions.antialias}
         * @default false
         */
        antialias: false
      };
      ViewSystem = _ViewSystem;
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs
  var SharedSystems, SharedRenderPipes;
  var init_SharedSystems = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs"() {
      init_CustomRenderPipe();
      init_RenderGroupPipe();
      init_RenderGroupSystem();
      init_SpritePipe();
      init_BatcherPipe();
      init_AlphaMaskPipe();
      init_ColorMaskPipe();
      init_StencilMaskPipe();
      init_BackgroundSystem();
      init_BlendModePipe();
      init_ExtractSystem();
      init_GenerateTextureSystem();
      init_GlobalUniformSystem();
      init_HelloSystem();
      init_TextureGCSystem();
      init_ViewSystem();
      SharedSystems = [
        BackgroundSystem,
        GlobalUniformSystem,
        HelloSystem,
        ViewSystem,
        RenderGroupSystem,
        TextureGCSystem,
        GenerateTextureSystem,
        ExtractSystem
      ];
      SharedRenderPipes = [
        BlendModePipe,
        BatcherPipe,
        SpritePipe,
        RenderGroupPipe,
        AlphaMaskPipe,
        StencilMaskPipe,
        ColorMaskPipe,
        CustomRenderPipe
      ];
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gpu/BindGroupSystem.mjs
  var BindGroupSystem;
  var init_BindGroupSystem = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gpu/BindGroupSystem.mjs"() {
      init_Extensions();
      BindGroupSystem = class {
        constructor(renderer) {
          this._hash = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
        }
        contextChange(gpu) {
          this._gpu = gpu;
        }
        getBindGroup(bindGroup, program, groupIndex) {
          bindGroup._updateKey();
          const gpuBindGroup = this._hash[bindGroup._key] || this._createBindGroup(bindGroup, program, groupIndex);
          return gpuBindGroup;
        }
        _createBindGroup(group, program, groupIndex) {
          const device = this._gpu.device;
          const groupLayout = program.layout[groupIndex];
          const entries = [];
          const renderer = this._renderer;
          for (const j2 in groupLayout) {
            const resource = group.resources[j2] ?? group.resources[groupLayout[j2]];
            let gpuResource;
            if (resource._resourceType === "uniformGroup") {
              const uniformGroup = resource;
              renderer.ubo.updateUniformGroup(uniformGroup);
              const buffer = uniformGroup.buffer;
              gpuResource = {
                buffer: renderer.buffer.getGPUBuffer(buffer),
                offset: 0,
                size: buffer.descriptor.size
              };
            } else if (resource._resourceType === "buffer") {
              const buffer = resource;
              gpuResource = {
                buffer: renderer.buffer.getGPUBuffer(buffer),
                offset: 0,
                size: buffer.descriptor.size
              };
            } else if (resource._resourceType === "bufferResource") {
              const bufferResource = resource;
              gpuResource = {
                buffer: renderer.buffer.getGPUBuffer(bufferResource.buffer),
                offset: bufferResource.offset,
                size: bufferResource.size
              };
            } else if (resource._resourceType === "textureSampler") {
              const sampler = resource;
              gpuResource = renderer.texture.getGpuSampler(sampler);
            } else if (resource._resourceType === "textureSource") {
              const texture = resource;
              gpuResource = renderer.texture.getGpuSource(texture).createView({});
            }
            entries.push({
              binding: groupLayout[j2],
              resource: gpuResource
            });
          }
          const layout = renderer.shader.getProgramData(program).bindGroups[groupIndex];
          const gpuBindGroup = device.createBindGroup({
            layout,
            entries
          });
          this._hash[group._key] = gpuBindGroup;
          return gpuBindGroup;
        }
        destroy() {
          for (const key of Object.keys(this._hash)) {
            this._hash[key] = null;
          }
          this._hash = null;
          this._renderer = null;
        }
      };
      BindGroupSystem.extension = {
        type: [
          ExtensionType.WebGPUSystem
        ],
        name: "bindGroup"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.mjs
  var GpuBufferSystem;
  var init_GpuBufferSystem = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.mjs"() {
      init_Extensions();
      init_fastCopy();
      GpuBufferSystem = class {
        constructor() {
          this._gpuBuffers = /* @__PURE__ */ Object.create(null);
          this._managedBuffers = [];
        }
        contextChange(gpu) {
          this._gpu = gpu;
        }
        getGPUBuffer(buffer) {
          return this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);
        }
        updateBuffer(buffer) {
          const gpuBuffer = this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);
          const data = buffer.data;
          if (buffer._updateID && data) {
            buffer._updateID = 0;
            this._gpu.device.queue.writeBuffer(
              gpuBuffer,
              0,
              data.buffer,
              0,
              // round to the nearest 4 bytes
              (buffer._updateSize || data.byteLength) + 3 & ~3
            );
          }
          return gpuBuffer;
        }
        /** dispose all WebGL resources of all managed buffers */
        destroyAll() {
          for (const id in this._gpuBuffers) {
            this._gpuBuffers[id].destroy();
          }
          this._gpuBuffers = {};
        }
        createGPUBuffer(buffer) {
          if (!this._gpuBuffers[buffer.uid]) {
            buffer.on("update", this.updateBuffer, this);
            buffer.on("change", this.onBufferChange, this);
            buffer.on("destroy", this.onBufferDestroy, this);
          }
          const gpuBuffer = this._gpu.device.createBuffer(buffer.descriptor);
          buffer._updateID = 0;
          if (buffer.data) {
            fastCopy(buffer.data.buffer, gpuBuffer.getMappedRange());
            gpuBuffer.unmap();
          }
          this._gpuBuffers[buffer.uid] = gpuBuffer;
          this._managedBuffers.push(buffer);
          return gpuBuffer;
        }
        onBufferChange(buffer) {
          const gpuBuffer = this._gpuBuffers[buffer.uid];
          gpuBuffer.destroy();
          buffer._updateID = 0;
          this._gpuBuffers[buffer.uid] = this.createGPUBuffer(buffer);
        }
        /**
         * Disposes buffer
         * @param buffer - buffer with data
         */
        onBufferDestroy(buffer) {
          this._managedBuffers.splice(this._managedBuffers.indexOf(buffer), 1);
          this._destroyBuffer(buffer);
        }
        destroy() {
          this._managedBuffers.forEach((buffer) => this._destroyBuffer(buffer));
          this._managedBuffers = null;
          this._gpuBuffers = null;
        }
        _destroyBuffer(buffer) {
          const gpuBuffer = this._gpuBuffers[buffer.uid];
          gpuBuffer.destroy();
          buffer.off("update", this.updateBuffer, this);
          buffer.off("change", this.onBufferChange, this);
          buffer.off("destroy", this.onBufferDestroy, this);
          this._gpuBuffers[buffer.uid] = null;
        }
      };
      GpuBufferSystem.extension = {
        type: [
          ExtensionType.WebGPUSystem
        ],
        name: "buffer"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuColorMaskSystem.mjs
  var GpuColorMaskSystem;
  var init_GpuColorMaskSystem = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuColorMaskSystem.mjs"() {
      init_Extensions();
      GpuColorMaskSystem = class {
        constructor(renderer) {
          this._colorMaskCache = 15;
          this._renderer = renderer;
        }
        setMask(colorMask) {
          if (this._colorMaskCache === colorMask)
            return;
          this._colorMaskCache = colorMask;
          this._renderer.pipeline.setColorMask(colorMask);
        }
        destroy() {
          this._renderer = null;
          this._colorMaskCache = null;
        }
      };
      GpuColorMaskSystem.extension = {
        type: [
          ExtensionType.WebGPUSystem
        ],
        name: "colorMask"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuDeviceSystem.mjs
  var GpuDeviceSystem;
  var init_GpuDeviceSystem = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuDeviceSystem.mjs"() {
      init_Extensions();
      GpuDeviceSystem = class {
        /**
         * @param {WebGPURenderer} renderer - The renderer this System works for.
         */
        constructor(renderer) {
          this._renderer = renderer;
        }
        async init(options) {
          if (this._initPromise)
            return this._initPromise;
          this._initPromise = this._createDeviceAndAdaptor(options).then((gpu) => {
            this.gpu = gpu;
            this._renderer.runners.contextChange.emit(this.gpu);
          });
          return this._initPromise;
        }
        /**
         * Handle the context change event
         * @param gpu
         */
        contextChange(gpu) {
          this._renderer.gpu = gpu;
        }
        /**
         * Helper class to create a WebGL Context
         * @param {object} options - An options object that gets passed in to the canvas element containing the
         *    context attributes
         * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext
         * @returns {WebGLRenderingContext} the WebGL context
         */
        async _createDeviceAndAdaptor(options) {
          const adapter = await navigator.gpu.requestAdapter({
            powerPreference: options.powerPreference,
            forceFallbackAdapter: options.forceFallbackAdapter
          });
          const requiredFeatures = [
            "texture-compression-bc",
            "texture-compression-astc",
            "texture-compression-etc2"
          ].filter((feature) => adapter.features.has(feature));
          const device = await adapter.requestDevice({
            requiredFeatures
          });
          return { adapter, device };
        }
        destroy() {
          this.gpu = null;
          this._renderer = null;
        }
      };
      GpuDeviceSystem.extension = {
        type: [
          ExtensionType.WebGPUSystem
        ],
        name: "device"
      };
      GpuDeviceSystem.defaultOptions = {
        /**
         * {@link WebGPUOptions.powerPreference}
         * @default default
         */
        powerPreference: void 0,
        /**
         * Force the use of the fallback adapter
         * @default false
         */
        forceFallbackAdapter: false
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuEncoderSystem.mjs
  var GpuEncoderSystem;
  var init_GpuEncoderSystem = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuEncoderSystem.mjs"() {
      init_Extensions();
      GpuEncoderSystem = class {
        constructor(renderer) {
          this._boundBindGroup = /* @__PURE__ */ Object.create(null);
          this._boundVertexBuffer = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
        }
        renderStart() {
          this.commandFinished = new Promise((resolve) => {
            this._resolveCommandFinished = resolve;
          });
          this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();
        }
        beginRenderPass(gpuRenderTarget) {
          this.endRenderPass();
          this._clearCache();
          this.renderPassEncoder = this.commandEncoder.beginRenderPass(gpuRenderTarget.descriptor);
        }
        endRenderPass() {
          if (this.renderPassEncoder) {
            this.renderPassEncoder.end();
          }
          this.renderPassEncoder = null;
        }
        setViewport(viewport) {
          this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
        }
        setPipelineFromGeometryProgramAndState(geometry, program, state, topology) {
          const pipeline = this._renderer.pipeline.getPipeline(geometry, program, state, topology);
          this.setPipeline(pipeline);
        }
        setPipeline(pipeline) {
          if (this._boundPipeline === pipeline)
            return;
          this._boundPipeline = pipeline;
          this.renderPassEncoder.setPipeline(pipeline);
        }
        _setVertexBuffer(index, buffer) {
          if (this._boundVertexBuffer[index] === buffer)
            return;
          this._boundVertexBuffer[index] = buffer;
          this.renderPassEncoder.setVertexBuffer(index, this._renderer.buffer.updateBuffer(buffer));
        }
        _setIndexBuffer(buffer) {
          if (this._boundIndexBuffer === buffer)
            return;
          this._boundIndexBuffer = buffer;
          const indexFormat = buffer.data.BYTES_PER_ELEMENT === 2 ? "uint16" : "uint32";
          this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(buffer), indexFormat);
        }
        resetBindGroup(index) {
          this._boundBindGroup[index] = null;
        }
        setBindGroup(index, bindGroup, program) {
          if (this._boundBindGroup[index] === bindGroup)
            return;
          this._boundBindGroup[index] = bindGroup;
          bindGroup._touch(this._renderer.textureGC.count);
          const gpuBindGroup = this._renderer.bindGroup.getBindGroup(bindGroup, program, index);
          this.renderPassEncoder.setBindGroup(index, gpuBindGroup);
        }
        setGeometry(geometry) {
          for (const i2 in geometry.attributes) {
            const attribute = geometry.attributes[i2];
            this._setVertexBuffer(attribute.location, attribute.buffer);
          }
          if (geometry.indexBuffer) {
            this._setIndexBuffer(geometry.indexBuffer);
          }
        }
        _setShaderBindGroups(shader, skipSync) {
          for (const i2 in shader.groups) {
            const bindGroup = shader.groups[i2];
            if (!skipSync) {
              this._syncBindGroup(bindGroup);
            }
            this.setBindGroup(i2, bindGroup, shader.gpuProgram);
          }
        }
        _syncBindGroup(bindGroup) {
          for (const j2 in bindGroup.resources) {
            const resource = bindGroup.resources[j2];
            if (resource.isUniformGroup) {
              this._renderer.ubo.updateUniformGroup(resource);
            }
          }
        }
        draw(options) {
          const { geometry, shader, state, topology, size, start, instanceCount, skipSync } = options;
          this.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, state, topology);
          this.setGeometry(geometry);
          this._setShaderBindGroups(shader, skipSync);
          if (geometry.indexBuffer) {
            this.renderPassEncoder.drawIndexed(
              size || geometry.indexBuffer.data.length,
              instanceCount || geometry.instanceCount,
              start || 0
            );
          } else {
            this.renderPassEncoder.draw(size || geometry.getSize(), instanceCount || geometry.instanceCount, start || 0);
          }
        }
        finishRenderPass() {
          if (this.renderPassEncoder) {
            this.renderPassEncoder.end();
            this.renderPassEncoder = null;
          }
        }
        postrender() {
          this.finishRenderPass();
          this._gpu.device.queue.submit([this.commandEncoder.finish()]);
          this._resolveCommandFinished();
          this.commandEncoder = null;
        }
        // restores a render pass if finishRenderPass was called
        // not optimised as really used for debugging!
        // used when we want to stop drawing and log a texture..
        restoreRenderPass() {
          const descriptor = this._renderer.renderTarget.adaptor.getDescriptor(
            this._renderer.renderTarget.renderTarget,
            false,
            [0, 0, 0, 1]
          );
          this.renderPassEncoder = this.commandEncoder.beginRenderPass(descriptor);
          const boundPipeline = this._boundPipeline;
          const boundVertexBuffer = { ...this._boundVertexBuffer };
          const boundIndexBuffer = this._boundIndexBuffer;
          const boundBindGroup = { ...this._boundBindGroup };
          this._clearCache();
          const viewport = this._renderer.renderTarget.viewport;
          this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
          this.setPipeline(boundPipeline);
          for (const i2 in boundVertexBuffer) {
            this._setVertexBuffer(i2, boundVertexBuffer[i2]);
          }
          for (const i2 in boundBindGroup) {
            this.setBindGroup(i2, boundBindGroup[i2], null);
          }
          this._setIndexBuffer(boundIndexBuffer);
        }
        _clearCache() {
          for (let i2 = 0; i2 < 16; i2++) {
            this._boundBindGroup[i2] = null;
            this._boundVertexBuffer[i2] = null;
          }
          this._boundIndexBuffer = null;
          this._boundPipeline = null;
        }
        destroy() {
          this._renderer = null;
          this._gpu = null;
          this._boundBindGroup = null;
          this._boundVertexBuffer = null;
          this._boundIndexBuffer = null;
          this._boundPipeline = null;
        }
        contextChange(gpu) {
          this._gpu = gpu;
        }
      };
      GpuEncoderSystem.extension = {
        type: [ExtensionType.WebGPUSystem],
        name: "encoder",
        priority: 1
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuStencilSystem.mjs
  var GpuStencilSystem;
  var init_GpuStencilSystem = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuStencilSystem.mjs"() {
      init_Extensions();
      init_const5();
      GpuStencilSystem = class {
        constructor(renderer) {
          this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
          renderer.renderTarget.onRenderTargetChange.add(this);
        }
        onRenderTargetChange(renderTarget) {
          let stencilState = this._renderTargetStencilState[renderTarget.uid];
          if (!stencilState) {
            stencilState = this._renderTargetStencilState[renderTarget.uid] = {
              stencilMode: STENCIL_MODES.DISABLED,
              stencilReference: 0
            };
          }
          this._activeRenderTarget = renderTarget;
          this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);
        }
        setStencilMode(stencilMode, stencilReference) {
          const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];
          stencilState.stencilMode = stencilMode;
          stencilState.stencilReference = stencilReference;
          const renderer = this._renderer;
          renderer.pipeline.setStencilMode(stencilMode);
          renderer.encoder.renderPassEncoder.setStencilReference(stencilReference);
        }
        destroy() {
          this._renderer.renderTarget.onRenderTargetChange.remove(this);
          this._renderer = null;
          this._activeRenderTarget = null;
          this._renderTargetStencilState = null;
        }
      };
      GpuStencilSystem.extension = {
        type: [
          ExtensionType.WebGPUSystem
        ],
        name: "stencil"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.mjs
  var UboSystem;
  var init_UboSystem = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.mjs"() {
      init_unsafeEvalSupported();
      init_Buffer();
      init_const3();
      UboSystem = class {
        constructor(adaptor) {
          this._syncFunctionHash = /* @__PURE__ */ Object.create(null);
          this._adaptor = adaptor;
          this._systemCheck();
        }
        /**
         * Overrideable function by `pixi.js/unsafe-eval` to silence
         * throwing an error if platform doesn't support unsafe-evals.
         * @private
         */
        _systemCheck() {
          if (!unsafeEvalSupported()) {
            throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
          }
        }
        ensureUniformGroup(uniformGroup) {
          const uniformData = this.getUniformGroupData(uniformGroup);
          uniformGroup.buffer || (uniformGroup.buffer = new Buffer2({
            data: new Float32Array(uniformData.layout.size / 4),
            usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST
          }));
        }
        getUniformGroupData(uniformGroup) {
          return this._syncFunctionHash[uniformGroup._signature] || this._initUniformGroup(uniformGroup);
        }
        _initUniformGroup(uniformGroup) {
          const uniformGroupSignature = uniformGroup._signature;
          let uniformData = this._syncFunctionHash[uniformGroupSignature];
          if (!uniformData) {
            const elements = Object.keys(uniformGroup.uniformStructures).map((i2) => uniformGroup.uniformStructures[i2]);
            const layout = this._adaptor.createUboElements(elements);
            const syncFunction = this._generateUboSync(layout.uboElements);
            uniformData = this._syncFunctionHash[uniformGroupSignature] = {
              layout,
              syncFunction
            };
          }
          return this._syncFunctionHash[uniformGroupSignature];
        }
        _generateUboSync(uboElements) {
          return this._adaptor.generateUboSync(uboElements);
        }
        syncUniformGroup(uniformGroup, data, offset) {
          const uniformGroupData = this.getUniformGroupData(uniformGroup);
          uniformGroup.buffer || (uniformGroup.buffer = new Buffer2({
            data: new Float32Array(uniformGroupData.layout.size / 4),
            usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST
          }));
          data || (data = uniformGroup.buffer.data);
          offset || (offset = 0);
          uniformGroupData.syncFunction(uniformGroup.uniforms, data, offset);
          return true;
        }
        updateUniformGroup(uniformGroup) {
          if (uniformGroup.isStatic && !uniformGroup._dirtyId)
            return false;
          uniformGroup._dirtyId = 0;
          const synced = this.syncUniformGroup(uniformGroup);
          uniformGroup.buffer.update();
          return synced;
        }
        destroy() {
          this._syncFunctionHash = null;
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.mjs
  function createUboElementsWGSL(uniformData) {
    const uboElements = uniformData.map((data) => ({
      data,
      offset: 0,
      size: 0
    }));
    let offset = 0;
    for (let i2 = 0; i2 < uboElements.length; i2++) {
      const uboElement = uboElements[i2];
      let size = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].size;
      const align = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].align;
      if (!WGSL_ALIGN_SIZE_DATA[uboElement.data.type]) {
        throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${uboElement.data.type}`);
      }
      if (uboElement.data.size > 1) {
        size = Math.max(size, align) * uboElement.data.size;
      }
      offset = Math.ceil(offset / align) * align;
      uboElement.size = size;
      uboElement.offset = offset;
      offset += size;
    }
    offset = Math.ceil(offset / 16) * 16;
    return { uboElements, size: offset };
  }
  var WGSL_ALIGN_SIZE_DATA;
  var init_createUboElementsWGSL = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.mjs"() {
      "use strict";
      WGSL_ALIGN_SIZE_DATA = {
        i32: { align: 4, size: 4 },
        u32: { align: 4, size: 4 },
        f32: { align: 4, size: 4 },
        f16: { align: 2, size: 2 },
        "vec2<i32>": { align: 8, size: 8 },
        "vec2<u32>": { align: 8, size: 8 },
        "vec2<f32>": { align: 8, size: 8 },
        "vec2<f16>": { align: 4, size: 4 },
        "vec3<i32>": { align: 16, size: 12 },
        "vec3<u32>": { align: 16, size: 12 },
        "vec3<f32>": { align: 16, size: 12 },
        "vec3<f16>": { align: 8, size: 6 },
        "vec4<i32>": { align: 16, size: 16 },
        "vec4<u32>": { align: 16, size: 16 },
        "vec4<f32>": { align: 16, size: 16 },
        "vec4<f16>": { align: 8, size: 8 },
        "mat2x2<f32>": { align: 8, size: 16 },
        "mat2x2<f16>": { align: 4, size: 8 },
        "mat3x2<f32>": { align: 8, size: 24 },
        "mat3x2<f16>": { align: 4, size: 12 },
        "mat4x2<f32>": { align: 8, size: 32 },
        "mat4x2<f16>": { align: 4, size: 16 },
        "mat2x3<f32>": { align: 16, size: 32 },
        "mat2x3<f16>": { align: 8, size: 16 },
        "mat3x3<f32>": { align: 16, size: 48 },
        "mat3x3<f16>": { align: 8, size: 24 },
        "mat4x3<f32>": { align: 16, size: 64 },
        "mat4x3<f16>": { align: 8, size: 32 },
        "mat2x4<f32>": { align: 16, size: 32 },
        "mat2x4<f16>": { align: 8, size: 16 },
        "mat3x4<f32>": { align: 16, size: 48 },
        "mat3x4<f16>": { align: 8, size: 24 },
        "mat4x4<f32>": { align: 16, size: 64 },
        "mat4x4<f16>": { align: 8, size: 32 }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformParsers.mjs
  var uniformParsers;
  var init_uniformParsers = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformParsers.mjs"() {
      "use strict";
      uniformParsers = [
        // uploading pixi matrix object to mat3
        {
          type: "mat3x3<f32>",
          test: (data) => {
            const value = data.value;
            return value.a !== void 0;
          },
          ubo: `
            var matrix = uv[name].toArray(true);
            data[offset] = matrix[0];
            data[offset + 1] = matrix[1];
            data[offset + 2] = matrix[2];
            data[offset + 4] = matrix[3];
            data[offset + 5] = matrix[4];
            data[offset + 6] = matrix[5];
            data[offset + 8] = matrix[6];
            data[offset + 9] = matrix[7];
            data[offset + 10] = matrix[8];
        `,
          uniform: ` 
            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));
        `
        },
        // uploading a pixi rectangle as a vec4
        {
          type: "vec4<f32>",
          test: (data) => data.type === "vec4<f32>" && data.size === 1 && data.value.width !== void 0,
          ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
            data[offset + 2] = v.width;
            data[offset + 3] = v.height;
        `,
          uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {
                cv[0] = v.x;
                cv[1] = v.y;
                cv[2] = v.width;
                cv[3] = v.height;
                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);
            }
        `
        },
        // uploading a pixi point as a vec2
        {
          type: "vec2<f32>",
          test: (data) => data.type === "vec2<f32>" && data.size === 1 && data.value.x !== void 0,
          ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
        `,
          uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y) {
                cv[0] = v.x;
                cv[1] = v.y;
                gl.uniform2f(ud[name].location, v.x, v.y);
            }
        `
        },
        // uploading a pixi color as a vec4
        {
          type: "vec4<f32>",
          test: (data) => data.type === "vec4<f32>" && data.size === 1 && data.value.red !== void 0,
          ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
            data[offset + 3] = v.alpha;
        `,
          uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                cv[3] = v.alpha;
                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);
            }
        `
        },
        // uploading a pixi color as a vec3
        {
          type: "vec3<f32>",
          test: (data) => data.type === "vec3<f32>" && data.size === 1 && data.value.red !== void 0,
          ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
        `,
          uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);
            }
        `
        }
      ];
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs
  function createUboSyncFunction(uboElements, parserCode, arrayGenerationFunction, singleSettersMap) {
    const funcFragments = [`
        var v = null;
        var v2 = null;
        var t = 0;
        var index = 0;
        var name = null;
        var arrayOffset = null;
    `];
    let prev = 0;
    for (let i2 = 0; i2 < uboElements.length; i2++) {
      const uboElement = uboElements[i2];
      const name = uboElement.data.name;
      let parsed = false;
      let offset = 0;
      for (let j2 = 0; j2 < uniformParsers.length; j2++) {
        const uniformParser = uniformParsers[j2];
        if (uniformParser.test(uboElement.data)) {
          offset = uboElement.offset / 4;
          funcFragments.push(
            `name = "${name}";`,
            `offset += ${offset - prev};`,
            uniformParsers[j2][parserCode] || uniformParsers[j2].ubo
          );
          parsed = true;
          break;
        }
      }
      if (!parsed) {
        if (uboElement.data.size > 1) {
          offset = uboElement.offset / 4;
          funcFragments.push(arrayGenerationFunction(uboElement, offset - prev));
        } else {
          const template = singleSettersMap[uboElement.data.type];
          offset = uboElement.offset / 4;
          funcFragments.push(
            /* wgsl */
            `
                    v = uv.${name};
                    offset += ${offset - prev};
                    ${template};
                `
          );
        }
      }
      prev = offset;
    }
    const fragmentSrc = funcFragments.join("\n");
    return new Function(
      "uv",
      "data",
      "offset",
      fragmentSrc
    );
  }
  var init_createUboSyncFunction = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs"() {
      init_uniformParsers();
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs
  function loopMatrix(col, row) {
    const total = col * row;
    return `
        for (let i = 0; i < ${total}; i++) {
            data[offset + (((i / ${col})|0) * 4) + (i % ${col})] = v[i];
        }
    `;
  }
  var uboSyncFunctionsSTD40, uboSyncFunctionsWGSL;
  var init_uboSyncFunctions = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs"() {
      "use strict";
      uboSyncFunctionsSTD40 = {
        f32: `
        data[offset] = v;`,
        i32: `
        data[offset] = v;`,
        "vec2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];`,
        "vec3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];`,
        "vec4<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];`,
        "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 4] = v[2];
        data[offset + 5] = v[3];`,
        "mat3x3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];
        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];`,
        "mat4x4<f32>": `
        for (let i = 0; i < 16; i++) {
            data[offset + i] = v[i];
        }`,
        "mat3x2<f32>": loopMatrix(3, 2),
        "mat4x2<f32>": loopMatrix(4, 2),
        "mat2x3<f32>": loopMatrix(2, 3),
        "mat4x3<f32>": loopMatrix(4, 3),
        "mat2x4<f32>": loopMatrix(2, 4),
        "mat3x4<f32>": loopMatrix(3, 4)
      };
      uboSyncFunctionsWGSL = {
        ...uboSyncFunctionsSTD40,
        "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];
    `
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.mjs
  function generateArraySyncWGSL(uboElement, offsetToAdd) {
    const { size, align } = WGSL_ALIGN_SIZE_DATA[uboElement.data.type];
    const remainder = (align - size) / 4;
    return `
         v = uv.${uboElement.data.name};
         ${offsetToAdd !== 0 ? `offset += ${offsetToAdd};` : ""}

         arrayOffset = offset;

         t = 0;

         for(var i=0; i < ${uboElement.data.size * (size / 4)}; i++)
         {
             for(var j = 0; j < ${size / 4}; j++)
             {
                 data[arrayOffset++] = v[t++];
             }
             ${remainder !== 0 ? `arrayOffset += ${remainder};` : ""}
         }
     `;
  }
  var init_generateArraySyncWGSL = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.mjs"() {
      init_createUboElementsWGSL();
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.mjs
  function createUboSyncFunctionWGSL(uboElements) {
    return createUboSyncFunction(
      uboElements,
      "uboWgsl",
      generateArraySyncWGSL,
      uboSyncFunctionsWGSL
    );
  }
  var init_createUboSyncFunctionWGSL = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.mjs"() {
      init_createUboSyncFunction();
      init_uboSyncFunctions();
      init_generateArraySyncWGSL();
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUboSystem.mjs
  var GpuUboSystem;
  var init_GpuUboSystem = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUboSystem.mjs"() {
      init_Extensions();
      init_UboSystem();
      init_createUboElementsWGSL();
      init_createUboSyncFunctionWGSL();
      GpuUboSystem = class extends UboSystem {
        constructor() {
          super({
            createUboElements: createUboElementsWGSL,
            generateUboSync: createUboSyncFunctionWGSL
          });
        }
      };
      GpuUboSystem.extension = {
        type: [ExtensionType.WebGPUSystem],
        name: "ubo"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs
  var BufferResource;
  var init_BufferResource = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs"() {
      init_eventemitter3();
      init_uid();
      BufferResource = class extends eventemitter3_default {
        /**
         * Create a new Buffer Resource.
         * @param options - The options for the buffer resource
         * @param options.buffer - The underlying buffer that this resource is using
         * @param options.offset - The offset of the buffer this resource is using.
         * If not provided, then it will use the offset of the buffer.
         * @param options.size - The size of the buffer this resource is using.
         * If not provided, then it will use the size of the buffer.
         */
        constructor({ buffer, offset, size }) {
          super();
          this.uid = uid("buffer");
          this._resourceType = "bufferResource";
          this._touched = 0;
          this._resourceId = uid("resource");
          this._bufferResource = true;
          this.destroyed = false;
          this.buffer = buffer;
          this.offset = offset | 0;
          this.size = size;
          this.buffer.on("change", this.onBufferChange, this);
        }
        onBufferChange() {
          this._resourceId = uid("resource");
          this.emit("change", this);
        }
        /**
         * Destroys this resource. Make sure the underlying buffer is not used anywhere else
         * if you want to destroy it as well, or code will explode
         * @param destroyBuffer - Should the underlying buffer be destroyed as well?
         */
        destroy(destroyBuffer = false) {
          this.destroyed = true;
          if (destroyBuffer) {
            this.buffer.destroy();
          }
          this.emit("change", this);
          this.buffer = null;
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/UboBatch.mjs
  var UboBatch;
  var init_UboBatch = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/UboBatch.mjs"() {
      "use strict";
      UboBatch = class {
        constructor({ minUniformOffsetAlignment: minUniformOffsetAlignment2 }) {
          this._minUniformOffsetAlignment = 256;
          this.byteIndex = 0;
          this._minUniformOffsetAlignment = minUniformOffsetAlignment2;
          this.data = new Float32Array(65535);
        }
        clear() {
          this.byteIndex = 0;
        }
        addEmptyGroup(size) {
          if (size > this._minUniformOffsetAlignment / 4) {
            throw new Error(`UniformBufferBatch: array is too large: ${size * 4}`);
          }
          const start = this.byteIndex;
          let newSize = start + size * 4;
          newSize = Math.ceil(newSize / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment;
          if (newSize > this.data.length * 4) {
            throw new Error("UniformBufferBatch: ubo batch got too big");
          }
          this.byteIndex = newSize;
          return start;
        }
        addGroup(array) {
          const offset = this.addEmptyGroup(array.length);
          for (let i2 = 0; i2 < array.length; i2++) {
            this.data[offset / 4 + i2] = array[i2];
          }
          return offset;
        }
        destroy() {
          this._buffer.destroy();
          this._buffer = null;
          this.data = null;
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBatchPipe.mjs
  var minUniformOffsetAlignment, GpuUniformBatchPipe;
  var init_GpuUniformBatchPipe = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBatchPipe.mjs"() {
      init_Extensions();
      init_Buffer();
      init_BufferResource();
      init_const3();
      init_UboBatch();
      init_BindGroup();
      minUniformOffsetAlignment = 128;
      GpuUniformBatchPipe = class {
        constructor(renderer) {
          this._bindGroupHash = /* @__PURE__ */ Object.create(null);
          this._buffers = [];
          this._bindGroups = [];
          this._bufferResources = [];
          this._renderer = renderer;
          this._batchBuffer = new UboBatch({ minUniformOffsetAlignment });
          const totalBuffers = 256 / minUniformOffsetAlignment;
          for (let i2 = 0; i2 < totalBuffers; i2++) {
            let usage = BufferUsage.UNIFORM | BufferUsage.COPY_DST;
            if (i2 === 0)
              usage |= BufferUsage.COPY_SRC;
            this._buffers.push(new Buffer2({
              data: this._batchBuffer.data,
              usage
            }));
          }
        }
        renderEnd() {
          this._uploadBindGroups();
          this._resetBindGroups();
        }
        _resetBindGroups() {
          for (const i2 in this._bindGroupHash) {
            this._bindGroupHash[i2] = null;
          }
          this._batchBuffer.clear();
        }
        // just works for single bind groups for now
        getUniformBindGroup(group, duplicate) {
          if (!duplicate && this._bindGroupHash[group.uid]) {
            return this._bindGroupHash[group.uid];
          }
          this._renderer.ubo.ensureUniformGroup(group);
          const data = group.buffer.data;
          const offset = this._batchBuffer.addEmptyGroup(data.length);
          this._renderer.ubo.syncUniformGroup(group, this._batchBuffer.data, offset / 4);
          this._bindGroupHash[group.uid] = this._getBindGroup(offset / minUniformOffsetAlignment);
          return this._bindGroupHash[group.uid];
        }
        getUboResource(group) {
          this._renderer.ubo.updateUniformGroup(group);
          const data = group.buffer.data;
          const offset = this._batchBuffer.addGroup(data);
          return this._getBufferResource(offset / minUniformOffsetAlignment);
        }
        getArrayBindGroup(data) {
          const offset = this._batchBuffer.addGroup(data);
          return this._getBindGroup(offset / minUniformOffsetAlignment);
        }
        getArrayBufferResource(data) {
          const offset = this._batchBuffer.addGroup(data);
          const index = offset / minUniformOffsetAlignment;
          return this._getBufferResource(index);
        }
        _getBufferResource(index) {
          if (!this._bufferResources[index]) {
            const buffer = this._buffers[index % 2];
            this._bufferResources[index] = new BufferResource({
              buffer,
              offset: (index / 2 | 0) * 256,
              size: minUniformOffsetAlignment
            });
          }
          return this._bufferResources[index];
        }
        _getBindGroup(index) {
          if (!this._bindGroups[index]) {
            const bindGroup = new BindGroup({
              0: this._getBufferResource(index)
            });
            this._bindGroups[index] = bindGroup;
          }
          return this._bindGroups[index];
        }
        _uploadBindGroups() {
          const bufferSystem = this._renderer.buffer;
          const firstBuffer = this._buffers[0];
          firstBuffer.update(this._batchBuffer.byteIndex);
          bufferSystem.updateBuffer(firstBuffer);
          const commandEncoder = this._renderer.gpu.device.createCommandEncoder();
          for (let i2 = 1; i2 < this._buffers.length; i2++) {
            const buffer = this._buffers[i2];
            commandEncoder.copyBufferToBuffer(
              bufferSystem.getGPUBuffer(firstBuffer),
              minUniformOffsetAlignment,
              bufferSystem.getGPUBuffer(buffer),
              0,
              this._batchBuffer.byteIndex
            );
          }
          this._renderer.gpu.device.queue.submit([commandEncoder.finish()]);
        }
        destroy() {
          for (let i2 = 0; i2 < this._bindGroups.length; i2++) {
            this._bindGroups[i2].destroy();
          }
          this._bindGroups = null;
          this._bindGroupHash = null;
          for (let i2 = 0; i2 < this._buffers.length; i2++) {
            this._buffers[i2].destroy();
          }
          this._buffers = null;
          for (let i2 = 0; i2 < this._bufferResources.length; i2++) {
            this._bufferResources[i2].destroy();
          }
          this._bufferResources = null;
          this._batchBuffer.destroy();
          this._bindGroupHash = null;
          this._renderer = null;
        }
      };
      GpuUniformBatchPipe.extension = {
        type: [
          ExtensionType.WebGPUPipes
        ],
        name: "uniformBatch"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.mjs
  function ensureAttributes(geometry, extractedData) {
    for (const i2 in geometry.attributes) {
      const attribute = geometry.attributes[i2];
      const attributeData = extractedData[i2];
      if (attributeData) {
        attribute.location ?? (attribute.location = attributeData.location);
        attribute.format ?? (attribute.format = attributeData.format);
        attribute.offset ?? (attribute.offset = attributeData.offset);
        attribute.instance ?? (attribute.instance = attributeData.instance);
      } else {
        warn(`Attribute ${i2} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);
      }
    }
    ensureStartAndStride(geometry);
  }
  function ensureStartAndStride(geometry) {
    const { buffers, attributes } = geometry;
    const tempStride = {};
    const tempStart = {};
    for (const j2 in buffers) {
      const buffer = buffers[j2];
      tempStride[buffer.uid] = 0;
      tempStart[buffer.uid] = 0;
    }
    for (const j2 in attributes) {
      const attribute = attributes[j2];
      tempStride[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;
    }
    for (const j2 in attributes) {
      const attribute = attributes[j2];
      attribute.stride ?? (attribute.stride = tempStride[attribute.buffer.uid]);
      attribute.start ?? (attribute.start = tempStart[attribute.buffer.uid]);
      tempStart[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;
    }
  }
  var init_ensureAttributes = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.mjs"() {
      init_warn();
      init_getAttributeInfoFromFormat();
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs
  var GpuStencilModesToPixi;
  var init_GpuStencilModesToPixi = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs"() {
      init_const5();
      GpuStencilModesToPixi = [];
      GpuStencilModesToPixi[STENCIL_MODES.NONE] = void 0;
      GpuStencilModesToPixi[STENCIL_MODES.DISABLED] = {
        stencilWriteMask: 0,
        stencilReadMask: 0
      };
      GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD] = {
        stencilFront: {
          compare: "equal",
          passOp: "increment-clamp"
        },
        stencilBack: {
          compare: "equal",
          passOp: "increment-clamp"
        }
      };
      GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE] = {
        stencilFront: {
          compare: "equal",
          passOp: "decrement-clamp"
        },
        stencilBack: {
          compare: "equal",
          passOp: "decrement-clamp"
        }
      };
      GpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE] = {
        stencilWriteMask: 0,
        stencilFront: {
          compare: "equal",
          passOp: "keep"
        },
        stencilBack: {
          compare: "equal",
          passOp: "keep"
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gpu/pipeline/PipelineSystem.mjs
  function getGraphicsStateKey(geometryLayout, shaderKey, state, blendMode, topology) {
    return geometryLayout << 24 | shaderKey << 16 | state << 10 | blendMode << 5 | topology;
  }
  function getGlobalStateKey(stencilStateId, multiSampleCount, colorMask, renderTarget) {
    return colorMask << 6 | stencilStateId << 3 | renderTarget << 1 | multiSampleCount;
  }
  var topologyStringToId, PipelineSystem;
  var init_PipelineSystem = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gpu/pipeline/PipelineSystem.mjs"() {
      init_Extensions();
      init_ensureAttributes();
      init_const5();
      init_createIdFromString();
      init_GpuStencilModesToPixi();
      topologyStringToId = {
        "point-list": 0,
        "line-list": 1,
        "line-strip": 2,
        "triangle-list": 3,
        "triangle-strip": 4
      };
      PipelineSystem = class {
        constructor(renderer) {
          this._moduleCache = /* @__PURE__ */ Object.create(null);
          this._bufferLayoutsCache = /* @__PURE__ */ Object.create(null);
          this._pipeCache = /* @__PURE__ */ Object.create(null);
          this._pipeStateCaches = /* @__PURE__ */ Object.create(null);
          this._colorMask = 15;
          this._multisampleCount = 1;
          this._renderer = renderer;
        }
        contextChange(gpu) {
          this._gpu = gpu;
          this.setStencilMode(STENCIL_MODES.DISABLED);
          this._updatePipeHash();
        }
        setMultisampleCount(multisampleCount) {
          if (this._multisampleCount === multisampleCount)
            return;
          this._multisampleCount = multisampleCount;
          this._updatePipeHash();
        }
        setRenderTarget(renderTarget) {
          this._multisampleCount = renderTarget.msaaSamples;
          this._depthStencilAttachment = renderTarget.descriptor.depthStencilAttachment ? 1 : 0;
          this._updatePipeHash();
        }
        setColorMask(colorMask) {
          if (this._colorMask === colorMask)
            return;
          this._colorMask = colorMask;
          this._updatePipeHash();
        }
        setStencilMode(stencilMode) {
          if (this._stencilMode === stencilMode)
            return;
          this._stencilMode = stencilMode;
          this._stencilState = GpuStencilModesToPixi[stencilMode];
          this._updatePipeHash();
        }
        setPipeline(geometry, program, state, passEncoder) {
          const pipeline = this.getPipeline(geometry, program, state);
          passEncoder.setPipeline(pipeline);
        }
        getPipeline(geometry, program, state, topology) {
          if (!geometry._layoutKey) {
            ensureAttributes(geometry, program.attributeData);
            this._generateBufferKey(geometry);
          }
          topology = topology || geometry.topology;
          const key = getGraphicsStateKey(
            geometry._layoutKey,
            program._layoutKey,
            state.data,
            state._blendModeId,
            topologyStringToId[topology]
          );
          if (this._pipeCache[key])
            return this._pipeCache[key];
          this._pipeCache[key] = this._createPipeline(geometry, program, state, topology);
          return this._pipeCache[key];
        }
        _createPipeline(geometry, program, state, topology) {
          const device = this._gpu.device;
          const buffers = this._createVertexBufferLayouts(geometry);
          const blendModes = this._renderer.state.getColorTargets(state);
          blendModes[0].writeMask = this._stencilMode === STENCIL_MODES.RENDERING_MASK_ADD ? 0 : this._colorMask;
          const layout = this._renderer.shader.getProgramData(program).pipeline;
          const descriptor = {
            // TODO later check if its helpful to create..
            // layout,
            vertex: {
              module: this._getModule(program.vertex.source),
              entryPoint: program.vertex.entryPoint,
              // geometry..
              buffers
            },
            fragment: {
              module: this._getModule(program.fragment.source),
              entryPoint: program.fragment.entryPoint,
              targets: blendModes
            },
            primitive: {
              topology,
              cullMode: state.cullMode
            },
            layout,
            multisample: {
              count: this._multisampleCount
            },
            // depthStencil,
            label: `PIXI Pipeline`
          };
          if (this._depthStencilAttachment) {
            descriptor.depthStencil = {
              ...this._stencilState,
              format: "depth24plus-stencil8",
              depthWriteEnabled: state.depthTest,
              depthCompare: state.depthTest ? "less" : "always"
            };
          }
          const pipeline = device.createRenderPipeline(descriptor);
          return pipeline;
        }
        _getModule(code) {
          return this._moduleCache[code] || this._createModule(code);
        }
        _createModule(code) {
          const device = this._gpu.device;
          this._moduleCache[code] = device.createShaderModule({
            code
          });
          return this._moduleCache[code];
        }
        _generateBufferKey(geometry) {
          const keyGen = [];
          let index = 0;
          const attributeKeys = Object.keys(geometry.attributes).sort();
          for (let i2 = 0; i2 < attributeKeys.length; i2++) {
            const attribute = geometry.attributes[attributeKeys[i2]];
            keyGen[index++] = attribute.location;
            keyGen[index++] = attribute.offset;
            keyGen[index++] = attribute.format;
            keyGen[index++] = attribute.stride;
          }
          const stringKey = keyGen.join("");
          geometry._layoutKey = createIdFromString(stringKey, "geometry");
          return geometry._layoutKey;
        }
        _createVertexBufferLayouts(geometry) {
          if (this._bufferLayoutsCache[geometry._layoutKey]) {
            return this._bufferLayoutsCache[geometry._layoutKey];
          }
          const vertexBuffersLayout = [];
          geometry.buffers.forEach((buffer) => {
            const bufferEntry = {
              arrayStride: 0,
              stepMode: "vertex",
              attributes: []
            };
            const bufferEntryAttributes = bufferEntry.attributes;
            for (const i2 in geometry.attributes) {
              const attribute = geometry.attributes[i2];
              if (attribute.buffer === buffer) {
                bufferEntry.arrayStride = attribute.stride;
                bufferEntry.stepMode = attribute.instance ? "instance" : "vertex";
                bufferEntryAttributes.push({
                  shaderLocation: attribute.location,
                  offset: attribute.offset,
                  format: attribute.format
                });
              }
            }
            if (bufferEntryAttributes.length) {
              vertexBuffersLayout.push(bufferEntry);
            }
          });
          this._bufferLayoutsCache[geometry._layoutKey] = vertexBuffersLayout;
          return vertexBuffersLayout;
        }
        _updatePipeHash() {
          const key = getGlobalStateKey(
            this._stencilMode,
            this._multisampleCount,
            this._colorMask,
            this._depthStencilAttachment
          );
          if (!this._pipeStateCaches[key]) {
            this._pipeStateCaches[key] = /* @__PURE__ */ Object.create(null);
          }
          this._pipeCache = this._pipeStateCaches[key];
        }
        destroy() {
          this._renderer = null;
          this._bufferLayoutsCache = null;
        }
      };
      PipelineSystem.extension = {
        type: [ExtensionType.WebGPUSystem],
        name: "pipeline"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.mjs
  function calculateProjection(pm, x2, y2, width, height, flipY) {
    const sign = flipY ? 1 : -1;
    pm.identity();
    pm.a = 1 / width * 2;
    pm.d = sign * (1 / height * 2);
    pm.tx = -1 - x2 * pm.a;
    pm.ty = -sign - y2 * pm.d;
    return pm;
  }
  var init_calculateProjection = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs
  function isRenderingToScreen(renderTarget) {
    const resource = renderTarget.colorTexture.source.resource;
    return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement && document.body.contains(resource);
  }
  var init_isRenderingToScreen = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs
  var RenderTargetSystem;
  var init_RenderTargetSystem = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs"() {
      init_Matrix();
      init_Rectangle();
      init_const8();
      init_calculateProjection();
      init_SystemRunner();
      init_CanvasSource();
      init_TextureSource();
      init_Texture();
      init_getCanvasTexture();
      init_isRenderingToScreen();
      init_RenderTarget();
      RenderTargetSystem = class {
        constructor(renderer) {
          this.rootViewPort = new Rectangle();
          this.viewport = new Rectangle();
          this.onRenderTargetChange = new SystemRunner("onRenderTargetChange");
          this.projectionMatrix = new Matrix();
          this.defaultClearColor = [0, 0, 0, 0];
          this._renderSurfaceToRenderTargetHash = /* @__PURE__ */ new Map();
          this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
          this._renderTargetStack = [];
          this._renderer = renderer;
        }
        /** called when dev wants to finish a render pass */
        finishRenderPass() {
          this.adaptor.finishRenderPass(this.renderTarget);
        }
        /**
         * called when the renderer starts to render a scene.
         * @param options
         * @param options.target - the render target to render to
         * @param options.clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111
         * @param options.clearColor - the color to clear to
         * @param options.frame - the frame to render to
         */
        renderStart({
          target,
          clear,
          clearColor,
          frame
        }) {
          this._renderTargetStack.length = 0;
          this.push(
            target,
            clear,
            clearColor,
            frame
          );
          this.rootViewPort.copyFrom(this.viewport);
          this.rootRenderTarget = this.renderTarget;
          this.renderingToScreen = isRenderingToScreen(this.rootRenderTarget);
        }
        /**
         * Binding a render surface! This is the main function of the render target system.
         * It will take the RenderSurface (which can be a texture, canvas, or render target) and bind it to the renderer.
         * Once bound all draw calls will be rendered to the render surface.
         *
         * If a frame is not provide and the render surface is a texture, the frame of the texture will be used.
         * @param renderSurface - the render surface to bind
         * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111
         * @param clearColor - the color to clear to
         * @param frame - the frame to render to
         * @returns the render target that was bound
         */
        bind(renderSurface, clear = true, clearColor, frame) {
          const renderTarget = this.getRenderTarget(renderSurface);
          const didChange = this.renderTarget !== renderTarget;
          this.renderTarget = renderTarget;
          this.renderSurface = renderSurface;
          const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);
          if (renderTarget.pixelWidth !== gpuRenderTarget.width || renderTarget.pixelHeight !== gpuRenderTarget.height) {
            this.adaptor.resizeGpuRenderTarget(renderTarget);
            gpuRenderTarget.width = renderTarget.pixelWidth;
            gpuRenderTarget.height = renderTarget.pixelHeight;
          }
          const source2 = renderTarget.colorTexture;
          const viewport = this.viewport;
          const pixelWidth = source2.pixelWidth;
          const pixelHeight = source2.pixelHeight;
          if (!frame && renderSurface instanceof Texture) {
            frame = renderSurface.frame;
          }
          if (frame) {
            const resolution = source2._resolution;
            viewport.x = frame.x * resolution + 0.5 | 0;
            viewport.y = frame.y * resolution + 0.5 | 0;
            viewport.width = frame.width * resolution + 0.5 | 0;
            viewport.height = frame.height * resolution + 0.5 | 0;
          } else {
            viewport.x = 0;
            viewport.y = 0;
            viewport.width = pixelWidth;
            viewport.height = pixelHeight;
          }
          calculateProjection(
            this.projectionMatrix,
            0,
            0,
            viewport.width / source2.resolution,
            viewport.height / source2.resolution,
            !renderTarget.isRoot
          );
          this.adaptor.startRenderPass(renderTarget, clear, clearColor, viewport);
          if (didChange) {
            this.onRenderTargetChange.emit(renderTarget);
          }
          return renderTarget;
        }
        clear(target, clear = CLEAR.ALL, clearColor) {
          if (!clear)
            return;
          if (target) {
            target = this.getRenderTarget(target);
          }
          this.adaptor.clear(
            target || this.renderTarget,
            clear,
            clearColor,
            this.viewport
          );
        }
        contextChange() {
          this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
        }
        /**
         * Push a render surface to the renderer. This will bind the render surface to the renderer,
         * @param renderSurface - the render surface to push
         * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111
         * @param clearColor - the color to clear to
         * @param frame - the frame to use when rendering to the render surface
         */
        push(renderSurface, clear = CLEAR.ALL, clearColor, frame) {
          const renderTarget = this.bind(renderSurface, clear, clearColor, frame);
          this._renderTargetStack.push({
            renderTarget,
            frame
          });
          return renderTarget;
        }
        /** Pops the current render target from the renderer and restores the previous render target. */
        pop() {
          this._renderTargetStack.pop();
          const currentRenderTargetData = this._renderTargetStack[this._renderTargetStack.length - 1];
          this.bind(currentRenderTargetData.renderTarget, false, null, currentRenderTargetData.frame);
        }
        /**
         * Gets the render target from the provide render surface. Eg if its a texture,
         * it will return the render target for the texture.
         * If its a render target, it will return the same render target.
         * @param renderSurface - the render surface to get the render target for
         * @returns the render target for the render surface
         */
        getRenderTarget(renderSurface) {
          if (renderSurface.isTexture) {
            renderSurface = renderSurface.source;
          }
          return this._renderSurfaceToRenderTargetHash.get(renderSurface) ?? this._initRenderTarget(renderSurface);
        }
        /**
         * Copies a render surface to another texture
         * @param sourceRenderSurfaceTexture - the render surface to copy from
         * @param destinationTexture - the texture to copy to
         * @param originSrc - the origin of the copy
         * @param originSrc.x - the x origin of the copy
         * @param originSrc.y - the y origin of the copy
         * @param size - the size of the copy
         * @param size.width - the width of the copy
         * @param size.height - the height of the copy
         * @param originDest - the destination origin (top left to paste from!)
         * @param originDest.x - the x origin of the paste
         * @param originDest.y - the y origin of the paste
         */
        copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {
          if (originSrc.x < 0) {
            size.width += originSrc.x;
            originDest.x -= originSrc.x;
            originSrc.x = 0;
          }
          if (originSrc.y < 0) {
            size.height += originSrc.y;
            originDest.y -= originSrc.y;
            originSrc.y = 0;
          }
          const { pixelWidth, pixelHeight } = sourceRenderSurfaceTexture;
          size.width = Math.min(size.width, pixelWidth - originSrc.x);
          size.height = Math.min(size.height, pixelHeight - originSrc.y);
          return this.adaptor.copyToTexture(
            sourceRenderSurfaceTexture,
            destinationTexture,
            originSrc,
            size,
            originDest
          );
        }
        /**
         * ensures that we have a depth stencil buffer available to render to
         * This is used by the mask system to make sure we have a stencil buffer.
         */
        ensureDepthStencil() {
          if (!this.renderTarget.stencil) {
            this.renderTarget.stencil = true;
            this.adaptor.startRenderPass(this.renderTarget, false, null, this.viewport);
          }
        }
        /** nukes the render target system */
        destroy() {
          this._renderer = null;
          this._renderSurfaceToRenderTargetHash.forEach((renderTarget, key) => {
            if (renderTarget !== key) {
              renderTarget.destroy();
            }
          });
          this._renderSurfaceToRenderTargetHash.clear();
          this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
        }
        _initRenderTarget(renderSurface) {
          let renderTarget = null;
          if (CanvasSource.test(renderSurface)) {
            renderSurface = getCanvasTexture(renderSurface).source;
          }
          if (renderSurface instanceof RenderTarget) {
            renderTarget = renderSurface;
          } else if (renderSurface instanceof TextureSource) {
            renderTarget = new RenderTarget({
              colorTextures: [renderSurface]
            });
            if (CanvasSource.test(renderSurface.source.resource)) {
              renderTarget.isRoot = true;
            }
            renderSurface.once("destroy", () => {
              renderTarget.destroy();
              const gpuRenderTarget = this._gpuRenderTargetHash[renderTarget.uid];
              if (gpuRenderTarget) {
                this._gpuRenderTargetHash[renderTarget.uid] = null;
                this.adaptor.destroyGpuRenderTarget(gpuRenderTarget);
              }
            });
          }
          this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);
          return renderTarget;
        }
        getGpuRenderTarget(renderTarget) {
          return this._gpuRenderTargetHash[renderTarget.uid] || (this._gpuRenderTargetHash[renderTarget.uid] = this.adaptor.initGpuRenderTarget(renderTarget));
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs
  var GpuRenderTarget;
  var init_GpuRenderTarget = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs"() {
      "use strict";
      GpuRenderTarget = class {
        constructor() {
          this.contexts = [];
          this.msaaTextures = [];
          this.msaaSamples = 1;
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.mjs
  var GpuRenderTargetAdaptor;
  var init_GpuRenderTargetAdaptor = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.mjs"() {
      init_const8();
      init_CanvasSource();
      init_TextureSource();
      init_GpuRenderTarget();
      GpuRenderTargetAdaptor = class {
        init(renderer, renderTargetSystem) {
          this._renderer = renderer;
          this._renderTargetSystem = renderTargetSystem;
        }
        copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {
          const renderer = this._renderer;
          const baseGpuTexture = this._getGpuColorTexture(
            sourceRenderSurfaceTexture
          );
          const backGpuTexture = renderer.texture.getGpuSource(
            destinationTexture.source
          );
          renderer.encoder.commandEncoder.copyTextureToTexture(
            {
              texture: baseGpuTexture,
              origin: originSrc
            },
            {
              texture: backGpuTexture,
              origin: originDest
            },
            size
          );
          return destinationTexture;
        }
        startRenderPass(renderTarget, clear = true, clearColor, viewport) {
          const renderTargetSystem = this._renderTargetSystem;
          const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
          const descriptor = this.getDescriptor(renderTarget, clear, clearColor);
          gpuRenderTarget.descriptor = descriptor;
          this._renderer.pipeline.setRenderTarget(gpuRenderTarget);
          this._renderer.encoder.beginRenderPass(gpuRenderTarget);
          this._renderer.encoder.setViewport(viewport);
        }
        finishRenderPass() {
          this._renderer.encoder.endRenderPass();
        }
        /**
         * returns the gpu texture for the first color texture in the render target
         * mainly used by the filter manager to get copy the texture for blending
         * @param renderTarget
         * @returns a gpu texture
         */
        _getGpuColorTexture(renderTarget) {
          const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
          if (gpuRenderTarget.contexts[0]) {
            return gpuRenderTarget.contexts[0].getCurrentTexture();
          }
          return this._renderer.texture.getGpuSource(
            renderTarget.colorTextures[0].source
          );
        }
        getDescriptor(renderTarget, clear, clearValue) {
          if (typeof clear === "boolean") {
            clear = clear ? CLEAR.ALL : CLEAR.NONE;
          }
          const renderTargetSystem = this._renderTargetSystem;
          const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
          const colorAttachments = renderTarget.colorTextures.map(
            (texture, i2) => {
              const context4 = gpuRenderTarget.contexts[i2];
              let view;
              let resolveTarget;
              if (context4) {
                const currentTexture = context4.getCurrentTexture();
                const canvasTextureView = currentTexture.createView();
                view = canvasTextureView;
              } else {
                view = this._renderer.texture.getGpuSource(texture).createView({
                  mipLevelCount: 1
                });
              }
              if (gpuRenderTarget.msaaTextures[i2]) {
                resolveTarget = view;
                view = this._renderer.texture.getTextureView(
                  gpuRenderTarget.msaaTextures[i2]
                );
              }
              const loadOp = clear & CLEAR.COLOR ? "clear" : "load";
              clearValue ?? (clearValue = renderTargetSystem.defaultClearColor);
              return {
                view,
                resolveTarget,
                clearValue,
                storeOp: "store",
                loadOp
              };
            }
          );
          let depthStencilAttachment;
          if ((renderTarget.stencil || renderTarget.depth) && !renderTarget.depthStencilTexture) {
            renderTarget.ensureDepthStencilTexture();
            renderTarget.depthStencilTexture.source.sampleCount = gpuRenderTarget.msaa ? 4 : 1;
          }
          if (renderTarget.depthStencilTexture) {
            const stencilLoadOp = clear & CLEAR.STENCIL ? "clear" : "load";
            const depthLoadOp = clear & CLEAR.DEPTH ? "clear" : "load";
            depthStencilAttachment = {
              view: this._renderer.texture.getGpuSource(renderTarget.depthStencilTexture.source).createView(),
              stencilStoreOp: "store",
              stencilLoadOp,
              depthClearValue: 1,
              depthLoadOp,
              depthStoreOp: "store"
            };
          }
          const descriptor = {
            colorAttachments,
            depthStencilAttachment
          };
          return descriptor;
        }
        clear(renderTarget, clear = true, clearColor, viewport) {
          if (!clear)
            return;
          const { gpu, encoder } = this._renderer;
          const device = gpu.device;
          const standAlone = encoder.commandEncoder === null;
          if (standAlone) {
            const commandEncoder = device.createCommandEncoder();
            const renderPassDescriptor = this.getDescriptor(renderTarget, clear, clearColor);
            const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
            passEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
            passEncoder.end();
            const gpuCommands = commandEncoder.finish();
            device.queue.submit([gpuCommands]);
          } else {
            this.startRenderPass(renderTarget, clear, clearColor, viewport);
          }
        }
        initGpuRenderTarget(renderTarget) {
          renderTarget.isRoot = true;
          const gpuRenderTarget = new GpuRenderTarget();
          renderTarget.colorTextures.forEach((colorTexture, i2) => {
            if (CanvasSource.test(colorTexture.resource)) {
              const context4 = colorTexture.resource.getContext(
                "webgpu"
              );
              const alphaMode = colorTexture.transparent ? "premultiplied" : "opaque";
              try {
                context4.configure({
                  device: this._renderer.gpu.device,
                  // eslint-disable-next-line max-len
                  usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
                  format: "bgra8unorm",
                  alphaMode
                });
              } catch (e2) {
                console.error(e2);
              }
              gpuRenderTarget.contexts[i2] = context4;
            }
            gpuRenderTarget.msaa = colorTexture.source.antialias;
            if (colorTexture.source.antialias) {
              const msaaTexture = new TextureSource({
                width: 0,
                height: 0,
                sampleCount: 4
              });
              gpuRenderTarget.msaaTextures[i2] = msaaTexture;
            }
          });
          if (gpuRenderTarget.msaa) {
            gpuRenderTarget.msaaSamples = 4;
            if (renderTarget.depthStencilTexture) {
              renderTarget.depthStencilTexture.source.sampleCount = 4;
            }
          }
          return gpuRenderTarget;
        }
        destroyGpuRenderTarget(gpuRenderTarget) {
          gpuRenderTarget.contexts.forEach((context4) => {
            context4.unconfigure();
          });
          gpuRenderTarget.msaaTextures.forEach((texture) => {
            texture.destroy();
          });
          gpuRenderTarget.msaaTextures.length = 0;
          gpuRenderTarget.contexts.length = 0;
        }
        ensureDepthStencilTexture(renderTarget) {
          const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
          if (renderTarget.depthStencilTexture && gpuRenderTarget.msaa) {
            renderTarget.depthStencilTexture.source.sampleCount = 4;
          }
        }
        resizeGpuRenderTarget(renderTarget) {
          const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
          gpuRenderTarget.width = renderTarget.width;
          gpuRenderTarget.height = renderTarget.height;
          if (gpuRenderTarget.msaa) {
            renderTarget.colorTextures.forEach((colorTexture, i2) => {
              const msaaTexture = gpuRenderTarget.msaaTextures[i2];
              msaaTexture?.resize(
                colorTexture.source.width,
                colorTexture.source.height,
                colorTexture.source._resolution
              );
            });
          }
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs
  var GpuRenderTargetSystem;
  var init_GpuRenderTargetSystem = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs"() {
      init_Extensions();
      init_RenderTargetSystem();
      init_GpuRenderTargetAdaptor();
      GpuRenderTargetSystem = class extends RenderTargetSystem {
        constructor(renderer) {
          super(renderer);
          this.adaptor = new GpuRenderTargetAdaptor();
          this.adaptor.init(renderer, this);
        }
      };
      GpuRenderTargetSystem.extension = {
        type: [ExtensionType.WebGPUSystem],
        name: "renderTarget"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuShaderSystem.mjs
  var GpuShaderSystem;
  var init_GpuShaderSystem = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuShaderSystem.mjs"() {
      init_Extensions();
      GpuShaderSystem = class {
        constructor() {
          this._gpuProgramData = /* @__PURE__ */ Object.create(null);
        }
        contextChange(gpu) {
          this._gpu = gpu;
        }
        getProgramData(program) {
          return this._gpuProgramData[program._layoutKey] || this._createGPUProgramData(program);
        }
        _createGPUProgramData(program) {
          const device = this._gpu.device;
          const bindGroups = program.gpuLayout.map((group) => device.createBindGroupLayout({ entries: group }));
          const pipelineLayoutDesc = { bindGroupLayouts: bindGroups };
          this._gpuProgramData[program._layoutKey] = {
            bindGroups,
            pipeline: device.createPipelineLayout(pipelineLayoutDesc)
          };
          return this._gpuProgramData[program._layoutKey];
        }
        destroy() {
          this._gpu = null;
          this._gpuProgramData = null;
        }
      };
      GpuShaderSystem.extension = {
        type: [
          ExtensionType.WebGPUSystem
        ],
        name: "shader"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs
  var GpuBlendModesToPixi;
  var init_GpuBlendModesToPixi = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs"() {
      "use strict";
      GpuBlendModesToPixi = {};
      GpuBlendModesToPixi.normal = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        }
      };
      GpuBlendModesToPixi.add = {
        alpha: {
          srcFactor: "src-alpha",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "one",
          dstFactor: "one",
          operation: "add"
        }
      };
      GpuBlendModesToPixi.multiply = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "dst",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        }
      };
      GpuBlendModesToPixi.screen = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "one",
          dstFactor: "one-minus-src",
          operation: "add"
        }
      };
      GpuBlendModesToPixi.overlay = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "one",
          dstFactor: "one-minus-src",
          operation: "add"
        }
      };
      GpuBlendModesToPixi.none = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "zero",
          dstFactor: "zero",
          operation: "add"
        }
      };
      GpuBlendModesToPixi["normal-npm"] = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "src-alpha",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        }
      };
      GpuBlendModesToPixi["add-npm"] = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one",
          operation: "add"
        },
        color: {
          srcFactor: "src-alpha",
          dstFactor: "one",
          operation: "add"
        }
      };
      GpuBlendModesToPixi["screen-npm"] = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "src-alpha",
          dstFactor: "one-minus-src",
          operation: "add"
        }
      };
      GpuBlendModesToPixi.erase = {
        alpha: {
          srcFactor: "zero",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "zero",
          dstFactor: "one-minus-src",
          operation: "add"
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStateSystem.mjs
  var GpuStateSystem;
  var init_GpuStateSystem = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStateSystem.mjs"() {
      init_Extensions();
      init_State();
      init_GpuBlendModesToPixi();
      GpuStateSystem = class {
        constructor() {
          this.defaultState = new State();
          this.defaultState.blend = true;
        }
        contextChange(gpu) {
          this.gpu = gpu;
        }
        /**
         * Gets the blend mode data for the current state
         * @param state - The state to get the blend mode from
         */
        getColorTargets(state) {
          const blend = GpuBlendModesToPixi[state.blendMode] || GpuBlendModesToPixi.normal;
          return [
            {
              format: "bgra8unorm",
              writeMask: 0,
              blend
            }
          ];
        }
        destroy() {
          this.gpu = null;
        }
      };
      GpuStateSystem.extension = {
        type: [
          ExtensionType.WebGPUSystem
        ],
        name: "state"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs
  var gpuUploadBufferImageResource;
  var init_gpuUploadBufferImageResource = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs"() {
      "use strict";
      gpuUploadBufferImageResource = {
        type: "image",
        upload(source2, gpuTexture, gpu) {
          const resource = source2.resource;
          const total = (source2.pixelWidth | 0) * (source2.pixelHeight | 0);
          const bytesPerPixel = resource.byteLength / total;
          gpu.device.queue.writeTexture(
            { texture: gpuTexture },
            resource,
            {
              offset: 0,
              rowsPerImage: source2.pixelHeight,
              bytesPerRow: source2.pixelHeight * bytesPerPixel
            },
            {
              width: source2.pixelWidth,
              height: source2.pixelHeight,
              depthOrArrayLayers: 1
            }
          );
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.mjs
  var blockDataMap, defaultBlockData, gpuUploadCompressedTextureResource;
  var init_gpuUploadCompressedTextureResource = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.mjs"() {
      "use strict";
      blockDataMap = {
        "bc1-rgba-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
        "bc2-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
        "bc3-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
        "bc7-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
        "etc1-rgb-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
        "etc2-rgba8unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
        "astc-4x4-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }
      };
      defaultBlockData = { blockBytes: 4, blockWidth: 1, blockHeight: 1 };
      gpuUploadCompressedTextureResource = {
        type: "compressed",
        upload(source2, gpuTexture, gpu) {
          let mipWidth = source2.pixelWidth;
          let mipHeight = source2.pixelHeight;
          const blockData = blockDataMap[source2.format] || defaultBlockData;
          for (let i2 = 0; i2 < source2.resource.length; i2++) {
            const levelBuffer = source2.resource[i2];
            const bytesPerRow = Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockBytes;
            gpu.device.queue.writeTexture(
              {
                texture: gpuTexture,
                mipLevel: i2
              },
              levelBuffer,
              {
                offset: 0,
                bytesPerRow
              },
              {
                width: Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockWidth,
                height: Math.ceil(mipHeight / blockData.blockHeight) * blockData.blockHeight,
                depthOrArrayLayers: 1
              }
            );
            mipWidth = Math.max(mipWidth >> 1, 1);
            mipHeight = Math.max(mipHeight >> 1, 1);
          }
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs
  var gpuUploadImageResource;
  var init_gpuUploadImageSource = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs"() {
      "use strict";
      gpuUploadImageResource = {
        type: "image",
        upload(source2, gpuTexture, gpu) {
          const resource = source2.resource;
          if (!resource)
            return;
          const width = Math.min(gpuTexture.width, source2.resourceWidth || source2.pixelWidth);
          const height = Math.min(gpuTexture.height, source2.resourceHeight || source2.pixelHeight);
          const premultipliedAlpha = source2.alphaMode === "premultiply-alpha-on-upload";
          gpu.device.queue.copyExternalImageToTexture(
            { source: resource },
            { texture: gpuTexture, premultipliedAlpha },
            {
              width,
              height
            }
          );
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs
  var gpuUploadVideoResource;
  var init_gpuUploadVideoSource = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs"() {
      init_gpuUploadImageSource();
      gpuUploadVideoResource = {
        type: "video",
        upload(source2, gpuTexture, gpu) {
          gpuUploadImageResource.upload(source2, gpuTexture, gpu);
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs
  var GpuMipmapGenerator;
  var init_GpuMipmapGenerator = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs"() {
      "use strict";
      GpuMipmapGenerator = class {
        constructor(device) {
          this.device = device;
          this.sampler = device.createSampler({ minFilter: "linear" });
          this.pipelines = {};
        }
        _getMipmapPipeline(format) {
          let pipeline = this.pipelines[format];
          if (!pipeline) {
            if (!this.mipmapShaderModule) {
              this.mipmapShaderModule = this.device.createShaderModule({
                code: (
                  /* wgsl */
                  `
                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

                        struct VertexOutput {
                        @builtin(position) position : vec4<f32>,
                        @location(0) texCoord : vec2<f32>,
                        };

                        @vertex
                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                        var output : VertexOutput;
                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                        return output;
                        }

                        @group(0) @binding(0) var imgSampler : sampler;
                        @group(0) @binding(1) var img : texture_2d<f32>;

                        @fragment
                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
                        return textureSample(img, imgSampler, texCoord);
                        }
                    `
                )
              });
            }
            pipeline = this.device.createRenderPipeline({
              layout: "auto",
              vertex: {
                module: this.mipmapShaderModule,
                entryPoint: "vertexMain"
              },
              fragment: {
                module: this.mipmapShaderModule,
                entryPoint: "fragmentMain",
                targets: [{ format }]
              }
            });
            this.pipelines[format] = pipeline;
          }
          return pipeline;
        }
        /**
         * Generates mipmaps for the given GPUTexture from the data in level 0.
         * @param {module:External.GPUTexture} texture - Texture to generate mipmaps for.
         * @returns {module:External.GPUTexture} - The originally passed texture
         */
        generateMipmap(texture) {
          const pipeline = this._getMipmapPipeline(texture.format);
          if (texture.dimension === "3d" || texture.dimension === "1d") {
            throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");
          }
          let mipTexture = texture;
          const arrayLayerCount = texture.depthOrArrayLayers || 1;
          const renderToSource = texture.usage & GPUTextureUsage.RENDER_ATTACHMENT;
          if (!renderToSource) {
            const mipTextureDescriptor = {
              size: {
                width: Math.ceil(texture.width / 2),
                height: Math.ceil(texture.height / 2),
                depthOrArrayLayers: arrayLayerCount
              },
              format: texture.format,
              usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,
              mipLevelCount: texture.mipLevelCount - 1
            };
            mipTexture = this.device.createTexture(mipTextureDescriptor);
          }
          const commandEncoder = this.device.createCommandEncoder({});
          const bindGroupLayout = pipeline.getBindGroupLayout(0);
          for (let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer) {
            let srcView = texture.createView({
              baseMipLevel: 0,
              mipLevelCount: 1,
              dimension: "2d",
              baseArrayLayer: arrayLayer,
              arrayLayerCount: 1
            });
            let dstMipLevel = renderToSource ? 1 : 0;
            for (let i2 = 1; i2 < texture.mipLevelCount; ++i2) {
              const dstView = mipTexture.createView({
                baseMipLevel: dstMipLevel++,
                mipLevelCount: 1,
                dimension: "2d",
                baseArrayLayer: arrayLayer,
                arrayLayerCount: 1
              });
              const passEncoder = commandEncoder.beginRenderPass({
                colorAttachments: [{
                  view: dstView,
                  storeOp: "store",
                  loadOp: "clear",
                  clearValue: { r: 0, g: 0, b: 0, a: 0 }
                }]
              });
              const bindGroup = this.device.createBindGroup({
                layout: bindGroupLayout,
                entries: [{
                  binding: 0,
                  resource: this.sampler
                }, {
                  binding: 1,
                  resource: srcView
                }]
              });
              passEncoder.setPipeline(pipeline);
              passEncoder.setBindGroup(0, bindGroup);
              passEncoder.draw(3, 1, 0, 0);
              passEncoder.end();
              srcView = dstView;
            }
          }
          if (!renderToSource) {
            const mipLevelSize = {
              width: Math.ceil(texture.width / 2),
              height: Math.ceil(texture.height / 2),
              depthOrArrayLayers: arrayLayerCount
            };
            for (let i2 = 1; i2 < texture.mipLevelCount; ++i2) {
              commandEncoder.copyTextureToTexture({
                texture: mipTexture,
                mipLevel: i2 - 1
              }, {
                texture,
                mipLevel: i2
              }, mipLevelSize);
              mipLevelSize.width = Math.ceil(mipLevelSize.width / 2);
              mipLevelSize.height = Math.ceil(mipLevelSize.height / 2);
            }
          }
          this.device.queue.submit([commandEncoder.finish()]);
          if (!renderToSource) {
            mipTexture.destroy();
          }
          return texture;
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/GpuTextureSystem.mjs
  var GpuTextureSystem;
  var init_GpuTextureSystem = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/GpuTextureSystem.mjs"() {
      init_adapter();
      init_Extensions();
      init_CanvasPool();
      init_BindGroup();
      init_gpuUploadBufferImageResource();
      init_gpuUploadCompressedTextureResource();
      init_gpuUploadImageSource();
      init_gpuUploadVideoSource();
      init_GpuMipmapGenerator();
      GpuTextureSystem = class {
        constructor(renderer) {
          this.managedTextures = [];
          this._gpuSources = /* @__PURE__ */ Object.create(null);
          this._gpuSamplers = /* @__PURE__ */ Object.create(null);
          this._bindGroupHash = /* @__PURE__ */ Object.create(null);
          this._textureViewHash = /* @__PURE__ */ Object.create(null);
          this._uploads = {
            image: gpuUploadImageResource,
            buffer: gpuUploadBufferImageResource,
            video: gpuUploadVideoResource,
            compressed: gpuUploadCompressedTextureResource
          };
          this._renderer = renderer;
        }
        contextChange(gpu) {
          this._gpu = gpu;
        }
        initSource(source2) {
          if (source2.autoGenerateMipmaps) {
            const biggestDimension = Math.max(source2.pixelWidth, source2.pixelHeight);
            source2.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;
          }
          let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
          if (source2.uploadMethodId !== "compressed") {
            usage |= GPUTextureUsage.RENDER_ATTACHMENT;
            usage |= GPUTextureUsage.COPY_SRC;
          }
          const blockData = blockDataMap[source2.format] || { blockBytes: 4, blockWidth: 1, blockHeight: 1 };
          const width = Math.ceil(source2.pixelWidth / blockData.blockWidth) * blockData.blockWidth;
          const height = Math.ceil(source2.pixelHeight / blockData.blockHeight) * blockData.blockHeight;
          const textureDescriptor = {
            label: source2.label,
            size: { width, height },
            format: source2.format,
            sampleCount: source2.sampleCount,
            mipLevelCount: source2.mipLevelCount,
            dimension: source2.dimension,
            usage
          };
          const gpuTexture = this._gpu.device.createTexture(textureDescriptor);
          this._gpuSources[source2.uid] = gpuTexture;
          if (!this.managedTextures.includes(source2)) {
            source2.on("update", this.onSourceUpdate, this);
            source2.on("resize", this.onSourceResize, this);
            source2.on("destroy", this.onSourceDestroy, this);
            source2.on("unload", this.onSourceUnload, this);
            source2.on("updateMipmaps", this.onUpdateMipmaps, this);
            this.managedTextures.push(source2);
          }
          this.onSourceUpdate(source2);
          return gpuTexture;
        }
        onSourceUpdate(source2) {
          const gpuTexture = this.getGpuSource(source2);
          if (!gpuTexture)
            return;
          if (this._uploads[source2.uploadMethodId]) {
            this._uploads[source2.uploadMethodId].upload(source2, gpuTexture, this._gpu);
          }
          if (source2.autoGenerateMipmaps && source2.mipLevelCount > 1) {
            this.onUpdateMipmaps(source2);
          }
        }
        onSourceUnload(source2) {
          const gpuTexture = this._gpuSources[source2.uid];
          if (gpuTexture) {
            this._gpuSources[source2.uid] = null;
            gpuTexture.destroy();
          }
        }
        onUpdateMipmaps(source2) {
          if (!this._mipmapGenerator) {
            this._mipmapGenerator = new GpuMipmapGenerator(this._gpu.device);
          }
          const gpuTexture = this.getGpuSource(source2);
          this._mipmapGenerator.generateMipmap(gpuTexture);
        }
        onSourceDestroy(source2) {
          source2.off("update", this.onSourceUpdate, this);
          source2.off("unload", this.onSourceUnload, this);
          source2.off("destroy", this.onSourceDestroy, this);
          source2.off("resize", this.onSourceResize, this);
          source2.off("updateMipmaps", this.onUpdateMipmaps, this);
          this.managedTextures.splice(this.managedTextures.indexOf(source2), 1);
          this.onSourceUnload(source2);
        }
        onSourceResize(source2) {
          const gpuTexture = this._gpuSources[source2.uid];
          if (!gpuTexture) {
            this.initSource(source2);
          } else if (gpuTexture.width !== source2.pixelWidth || gpuTexture.height !== source2.pixelHeight) {
            this._textureViewHash[source2.uid] = null;
            this._bindGroupHash[source2.uid] = null;
            this.onSourceUnload(source2);
            this.initSource(source2);
          }
        }
        _initSampler(sampler) {
          this._gpuSamplers[sampler._resourceId] = this._gpu.device.createSampler(sampler);
          return this._gpuSamplers[sampler._resourceId];
        }
        getGpuSampler(sampler) {
          return this._gpuSamplers[sampler._resourceId] || this._initSampler(sampler);
        }
        getGpuSource(source2) {
          return this._gpuSources[source2.uid] || this.initSource(source2);
        }
        getTextureBindGroup(texture) {
          return this._bindGroupHash[texture.uid] ?? this._createTextureBindGroup(texture);
        }
        _createTextureBindGroup(texture) {
          const source2 = texture.source;
          const bindGroupId = source2.uid;
          this._bindGroupHash[bindGroupId] = new BindGroup({
            0: source2,
            1: source2.style
          });
          return this._bindGroupHash[bindGroupId];
        }
        getTextureView(texture) {
          const source2 = texture.source;
          return this._textureViewHash[source2.uid] ?? this._createTextureView(source2);
        }
        _createTextureView(texture) {
          this._textureViewHash[texture.uid] = this.getGpuSource(texture).createView();
          return this._textureViewHash[texture.uid];
        }
        generateCanvas(texture) {
          const renderer = this._renderer;
          const commandEncoder = renderer.gpu.device.createCommandEncoder();
          const canvas = DOMAdapter.get().createCanvas();
          canvas.width = texture.source.pixelWidth;
          canvas.height = texture.source.pixelHeight;
          const context4 = canvas.getContext("webgpu");
          context4.configure({
            device: renderer.gpu.device,
            // eslint-disable-next-line max-len
            usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,
            format: navigator.gpu.getPreferredCanvasFormat(),
            alphaMode: "premultiplied"
          });
          commandEncoder.copyTextureToTexture({
            texture: renderer.texture.getGpuSource(texture.source),
            origin: {
              x: 0,
              y: 0
            }
          }, {
            texture: context4.getCurrentTexture()
          }, {
            width: canvas.width,
            height: canvas.height
          });
          renderer.gpu.device.queue.submit([commandEncoder.finish()]);
          return canvas;
        }
        getPixels(texture) {
          const webGPUCanvas = this.generateCanvas(texture);
          const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(webGPUCanvas.width, webGPUCanvas.height);
          const context4 = canvasAndContext.context;
          context4.drawImage(webGPUCanvas, 0, 0);
          const { width, height } = webGPUCanvas;
          const imageData = context4.getImageData(0, 0, width, height);
          const pixels = new Uint8ClampedArray(imageData.data.buffer);
          CanvasPool.returnCanvasAndContext(canvasAndContext);
          return { pixels, width, height };
        }
        destroy() {
          this.managedTextures.slice().forEach((source2) => this.onSourceDestroy(source2));
          this.managedTextures = null;
          for (const k2 of Object.keys(this._bindGroupHash)) {
            const key = Number(k2);
            const bindGroup = this._bindGroupHash[key];
            bindGroup?.destroy();
            this._bindGroupHash[key] = null;
          }
          this._gpu = null;
          this._mipmapGenerator = null;
          this._gpuSources = null;
          this._bindGroupHash = null;
          this._textureViewHash = null;
          this._gpuSamplers = null;
        }
      };
      GpuTextureSystem.extension = {
        type: [
          ExtensionType.WebGPUSystem
        ],
        name: "texture"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.mjs
  var WebGPURenderer_exports = {};
  __export(WebGPURenderer_exports, {
    WebGPURenderer: () => WebGPURenderer
  });
  var DefaultWebGPUSystems, DefaultWebGPUPipes, DefaultWebGPUAdapters, systems, renderPipes, renderPipeAdaptors, WebGPURenderer;
  var init_WebGPURenderer = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.mjs"() {
      init_Extensions();
      init_GpuGraphicsAdaptor();
      init_GpuMeshAdapter();
      init_GpuBatchAdaptor();
      init_AbstractRenderer();
      init_SharedSystems();
      init_types();
      init_BindGroupSystem();
      init_GpuBufferSystem();
      init_GpuColorMaskSystem();
      init_GpuDeviceSystem();
      init_GpuEncoderSystem();
      init_GpuStencilSystem();
      init_GpuUboSystem();
      init_GpuUniformBatchPipe();
      init_PipelineSystem();
      init_GpuRenderTargetSystem();
      init_GpuShaderSystem();
      init_GpuStateSystem();
      init_GpuTextureSystem();
      DefaultWebGPUSystems = [
        ...SharedSystems,
        GpuUboSystem,
        GpuEncoderSystem,
        GpuDeviceSystem,
        GpuBufferSystem,
        GpuTextureSystem,
        GpuRenderTargetSystem,
        GpuShaderSystem,
        GpuStateSystem,
        PipelineSystem,
        GpuColorMaskSystem,
        GpuStencilSystem,
        BindGroupSystem
      ];
      DefaultWebGPUPipes = [...SharedRenderPipes, GpuUniformBatchPipe];
      DefaultWebGPUAdapters = [GpuBatchAdaptor, GpuMeshAdapter, GpuGraphicsAdaptor];
      systems = [];
      renderPipes = [];
      renderPipeAdaptors = [];
      extensions.handleByNamedList(ExtensionType.WebGPUSystem, systems);
      extensions.handleByNamedList(ExtensionType.WebGPUPipes, renderPipes);
      extensions.handleByNamedList(ExtensionType.WebGPUPipesAdaptor, renderPipeAdaptors);
      extensions.add(...DefaultWebGPUSystems, ...DefaultWebGPUPipes, ...DefaultWebGPUAdapters);
      WebGPURenderer = class extends AbstractRenderer {
        constructor() {
          const systemConfig = {
            name: "webgpu",
            type: RendererType.WEBGPU,
            systems,
            renderPipes,
            renderPipeAdaptors
          };
          super(systemConfig);
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/graphics/gl/GlGraphicsAdaptor.mjs
  var GlGraphicsAdaptor;
  var init_GlGraphicsAdaptor = __esm({
    "../core/node_modules/pixi.js/lib/scene/graphics/gl/GlGraphicsAdaptor.mjs"() {
      init_Extensions();
      init_Matrix();
      init_const4();
      init_compileHighShaderToProgram();
      init_colorBit();
      init_generateTextureBatchBit();
      init_localUniformBit();
      init_roundPixelsBit();
      init_batchSamplersUniformGroup();
      init_Shader();
      init_UniformGroup();
      GlGraphicsAdaptor = class {
        init() {
          const uniforms = new UniformGroup({
            uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
            uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
            uRound: { value: 0, type: "f32" }
          });
          const glProgram2 = compileHighShaderGlProgram({
            name: "graphics",
            bits: [
              colorBitGl,
              generateTextureBatchBitGl(MAX_TEXTURES),
              localUniformBitGl,
              roundPixelsBitGl
            ]
          });
          this.shader = new Shader({
            glProgram: glProgram2,
            resources: {
              localUniforms: uniforms,
              batchSamplers: batchSamplersUniformGroup
            }
          });
        }
        execute(graphicsPipe, renderable) {
          const context4 = renderable.context;
          const shader = context4.customShader || this.shader;
          const renderer = graphicsPipe.renderer;
          const contextSystem = renderer.graphicsContext;
          const {
            geometry,
            instructions
          } = contextSystem.getContextRenderData(context4);
          shader.groups[0] = renderer.globalUniforms.bindGroup;
          renderer.state.set(graphicsPipe.state);
          renderer.shader.bind(shader);
          renderer.geometry.bind(geometry, shader.glProgram);
          const batches = instructions.instructions;
          for (let i2 = 0; i2 < instructions.instructionSize; i2++) {
            const batch = batches[i2];
            if (batch.size) {
              for (let j2 = 0; j2 < batch.textures.textures.length; j2++) {
                renderer.texture.bind(batch.textures.textures[j2], j2);
              }
              renderer.geometry.draw("triangle-list", batch.size, batch.start);
            }
          }
        }
        destroy() {
          this.shader.destroy(true);
          this.shader = null;
        }
      };
      GlGraphicsAdaptor.extension = {
        type: [
          ExtensionType.WebGLPipesAdaptor
        ],
        name: "graphics"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/scene/mesh/gl/GlMeshAdaptor.mjs
  var GlMeshAdaptor;
  var init_GlMeshAdaptor = __esm({
    "../core/node_modules/pixi.js/lib/scene/mesh/gl/GlMeshAdaptor.mjs"() {
      init_Extensions();
      init_Matrix();
      init_compileHighShaderToProgram();
      init_localUniformBit();
      init_roundPixelsBit();
      init_textureBit();
      init_Shader();
      init_Texture();
      init_warn();
      GlMeshAdaptor = class {
        init() {
          const glProgram2 = compileHighShaderGlProgram({
            name: "mesh",
            bits: [
              localUniformBitGl,
              textureBitGl,
              roundPixelsBitGl
            ]
          });
          this._shader = new Shader({
            glProgram: glProgram2,
            resources: {
              uTexture: Texture.EMPTY.source,
              textureUniforms: {
                uTextureMatrix: { type: "mat3x3<f32>", value: new Matrix() }
              }
            }
          });
        }
        execute(meshPipe, mesh) {
          const renderer = meshPipe.renderer;
          let shader = mesh._shader;
          if (!shader) {
            shader = this._shader;
            const texture = mesh.texture;
            const source2 = texture.source;
            shader.resources.uTexture = source2;
            shader.resources.uSampler = source2.style;
            shader.resources.textureUniforms.uniforms.uTextureMatrix = texture.textureMatrix.mapCoord;
          } else if (!shader.glProgram) {
            warn("Mesh shader has no glProgram", mesh.shader);
            return;
          }
          shader.groups[100] = renderer.globalUniforms.bindGroup;
          shader.groups[101] = meshPipe.localUniformsBindGroup;
          renderer.encoder.draw({
            geometry: mesh._geometry,
            shader,
            state: mesh.state
          });
        }
        destroy() {
          this._shader.destroy(true);
          this._shader = null;
        }
      };
      GlMeshAdaptor.extension = {
        type: [
          ExtensionType.WebGLPipesAdaptor
        ],
        name: "mesh"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/batcher/gl/GlBatchAdaptor.mjs
  var GlBatchAdaptor;
  var init_GlBatchAdaptor = __esm({
    "../core/node_modules/pixi.js/lib/rendering/batcher/gl/GlBatchAdaptor.mjs"() {
      init_Extensions();
      init_compileHighShaderToProgram();
      init_colorBit();
      init_generateTextureBatchBit();
      init_roundPixelsBit();
      init_batchSamplersUniformGroup();
      init_Shader();
      init_State();
      init_const4();
      GlBatchAdaptor = class {
        constructor() {
          this._didUpload = false;
          this._tempState = State.for2d();
        }
        init(batcherPipe) {
          const glProgram2 = compileHighShaderGlProgram({
            name: "batch",
            bits: [
              colorBitGl,
              generateTextureBatchBitGl(MAX_TEXTURES),
              roundPixelsBitGl
            ]
          });
          this._shader = new Shader({
            glProgram: glProgram2,
            resources: {
              batchSamplers: batchSamplersUniformGroup
            }
          });
          batcherPipe.renderer.runners.contextChange.add(this);
        }
        contextChange() {
          this._didUpload = false;
        }
        start(batchPipe, geometry) {
          const renderer = batchPipe.renderer;
          renderer.shader.bind(this._shader, this._didUpload);
          renderer.shader.updateUniformGroup(renderer.globalUniforms.uniformGroup);
          renderer.geometry.bind(geometry, this._shader.glProgram);
        }
        execute(batchPipe, batch) {
          const renderer = batchPipe.renderer;
          this._didUpload = true;
          this._tempState.blendMode = batch.blendMode;
          renderer.state.set(this._tempState);
          const textures = batch.textures.textures;
          for (let i2 = 0; i2 < textures.length; i2++) {
            renderer.texture.bind(textures[i2], i2);
          }
          renderer.geometry.draw("triangle-list", batch.size, batch.start);
        }
        destroy() {
          this._shader.destroy(true);
          this._shader = null;
        }
      };
      GlBatchAdaptor.extension = {
        type: [
          ExtensionType.WebGLPipesAdaptor
        ],
        name: "batch"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/buffer/const.mjs
  var BUFFER_TYPE;
  var init_const9 = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/buffer/const.mjs"() {
      "use strict";
      BUFFER_TYPE = /* @__PURE__ */ ((BUFFER_TYPE2) => {
        BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
        BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
        BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
        return BUFFER_TYPE2;
      })(BUFFER_TYPE || {});
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBuffer.mjs
  var GlBuffer;
  var init_GlBuffer = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBuffer.mjs"() {
      "use strict";
      GlBuffer = class {
        constructor(buffer, type) {
          this.buffer = buffer || null;
          this.updateID = -1;
          this.byteLength = -1;
          this.type = type;
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBufferSystem.mjs
  var GlBufferSystem;
  var init_GlBufferSystem = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBufferSystem.mjs"() {
      init_Extensions();
      init_const3();
      init_const9();
      init_GlBuffer();
      GlBufferSystem = class {
        /**
         * @param {Renderer} renderer - The renderer this System works for.
         */
        constructor(renderer) {
          this._gpuBuffers = /* @__PURE__ */ Object.create(null);
          this._boundBufferBases = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
        }
        /**
         * @ignore
         */
        destroy() {
          this._renderer = null;
          this._gl = null;
          this._gpuBuffers = null;
          this._boundBufferBases = null;
        }
        /** Sets up the renderer context and necessary buffers. */
        contextChange() {
          this._gpuBuffers = /* @__PURE__ */ Object.create(null);
          this._gl = this._renderer.gl;
        }
        getGlBuffer(buffer) {
          return this._gpuBuffers[buffer.uid] || this.createGLBuffer(buffer);
        }
        /**
         * This binds specified buffer. On first run, it will create the webGL buffers for the context too
         * @param buffer - the buffer to bind to the renderer
         */
        bind(buffer) {
          const { _gl: gl } = this;
          const glBuffer = this.getGlBuffer(buffer);
          gl.bindBuffer(glBuffer.type, glBuffer.buffer);
        }
        /**
         * Binds an uniform buffer to at the given index.
         *
         * A cache is used so a buffer will not be bound again if already bound.
         * @param buffer - the buffer to bind
         * @param index - the base index to bind it to.
         */
        bindBufferBase(buffer, index) {
          const { _gl: gl } = this;
          if (this._boundBufferBases[index] !== buffer) {
            const glBuffer = this.getGlBuffer(buffer);
            this._boundBufferBases[index] = buffer;
            gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);
          }
        }
        /**
         * Binds a buffer whilst also binding its range.
         * This will make the buffer start from the offset supplied rather than 0 when it is read.
         * @param buffer - the buffer to bind
         * @param index - the base index to bind at, defaults to 0
         * @param offset - the offset to bind at (this is blocks of 256). 0 = 0, 1 = 256, 2 = 512 etc
         */
        bindBufferRange(buffer, index, offset) {
          const { _gl: gl } = this;
          offset = offset || 0;
          const glBuffer = this.getGlBuffer(buffer);
          gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, 256);
        }
        /**
         * Will ensure the data in the buffer is uploaded to the GPU.
         * @param {Buffer} buffer - the buffer to update
         */
        updateBuffer(buffer) {
          const { _gl: gl } = this;
          const glBuffer = this.getGlBuffer(buffer);
          if (buffer._updateID === glBuffer.updateID) {
            return glBuffer;
          }
          glBuffer.updateID = buffer._updateID;
          gl.bindBuffer(glBuffer.type, glBuffer.buffer);
          const data = buffer.data;
          if (glBuffer.byteLength >= buffer.data.byteLength) {
            gl.bufferSubData(glBuffer.type, 0, data, 0, buffer._updateSize / data.BYTES_PER_ELEMENT);
          } else {
            const drawType = buffer.descriptor.usage & BufferUsage.STATIC ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
            glBuffer.byteLength = data.byteLength;
            gl.bufferData(glBuffer.type, data, drawType);
          }
          return glBuffer;
        }
        /** dispose all WebGL resources of all managed buffers */
        destroyAll() {
          const gl = this._gl;
          for (const id in this._gpuBuffers) {
            gl.deleteBuffer(this._gpuBuffers[id].buffer);
          }
          this._gpuBuffers = /* @__PURE__ */ Object.create(null);
        }
        /**
         * Disposes buffer
         * @param {Buffer} buffer - buffer with data
         * @param {boolean} [contextLost=false] - If context was lost, we suppress deleteVertexArray
         */
        onBufferDestroy(buffer, contextLost) {
          const glBuffer = this._gpuBuffers[buffer.uid];
          const gl = this._gl;
          if (!contextLost) {
            gl.deleteBuffer(glBuffer.buffer);
          }
          this._gpuBuffers[buffer.uid] = null;
        }
        /**
         * creates and attaches a GLBuffer object tied to the current context.
         * @param buffer
         * @protected
         */
        createGLBuffer(buffer) {
          const { _gl: gl } = this;
          let type = BUFFER_TYPE.ARRAY_BUFFER;
          if (buffer.descriptor.usage & BufferUsage.INDEX) {
            type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
          } else if (buffer.descriptor.usage & BufferUsage.UNIFORM) {
            type = BUFFER_TYPE.UNIFORM_BUFFER;
          }
          const glBuffer = new GlBuffer(gl.createBuffer(), type);
          this._gpuBuffers[buffer.uid] = glBuffer;
          buffer.on("destroy", this.onBufferDestroy, this);
          return glBuffer;
        }
      };
      GlBufferSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "buffer"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/context/GlContextSystem.mjs
  var _GlContextSystem, GlContextSystem;
  var init_GlContextSystem = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/context/GlContextSystem.mjs"() {
      init_adapter();
      init_Extensions();
      init_warn();
      _GlContextSystem = class _GlContextSystem2 {
        /** @param renderer - The renderer this System works for. */
        constructor(renderer) {
          this.supports = {
            /** Support for 32-bit indices buffer. */
            uint32Indices: true,
            /** Support for UniformBufferObjects */
            uniformBufferObject: true,
            /** Support for VertexArrayObjects */
            vertexArrayObject: true,
            /** Support for SRGB texture format */
            srgbTextures: true,
            /** Support for wrapping modes if a texture is non-power of two */
            nonPowOf2wrapping: true,
            /** Support for MSAA (antialiasing of dynamic textures) */
            msaa: true,
            /** Support for mipmaps if a texture is non-power of two */
            nonPowOf2mipmaps: true
          };
          this._renderer = renderer;
          this.extensions = /* @__PURE__ */ Object.create(null);
          this.handleContextLost = this.handleContextLost.bind(this);
          this.handleContextRestored = this.handleContextRestored.bind(this);
        }
        /**
         * `true` if the context is lost
         * @readonly
         */
        get isLost() {
          return !this.gl || this.gl.isContextLost();
        }
        /**
         * Handles the context change event.
         * @param {WebGLRenderingContext} gl - New WebGL context.
         */
        contextChange(gl) {
          this.gl = gl;
          this._renderer.gl = gl;
        }
        init(options) {
          options = { ..._GlContextSystem2.defaultOptions, ...options };
          if (options.context) {
            this.initFromContext(options.context);
          } else {
            const alpha = this._renderer.background.alpha < 1;
            const premultipliedAlpha = options.premultipliedAlpha ?? true;
            const antialias = options.antialias && !this._renderer.backBuffer.useBackBuffer;
            this.createContext(options.preferWebGLVersion, {
              alpha,
              premultipliedAlpha,
              antialias,
              stencil: true,
              preserveDrawingBuffer: options.preserveDrawingBuffer,
              powerPreference: options.powerPreference ?? "default"
            });
          }
        }
        /**
         * Initializes the context.
         * @protected
         * @param {WebGLRenderingContext} gl - WebGL context
         */
        initFromContext(gl) {
          this.gl = gl;
          this.webGLVersion = gl instanceof DOMAdapter.get().getWebGLRenderingContext() ? 1 : 2;
          this.getExtensions();
          this.validateContext(gl);
          this._renderer.runners.contextChange.emit(gl);
          const element2 = this._renderer.view.canvas;
          element2.addEventListener("webglcontextlost", this.handleContextLost, false);
          element2.addEventListener("webglcontextrestored", this.handleContextRestored, false);
        }
        /**
         * Initialize from context options
         * @protected
         * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext
         * @param preferWebGLVersion
         * @param {object} options - context attributes
         */
        createContext(preferWebGLVersion, options) {
          let gl;
          const canvas = this._renderer.view.canvas;
          if (preferWebGLVersion === 2) {
            gl = canvas.getContext("webgl2", options);
          }
          if (!gl) {
            gl = canvas.getContext("webgl", options);
            if (!gl) {
              throw new Error("This browser does not support WebGL. Try using the canvas renderer");
            }
          }
          this.gl = gl;
          this.initFromContext(this.gl);
        }
        /** Auto-populate the {@link GlContextSystem.extensions extensions}. */
        getExtensions() {
          const { gl } = this;
          const common = {
            anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
            floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
            s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
            s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
            // eslint-disable-line camelcase
            etc: gl.getExtension("WEBGL_compressed_texture_etc"),
            etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
            pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
            atc: gl.getExtension("WEBGL_compressed_texture_atc"),
            astc: gl.getExtension("WEBGL_compressed_texture_astc"),
            bptc: gl.getExtension("EXT_texture_compression_bptc"),
            rgtc: gl.getExtension("EXT_texture_compression_rgtc"),
            loseContext: gl.getExtension("WEBGL_lose_context")
          };
          if (this.webGLVersion === 1) {
            this.extensions = {
              ...common,
              drawBuffers: gl.getExtension("WEBGL_draw_buffers"),
              depthTexture: gl.getExtension("WEBGL_depth_texture"),
              vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),
              uint32ElementIndex: gl.getExtension("OES_element_index_uint"),
              // Floats and half-floats
              floatTexture: gl.getExtension("OES_texture_float"),
              floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
              textureHalfFloat: gl.getExtension("OES_texture_half_float"),
              textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear"),
              vertexAttribDivisorANGLE: gl.getExtension("ANGLE_instanced_arrays"),
              srgb: gl.getExtension("EXT_sRGB")
            };
          } else {
            this.extensions = {
              ...common,
              colorBufferFloat: gl.getExtension("EXT_color_buffer_float")
            };
            const provokeExt = gl.getExtension("WEBGL_provoking_vertex");
            if (provokeExt) {
              provokeExt.provokingVertexWEBGL(provokeExt.FIRST_VERTEX_CONVENTION_WEBGL);
            }
          }
        }
        /**
         * Handles a lost webgl context
         * @param {WebGLContextEvent} event - The context lost event.
         */
        handleContextLost(event) {
          event.preventDefault();
          if (this._contextLossForced) {
            this._contextLossForced = false;
            setTimeout(() => {
              if (this.gl.isContextLost()) {
                this.extensions.loseContext?.restoreContext();
              }
            }, 0);
          }
        }
        /** Handles a restored webgl context. */
        handleContextRestored() {
          this._renderer.runners.contextChange.emit(this.gl);
        }
        destroy() {
          const element2 = this._renderer.view.canvas;
          this._renderer = null;
          element2.removeEventListener("webglcontextlost", this.handleContextLost);
          element2.removeEventListener("webglcontextrestored", this.handleContextRestored);
          this.gl.useProgram(null);
          this.extensions.loseContext?.loseContext();
        }
        /**
         * this function can be called to force a webGL context loss
         * this will release all resources on the GPU.
         * Useful if you need to put Pixi to sleep, and save some GPU memory
         *
         * As soon as render is called - all resources will be created again.
         */
        forceContextLoss() {
          this.extensions.loseContext?.loseContext();
          this._contextLossForced = true;
        }
        /**
         * Validate context.
         * @param {WebGLRenderingContext} gl - Render context.
         */
        validateContext(gl) {
          const attributes = gl.getContextAttributes();
          if (attributes && !attributes.stencil) {
            warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
          }
          const supports = this.supports;
          const isWebGl2 = this.webGLVersion === 2;
          const extensions2 = this.extensions;
          supports.uint32Indices = isWebGl2 || !!extensions2.uint32ElementIndex;
          supports.uniformBufferObject = isWebGl2;
          supports.vertexArrayObject = isWebGl2 || !!extensions2.vertexArrayObject;
          supports.srgbTextures = isWebGl2 || !!extensions2.srgb;
          supports.nonPowOf2wrapping = isWebGl2;
          supports.nonPowOf2mipmaps = isWebGl2;
          supports.msaa = isWebGl2;
          if (!supports.uint32Indices) {
            warn("Provided WebGL context does not support 32 index buffer, large scenes may not render correctly");
          }
        }
      };
      _GlContextSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "context"
      };
      _GlContextSystem.defaultOptions = {
        /**
         * {@link WebGLOptions.context}
         * @default null
         */
        context: null,
        /**
         * {@link WebGLOptions.premultipliedAlpha}
         * @default true
         */
        premultipliedAlpha: true,
        /**
         * {@link WebGLOptions.preserveDrawingBuffer}
         * @default false
         */
        preserveDrawingBuffer: false,
        /**
         * {@link WebGLOptions.powerPreference}
         * @default default
         */
        powerPreference: void 0,
        /**
         * {@link WebGLOptions.webGLVersion}
         * @default 2
         */
        preferWebGLVersion: 2
      };
      GlContextSystem = _GlContextSystem;
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/texture/const.mjs
  var GL_FORMATS, GL_TARGETS, GL_TYPES;
  var init_const10 = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/texture/const.mjs"() {
      "use strict";
      GL_FORMATS = /* @__PURE__ */ ((GL_FORMATS2) => {
        GL_FORMATS2[GL_FORMATS2["RGBA"] = 6408] = "RGBA";
        GL_FORMATS2[GL_FORMATS2["RGB"] = 6407] = "RGB";
        GL_FORMATS2[GL_FORMATS2["RG"] = 33319] = "RG";
        GL_FORMATS2[GL_FORMATS2["RED"] = 6403] = "RED";
        GL_FORMATS2[GL_FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
        GL_FORMATS2[GL_FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
        GL_FORMATS2[GL_FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
        GL_FORMATS2[GL_FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
        GL_FORMATS2[GL_FORMATS2["ALPHA"] = 6406] = "ALPHA";
        GL_FORMATS2[GL_FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
        GL_FORMATS2[GL_FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
        GL_FORMATS2[GL_FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
        GL_FORMATS2[GL_FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
        return GL_FORMATS2;
      })(GL_FORMATS || {});
      GL_TARGETS = /* @__PURE__ */ ((GL_TARGETS2) => {
        GL_TARGETS2[GL_TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
        return GL_TARGETS2;
      })(GL_TARGETS || {});
      GL_TYPES = /* @__PURE__ */ ((GL_TYPES2) => {
        GL_TYPES2[GL_TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
        GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
        GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
        GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
        GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
        GL_TYPES2[GL_TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
        GL_TYPES2[GL_TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
        GL_TYPES2[GL_TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
        GL_TYPES2[GL_TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
        GL_TYPES2[GL_TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
        GL_TYPES2[GL_TYPES2["BYTE"] = 5120] = "BYTE";
        GL_TYPES2[GL_TYPES2["SHORT"] = 5122] = "SHORT";
        GL_TYPES2[GL_TYPES2["INT"] = 5124] = "INT";
        GL_TYPES2[GL_TYPES2["FLOAT"] = 5126] = "FLOAT";
        GL_TYPES2[GL_TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
        GL_TYPES2[GL_TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
        return GL_TYPES2;
      })(GL_TYPES || {});
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.mjs
  function getGlTypeFromFormat(format) {
    return infoMap[format] ?? infoMap.float32;
  }
  var infoMap;
  var init_getGlTypeFromFormat = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.mjs"() {
      init_const10();
      infoMap = {
        uint8x2: GL_TYPES.UNSIGNED_BYTE,
        uint8x4: GL_TYPES.UNSIGNED_BYTE,
        sint8x2: GL_TYPES.BYTE,
        sint8x4: GL_TYPES.BYTE,
        unorm8x2: GL_TYPES.UNSIGNED_BYTE,
        unorm8x4: GL_TYPES.UNSIGNED_BYTE,
        snorm8x2: GL_TYPES.BYTE,
        snorm8x4: GL_TYPES.BYTE,
        uint16x2: GL_TYPES.UNSIGNED_SHORT,
        uint16x4: GL_TYPES.UNSIGNED_SHORT,
        sint16x2: GL_TYPES.SHORT,
        sint16x4: GL_TYPES.SHORT,
        unorm16x2: GL_TYPES.UNSIGNED_SHORT,
        unorm16x4: GL_TYPES.UNSIGNED_SHORT,
        snorm16x2: GL_TYPES.SHORT,
        snorm16x4: GL_TYPES.SHORT,
        float16x2: GL_TYPES.HALF_FLOAT,
        float16x4: GL_TYPES.HALF_FLOAT,
        float32: GL_TYPES.FLOAT,
        float32x2: GL_TYPES.FLOAT,
        float32x3: GL_TYPES.FLOAT,
        float32x4: GL_TYPES.FLOAT,
        uint32: GL_TYPES.UNSIGNED_INT,
        uint32x2: GL_TYPES.UNSIGNED_INT,
        uint32x3: GL_TYPES.UNSIGNED_INT,
        uint32x4: GL_TYPES.UNSIGNED_INT,
        sint32: GL_TYPES.INT,
        sint32x2: GL_TYPES.INT,
        sint32x3: GL_TYPES.INT,
        sint32x4: GL_TYPES.INT
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/geometry/GlGeometrySystem.mjs
  var topologyToGlMap, GlGeometrySystem;
  var init_GlGeometrySystem = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/geometry/GlGeometrySystem.mjs"() {
      init_Extensions();
      init_getAttributeInfoFromFormat();
      init_ensureAttributes();
      init_getGlTypeFromFormat();
      topologyToGlMap = {
        "point-list": 0,
        "line-list": 1,
        "line-strip": 3,
        "triangle-list": 4,
        "triangle-strip": 5
      };
      GlGeometrySystem = class {
        /** @param renderer - The renderer this System works for. */
        constructor(renderer) {
          this._geometryVaoHash = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
          this._activeGeometry = null;
          this._activeVao = null;
          this.hasVao = true;
          this.hasInstance = true;
        }
        /** Sets up the renderer context and necessary buffers. */
        contextChange() {
          const gl = this.gl = this._renderer.gl;
          if (!this._renderer.context.supports.vertexArrayObject) {
            throw new Error("[PixiJS] Vertex Array Objects are not supported on this device");
          }
          const nativeVaoExtension = this._renderer.context.extensions.vertexArrayObject;
          if (nativeVaoExtension) {
            gl.createVertexArray = () => nativeVaoExtension.createVertexArrayOES();
            gl.bindVertexArray = (vao) => nativeVaoExtension.bindVertexArrayOES(vao);
            gl.deleteVertexArray = (vao) => nativeVaoExtension.deleteVertexArrayOES(vao);
          }
          const nativeInstancedExtension = this._renderer.context.extensions.vertexAttribDivisorANGLE;
          if (nativeInstancedExtension) {
            gl.drawArraysInstanced = (a2, b2, c2, d2) => {
              nativeInstancedExtension.drawArraysInstancedANGLE(a2, b2, c2, d2);
            };
            gl.drawElementsInstanced = (a2, b2, c2, d2, e2) => {
              nativeInstancedExtension.drawElementsInstancedANGLE(a2, b2, c2, d2, e2);
            };
            gl.vertexAttribDivisor = (a2, b2) => nativeInstancedExtension.vertexAttribDivisorANGLE(a2, b2);
          }
          this._activeGeometry = null;
          this._activeVao = null;
          this._geometryVaoHash = /* @__PURE__ */ Object.create(null);
        }
        /**
         * Binds geometry so that is can be drawn. Creating a Vao if required
         * @param geometry - Instance of geometry to bind.
         * @param program - Instance of program to use vao for.
         */
        bind(geometry, program) {
          const gl = this.gl;
          this._activeGeometry = geometry;
          const vao = this.getVao(geometry, program);
          if (this._activeVao !== vao) {
            this._activeVao = vao;
            gl.bindVertexArray(vao);
          }
          this.updateBuffers();
        }
        /** Reset and unbind any active VAO and geometry. */
        reset() {
          this.unbind();
        }
        /** Update buffers of the currently bound geometry. */
        updateBuffers() {
          const geometry = this._activeGeometry;
          const bufferSystem = this._renderer.buffer;
          for (let i2 = 0; i2 < geometry.buffers.length; i2++) {
            const buffer = geometry.buffers[i2];
            bufferSystem.updateBuffer(buffer);
          }
        }
        /**
         * Check compatibility between a geometry and a program
         * @param geometry - Geometry instance.
         * @param program - Program instance.
         */
        checkCompatibility(geometry, program) {
          const geometryAttributes = geometry.attributes;
          const shaderAttributes = program._attributeData;
          for (const j2 in shaderAttributes) {
            if (!geometryAttributes[j2]) {
              throw new Error(`shader and geometry incompatible, geometry missing the "${j2}" attribute`);
            }
          }
        }
        /**
         * Takes a geometry and program and generates a unique signature for them.
         * @param geometry - To get signature from.
         * @param program - To test geometry against.
         * @returns - Unique signature of the geometry and program
         */
        getSignature(geometry, program) {
          const attribs = geometry.attributes;
          const shaderAttributes = program._attributeData;
          const strings = ["g", geometry.uid];
          for (const i2 in attribs) {
            if (shaderAttributes[i2]) {
              strings.push(i2, shaderAttributes[i2].location);
            }
          }
          return strings.join("-");
        }
        getVao(geometry, program) {
          return this._geometryVaoHash[geometry.uid]?.[program._key] || this.initGeometryVao(geometry, program);
        }
        /**
         * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.
         * If vao is created, it is bound automatically. We use a shader to infer what and how to set up the
         * attribute locations.
         * @param geometry - Instance of geometry to to generate Vao for.
         * @param program
         * @param _incRefCount - Increment refCount of all geometry buffers.
         */
        initGeometryVao(geometry, program, _incRefCount = true) {
          const gl = this._renderer.gl;
          const bufferSystem = this._renderer.buffer;
          this._renderer.shader._getProgramData(program);
          this.checkCompatibility(geometry, program);
          const signature = this.getSignature(geometry, program);
          if (!this._geometryVaoHash[geometry.uid]) {
            this._geometryVaoHash[geometry.uid] = /* @__PURE__ */ Object.create(null);
            geometry.on("destroy", this.onGeometryDestroy, this);
          }
          const vaoObjectHash = this._geometryVaoHash[geometry.uid];
          let vao = vaoObjectHash[signature];
          if (vao) {
            vaoObjectHash[program._key] = vao;
            return vao;
          }
          ensureAttributes(geometry, program._attributeData);
          const buffers = geometry.buffers;
          vao = gl.createVertexArray();
          gl.bindVertexArray(vao);
          for (let i2 = 0; i2 < buffers.length; i2++) {
            const buffer = buffers[i2];
            bufferSystem.bind(buffer);
          }
          this.activateVao(geometry, program);
          vaoObjectHash[program._key] = vao;
          vaoObjectHash[signature] = vao;
          gl.bindVertexArray(null);
          return vao;
        }
        /**
         * Disposes geometry.
         * @param geometry - Geometry with buffers. Only VAO will be disposed
         * @param [contextLost=false] - If context was lost, we suppress deleteVertexArray
         */
        onGeometryDestroy(geometry, contextLost) {
          const vaoObjectHash = this._geometryVaoHash[geometry.uid];
          const gl = this.gl;
          if (vaoObjectHash) {
            if (contextLost) {
              for (const i2 in vaoObjectHash) {
                if (this._activeVao !== vaoObjectHash[i2]) {
                  this.unbind();
                }
                gl.deleteVertexArray(vaoObjectHash[i2]);
              }
            }
            this._geometryVaoHash[geometry.uid] = null;
          }
        }
        /**
         * Dispose all WebGL resources of all managed geometries.
         * @param [contextLost=false] - If context was lost, we suppress `gl.delete` calls
         */
        destroyAll(contextLost = false) {
          const gl = this.gl;
          for (const i2 in this._geometryVaoHash) {
            if (contextLost) {
              for (const j2 in this._geometryVaoHash[i2]) {
                const vaoObjectHash = this._geometryVaoHash[i2];
                if (this._activeVao !== vaoObjectHash) {
                  this.unbind();
                }
                gl.deleteVertexArray(vaoObjectHash[j2]);
              }
            }
            this._geometryVaoHash[i2] = null;
          }
        }
        /**
         * Activate vertex array object.
         * @param geometry - Geometry instance.
         * @param program - Shader program instance.
         */
        activateVao(geometry, program) {
          const gl = this._renderer.gl;
          const bufferSystem = this._renderer.buffer;
          const attributes = geometry.attributes;
          if (geometry.indexBuffer) {
            bufferSystem.bind(geometry.indexBuffer);
          }
          let lastBuffer = null;
          for (const j2 in attributes) {
            const attribute = attributes[j2];
            const buffer = attribute.buffer;
            const glBuffer = bufferSystem.getGlBuffer(buffer);
            const programAttrib = program._attributeData[j2];
            if (programAttrib) {
              if (lastBuffer !== glBuffer) {
                bufferSystem.bind(buffer);
                lastBuffer = glBuffer;
              }
              const location = attribute.location;
              gl.enableVertexAttribArray(location);
              const attributeInfo = getAttributeInfoFromFormat(attribute.format);
              const type = getGlTypeFromFormat(attribute.format);
              if (programAttrib.format?.substring(1, 4) === "int") {
                gl.vertexAttribIPointer(
                  location,
                  attributeInfo.size,
                  type,
                  attribute.stride,
                  attribute.offset
                );
              } else {
                gl.vertexAttribPointer(
                  location,
                  attributeInfo.size,
                  type,
                  attributeInfo.normalised,
                  attribute.stride,
                  attribute.offset
                );
              }
              if (attribute.instance) {
                if (this.hasInstance) {
                  gl.vertexAttribDivisor(location, 1);
                } else {
                  throw new Error("geometry error, GPU Instancing is not supported on this device");
                }
              }
            }
          }
        }
        /**
         * Draws the currently bound geometry.
         * @param topology - The type primitive to render.
         * @param size - The number of elements to be rendered. If not specified, all vertices after the
         *  starting vertex will be drawn.
         * @param start - The starting vertex in the geometry to start drawing from. If not specified,
         *  drawing will start from the first vertex.
         * @param instanceCount - The number of instances of the set of elements to execute. If not specified,
         *  all instances will be drawn.
         */
        draw(topology, size, start, instanceCount) {
          const { gl } = this._renderer;
          const geometry = this._activeGeometry;
          const glTopology = topologyToGlMap[geometry.topology || topology];
          instanceCount || (instanceCount = geometry.instanceCount);
          if (geometry.indexBuffer) {
            const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
            const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
            if (instanceCount > 1) {
              gl.drawElementsInstanced(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount);
            } else {
              gl.drawElements(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);
            }
          } else if (instanceCount > 1) {
            gl.drawArraysInstanced(glTopology, start || 0, size || geometry.getSize(), instanceCount);
          } else {
            gl.drawArrays(glTopology, start || 0, size || geometry.getSize());
          }
          return this;
        }
        /** Unbind/reset everything. */
        unbind() {
          this.gl.bindVertexArray(null);
          this._activeVao = null;
          this._activeGeometry = null;
        }
        destroy() {
          this._renderer = null;
          this.gl = null;
          this._activeVao = null;
          this._activeGeometry = null;
        }
      };
      GlGeometrySystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "geometry"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/GlBackBufferSystem.mjs
  var bigTriangleGeometry, _GlBackBufferSystem, GlBackBufferSystem;
  var init_GlBackBufferSystem = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/GlBackBufferSystem.mjs"() {
      init_Extensions();
      init_warn();
      init_Geometry();
      init_Shader();
      init_State();
      init_TextureSource();
      init_Texture();
      init_GlProgram();
      bigTriangleGeometry = new Geometry({
        attributes: {
          aPosition: [
            -1,
            -1,
            // Bottom left corner
            3,
            -1,
            // Bottom right corner, extending beyond right edge
            -1,
            3
            // Top left corner, extending beyond top edge
          ]
        }
      });
      _GlBackBufferSystem = class _GlBackBufferSystem2 {
        constructor(renderer) {
          this.useBackBuffer = false;
          this._useBackBufferThisRender = false;
          this._renderer = renderer;
        }
        init(options = {}) {
          const { useBackBuffer, antialias } = { ..._GlBackBufferSystem2.defaultOptions, ...options };
          this.useBackBuffer = useBackBuffer;
          this._antialias = antialias;
          if (!this._renderer.context.supports.msaa) {
            warn("antialiasing, is not supported on when using the back buffer");
            this._antialias = false;
          }
          this._state = State.for2d();
          const bigTriangleProgram = new GlProgram({
            vertex: `
                attribute vec2 aPosition;
                out vec2 vUv;

                void main() {
                    gl_Position = vec4(aPosition, 0.0, 1.0);

                    vUv = (aPosition + 1.0) / 2.0;

                    // flip dem UVs
                    vUv.y = 1.0 - vUv.y;
                }`,
            fragment: `
                in vec2 vUv;
                out vec4 finalColor;

                uniform sampler2D uTexture;

                void main() {
                    finalColor = texture(uTexture, vUv);
                }`,
            name: "big-triangle"
          });
          this._bigTriangleShader = new Shader({
            glProgram: bigTriangleProgram,
            resources: {
              uTexture: Texture.WHITE.source
            }
          });
        }
        /**
         * This is called before the RenderTargetSystem is started. This is where
         * we replace the target with the back buffer if required.
         * @param options - The options for this render.
         */
        renderStart(options) {
          const renderTarget = this._renderer.renderTarget.getRenderTarget(options.target);
          this._useBackBufferThisRender = this.useBackBuffer && !!renderTarget.isRoot;
          if (this._useBackBufferThisRender) {
            const renderTarget2 = this._renderer.renderTarget.getRenderTarget(options.target);
            this._targetTexture = renderTarget2.colorTexture;
            options.target = this._getBackBufferTexture(renderTarget2.colorTexture);
          }
        }
        renderEnd() {
          this._presentBackBuffer();
        }
        _presentBackBuffer() {
          const renderer = this._renderer;
          renderer.renderTarget.finishRenderPass();
          if (!this._useBackBufferThisRender)
            return;
          renderer.renderTarget.bind(this._targetTexture, false);
          this._bigTriangleShader.resources.uTexture = this._backBufferTexture.source;
          renderer.encoder.draw({
            geometry: bigTriangleGeometry,
            shader: this._bigTriangleShader,
            state: this._state
          });
        }
        _getBackBufferTexture(targetSourceTexture) {
          this._backBufferTexture = this._backBufferTexture || new Texture({
            source: new TextureSource({
              width: targetSourceTexture.width,
              height: targetSourceTexture.height,
              resolution: targetSourceTexture._resolution,
              antialias: this._antialias
            })
          });
          this._backBufferTexture.source.resize(
            targetSourceTexture.width,
            targetSourceTexture.height,
            targetSourceTexture._resolution
          );
          return this._backBufferTexture;
        }
        /** destroys the back buffer */
        destroy() {
          if (this._backBufferTexture) {
            this._backBufferTexture.destroy();
            this._backBufferTexture = null;
          }
        }
      };
      _GlBackBufferSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "backBuffer",
        priority: 1
      };
      _GlBackBufferSystem.defaultOptions = {
        /** if true will use the back buffer where required */
        useBackBuffer: false
      };
      GlBackBufferSystem = _GlBackBufferSystem;
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/GlColorMaskSystem.mjs
  var GlColorMaskSystem;
  var init_GlColorMaskSystem = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/GlColorMaskSystem.mjs"() {
      init_Extensions();
      GlColorMaskSystem = class {
        constructor(renderer) {
          this._colorMaskCache = 15;
          this._renderer = renderer;
        }
        setMask(colorMask) {
          if (this._colorMaskCache === colorMask)
            return;
          this._colorMaskCache = colorMask;
          this._renderer.gl.colorMask(
            !!(colorMask & 8),
            !!(colorMask & 4),
            !!(colorMask & 2),
            !!(colorMask & 1)
          );
        }
      };
      GlColorMaskSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "colorMask"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/GlEncoderSystem.mjs
  var GlEncoderSystem;
  var init_GlEncoderSystem = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/GlEncoderSystem.mjs"() {
      init_Extensions();
      GlEncoderSystem = class {
        constructor(renderer) {
          this.commandFinished = Promise.resolve();
          this._renderer = renderer;
        }
        setGeometry(geometry, shader) {
          this._renderer.geometry.bind(geometry, shader.glProgram);
        }
        finishRenderPass() {
        }
        draw(options) {
          const renderer = this._renderer;
          const { geometry, shader, state, skipSync, topology: type, size, start, instanceCount } = options;
          renderer.shader.bind(shader, skipSync);
          renderer.geometry.bind(geometry, renderer.shader._activeProgram);
          if (state) {
            renderer.state.set(state);
          }
          renderer.geometry.draw(type, size, start, instanceCount ?? geometry.instanceCount);
        }
        destroy() {
          this._renderer = null;
        }
      };
      GlEncoderSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "encoder"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/GlStencilSystem.mjs
  var GlStencilSystem;
  var init_GlStencilSystem = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/GlStencilSystem.mjs"() {
      init_Extensions();
      init_GpuStencilModesToPixi();
      init_const5();
      GlStencilSystem = class {
        constructor(renderer) {
          this._stencilCache = {
            enabled: false,
            stencilReference: 0,
            stencilMode: STENCIL_MODES.NONE
          };
          this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);
          renderer.renderTarget.onRenderTargetChange.add(this);
        }
        contextChange(gl) {
          this._gl = gl;
          this._comparisonFuncMapping = {
            always: gl.ALWAYS,
            never: gl.NEVER,
            equal: gl.EQUAL,
            "not-equal": gl.NOTEQUAL,
            less: gl.LESS,
            "less-equal": gl.LEQUAL,
            greater: gl.GREATER,
            "greater-equal": gl.GEQUAL
          };
          this._stencilOpsMapping = {
            keep: gl.KEEP,
            zero: gl.ZERO,
            replace: gl.REPLACE,
            invert: gl.INVERT,
            "increment-clamp": gl.INCR,
            "decrement-clamp": gl.DECR,
            "increment-wrap": gl.INCR_WRAP,
            "decrement-wrap": gl.DECR_WRAP
          };
          this._stencilCache.enabled = false;
          this._stencilCache.stencilMode = STENCIL_MODES.NONE;
          this._stencilCache.stencilReference = 0;
        }
        onRenderTargetChange(renderTarget) {
          if (this._activeRenderTarget === renderTarget)
            return;
          this._activeRenderTarget = renderTarget;
          let stencilState = this._renderTargetStencilState[renderTarget.uid];
          if (!stencilState) {
            stencilState = this._renderTargetStencilState[renderTarget.uid] = {
              stencilMode: STENCIL_MODES.DISABLED,
              stencilReference: 0
            };
          }
          this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);
        }
        setStencilMode(stencilMode, stencilReference) {
          const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];
          const gl = this._gl;
          const mode = GpuStencilModesToPixi[stencilMode];
          const _stencilCache = this._stencilCache;
          stencilState.stencilMode = stencilMode;
          stencilState.stencilReference = stencilReference;
          if (stencilMode === STENCIL_MODES.DISABLED) {
            if (this._stencilCache.enabled) {
              this._stencilCache.enabled = false;
              gl.disable(gl.STENCIL_TEST);
            }
            return;
          }
          if (!this._stencilCache.enabled) {
            this._stencilCache.enabled = true;
            gl.enable(gl.STENCIL_TEST);
          }
          if (stencilMode !== _stencilCache.stencilMode || _stencilCache.stencilReference !== stencilReference) {
            _stencilCache.stencilMode = stencilMode;
            _stencilCache.stencilReference = stencilReference;
            gl.stencilFunc(this._comparisonFuncMapping[mode.stencilBack.compare], stencilReference, 255);
            gl.stencilOp(gl.KEEP, gl.KEEP, this._stencilOpsMapping[mode.stencilBack.passOp]);
          }
        }
      };
      GlStencilSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "stencil"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboElementsSTD40.mjs
  function createUboElementsSTD40(uniformData) {
    const uboElements = uniformData.map((data) => ({
      data,
      offset: 0,
      size: 0
    }));
    let size = 0;
    let chunkSize = 0;
    let offset = 0;
    for (let i2 = 0; i2 < uboElements.length; i2++) {
      const uboElement = uboElements[i2];
      size = WGSL_TO_STD40_SIZE[uboElement.data.type];
      if (!size) {
        throw new Error(`Unknown type ${uboElement.data.type}`);
      }
      if (uboElement.data.size > 1) {
        size = Math.max(size, 16) * uboElement.data.size;
      }
      uboElement.size = size;
      if (chunkSize % size !== 0 && chunkSize < 16) {
        const lineUpValue = chunkSize % size % 16;
        chunkSize += lineUpValue;
        offset += lineUpValue;
      }
      if (chunkSize + size > 16) {
        offset = Math.ceil(offset / 16) * 16;
        uboElement.offset = offset;
        offset += size;
        chunkSize = size;
      } else {
        uboElement.offset = offset;
        chunkSize += size;
        offset += size;
      }
    }
    offset = Math.ceil(offset / 16) * 16;
    return { uboElements, size: offset };
  }
  var WGSL_TO_STD40_SIZE;
  var init_createUboElementsSTD40 = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboElementsSTD40.mjs"() {
      "use strict";
      WGSL_TO_STD40_SIZE = {
        f32: 4,
        "vec2<f32>": 8,
        "vec3<f32>": 12,
        "vec4<f32>": 16,
        "mat2x2<f32>": 16 * 2,
        "mat3x3<f32>": 16 * 3,
        "mat4x4<f32>": 16 * 4
        // TODO - not essential for now but support these in the future
        // int:      4,
        // ivec2:    8,
        // ivec3:    12,
        // ivec4:    16,
        // uint:     4,
        // uvec2:    8,
        // uvec3:    12,
        // uvec4:    16,
        // bool:     4,
        // bvec2:    8,
        // bvec3:    12,
        // bvec4:    16,
        // mat2:     16 * 2,
        // mat3:     16 * 3,
        // mat4:     16 * 4,
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateArraySyncSTD40.mjs
  function generateArraySyncSTD40(uboElement, offsetToAdd) {
    const rowSize = Math.max(WGSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);
    const elementSize = uboElement.data.value.length / uboElement.data.size;
    const remainder = (4 - elementSize % 4) % 4;
    return `
        v = uv.${uboElement.data.name};
        offset += ${offsetToAdd};

        arrayOffset = offset;

        t = 0;

        for(var i=0; i < ${uboElement.data.size * rowSize}; i++)
        {
            for(var j = 0; j < ${elementSize}; j++)
            {
                data[arrayOffset++] = v[t++];
            }
            ${remainder !== 0 ? `arrayOffset += ${remainder};` : ""}
        }
    `;
  }
  var init_generateArraySyncSTD40 = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateArraySyncSTD40.mjs"() {
      init_createUboElementsSTD40();
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboSyncSTD40.mjs
  function createUboSyncFunctionSTD40(uboElements) {
    return createUboSyncFunction(
      uboElements,
      "uboStd40",
      generateArraySyncSTD40,
      uboSyncFunctionsSTD40
    );
  }
  var init_createUboSyncSTD40 = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboSyncSTD40.mjs"() {
      init_createUboSyncFunction();
      init_uboSyncFunctions();
      init_generateArraySyncSTD40();
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/GlUboSystem.mjs
  var GlUboSystem;
  var init_GlUboSystem = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/GlUboSystem.mjs"() {
      init_Extensions();
      init_UboSystem();
      init_createUboElementsSTD40();
      init_createUboSyncSTD40();
      GlUboSystem = class extends UboSystem {
        constructor() {
          super({
            createUboElements: createUboElementsSTD40,
            generateUboSync: createUboSyncFunctionSTD40
          });
        }
      };
      GlUboSystem.extension = {
        type: [ExtensionType.WebGLSystem],
        name: "ubo"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/GlRenderTarget.mjs
  var GlRenderTarget;
  var init_GlRenderTarget = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/GlRenderTarget.mjs"() {
      "use strict";
      GlRenderTarget = class {
        constructor() {
          this.width = -1;
          this.height = -1;
          this.msaa = false;
          this.msaaRenderBuffer = [];
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.mjs
  var GlRenderTargetAdaptor;
  var init_GlRenderTargetAdaptor = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.mjs"() {
      init_Rectangle();
      init_warn();
      init_const8();
      init_GlRenderTarget();
      GlRenderTargetAdaptor = class {
        constructor() {
          this._clearColorCache = [0, 0, 0, 0];
          this._viewPortCache = new Rectangle();
        }
        init(renderer, renderTargetSystem) {
          this._renderer = renderer;
          this._renderTargetSystem = renderTargetSystem;
          renderer.runners.contextChange.add(this);
        }
        contextChange() {
          this._clearColorCache = [0, 0, 0, 0];
          this._viewPortCache = new Rectangle();
        }
        copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {
          const renderTargetSystem = this._renderTargetSystem;
          const renderer = this._renderer;
          const glRenderTarget = renderTargetSystem.getGpuRenderTarget(sourceRenderSurfaceTexture);
          const gl = renderer.gl;
          this.finishRenderPass(sourceRenderSurfaceTexture);
          gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);
          renderer.texture.bind(destinationTexture, 0);
          gl.copyTexSubImage2D(
            gl.TEXTURE_2D,
            0,
            originDest.x,
            originDest.y,
            originSrc.x,
            originSrc.y,
            size.width,
            size.height
          );
          return destinationTexture;
        }
        startRenderPass(renderTarget, clear = true, clearColor, viewport) {
          const renderTargetSystem = this._renderTargetSystem;
          const source2 = renderTarget.colorTexture;
          const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
          let viewPortY = viewport.y;
          if (renderTarget.isRoot) {
            viewPortY = source2.pixelHeight - viewport.height;
          }
          renderTarget.colorTextures.forEach((texture) => {
            this._renderer.texture.unbind(texture);
          });
          const gl = this._renderer.gl;
          gl.bindFramebuffer(gl.FRAMEBUFFER, gpuRenderTarget.framebuffer);
          const viewPortCache = this._viewPortCache;
          if (viewPortCache.x !== viewport.x || viewPortCache.y !== viewPortY || viewPortCache.width !== viewport.width || viewPortCache.height !== viewport.height) {
            viewPortCache.x = viewport.x;
            viewPortCache.y = viewPortY;
            viewPortCache.width = viewport.width;
            viewPortCache.height = viewport.height;
            gl.viewport(
              viewport.x,
              viewPortY,
              viewport.width,
              viewport.height
            );
          }
          if (!gpuRenderTarget.depthStencilRenderBuffer && (renderTarget.stencil || renderTarget.depth)) {
            this._initStencil(gpuRenderTarget);
          }
          this.clear(renderTarget, clear, clearColor);
        }
        finishRenderPass(renderTarget) {
          const renderTargetSystem = this._renderTargetSystem;
          const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
          if (!glRenderTarget.msaa)
            return;
          const gl = this._renderer.gl;
          gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);
          gl.bindFramebuffer(gl.READ_FRAMEBUFFER, glRenderTarget.framebuffer);
          gl.blitFramebuffer(
            0,
            0,
            glRenderTarget.width,
            glRenderTarget.height,
            0,
            0,
            glRenderTarget.width,
            glRenderTarget.height,
            gl.COLOR_BUFFER_BIT,
            gl.NEAREST
          );
          gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.framebuffer);
        }
        initGpuRenderTarget(renderTarget) {
          const renderer = this._renderer;
          const gl = renderer.gl;
          const glRenderTarget = new GlRenderTarget();
          if (renderTarget.colorTexture.resource === renderer.gl.canvas) {
            glRenderTarget.framebuffer = null;
            return glRenderTarget;
          }
          this._initColor(renderTarget, glRenderTarget);
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          return glRenderTarget;
        }
        destroyGpuRenderTarget(gpuRenderTarget) {
          const gl = this._renderer.gl;
          if (gpuRenderTarget.framebuffer) {
            gl.deleteFramebuffer(gpuRenderTarget.framebuffer);
            gpuRenderTarget.framebuffer = null;
          }
          if (gpuRenderTarget.resolveTargetFramebuffer) {
            gl.deleteFramebuffer(gpuRenderTarget.resolveTargetFramebuffer);
            gpuRenderTarget.resolveTargetFramebuffer = null;
          }
          if (gpuRenderTarget.depthStencilRenderBuffer) {
            gl.deleteRenderbuffer(gpuRenderTarget.depthStencilRenderBuffer);
            gpuRenderTarget.depthStencilRenderBuffer = null;
          }
          gpuRenderTarget.msaaRenderBuffer.forEach((renderBuffer) => {
            gl.deleteRenderbuffer(renderBuffer);
          });
          gpuRenderTarget.msaaRenderBuffer = null;
        }
        clear(_renderTarget, clear, clearColor) {
          if (!clear)
            return;
          const renderTargetSystem = this._renderTargetSystem;
          if (typeof clear === "boolean") {
            clear = clear ? CLEAR.ALL : CLEAR.NONE;
          }
          const gl = this._renderer.gl;
          if (clear & CLEAR.COLOR) {
            clearColor ?? (clearColor = renderTargetSystem.defaultClearColor);
            const clearColorCache = this._clearColorCache;
            const clearColorArray = clearColor;
            if (clearColorCache[0] !== clearColorArray[0] || clearColorCache[1] !== clearColorArray[1] || clearColorCache[2] !== clearColorArray[2] || clearColorCache[3] !== clearColorArray[3]) {
              clearColorCache[0] = clearColorArray[0];
              clearColorCache[1] = clearColorArray[1];
              clearColorCache[2] = clearColorArray[2];
              clearColorCache[3] = clearColorArray[3];
              gl.clearColor(clearColorArray[0], clearColorArray[1], clearColorArray[2], clearColorArray[3]);
            }
          }
          gl.clear(clear);
        }
        resizeGpuRenderTarget(renderTarget) {
          if (renderTarget.isRoot)
            return;
          const renderTargetSystem = this._renderTargetSystem;
          const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
          this._resizeColor(renderTarget, glRenderTarget);
          if (renderTarget.stencil) {
            this._resizeStencil(glRenderTarget);
          }
        }
        _initColor(renderTarget, glRenderTarget) {
          const renderer = this._renderer;
          const gl = renderer.gl;
          const resolveTargetFramebuffer = gl.createFramebuffer();
          glRenderTarget.resolveTargetFramebuffer = resolveTargetFramebuffer;
          gl.bindFramebuffer(gl.FRAMEBUFFER, resolveTargetFramebuffer);
          glRenderTarget.width = renderTarget.colorTexture.source.pixelWidth;
          glRenderTarget.height = renderTarget.colorTexture.source.pixelHeight;
          renderTarget.colorTextures.forEach((colorTexture, i2) => {
            const source2 = colorTexture.source;
            if (source2.antialias) {
              if (renderer.context.supports.msaa) {
                glRenderTarget.msaa = true;
              } else {
                warn("[RenderTexture] Antialiasing on textures is not supported in WebGL1");
              }
            }
            renderer.texture.bindSource(source2, 0);
            const glSource = renderer.texture.getGlSource(source2);
            const glTexture = glSource.texture;
            gl.framebufferTexture2D(
              gl.FRAMEBUFFER,
              gl.COLOR_ATTACHMENT0 + i2,
              3553,
              // texture.target,
              glTexture,
              0
            );
          });
          if (glRenderTarget.msaa) {
            const viewFramebuffer = gl.createFramebuffer();
            glRenderTarget.framebuffer = viewFramebuffer;
            gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);
            renderTarget.colorTextures.forEach((_, i2) => {
              const msaaRenderBuffer = gl.createRenderbuffer();
              glRenderTarget.msaaRenderBuffer[i2] = msaaRenderBuffer;
            });
          } else {
            glRenderTarget.framebuffer = resolveTargetFramebuffer;
          }
          this._resizeColor(renderTarget, glRenderTarget);
        }
        _resizeColor(renderTarget, glRenderTarget) {
          const source2 = renderTarget.colorTexture.source;
          glRenderTarget.width = source2.pixelWidth;
          glRenderTarget.height = source2.pixelHeight;
          renderTarget.colorTextures.forEach((colorTexture, i2) => {
            if (i2 === 0)
              return;
            colorTexture.source.resize(source2.width, source2.height, source2._resolution);
          });
          if (glRenderTarget.msaa) {
            const renderer = this._renderer;
            const gl = renderer.gl;
            const viewFramebuffer = glRenderTarget.framebuffer;
            gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);
            renderTarget.colorTextures.forEach((colorTexture, i2) => {
              const source22 = colorTexture.source;
              renderer.texture.bindSource(source22, 0);
              const glSource = renderer.texture.getGlSource(source22);
              const glInternalFormat = glSource.internalFormat;
              const msaaRenderBuffer = glRenderTarget.msaaRenderBuffer[i2];
              gl.bindRenderbuffer(
                gl.RENDERBUFFER,
                msaaRenderBuffer
              );
              gl.renderbufferStorageMultisample(
                gl.RENDERBUFFER,
                4,
                glInternalFormat,
                source22.pixelWidth,
                source22.pixelHeight
              );
              gl.framebufferRenderbuffer(
                gl.FRAMEBUFFER,
                gl.COLOR_ATTACHMENT0 + i2,
                gl.RENDERBUFFER,
                msaaRenderBuffer
              );
            });
          }
        }
        _initStencil(glRenderTarget) {
          if (glRenderTarget.framebuffer === null)
            return;
          const gl = this._renderer.gl;
          const depthStencilRenderBuffer = gl.createRenderbuffer();
          glRenderTarget.depthStencilRenderBuffer = depthStencilRenderBuffer;
          gl.bindRenderbuffer(
            gl.RENDERBUFFER,
            depthStencilRenderBuffer
          );
          gl.framebufferRenderbuffer(
            gl.FRAMEBUFFER,
            gl.DEPTH_STENCIL_ATTACHMENT,
            gl.RENDERBUFFER,
            depthStencilRenderBuffer
          );
          this._resizeStencil(glRenderTarget);
        }
        _resizeStencil(glRenderTarget) {
          const gl = this._renderer.gl;
          gl.bindRenderbuffer(
            gl.RENDERBUFFER,
            glRenderTarget.depthStencilRenderBuffer
          );
          if (glRenderTarget.msaa) {
            gl.renderbufferStorageMultisample(
              gl.RENDERBUFFER,
              4,
              gl.DEPTH24_STENCIL8,
              glRenderTarget.width,
              glRenderTarget.height
            );
          } else {
            gl.renderbufferStorage(
              gl.RENDERBUFFER,
              this._renderer.context.webGLVersion === 2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,
              glRenderTarget.width,
              glRenderTarget.height
            );
          }
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetSystem.mjs
  var GlRenderTargetSystem;
  var init_GlRenderTargetSystem = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetSystem.mjs"() {
      init_Extensions();
      init_RenderTargetSystem();
      init_GlRenderTargetAdaptor();
      GlRenderTargetSystem = class extends RenderTargetSystem {
        constructor(renderer) {
          super(renderer);
          this.adaptor = new GlRenderTargetAdaptor();
          this.adaptor.init(renderer, this);
        }
      };
      GlRenderTargetSystem.extension = {
        type: [ExtensionType.WebGLSystem],
        name: "renderTarget"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GenerateShaderSyncCode.mjs
  function generateShaderSyncCode(shader, shaderSystem) {
    const funcFragments = [];
    const headerFragments = [`
        var g = s.groups;
        var sS = r.shader;
        var p = s.glProgram;
        var ugS = r.uniformGroup;
        var resources;
    `];
    let addedTextreSystem = false;
    let blockIndex = 0;
    let textureCount = 0;
    const programData = shaderSystem._getProgramData(shader.glProgram);
    for (const i2 in shader.groups) {
      const group = shader.groups[i2];
      funcFragments.push(`
            resources = g[${i2}].resources;
        `);
      for (const j2 in group.resources) {
        const resource = group.resources[j2];
        if (resource instanceof UniformGroup) {
          if (resource.ubo) {
            funcFragments.push(`
                        sS.bindUniformBlock(
                            resources[${j2}],
                            sS._uniformBindMap[${i2}[${j2}],
                            ${blockIndex++}
                        );
                    `);
          } else {
            funcFragments.push(`
                        ugS.updateUniformGroup(resources[${j2}], p, sD);
                    `);
          }
        } else if (resource instanceof BufferResource) {
          funcFragments.push(`
                    sS.bindUniformBlock(
                        resources[${j2}],
                        sS._uniformBindMap[${i2}[${j2}],
                        ${blockIndex++}
                    );
                `);
        } else if (resource instanceof TextureSource) {
          const uniformName = shader._uniformBindMap[i2][j2];
          const uniformData = programData.uniformData[uniformName];
          if (uniformData) {
            if (!addedTextreSystem) {
              addedTextreSystem = true;
              headerFragments.push(`
                        var tS = r.texture;
                        `);
            }
            shaderSystem._gl.uniform1i(uniformData.location, textureCount);
            funcFragments.push(`
                        tS.bind(resources[${j2}], ${textureCount});
                    `);
            textureCount++;
          }
        }
      }
    }
    const functionSource = [...headerFragments, ...funcFragments].join("\n");
    return new Function("r", "s", "sD", functionSource);
  }
  var init_GenerateShaderSyncCode = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GenerateShaderSyncCode.mjs"() {
      init_BufferResource();
      init_UniformGroup();
      init_TextureSource();
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgramData.mjs
  var GlProgramData;
  var init_GlProgramData = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgramData.mjs"() {
      "use strict";
      GlProgramData = class {
        /**
         * Makes a new Pixi program.
         * @param program - webgl program
         * @param uniformData - uniforms
         */
        constructor(program, uniformData) {
          this.program = program;
          this.uniformData = uniformData;
          this.uniformGroups = {};
          this.uniformDirtyGroups = {};
          this.uniformBlockBindings = {};
        }
        /** Destroys this program. */
        destroy() {
          this.uniformData = null;
          this.uniformGroups = null;
          this.uniformDirtyGroups = null;
          this.uniformBlockBindings = null;
          this.program = null;
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/compileShader.mjs
  function compileShader(gl, type, src) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, src);
    gl.compileShader(shader);
    return shader;
  }
  var init_compileShader = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/compileShader.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/defaultValue.mjs
  function booleanArray(size) {
    const array = new Array(size);
    for (let i2 = 0; i2 < array.length; i2++) {
      array[i2] = false;
    }
    return array;
  }
  function defaultValue(type, size) {
    switch (type) {
      case "float":
        return 0;
      case "vec2":
        return new Float32Array(2 * size);
      case "vec3":
        return new Float32Array(3 * size);
      case "vec4":
        return new Float32Array(4 * size);
      case "int":
      case "uint":
      case "sampler2D":
      case "sampler2DArray":
        return 0;
      case "ivec2":
        return new Int32Array(2 * size);
      case "ivec3":
        return new Int32Array(3 * size);
      case "ivec4":
        return new Int32Array(4 * size);
      case "uvec2":
        return new Uint32Array(2 * size);
      case "uvec3":
        return new Uint32Array(3 * size);
      case "uvec4":
        return new Uint32Array(4 * size);
      case "bool":
        return false;
      case "bvec2":
        return booleanArray(2 * size);
      case "bvec3":
        return booleanArray(3 * size);
      case "bvec4":
        return booleanArray(4 * size);
      case "mat2":
        return new Float32Array([
          1,
          0,
          0,
          1
        ]);
      case "mat3":
        return new Float32Array([
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ]);
      case "mat4":
        return new Float32Array([
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ]);
    }
    return null;
  }
  var init_defaultValue = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/defaultValue.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapType.mjs
  function mapType(gl, type) {
    if (!GL_TABLE) {
      const typeNames = Object.keys(GL_TO_GLSL_TYPES);
      GL_TABLE = {};
      for (let i2 = 0; i2 < typeNames.length; ++i2) {
        const tn = typeNames[i2];
        GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
      }
    }
    return GL_TABLE[type];
  }
  function mapGlToVertexFormat(gl, type) {
    const typeValue = mapType(gl, type);
    return GLSL_TO_VERTEX_TYPES[typeValue] || "float32";
  }
  var GL_TABLE, GL_TO_GLSL_TYPES, GLSL_TO_VERTEX_TYPES;
  var init_mapType = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapType.mjs"() {
      "use strict";
      GL_TABLE = null;
      GL_TO_GLSL_TYPES = {
        FLOAT: "float",
        FLOAT_VEC2: "vec2",
        FLOAT_VEC3: "vec3",
        FLOAT_VEC4: "vec4",
        INT: "int",
        INT_VEC2: "ivec2",
        INT_VEC3: "ivec3",
        INT_VEC4: "ivec4",
        UNSIGNED_INT: "uint",
        UNSIGNED_INT_VEC2: "uvec2",
        UNSIGNED_INT_VEC3: "uvec3",
        UNSIGNED_INT_VEC4: "uvec4",
        BOOL: "bool",
        BOOL_VEC2: "bvec2",
        BOOL_VEC3: "bvec3",
        BOOL_VEC4: "bvec4",
        FLOAT_MAT2: "mat2",
        FLOAT_MAT3: "mat3",
        FLOAT_MAT4: "mat4",
        SAMPLER_2D: "sampler2D",
        INT_SAMPLER_2D: "sampler2D",
        UNSIGNED_INT_SAMPLER_2D: "sampler2D",
        SAMPLER_CUBE: "samplerCube",
        INT_SAMPLER_CUBE: "samplerCube",
        UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
        SAMPLER_2D_ARRAY: "sampler2DArray",
        INT_SAMPLER_2D_ARRAY: "sampler2DArray",
        UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
      };
      GLSL_TO_VERTEX_TYPES = {
        float: "float32",
        vec2: "float32x2",
        vec3: "float32x3",
        vec4: "float32x4",
        int: "sint32",
        ivec2: "sint32x2",
        ivec3: "sint32x3",
        ivec4: "sint32x4",
        uint: "uint32",
        uvec2: "uint32x2",
        uvec3: "uint32x3",
        uvec4: "uint32x4",
        bool: "uint32",
        bvec2: "uint32x2",
        bvec3: "uint32x3",
        bvec4: "uint32x4"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/extractAttributesFromGlProgram.mjs
  function extractAttributesFromGlProgram(program, gl, sortAttributes = false) {
    const attributes = {};
    const totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    for (let i2 = 0; i2 < totalAttributes; i2++) {
      const attribData = gl.getActiveAttrib(program, i2);
      if (attribData.name.startsWith("gl_")) {
        continue;
      }
      const format = mapGlToVertexFormat(gl, attribData.type);
      attributes[attribData.name] = {
        location: 0,
        // set further down..
        format,
        stride: getAttributeInfoFromFormat(format).stride,
        offset: 0,
        instance: false,
        start: 0
      };
    }
    const keys = Object.keys(attributes);
    if (sortAttributes) {
      keys.sort((a2, b2) => a2 > b2 ? 1 : -1);
      for (let i2 = 0; i2 < keys.length; i2++) {
        attributes[keys[i2]].location = i2;
        gl.bindAttribLocation(program, i2, keys[i2]);
      }
      gl.linkProgram(program);
    } else {
      for (let i2 = 0; i2 < keys.length; i2++) {
        attributes[keys[i2]].location = gl.getAttribLocation(program, keys[i2]);
      }
    }
    return attributes;
  }
  var init_extractAttributesFromGlProgram = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/extractAttributesFromGlProgram.mjs"() {
      init_getAttributeInfoFromFormat();
      init_mapType();
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUboData.mjs
  function getUboData(program, gl) {
    if (!gl.ACTIVE_UNIFORM_BLOCKS)
      return {};
    const uniformBlocks = {};
    const totalUniformsBlocks = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);
    for (let i2 = 0; i2 < totalUniformsBlocks; i2++) {
      const name = gl.getActiveUniformBlockName(program, i2);
      const uniformBlockIndex = gl.getUniformBlockIndex(program, name);
      const size = gl.getActiveUniformBlockParameter(program, i2, gl.UNIFORM_BLOCK_DATA_SIZE);
      uniformBlocks[name] = {
        name,
        index: uniformBlockIndex,
        size
      };
    }
    return uniformBlocks;
  }
  var init_getUboData = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUboData.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUniformData.mjs
  function getUniformData(program, gl) {
    const uniforms = {};
    const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    for (let i2 = 0; i2 < totalUniforms; i2++) {
      const uniformData = gl.getActiveUniform(program, i2);
      const name = uniformData.name.replace(/\[.*?\]$/, "");
      const isArray3 = !!uniformData.name.match(/\[.*?\]$/);
      const type = mapType(gl, uniformData.type);
      uniforms[name] = {
        name,
        index: i2,
        type,
        size: uniformData.size,
        isArray: isArray3,
        value: defaultValue(type, uniformData.size)
      };
    }
    return uniforms;
  }
  var init_getUniformData = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUniformData.mjs"() {
      init_defaultValue();
      init_mapType();
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/logProgramError.mjs
  function logPrettyShaderError(gl, shader) {
    const shaderSrc = gl.getShaderSource(shader).split("\n").map((line, index) => `${index}: ${line}`);
    const shaderLog = gl.getShaderInfoLog(shader);
    const splitShader = shaderLog.split("\n");
    const dedupe = {};
    const lineNumbers = splitShader.map((line) => parseFloat(line.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter((n2) => {
      if (n2 && !dedupe[n2]) {
        dedupe[n2] = true;
        return true;
      }
      return false;
    });
    const logArgs = [""];
    lineNumbers.forEach((number) => {
      shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`;
      logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
    });
    const fragmentSourceToLog = shaderSrc.join("\n");
    logArgs[0] = fragmentSourceToLog;
    console.error(shaderLog);
    console.groupCollapsed("click to view full shader code");
    console.warn(...logArgs);
    console.groupEnd();
  }
  function logProgramError(gl, program, vertexShader, fragmentShader) {
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        logPrettyShaderError(gl, vertexShader);
      }
      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        logPrettyShaderError(gl, fragmentShader);
      }
      console.error("PixiJS Error: Could not initialize shader.");
      if (gl.getProgramInfoLog(program) !== "") {
        console.warn("PixiJS Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));
      }
    }
  }
  var init_logProgramError = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/logProgramError.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/generateProgram.mjs
  function generateProgram(gl, program) {
    const glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertex);
    const glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragment);
    const webGLProgram = gl.createProgram();
    gl.attachShader(webGLProgram, glVertShader);
    gl.attachShader(webGLProgram, glFragShader);
    const transformFeedbackVaryings = program.transformFeedbackVaryings;
    if (transformFeedbackVaryings) {
      if (typeof gl.transformFeedbackVaryings !== "function") {
        warn(`TransformFeedback is not supported but TransformFeedbackVaryings are given.`);
      } else {
        gl.transformFeedbackVaryings(
          webGLProgram,
          transformFeedbackVaryings.names,
          transformFeedbackVaryings.bufferMode === "separate" ? gl.SEPARATE_ATTRIBS : gl.INTERLEAVED_ATTRIBS
        );
      }
    }
    gl.linkProgram(webGLProgram);
    if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) {
      logProgramError(gl, webGLProgram, glVertShader, glFragShader);
    }
    program._attributeData = extractAttributesFromGlProgram(
      webGLProgram,
      gl,
      !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(program.vertex)
    );
    program._uniformData = getUniformData(webGLProgram, gl);
    program._uniformBlockData = getUboData(webGLProgram, gl);
    gl.deleteShader(glVertShader);
    gl.deleteShader(glFragShader);
    const uniformData = {};
    for (const i2 in program._uniformData) {
      const data = program._uniformData[i2];
      uniformData[i2] = {
        location: gl.getUniformLocation(webGLProgram, i2),
        value: defaultValue(data.type, data.size)
      };
    }
    const glProgram2 = new GlProgramData(webGLProgram, uniformData);
    return glProgram2;
  }
  var init_generateProgram = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/generateProgram.mjs"() {
      init_warn();
      init_GlProgramData();
      init_compileShader();
      init_defaultValue();
      init_extractAttributesFromGlProgram();
      init_getUboData();
      init_getUniformData();
      init_logProgramError();
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlShaderSystem.mjs
  var defaultSyncData, GlShaderSystem;
  var init_GlShaderSystem = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlShaderSystem.mjs"() {
      init_Extensions();
      init_GenerateShaderSyncCode();
      init_generateProgram();
      defaultSyncData = {
        textureCount: 0,
        blockIndex: 0
      };
      GlShaderSystem = class {
        constructor(renderer) {
          this._activeProgram = null;
          this._programDataHash = /* @__PURE__ */ Object.create(null);
          this._nextIndex = 0;
          this._boundUniformsIdsToIndexHash = /* @__PURE__ */ Object.create(null);
          this._boundIndexToUniformsHash = /* @__PURE__ */ Object.create(null);
          this._shaderSyncFunctions = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
        }
        contextChange(gl) {
          this._gl = gl;
          this._maxBindings = gl.MAX_UNIFORM_BUFFER_BINDINGS ? gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
          this._programDataHash = /* @__PURE__ */ Object.create(null);
          this._boundUniformsIdsToIndexHash = /* @__PURE__ */ Object.create(null);
          this._boundIndexToUniformsHash = /* @__PURE__ */ Object.create(null);
          this._activeProgram = null;
        }
        /**
         * Changes the current shader to the one given in parameter.
         * @param shader - the new shader
         * @param skipSync - false if the shader should automatically sync its uniforms.
         * @returns the glProgram that belongs to the shader.
         */
        bind(shader, skipSync) {
          this._setProgram(shader.glProgram);
          if (skipSync)
            return;
          defaultSyncData.textureCount = 0;
          defaultSyncData.blockIndex = 0;
          let syncFunction = this._shaderSyncFunctions[shader.glProgram._key];
          if (!syncFunction) {
            syncFunction = this._shaderSyncFunctions[shader.glProgram._key] = this._generateShaderSync(shader, this);
          }
          syncFunction(this._renderer, shader, defaultSyncData);
        }
        /**
         * Updates the uniform group.
         * @param uniformGroup - the uniform group to update
         */
        updateUniformGroup(uniformGroup) {
          this._renderer.uniformGroup.updateUniformGroup(uniformGroup, this._activeProgram, defaultSyncData);
        }
        /**
         * Binds a uniform block to the shader.
         * @param uniformGroup - the uniform group to bind
         * @param name - the name of the uniform block
         * @param index - the index of the uniform block
         */
        bindUniformBlock(uniformGroup, name, index = 0) {
          const bufferSystem = this._renderer.buffer;
          const programData = this._getProgramData(this._activeProgram);
          const isBufferResource = uniformGroup._bufferResource;
          if (isBufferResource) {
            this._renderer.ubo.updateUniformGroup(uniformGroup);
          }
          bufferSystem.updateBuffer(uniformGroup.buffer);
          let boundIndex = this._boundUniformsIdsToIndexHash[uniformGroup.uid];
          if (boundIndex === void 0) {
            const nextIndex = this._nextIndex++ % this._maxBindings;
            const currentBoundUniformGroup = this._boundIndexToUniformsHash[nextIndex];
            if (currentBoundUniformGroup) {
              this._boundUniformsIdsToIndexHash[currentBoundUniformGroup.uid] = void 0;
            }
            boundIndex = this._boundUniformsIdsToIndexHash[uniformGroup.uid] = nextIndex;
            this._boundIndexToUniformsHash[nextIndex] = uniformGroup;
            if (isBufferResource) {
              bufferSystem.bindBufferRange(uniformGroup.buffer, nextIndex, uniformGroup.offset);
            } else {
              bufferSystem.bindBufferBase(uniformGroup.buffer, nextIndex);
            }
          }
          const gl = this._gl;
          const uniformBlockIndex = this._activeProgram._uniformBlockData[name].index;
          if (programData.uniformBlockBindings[index] === boundIndex)
            return;
          programData.uniformBlockBindings[index] = boundIndex;
          gl.uniformBlockBinding(programData.program, uniformBlockIndex, boundIndex);
        }
        _setProgram(program) {
          if (this._activeProgram === program)
            return;
          this._activeProgram = program;
          const programData = this._getProgramData(program);
          this._gl.useProgram(programData.program);
        }
        /**
         * @param program - the program to get the data for
         * @internal
         * @private
         */
        _getProgramData(program) {
          return this._programDataHash[program._key] || this._createProgramData(program);
        }
        _createProgramData(program) {
          const key = program._key;
          this._programDataHash[key] = generateProgram(this._gl, program);
          return this._programDataHash[key];
        }
        destroy() {
          for (const key of Object.keys(this._programDataHash)) {
            const programData = this._programDataHash[key];
            programData.destroy();
            this._programDataHash[key] = null;
          }
          this._programDataHash = null;
          this._boundUniformsIdsToIndexHash = null;
        }
        /**
         * Creates a function that can be executed that will sync the shader as efficiently as possible.
         * Overridden by the unsafe eval package if you don't want eval used in your project.
         * @param shader - the shader to generate the sync function for
         * @param shaderSystem - the shader system to use
         * @returns - the generated sync function
         * @ignore
         */
        _generateShaderSync(shader, shaderSystem) {
          return generateShaderSyncCode(shader, shaderSystem);
        }
      };
      GlShaderSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "shader"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSyncTypes.mjs
  var UNIFORM_TO_SINGLE_SETTERS, UNIFORM_TO_ARRAY_SETTERS;
  var init_generateUniformsSyncTypes = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSyncTypes.mjs"() {
      "use strict";
      UNIFORM_TO_SINGLE_SETTERS = {
        f32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1f(location, v);
        }`,
        "vec2<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2f(location, v[0], v[1]);
        }`,
        "vec3<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3f(location, v[0], v[1], v[2]);
        }`,
        "vec4<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4f(location, v[0], v[1], v[2], v[3]);
        }`,
        i32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
        "vec2<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
        "vec3<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
        "vec4<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
        u32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1ui(location, v);
        }`,
        "vec2<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2ui(location, v[0], v[1]);
        }`,
        "vec3<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3ui(location, v[0], v[1], v[2]);
        }`,
        "vec4<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
        }`,
        bool: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
        "vec2<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
        "vec3<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
        "vec4<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
        "mat2x2<f32>": `gl.uniformMatrix2fv(location, false, v);`,
        "mat3x3<f32>": `gl.uniformMatrix3fv(location, false, v);`,
        "mat4x4<f32>": `gl.uniformMatrix4fv(location, false, v);`
      };
      UNIFORM_TO_ARRAY_SETTERS = {
        f32: `gl.uniform1fv(location, v);`,
        "vec2<f32>": `gl.uniform2fv(location, v);`,
        "vec3<f32>": `gl.uniform3fv(location, v);`,
        "vec4<f32>": `gl.uniform4fv(location, v);`,
        "mat2x2<f32>": `gl.uniformMatrix2fv(location, false, v);`,
        "mat3x3<f32>": `gl.uniformMatrix3fv(location, false, v);`,
        "mat4x4<f32>": `gl.uniformMatrix4fv(location, false, v);`,
        i32: `gl.uniform1iv(location, v);`,
        "vec2<i32>": `gl.uniform2iv(location, v);`,
        "vec3<i32>": `gl.uniform3iv(location, v);`,
        "vec4<i32>": `gl.uniform4iv(location, v);`,
        u32: `gl.uniform1iv(location, v);`,
        "vec2<u32>": `gl.uniform2iv(location, v);`,
        "vec3<u32>": `gl.uniform3iv(location, v);`,
        "vec4<u32>": `gl.uniform4iv(location, v);`,
        bool: `gl.uniform1iv(location, v);`,
        "vec2<bool>": `gl.uniform2iv(location, v);`,
        "vec3<bool>": `gl.uniform3iv(location, v);`,
        "vec4<bool>": `gl.uniform4iv(location, v);`
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSync.mjs
  function generateUniformsSync(group, uniformData) {
    const funcFragments = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
        var name = null;
    `];
    for (const i2 in group.uniforms) {
      if (!uniformData[i2]) {
        if (group.uniforms[i2] instanceof UniformGroup) {
          if (group.uniforms[i2].ubo) {
            funcFragments.push(`
                        renderer.shader.bindUniformBlock(uv.${i2}, "${i2}");
                    `);
          } else {
            funcFragments.push(`
                        renderer.shader.updateUniformGroup(uv.${i2});
                    `);
          }
        } else if (group.uniforms[i2] instanceof BufferResource) {
          funcFragments.push(`
                        renderer.shader.bindBufferResource(uv.${i2}, "${i2}");
                    `);
        }
        continue;
      }
      const uniform = group.uniformStructures[i2];
      let parsed = false;
      for (let j2 = 0; j2 < uniformParsers.length; j2++) {
        const parser = uniformParsers[j2];
        if (uniform.type === parser.type && parser.test(uniform)) {
          funcFragments.push(`name = "${i2}";`, uniformParsers[j2].uniform);
          parsed = true;
          break;
        }
      }
      if (!parsed) {
        const templateType = uniform.size === 1 ? UNIFORM_TO_SINGLE_SETTERS : UNIFORM_TO_ARRAY_SETTERS;
        const template = templateType[uniform.type].replace("location", `ud["${i2}"].location`);
        funcFragments.push(`
            cu = ud["${i2}"];
            cv = cu.value;
            v = uv["${i2}"];
            ${template};`);
      }
    }
    return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\n"));
  }
  var init_generateUniformsSync = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSync.mjs"() {
      init_BufferResource();
      init_UniformGroup();
      init_uniformParsers();
      init_generateUniformsSyncTypes();
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlUniformGroupSystem.mjs
  var GlUniformGroupSystem;
  var init_GlUniformGroupSystem = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlUniformGroupSystem.mjs"() {
      init_Extensions();
      init_generateUniformsSync();
      GlUniformGroupSystem = class {
        /** @param renderer - The renderer this System works for. */
        constructor(renderer) {
          this._cache = {};
          this._uniformGroupSyncHash = {};
          this._renderer = renderer;
          this.gl = null;
          this._cache = {};
        }
        contextChange(gl) {
          this.gl = gl;
        }
        /**
         * Uploads the uniforms values to the currently bound shader.
         * @param group - the uniforms values that be applied to the current shader
         * @param program
         * @param syncData
         * @param syncData.textureCount
         */
        updateUniformGroup(group, program, syncData) {
          const programData = this._renderer.shader._getProgramData(program);
          if (!group.isStatic || group._dirtyId !== programData.uniformDirtyGroups[group.uid]) {
            programData.uniformDirtyGroups[group.uid] = group._dirtyId;
            const syncFunc = this._getUniformSyncFunction(group, program);
            syncFunc(programData.uniformData, group.uniforms, this._renderer, syncData);
          }
        }
        /**
         * Overrideable by the pixi.js/unsafe-eval package to use static syncUniforms instead.
         * @param group
         * @param program
         */
        _getUniformSyncFunction(group, program) {
          return this._uniformGroupSyncHash[group._signature]?.[program._key] || this._createUniformSyncFunction(group, program);
        }
        _createUniformSyncFunction(group, program) {
          const uniformGroupSyncHash = this._uniformGroupSyncHash[group._signature] || (this._uniformGroupSyncHash[group._signature] = {});
          const id = this._getSignature(group, program._uniformData, "u");
          if (!this._cache[id]) {
            this._cache[id] = this._generateUniformsSync(group, program._uniformData);
          }
          uniformGroupSyncHash[program._key] = this._cache[id];
          return uniformGroupSyncHash[program._key];
        }
        _generateUniformsSync(group, uniformData) {
          return generateUniformsSync(group, uniformData);
        }
        /**
         * Takes a uniform group and data and generates a unique signature for them.
         * @param group - The uniform group to get signature of
         * @param group.uniforms
         * @param uniformData - Uniform information generated by the shader
         * @param preFix
         * @returns Unique signature of the uniform group
         */
        _getSignature(group, uniformData, preFix) {
          const uniforms = group.uniforms;
          const strings = [`${preFix}-`];
          for (const i2 in uniforms) {
            strings.push(i2);
            if (uniformData[i2]) {
              strings.push(uniformData[i2].type);
            }
          }
          return strings.join("-");
        }
        /** Destroys this System and removes all its textures. */
        destroy() {
          this._renderer = null;
          this._cache = null;
        }
      };
      GlUniformGroupSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "uniformGroup"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.mjs
  function mapWebGLBlendModesToPixi(gl) {
    const blendMap = {};
    blendMap.normal = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    blendMap.add = [gl.ONE, gl.ONE];
    blendMap.multiply = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    blendMap.screen = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    blendMap.none = [0, 0];
    blendMap["normal-npm"] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    blendMap["add-npm"] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
    blendMap["screen-npm"] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    blendMap.erase = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
    return blendMap;
  }
  var init_mapWebGLBlendModesToPixi = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/state/GlStateSystem.mjs
  var BLEND2, OFFSET2, CULLING2, DEPTH_TEST2, WINDING2, DEPTH_MASK2, _GlStateSystem, GlStateSystem;
  var init_GlStateSystem = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/state/GlStateSystem.mjs"() {
      init_Extensions();
      init_State();
      init_mapWebGLBlendModesToPixi();
      BLEND2 = 0;
      OFFSET2 = 1;
      CULLING2 = 2;
      DEPTH_TEST2 = 3;
      WINDING2 = 4;
      DEPTH_MASK2 = 5;
      _GlStateSystem = class _GlStateSystem2 {
        constructor() {
          this.gl = null;
          this.stateId = 0;
          this.polygonOffset = 0;
          this.blendMode = "none";
          this._blendEq = false;
          this.map = [];
          this.map[BLEND2] = this.setBlend;
          this.map[OFFSET2] = this.setOffset;
          this.map[CULLING2] = this.setCullFace;
          this.map[DEPTH_TEST2] = this.setDepthTest;
          this.map[WINDING2] = this.setFrontFace;
          this.map[DEPTH_MASK2] = this.setDepthMask;
          this.checks = [];
          this.defaultState = State.for2d();
        }
        contextChange(gl) {
          this.gl = gl;
          this.blendModesMap = mapWebGLBlendModesToPixi(gl);
          this.reset();
        }
        /**
         * Sets the current state
         * @param {*} state - The state to set.
         */
        set(state) {
          state = state || this.defaultState;
          if (this.stateId !== state.data) {
            let diff = this.stateId ^ state.data;
            let i2 = 0;
            while (diff) {
              if (diff & 1) {
                this.map[i2].call(this, !!(state.data & 1 << i2));
              }
              diff = diff >> 1;
              i2++;
            }
            this.stateId = state.data;
          }
          for (let i2 = 0; i2 < this.checks.length; i2++) {
            this.checks[i2](this, state);
          }
        }
        /**
         * Sets the state, when previous state is unknown.
         * @param {*} state - The state to set
         */
        forceState(state) {
          state = state || this.defaultState;
          for (let i2 = 0; i2 < this.map.length; i2++) {
            this.map[i2].call(this, !!(state.data & 1 << i2));
          }
          for (let i2 = 0; i2 < this.checks.length; i2++) {
            this.checks[i2](this, state);
          }
          this.stateId = state.data;
        }
        /**
         * Sets whether to enable or disable blending.
         * @param value - Turn on or off WebGl blending.
         */
        setBlend(value) {
          this._updateCheck(_GlStateSystem2._checkBlendMode, value);
          this.gl[value ? "enable" : "disable"](this.gl.BLEND);
        }
        /**
         * Sets whether to enable or disable polygon offset fill.
         * @param value - Turn on or off webgl polygon offset testing.
         */
        setOffset(value) {
          this._updateCheck(_GlStateSystem2._checkPolygonOffset, value);
          this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
        }
        /**
         * Sets whether to enable or disable depth test.
         * @param value - Turn on or off webgl depth testing.
         */
        setDepthTest(value) {
          this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);
        }
        /**
         * Sets whether to enable or disable depth mask.
         * @param value - Turn on or off webgl depth mask.
         */
        setDepthMask(value) {
          this.gl.depthMask(value);
        }
        /**
         * Sets whether to enable or disable cull face.
         * @param {boolean} value - Turn on or off webgl cull face.
         */
        setCullFace(value) {
          this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);
        }
        /**
         * Sets the gl front face.
         * @param {boolean} value - true is clockwise and false is counter-clockwise
         */
        setFrontFace(value) {
          this.gl.frontFace(this.gl[value ? "CW" : "CCW"]);
        }
        /**
         * Sets the blend mode.
         * @param {number} value - The blend mode to set to.
         */
        setBlendMode(value) {
          if (!this.blendModesMap[value]) {
            value = "normal";
          }
          if (value === this.blendMode) {
            return;
          }
          this.blendMode = value;
          const mode = this.blendModesMap[value];
          const gl = this.gl;
          if (mode.length === 2) {
            gl.blendFunc(mode[0], mode[1]);
          } else {
            gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
          }
          if (mode.length === 6) {
            this._blendEq = true;
            gl.blendEquationSeparate(mode[4], mode[5]);
          } else if (this._blendEq) {
            this._blendEq = false;
            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
          }
        }
        /**
         * Sets the polygon offset.
         * @param {number} value - the polygon offset
         * @param {number} scale - the polygon offset scale
         */
        setPolygonOffset(value, scale) {
          this.gl.polygonOffset(value, scale);
        }
        // used
        /** Resets all the logic and disables the VAOs. */
        reset() {
          this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
          this.forceState(this.defaultState);
          this._blendEq = true;
          this.blendMode = "";
          this.setBlendMode("normal");
        }
        /**
         * Checks to see which updates should be checked based on which settings have been activated.
         *
         * For example, if blend is enabled then we should check the blend modes each time the state is changed
         * or if polygon fill is activated then we need to check if the polygon offset changes.
         * The idea is that we only check what we have too.
         * @param func - the checking function to add or remove
         * @param value - should the check function be added or removed.
         */
        _updateCheck(func, value) {
          const index = this.checks.indexOf(func);
          if (value && index === -1) {
            this.checks.push(func);
          } else if (!value && index !== -1) {
            this.checks.splice(index, 1);
          }
        }
        /**
         * A private little wrapper function that we call to check the blend mode.
         * @param system - the System to perform the state check on
         * @param state - the state that the blendMode will pulled from
         */
        static _checkBlendMode(system, state) {
          system.setBlendMode(state.blendMode);
        }
        /**
         * A private little wrapper function that we call to check the polygon offset.
         * @param system - the System to perform the state check on
         * @param state - the state that the blendMode will pulled from
         */
        static _checkPolygonOffset(system, state) {
          system.setPolygonOffset(1, state.polygonOffset);
        }
        /**
         * @ignore
         */
        destroy() {
          this.gl = null;
          this.checks.length = 0;
        }
      };
      _GlStateSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "state"
      };
      GlStateSystem = _GlStateSystem;
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTexture.mjs
  var GlTexture;
  var init_GlTexture = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTexture.mjs"() {
      init_const10();
      GlTexture = class {
        constructor(texture) {
          this.target = GL_TARGETS.TEXTURE_2D;
          this.texture = texture;
          this.width = -1;
          this.height = -1;
          this.type = GL_TYPES.UNSIGNED_BYTE;
          this.internalFormat = GL_FORMATS.RGBA;
          this.format = GL_FORMATS.RGBA;
          this.samplerType = 0;
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.mjs
  var glUploadBufferImageResource;
  var init_glUploadBufferImageResource = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.mjs"() {
      "use strict";
      glUploadBufferImageResource = {
        id: "image",
        upload(source2, glTexture, gl) {
          if (glTexture.width === source2.width || glTexture.height === source2.height) {
            gl.texSubImage2D(
              gl.TEXTURE_2D,
              0,
              0,
              0,
              glTexture.format,
              glTexture.type,
              source2.resource
            );
          } else {
            gl.texImage2D(
              glTexture.target,
              0,
              glTexture.internalFormat,
              source2.width,
              source2.height,
              0,
              glTexture.format,
              glTexture.type,
              source2.resource
            );
          }
          glTexture.width = source2.width;
          glTexture.height = source2.height;
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.mjs
  var compressedFormatMap, glUploadCompressedTextureResource;
  var init_glUploadCompressedTextureResource = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.mjs"() {
      "use strict";
      compressedFormatMap = {
        "bc1-rgba-unorm": true,
        "bc1-rgba-unorm-srgb": true,
        "bc2-rgba-unorm": true,
        "bc2-rgba-unorm-srgb": true,
        "bc3-rgba-unorm": true,
        "bc3-rgba-unorm-srgb": true,
        "bc4-r-unorm": true,
        "bc4-r-snorm": true,
        "bc5-rg-unorm": true,
        "bc5-rg-snorm": true,
        "bc6h-rgb-ufloat": true,
        "bc6h-rgb-float": true,
        "bc7-rgba-unorm": true,
        "bc7-rgba-unorm-srgb": true,
        // ETC2 compressed formats usable if "texture-compression-etc2" is both
        // supported by the device/user agent and enabled in requestDevice.
        "etc2-rgb8unorm": true,
        "etc2-rgb8unorm-srgb": true,
        "etc2-rgb8a1unorm": true,
        "etc2-rgb8a1unorm-srgb": true,
        "etc2-rgba8unorm": true,
        "etc2-rgba8unorm-srgb": true,
        "eac-r11unorm": true,
        "eac-r11snorm": true,
        "eac-rg11unorm": true,
        "eac-rg11snorm": true,
        // ASTC compressed formats usable if "texture-compression-astc" is both
        // supported by the device/user agent and enabled in requestDevice.
        "astc-4x4-unorm": true,
        "astc-4x4-unorm-srgb": true,
        "astc-5x4-unorm": true,
        "astc-5x4-unorm-srgb": true,
        "astc-5x5-unorm": true,
        "astc-5x5-unorm-srgb": true,
        "astc-6x5-unorm": true,
        "astc-6x5-unorm-srgb": true,
        "astc-6x6-unorm": true,
        "astc-6x6-unorm-srgb": true,
        "astc-8x5-unorm": true,
        "astc-8x5-unorm-srgb": true,
        "astc-8x6-unorm": true,
        "astc-8x6-unorm-srgb": true,
        "astc-8x8-unorm": true,
        "astc-8x8-unorm-srgb": true,
        "astc-10x5-unorm": true,
        "astc-10x5-unorm-srgb": true,
        "astc-10x6-unorm": true,
        "astc-10x6-unorm-srgb": true,
        "astc-10x8-unorm": true,
        "astc-10x8-unorm-srgb": true,
        "astc-10x10-unorm": true,
        "astc-10x10-unorm-srgb": true,
        "astc-12x10-unorm": true,
        "astc-12x10-unorm-srgb": true,
        "astc-12x12-unorm": true,
        "astc-12x12-unorm-srgb": true
      };
      glUploadCompressedTextureResource = {
        id: "compressed",
        upload(source2, glTexture, gl) {
          gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);
          let mipWidth = source2.pixelWidth;
          let mipHeight = source2.pixelHeight;
          const compressed = !!compressedFormatMap[source2.format];
          for (let i2 = 0; i2 < source2.resource.length; i2++) {
            const levelBuffer = source2.resource[i2];
            if (compressed) {
              gl.compressedTexImage2D(
                gl.TEXTURE_2D,
                i2,
                glTexture.internalFormat,
                mipWidth,
                mipHeight,
                0,
                levelBuffer
              );
            } else {
              gl.texImage2D(
                gl.TEXTURE_2D,
                i2,
                glTexture.internalFormat,
                mipWidth,
                mipHeight,
                0,
                glTexture.format,
                glTexture.type,
                levelBuffer
              );
            }
            mipWidth = Math.max(mipWidth >> 1, 1);
            mipHeight = Math.max(mipHeight >> 1, 1);
          }
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadImageResource.mjs
  var glUploadImageResource;
  var init_glUploadImageResource = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadImageResource.mjs"() {
      "use strict";
      glUploadImageResource = {
        id: "image",
        upload(source2, glTexture, gl, webGLVersion) {
          const premultipliedAlpha = source2.alphaMode === "premultiply-alpha-on-upload";
          gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultipliedAlpha);
          const glWidth = glTexture.width;
          const glHeight = glTexture.height;
          const textureWidth = source2.pixelWidth;
          const textureHeight = source2.pixelHeight;
          const resourceWidth = source2.resourceWidth;
          const resourceHeight = source2.resourceHeight;
          if (resourceWidth < textureWidth || resourceHeight < textureHeight) {
            if (glWidth !== textureWidth || glHeight !== textureHeight) {
              gl.texImage2D(
                glTexture.target,
                0,
                glTexture.internalFormat,
                textureWidth,
                textureHeight,
                0,
                glTexture.format,
                glTexture.type,
                null
              );
            }
            if (webGLVersion === 2) {
              gl.texSubImage2D(
                gl.TEXTURE_2D,
                0,
                0,
                0,
                resourceWidth,
                resourceHeight,
                glTexture.format,
                glTexture.type,
                source2.resource
              );
            } else {
              gl.texSubImage2D(
                gl.TEXTURE_2D,
                0,
                0,
                0,
                glTexture.format,
                glTexture.type,
                source2.resource
              );
            }
          } else if (glWidth === textureWidth || glHeight === textureHeight) {
            gl.texSubImage2D(
              gl.TEXTURE_2D,
              0,
              0,
              0,
              glTexture.format,
              glTexture.type,
              source2.resource
            );
          } else if (webGLVersion === 2) {
            gl.texImage2D(
              glTexture.target,
              0,
              glTexture.internalFormat,
              textureWidth,
              textureHeight,
              0,
              glTexture.format,
              glTexture.type,
              source2.resource
            );
          } else {
            gl.texImage2D(
              glTexture.target,
              0,
              glTexture.internalFormat,
              glTexture.format,
              glTexture.type,
              source2.resource
            );
          }
          glTexture.width = textureWidth;
          glTexture.height = textureHeight;
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.mjs
  var glUploadVideoResource;
  var init_glUploadVideoResource = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.mjs"() {
      init_glUploadImageResource();
      glUploadVideoResource = {
        id: "video",
        upload(source2, glTexture, gl, webGLVersion) {
          if (!source2.isValid) {
            gl.texImage2D(
              glTexture.target,
              0,
              glTexture.internalFormat,
              1,
              1,
              0,
              glTexture.format,
              glTexture.type,
              null
            );
            return;
          }
          glUploadImageResource.upload(source2, glTexture, gl, webGLVersion);
        }
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/pixiToGlMaps.mjs
  var scaleModeToGlFilter, mipmapScaleModeToGlFilter, wrapModeToGlAddress, compareModeToGlCompare;
  var init_pixiToGlMaps = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/pixiToGlMaps.mjs"() {
      "use strict";
      scaleModeToGlFilter = {
        linear: 9729,
        nearest: 9728
      };
      mipmapScaleModeToGlFilter = {
        linear: {
          linear: 9987,
          nearest: 9985
        },
        nearest: {
          linear: 9986,
          nearest: 9984
        }
      };
      wrapModeToGlAddress = {
        "clamp-to-edge": 33071,
        repeat: 10497,
        "mirror-repeat": 33648
      };
      compareModeToGlCompare = {
        never: 512,
        less: 513,
        equal: 514,
        "less-equal": 515,
        greater: 516,
        "not-equal": 517,
        "greater-equal": 518,
        always: 519
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/applyStyleParams.mjs
  function applyStyleParams(style, gl, mipmaps, anisotropicExt, glFunctionName, firstParam, forceClamp, firstCreation) {
    const castParam = firstParam;
    if (!firstCreation || style.addressModeU !== "repeat" || style.addressModeV !== "repeat" || style.addressModeW !== "repeat") {
      const wrapModeS = wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style.addressModeU];
      const wrapModeT = wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style.addressModeV];
      const wrapModeR = wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style.addressModeW];
      gl[glFunctionName](castParam, gl.TEXTURE_WRAP_S, wrapModeS);
      gl[glFunctionName](castParam, gl.TEXTURE_WRAP_T, wrapModeT);
      if (gl.TEXTURE_WRAP_R)
        gl[glFunctionName](castParam, gl.TEXTURE_WRAP_R, wrapModeR);
    }
    if (!firstCreation || style.magFilter !== "linear") {
      gl[glFunctionName](castParam, gl.TEXTURE_MAG_FILTER, scaleModeToGlFilter[style.magFilter]);
    }
    if (mipmaps) {
      if (!firstCreation || style.mipmapFilter !== "linear") {
        const glFilterMode = mipmapScaleModeToGlFilter[style.minFilter][style.mipmapFilter];
        gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, glFilterMode);
      }
    } else {
      gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, scaleModeToGlFilter[style.minFilter]);
    }
    if (anisotropicExt && style.maxAnisotropy > 1) {
      const level = Math.min(style.maxAnisotropy, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
      gl[glFunctionName](castParam, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
    }
    if (style.compare) {
      gl[glFunctionName](castParam, gl.TEXTURE_COMPARE_FUNC, compareModeToGlCompare[style.compare]);
    }
  }
  var init_applyStyleParams = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/applyStyleParams.mjs"() {
      init_pixiToGlMaps();
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.mjs
  function mapFormatToGlFormat(gl) {
    return {
      // 8-bit formats
      r8unorm: gl.RED,
      r8snorm: gl.RED,
      r8uint: gl.RED,
      r8sint: gl.RED,
      // 16-bit formats
      r16uint: gl.RED,
      r16sint: gl.RED,
      r16float: gl.RED,
      rg8unorm: gl.RG,
      rg8snorm: gl.RG,
      rg8uint: gl.RG,
      rg8sint: gl.RG,
      // 32-bit formats
      r32uint: gl.RED,
      r32sint: gl.RED,
      r32float: gl.RED,
      rg16uint: gl.RG,
      rg16sint: gl.RG,
      rg16float: gl.RG,
      rgba8unorm: gl.RGBA,
      "rgba8unorm-srgb": gl.RGBA,
      // Packed 32-bit formats
      rgba8snorm: gl.RGBA,
      rgba8uint: gl.RGBA,
      rgba8sint: gl.RGBA,
      bgra8unorm: gl.RGBA,
      "bgra8unorm-srgb": gl.RGBA,
      rgb9e5ufloat: gl.RGB,
      rgb10a2unorm: gl.RGBA,
      rg11b10ufloat: gl.RGB,
      // 64-bit formats
      rg32uint: gl.RG,
      rg32sint: gl.RG,
      rg32float: gl.RG,
      rgba16uint: gl.RGBA,
      rgba16sint: gl.RGBA,
      rgba16float: gl.RGBA,
      // 128-bit formats
      rgba32uint: gl.RGBA,
      rgba32sint: gl.RGBA,
      rgba32float: gl.RGBA,
      // Depth/stencil formats
      stencil8: gl.STENCIL_INDEX8,
      depth16unorm: gl.DEPTH_COMPONENT,
      depth24plus: gl.DEPTH_COMPONENT,
      "depth24plus-stencil8": gl.DEPTH_STENCIL,
      depth32float: gl.DEPTH_COMPONENT,
      "depth32float-stencil8": gl.DEPTH_STENCIL
    };
  }
  var init_mapFormatToGlFormat = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.mjs
  function mapFormatToGlInternalFormat(gl, extensions2) {
    let srgb = {};
    let bgra8unorm = gl.RGBA;
    if (!(gl instanceof DOMAdapter.get().getWebGLRenderingContext())) {
      srgb = {
        "rgba8unorm-srgb": gl.SRGB8_ALPHA8,
        "bgra8unorm-srgb": gl.SRGB8_ALPHA8
      };
      bgra8unorm = gl.RGBA8;
    } else if (extensions2.srgb) {
      srgb = {
        "rgba8unorm-srgb": extensions2.srgb.SRGB8_ALPHA8_EXT,
        "bgra8unorm-srgb": extensions2.srgb.SRGB8_ALPHA8_EXT
      };
    }
    return {
      // 8-bit formats
      r8unorm: gl.R8,
      r8snorm: gl.R8_SNORM,
      r8uint: gl.R8UI,
      r8sint: gl.R8I,
      // 16-bit formats
      r16uint: gl.R16UI,
      r16sint: gl.R16I,
      r16float: gl.R16F,
      rg8unorm: gl.RG8,
      rg8snorm: gl.RG8_SNORM,
      rg8uint: gl.RG8UI,
      rg8sint: gl.RG8I,
      // 32-bit formats
      r32uint: gl.R32UI,
      r32sint: gl.R32I,
      r32float: gl.R32F,
      rg16uint: gl.RG16UI,
      rg16sint: gl.RG16I,
      rg16float: gl.RG16F,
      rgba8unorm: gl.RGBA,
      ...srgb,
      // Packed 32-bit formats
      rgba8snorm: gl.RGBA8_SNORM,
      rgba8uint: gl.RGBA8UI,
      rgba8sint: gl.RGBA8I,
      bgra8unorm,
      rgb9e5ufloat: gl.RGB9_E5,
      rgb10a2unorm: gl.RGB10_A2,
      rg11b10ufloat: gl.R11F_G11F_B10F,
      // 64-bit formats
      rg32uint: gl.RG32UI,
      rg32sint: gl.RG32I,
      rg32float: gl.RG32F,
      rgba16uint: gl.RGBA16UI,
      rgba16sint: gl.RGBA16I,
      rgba16float: gl.RGBA16F,
      // 128-bit formats
      rgba32uint: gl.RGBA32UI,
      rgba32sint: gl.RGBA32I,
      rgba32float: gl.RGBA32F,
      // Depth/stencil formats
      stencil8: gl.STENCIL_INDEX8,
      depth16unorm: gl.DEPTH_COMPONENT16,
      depth24plus: gl.DEPTH_COMPONENT24,
      "depth24plus-stencil8": gl.DEPTH24_STENCIL8,
      depth32float: gl.DEPTH_COMPONENT32F,
      "depth32float-stencil8": gl.DEPTH32F_STENCIL8,
      // Compressed formats
      ...extensions2.s3tc ? {
        "bc1-rgba-unorm": extensions2.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,
        "bc2-rgba-unorm": extensions2.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,
        "bc3-rgba-unorm": extensions2.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT
      } : {},
      ...extensions2.s3tc_sRGB ? {
        "bc1-rgba-unorm-srgb": extensions2.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
        "bc2-rgba-unorm-srgb": extensions2.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
        "bc3-rgba-unorm-srgb": extensions2.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
      } : {},
      ...extensions2.rgtc ? {
        "bc4-r-unorm": extensions2.rgtc.COMPRESSED_RED_RGTC1_EXT,
        "bc4-r-snorm": extensions2.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,
        "bc5-rg-unorm": extensions2.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,
        "bc5-rg-snorm": extensions2.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
      } : {},
      ...extensions2.bptc ? {
        "bc6h-rgb-float": extensions2.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,
        "bc6h-rgb-ufloat": extensions2.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,
        "bc7-rgba-unorm": extensions2.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,
        "bc7-rgba-unorm-srgb": extensions2.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
      } : {},
      ...extensions2.etc ? {
        "etc2-rgb8unorm": extensions2.etc.COMPRESSED_RGB8_ETC2,
        "etc2-rgb8unorm-srgb": extensions2.etc.COMPRESSED_SRGB8_ETC2,
        "etc2-rgb8a1unorm": extensions2.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
        "etc2-rgb8a1unorm-srgb": extensions2.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,
        "etc2-rgba8unorm": extensions2.etc.COMPRESSED_RGBA8_ETC2_EAC,
        "etc2-rgba8unorm-srgb": extensions2.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,
        "eac-r11unorm": extensions2.etc.COMPRESSED_R11_EAC,
        // 'eac-r11snorm'
        "eac-rg11unorm": extensions2.etc.COMPRESSED_SIGNED_RG11_EAC
        // 'eac-rg11snorm'
      } : {},
      ...extensions2.astc ? {
        "astc-4x4-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,
        "astc-4x4-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,
        "astc-5x4-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,
        "astc-5x4-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,
        "astc-5x5-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,
        "astc-5x5-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,
        "astc-6x5-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,
        "astc-6x5-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,
        "astc-6x6-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,
        "astc-6x6-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,
        "astc-8x5-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,
        "astc-8x5-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,
        "astc-8x6-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,
        "astc-8x6-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,
        "astc-8x8-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,
        "astc-8x8-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,
        "astc-10x5-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,
        "astc-10x5-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,
        "astc-10x6-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,
        "astc-10x6-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,
        "astc-10x8-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,
        "astc-10x8-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,
        "astc-10x10-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,
        "astc-10x10-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,
        "astc-12x10-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,
        "astc-12x10-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,
        "astc-12x12-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,
        "astc-12x12-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
      } : {}
    };
  }
  var init_mapFormatToGlInternalFormat = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.mjs"() {
      init_adapter();
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlType.mjs
  function mapFormatToGlType(gl) {
    return {
      // 8-bit formats
      r8unorm: gl.UNSIGNED_BYTE,
      r8snorm: gl.BYTE,
      r8uint: gl.UNSIGNED_BYTE,
      r8sint: gl.BYTE,
      // 16-bit formats
      r16uint: gl.UNSIGNED_SHORT,
      r16sint: gl.SHORT,
      r16float: gl.HALF_FLOAT,
      rg8unorm: gl.UNSIGNED_BYTE,
      rg8snorm: gl.BYTE,
      rg8uint: gl.UNSIGNED_BYTE,
      rg8sint: gl.BYTE,
      // 32-bit formats
      r32uint: gl.UNSIGNED_INT,
      r32sint: gl.INT,
      r32float: gl.FLOAT,
      rg16uint: gl.UNSIGNED_SHORT,
      rg16sint: gl.SHORT,
      rg16float: gl.HALF_FLOAT,
      rgba8unorm: gl.UNSIGNED_BYTE,
      "rgba8unorm-srgb": gl.UNSIGNED_BYTE,
      // Packed 32-bit formats
      rgba8snorm: gl.BYTE,
      rgba8uint: gl.UNSIGNED_BYTE,
      rgba8sint: gl.BYTE,
      bgra8unorm: gl.UNSIGNED_BYTE,
      "bgra8unorm-srgb": gl.UNSIGNED_BYTE,
      rgb9e5ufloat: gl.UNSIGNED_INT_5_9_9_9_REV,
      rgb10a2unorm: gl.UNSIGNED_INT_2_10_10_10_REV,
      rg11b10ufloat: gl.UNSIGNED_INT_10F_11F_11F_REV,
      // 64-bit formats
      rg32uint: gl.UNSIGNED_INT,
      rg32sint: gl.INT,
      rg32float: gl.FLOAT,
      rgba16uint: gl.UNSIGNED_SHORT,
      rgba16sint: gl.SHORT,
      rgba16float: gl.HALF_FLOAT,
      // 128-bit formats
      rgba32uint: gl.UNSIGNED_INT,
      rgba32sint: gl.INT,
      rgba32float: gl.FLOAT,
      // Depth/stencil formats
      stencil8: gl.UNSIGNED_BYTE,
      depth16unorm: gl.UNSIGNED_SHORT,
      depth24plus: gl.UNSIGNED_INT,
      "depth24plus-stencil8": gl.UNSIGNED_INT_24_8,
      depth32float: gl.FLOAT,
      "depth32float-stencil8": gl.FLOAT_32_UNSIGNED_INT_24_8_REV
    };
  }
  var init_mapFormatToGlType = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlType.mjs"() {
      "use strict";
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTextureSystem.mjs
  var BYTES_PER_PIXEL, GlTextureSystem;
  var init_GlTextureSystem = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTextureSystem.mjs"() {
      init_adapter();
      init_Extensions();
      init_Texture();
      init_GlTexture();
      init_glUploadBufferImageResource();
      init_glUploadCompressedTextureResource();
      init_glUploadImageResource();
      init_glUploadVideoResource();
      init_applyStyleParams();
      init_mapFormatToGlFormat();
      init_mapFormatToGlInternalFormat();
      init_mapFormatToGlType();
      BYTES_PER_PIXEL = 4;
      GlTextureSystem = class {
        constructor(renderer) {
          this.managedTextures = [];
          this._glTextures = /* @__PURE__ */ Object.create(null);
          this._glSamplers = /* @__PURE__ */ Object.create(null);
          this._boundTextures = [];
          this._activeTextureLocation = -1;
          this._boundSamplers = /* @__PURE__ */ Object.create(null);
          this._uploads = {
            image: glUploadImageResource,
            buffer: glUploadBufferImageResource,
            video: glUploadVideoResource,
            compressed: glUploadCompressedTextureResource
          };
          this._useSeparateSamplers = false;
          this._renderer = renderer;
        }
        contextChange(gl) {
          this._gl = gl;
          if (!this._mapFormatToInternalFormat) {
            this._mapFormatToInternalFormat = mapFormatToGlInternalFormat(gl, this._renderer.context.extensions);
            this._mapFormatToType = mapFormatToGlType(gl);
            this._mapFormatToFormat = mapFormatToGlFormat(gl);
          }
          this._glTextures = /* @__PURE__ */ Object.create(null);
          this._glSamplers = /* @__PURE__ */ Object.create(null);
          this._boundSamplers = /* @__PURE__ */ Object.create(null);
          for (let i2 = 0; i2 < 16; i2++) {
            this.bind(Texture.EMPTY, i2);
          }
        }
        initSource(source2) {
          this.bind(source2);
        }
        bind(texture, location = 0) {
          const source2 = texture.source;
          if (texture) {
            this.bindSource(source2, location);
            if (this._useSeparateSamplers) {
              this._bindSampler(source2.style, location);
            }
          } else {
            this.bindSource(null, location);
            if (this._useSeparateSamplers) {
              this._bindSampler(null, location);
            }
          }
        }
        bindSource(source2, location = 0) {
          const gl = this._gl;
          source2._touched = this._renderer.textureGC.count;
          if (this._boundTextures[location] !== source2) {
            this._boundTextures[location] = source2;
            this._activateLocation(location);
            source2 = source2 || Texture.EMPTY.source;
            const glTexture = this.getGlSource(source2);
            gl.bindTexture(glTexture.target, glTexture.texture);
          }
        }
        _bindSampler(style, location = 0) {
          const gl = this._gl;
          if (!style) {
            this._boundSamplers[location] = null;
            gl.bindSampler(location, null);
            return;
          }
          const sampler = this._getGlSampler(style);
          if (this._boundSamplers[location] !== sampler) {
            this._boundSamplers[location] = sampler;
            gl.bindSampler(location, sampler);
          }
        }
        unbind(texture) {
          const source2 = texture.source;
          const boundTextures = this._boundTextures;
          const gl = this._gl;
          for (let i2 = 0; i2 < boundTextures.length; i2++) {
            if (boundTextures[i2] === source2) {
              this._activateLocation(i2);
              const glTexture = this.getGlSource(source2);
              gl.bindTexture(glTexture.target, null);
              boundTextures[i2] = null;
            }
          }
        }
        _activateLocation(location) {
          if (this._activeTextureLocation !== location) {
            this._activeTextureLocation = location;
            this._gl.activeTexture(this._gl.TEXTURE0 + location);
          }
        }
        _initSource(source2) {
          const gl = this._gl;
          const glTexture = new GlTexture(gl.createTexture());
          glTexture.type = this._mapFormatToType[source2.format];
          glTexture.internalFormat = this._mapFormatToInternalFormat[source2.format];
          glTexture.format = this._mapFormatToFormat[source2.format];
          if (source2.autoGenerateMipmaps && (this._renderer.context.supports.nonPowOf2mipmaps || source2.isPowerOfTwo)) {
            const biggestDimension = Math.max(source2.width, source2.height);
            source2.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;
          }
          this._glTextures[source2.uid] = glTexture;
          if (!this.managedTextures.includes(source2)) {
            source2.on("update", this.onSourceUpdate, this);
            source2.on("resize", this.onSourceUpdate, this);
            source2.on("styleChange", this.onStyleChange, this);
            source2.on("destroy", this.onSourceDestroy, this);
            source2.on("unload", this.onSourceUnload, this);
            source2.on("updateMipmaps", this.onUpdateMipmaps, this);
            this.managedTextures.push(source2);
          }
          this.onSourceUpdate(source2);
          this.updateStyle(source2, false);
          return glTexture;
        }
        onStyleChange(source2) {
          this.updateStyle(source2, false);
        }
        updateStyle(source2, firstCreation) {
          const gl = this._gl;
          const glTexture = this.getGlSource(source2);
          gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);
          this._boundTextures[this._activeTextureLocation] = source2;
          applyStyleParams(
            source2.style,
            gl,
            source2.mipLevelCount > 1,
            this._renderer.context.extensions.anisotropicFiltering,
            "texParameteri",
            gl.TEXTURE_2D,
            // will force a clamp to edge if the texture is not a power of two
            !this._renderer.context.supports.nonPowOf2wrapping && !source2.isPowerOfTwo,
            firstCreation
          );
        }
        onSourceUnload(source2) {
          const glTexture = this._glTextures[source2.uid];
          if (!glTexture)
            return;
          this.unbind(source2);
          this._glTextures[source2.uid] = null;
          this._gl.deleteTexture(glTexture.texture);
        }
        onSourceUpdate(source2) {
          const gl = this._gl;
          const glTexture = this.getGlSource(source2);
          gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);
          this._boundTextures[this._activeTextureLocation] = source2;
          if (this._uploads[source2.uploadMethodId]) {
            this._uploads[source2.uploadMethodId].upload(source2, glTexture, gl, this._renderer.context.webGLVersion);
          } else {
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, source2.pixelWidth, source2.pixelHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
          }
          if (source2.autoGenerateMipmaps && source2.mipLevelCount > 1) {
            this.onUpdateMipmaps(source2, false);
          }
        }
        onUpdateMipmaps(source2, bind3 = true) {
          if (bind3)
            this.bindSource(source2, 0);
          const glTexture = this.getGlSource(source2);
          this._gl.generateMipmap(glTexture.target);
        }
        onSourceDestroy(source2) {
          source2.off("destroy", this.onSourceDestroy, this);
          source2.off("update", this.onSourceUpdate, this);
          source2.off("resize", this.onSourceUpdate, this);
          source2.off("unload", this.onSourceUnload, this);
          source2.off("styleChange", this.onStyleChange, this);
          source2.off("updateMipmaps", this.onUpdateMipmaps, this);
          this.managedTextures.splice(this.managedTextures.indexOf(source2), 1);
          this.onSourceUnload(source2);
        }
        _initSampler(style) {
          const gl = this._gl;
          const glSampler = this._gl.createSampler();
          this._glSamplers[style._resourceId] = glSampler;
          applyStyleParams(
            style,
            gl,
            this._boundTextures[this._activeTextureLocation].mipLevelCount > 1,
            this._renderer.context.extensions.anisotropicFiltering,
            "samplerParameteri",
            glSampler,
            false,
            true
          );
          return this._glSamplers[style._resourceId];
        }
        _getGlSampler(sampler) {
          return this._glSamplers[sampler._resourceId] || this._initSampler(sampler);
        }
        getGlSource(source2) {
          return this._glTextures[source2.uid] || this._initSource(source2);
        }
        generateCanvas(texture) {
          const { pixels, width, height } = this.getPixels(texture);
          const canvas = DOMAdapter.get().createCanvas();
          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext("2d");
          if (ctx) {
            const imageData = ctx.createImageData(width, height);
            imageData.data.set(pixels);
            ctx.putImageData(imageData, 0, 0);
          }
          return canvas;
        }
        getPixels(texture) {
          const resolution = texture.source.resolution;
          const frame = texture.frame;
          const width = Math.max(Math.round(frame.width * resolution), 1);
          const height = Math.max(Math.round(frame.height * resolution), 1);
          const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
          const renderer = this._renderer;
          const renderTarget = renderer.renderTarget.getRenderTarget(texture);
          const glRenterTarget = renderer.renderTarget.getGpuRenderTarget(renderTarget);
          const gl = renderer.gl;
          gl.bindFramebuffer(gl.FRAMEBUFFER, glRenterTarget.resolveTargetFramebuffer);
          gl.readPixels(
            Math.round(frame.x * resolution),
            Math.round(frame.y * resolution),
            width,
            height,
            gl.RGBA,
            gl.UNSIGNED_BYTE,
            pixels
          );
          if (false) {
            unpremultiplyAlpha(pixels);
          }
          return { pixels: new Uint8ClampedArray(pixels.buffer), width, height };
        }
        destroy() {
          this.managedTextures.slice().forEach((source2) => this.onSourceDestroy(source2));
          this.managedTextures = null;
          this._renderer = null;
        }
      };
      GlTextureSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "texture"
      };
    }
  });

  // ../core/node_modules/pixi.js/lib/rendering/renderers/gl/WebGLRenderer.mjs
  var WebGLRenderer_exports = {};
  __export(WebGLRenderer_exports, {
    WebGLRenderer: () => WebGLRenderer
  });
  var DefaultWebGLSystems, DefaultWebGLPipes, DefaultWebGLAdapters, systems2, renderPipes2, renderPipeAdaptors2, WebGLRenderer;
  var init_WebGLRenderer = __esm({
    "../core/node_modules/pixi.js/lib/rendering/renderers/gl/WebGLRenderer.mjs"() {
      init_Extensions();
      init_GlGraphicsAdaptor();
      init_GlMeshAdaptor();
      init_GlBatchAdaptor();
      init_AbstractRenderer();
      init_SharedSystems();
      init_types();
      init_GlBufferSystem();
      init_GlContextSystem();
      init_GlGeometrySystem();
      init_GlBackBufferSystem();
      init_GlColorMaskSystem();
      init_GlEncoderSystem();
      init_GlStencilSystem();
      init_GlUboSystem();
      init_GlRenderTargetSystem();
      init_GlShaderSystem();
      init_GlUniformGroupSystem();
      init_GlStateSystem();
      init_GlTextureSystem();
      DefaultWebGLSystems = [
        ...SharedSystems,
        GlUboSystem,
        GlBackBufferSystem,
        GlContextSystem,
        GlBufferSystem,
        GlTextureSystem,
        GlRenderTargetSystem,
        GlGeometrySystem,
        GlUniformGroupSystem,
        GlShaderSystem,
        GlEncoderSystem,
        GlStateSystem,
        GlStencilSystem,
        GlColorMaskSystem
      ];
      DefaultWebGLPipes = [...SharedRenderPipes];
      DefaultWebGLAdapters = [GlBatchAdaptor, GlMeshAdaptor, GlGraphicsAdaptor];
      systems2 = [];
      renderPipes2 = [];
      renderPipeAdaptors2 = [];
      extensions.handleByNamedList(ExtensionType.WebGLSystem, systems2);
      extensions.handleByNamedList(ExtensionType.WebGLPipes, renderPipes2);
      extensions.handleByNamedList(ExtensionType.WebGLPipesAdaptor, renderPipeAdaptors2);
      extensions.add(...DefaultWebGLSystems, ...DefaultWebGLPipes, ...DefaultWebGLAdapters);
      WebGLRenderer = class extends AbstractRenderer {
        constructor() {
          const systemConfig = {
            name: "webgl",
            type: RendererType.WEBGL,
            systems: systems2,
            renderPipes: renderPipes2,
            renderPipeAdaptors: renderPipeAdaptors2
          };
          super(systemConfig);
        }
      };
    }
  });

  // ../core/node_modules/blockwise/dist/block-factory.js
  var require_block_factory = __commonJS({
    "../core/node_modules/blockwise/dist/block-factory.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BlockFactory = void 0;
      var blockwise_1 = require_dist();
      var BlockFactory = class {
        constructor() {
          this.block = blockwise_1.UNIT_BLOCK;
        }
        randomize(min = 0, max = 100) {
          this.block = {
            x: Math.random() * (max - min) + min,
            y: Math.random() * (max - min) + min,
            w: Math.random() * (max - min) + min,
            h: Math.random() * (max - min) + min
          };
          return this;
        }
        build() {
          return Object.assign({}, this.block);
        }
      };
      exports.BlockFactory = BlockFactory;
    }
  });

  // ../core/node_modules/blockwise/dist/calculate-block-center.js
  var require_calculate_block_center = __commonJS({
    "../core/node_modules/blockwise/dist/calculate-block-center.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.calculateBlockCenter = void 0;
      function calculateBlockCenter(block) {
        return {
          x: block.x + block.w / 2,
          y: block.y + block.h / 2,
          h: 0,
          w: 0
        };
      }
      exports.calculateBlockCenter = calculateBlockCenter;
    }
  });

  // ../core/node_modules/blockwise/dist/calculate-block-distance.js
  var require_calculate_block_distance = __commonJS({
    "../core/node_modules/blockwise/dist/calculate-block-distance.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.calculateBlockDistance = void 0;
      function calculateBlockDistance3(p1, p2) {
        const centerP1X = p1.x + p1.w / 2;
        const centerP1Y = p1.y + p1.h / 2;
        const centerP2X = p2.x + p2.w / 2;
        const centerP2Y = p2.y + p2.h / 2;
        const dx = centerP1X - centerP2X;
        const dy = centerP1Y - centerP2Y;
        return Math.sqrt(dx * dx + dy * dy);
      }
      exports.calculateBlockDistance = calculateBlockDistance3;
    }
  });

  // ../core/node_modules/blockwise/dist/centered-unit-block.js
  var require_centered_unit_block = __commonJS({
    "../core/node_modules/blockwise/dist/centered-unit-block.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CENTERED_UNIT_BLOCK = void 0;
      exports.CENTERED_UNIT_BLOCK = { x: -0.5, y: -0.5, w: 1, h: 1 };
      Object.freeze(exports.CENTERED_UNIT_BLOCK);
    }
  });

  // ../core/node_modules/blockwise/dist/find-closest-block.js
  var require_find_closest_block = __commonJS({
    "../core/node_modules/blockwise/dist/find-closest-block.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.findClosestBlock = void 0;
      var blockwise_1 = require_dist();
      function findClosestBlock2(blockList, target) {
        if (blockList.length === 0) {
          throw new Error("Block list should not be empty !");
        }
        let closestPoint = blockList[0];
        let closestDistance = (0, blockwise_1.calculateBlockDistance)(closestPoint, target);
        for (let i2 = 1; i2 < blockList.length; i2++) {
          const currentBlock = blockList[i2];
          const currentDistance = (0, blockwise_1.calculateBlockDistance)(currentBlock, target);
          if (currentDistance < closestDistance) {
            closestPoint = currentBlock;
            closestDistance = currentDistance;
          }
        }
        return closestPoint;
      }
      exports.findClosestBlock = findClosestBlock2;
    }
  });

  // ../core/node_modules/blockwise/dist/is-block-colliding.js
  var require_is_block_colliding = __commonJS({
    "../core/node_modules/blockwise/dist/is-block-colliding.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isBlockColliding = void 0;
      function isBlockColliding(a2, b2) {
        return a2.x + a2.w > b2.x && a2.x < b2.x + b2.w && a2.y + a2.h > b2.y && a2.y < b2.y + b2.h;
      }
      exports.isBlockColliding = isBlockColliding;
    }
  });

  // ../core/node_modules/blockwise/dist/is-block-equal.js
  var require_is_block_equal = __commonJS({
    "../core/node_modules/blockwise/dist/is-block-equal.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isBlockEqual = void 0;
      function isBlockEqual(a2, b2) {
        return a2.x === b2.x && a2.y === b2.y && a2.w === b2.w && a2.h === b2.h;
      }
      exports.isBlockEqual = isBlockEqual;
    }
  });

  // ../core/node_modules/blockwise/dist/is-block-including.js
  var require_is_block_including = __commonJS({
    "../core/node_modules/blockwise/dist/is-block-including.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isBlockIncluding = void 0;
      function isBlockIncluding(a2, b2) {
        return a2.x <= b2.x && a2.y <= b2.y && a2.x + a2.w >= b2.x + b2.w && a2.y + a2.h >= b2.y + b2.h;
      }
      exports.isBlockIncluding = isBlockIncluding;
    }
  });

  // ../core/node_modules/blockwise/dist/is-block-not-equal.js
  var require_is_block_not_equal = __commonJS({
    "../core/node_modules/blockwise/dist/is-block-not-equal.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isBlockNotEqual = void 0;
      var blockwise_1 = require_dist();
      function isBlockNotEqual(a2, b2) {
        return !(0, blockwise_1.isBlockEqual)(a2, b2);
      }
      exports.isBlockNotEqual = isBlockNotEqual;
    }
  });

  // ../core/node_modules/blockwise/dist/is-block-position-equal.js
  var require_is_block_position_equal = __commonJS({
    "../core/node_modules/blockwise/dist/is-block-position-equal.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isBlockPositionEqual = void 0;
      function isBlockPositionEqual2(a2, b2) {
        return a2.x === b2.x && a2.y === b2.y;
      }
      exports.isBlockPositionEqual = isBlockPositionEqual2;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/isFunction.js
  var require_isFunction = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/isFunction.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isFunction = void 0;
      function isFunction3(value) {
        return typeof value === "function";
      }
      exports.isFunction = isFunction3;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/createErrorClass.js
  var require_createErrorClass = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/createErrorClass.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createErrorClass = void 0;
      function createErrorClass3(createImpl) {
        var _super = function(instance2) {
          Error.call(instance2);
          instance2.stack = new Error().stack;
        };
        var ctorFunc = createImpl(_super);
        ctorFunc.prototype = Object.create(Error.prototype);
        ctorFunc.prototype.constructor = ctorFunc;
        return ctorFunc;
      }
      exports.createErrorClass = createErrorClass3;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/UnsubscriptionError.js
  var require_UnsubscriptionError = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/UnsubscriptionError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.UnsubscriptionError = void 0;
      var createErrorClass_1 = require_createErrorClass();
      exports.UnsubscriptionError = createErrorClass_1.createErrorClass(function(_super) {
        return function UnsubscriptionErrorImpl(errors) {
          _super(this);
          this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i2) {
            return i2 + 1 + ") " + err.toString();
          }).join("\n  ") : "";
          this.name = "UnsubscriptionError";
          this.errors = errors;
        };
      });
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/arrRemove.js
  var require_arrRemove = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/arrRemove.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.arrRemove = void 0;
      function arrRemove3(arr, item) {
        if (arr) {
          var index = arr.indexOf(item);
          0 <= index && arr.splice(index, 1);
        }
      }
      exports.arrRemove = arrRemove3;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/Subscription.js
  var require_Subscription = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/Subscription.js"(exports) {
      "use strict";
      var __values3 = exports && exports.__values || function(o2) {
        var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
        if (m2)
          return m2.call(o2);
        if (o2 && typeof o2.length === "number")
          return {
            next: function() {
              if (o2 && i2 >= o2.length)
                o2 = void 0;
              return { value: o2 && o2[i2++], done: !o2 };
            }
          };
        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      var __read3 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2)
          return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
            ar.push(r2.value);
        } catch (error) {
          e2 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray3 = exports && exports.__spreadArray || function(to, from3) {
        for (var i2 = 0, il = from3.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from3[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isSubscription = exports.EMPTY_SUBSCRIPTION = exports.Subscription = void 0;
      var isFunction_1 = require_isFunction();
      var UnsubscriptionError_1 = require_UnsubscriptionError();
      var arrRemove_1 = require_arrRemove();
      var Subscription3 = function() {
        function Subscription4(initialTeardown) {
          this.initialTeardown = initialTeardown;
          this.closed = false;
          this._parentage = null;
          this._finalizers = null;
        }
        Subscription4.prototype.unsubscribe = function() {
          var e_1, _a, e_2, _b;
          var errors;
          if (!this.closed) {
            this.closed = true;
            var _parentage = this._parentage;
            if (_parentage) {
              this._parentage = null;
              if (Array.isArray(_parentage)) {
                try {
                  for (var _parentage_1 = __values3(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                    var parent_1 = _parentage_1_1.value;
                    parent_1.remove(this);
                  }
                } catch (e_1_1) {
                  e_1 = { error: e_1_1 };
                } finally {
                  try {
                    if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                      _a.call(_parentage_1);
                  } finally {
                    if (e_1)
                      throw e_1.error;
                  }
                }
              } else {
                _parentage.remove(this);
              }
            }
            var initialFinalizer = this.initialTeardown;
            if (isFunction_1.isFunction(initialFinalizer)) {
              try {
                initialFinalizer();
              } catch (e2) {
                errors = e2 instanceof UnsubscriptionError_1.UnsubscriptionError ? e2.errors : [e2];
              }
            }
            var _finalizers = this._finalizers;
            if (_finalizers) {
              this._finalizers = null;
              try {
                for (var _finalizers_1 = __values3(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
                  var finalizer = _finalizers_1_1.value;
                  try {
                    execFinalizer3(finalizer);
                  } catch (err) {
                    errors = errors !== null && errors !== void 0 ? errors : [];
                    if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                      errors = __spreadArray3(__spreadArray3([], __read3(errors)), __read3(err.errors));
                    } else {
                      errors.push(err);
                    }
                  }
                }
              } catch (e_2_1) {
                e_2 = { error: e_2_1 };
              } finally {
                try {
                  if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
                    _b.call(_finalizers_1);
                } finally {
                  if (e_2)
                    throw e_2.error;
                }
              }
            }
            if (errors) {
              throw new UnsubscriptionError_1.UnsubscriptionError(errors);
            }
          }
        };
        Subscription4.prototype.add = function(teardown) {
          var _a;
          if (teardown && teardown !== this) {
            if (this.closed) {
              execFinalizer3(teardown);
            } else {
              if (teardown instanceof Subscription4) {
                if (teardown.closed || teardown._hasParent(this)) {
                  return;
                }
                teardown._addParent(this);
              }
              (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
            }
          }
        };
        Subscription4.prototype._hasParent = function(parent) {
          var _parentage = this._parentage;
          return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
        };
        Subscription4.prototype._addParent = function(parent) {
          var _parentage = this._parentage;
          this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
        };
        Subscription4.prototype._removeParent = function(parent) {
          var _parentage = this._parentage;
          if (_parentage === parent) {
            this._parentage = null;
          } else if (Array.isArray(_parentage)) {
            arrRemove_1.arrRemove(_parentage, parent);
          }
        };
        Subscription4.prototype.remove = function(teardown) {
          var _finalizers = this._finalizers;
          _finalizers && arrRemove_1.arrRemove(_finalizers, teardown);
          if (teardown instanceof Subscription4) {
            teardown._removeParent(this);
          }
        };
        Subscription4.EMPTY = function() {
          var empty = new Subscription4();
          empty.closed = true;
          return empty;
        }();
        return Subscription4;
      }();
      exports.Subscription = Subscription3;
      exports.EMPTY_SUBSCRIPTION = Subscription3.EMPTY;
      function isSubscription3(value) {
        return value instanceof Subscription3 || value && "closed" in value && isFunction_1.isFunction(value.remove) && isFunction_1.isFunction(value.add) && isFunction_1.isFunction(value.unsubscribe);
      }
      exports.isSubscription = isSubscription3;
      function execFinalizer3(finalizer) {
        if (isFunction_1.isFunction(finalizer)) {
          finalizer();
        } else {
          finalizer.unsubscribe();
        }
      }
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/config.js
  var require_config = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.config = void 0;
      exports.config = {
        onUnhandledError: null,
        onStoppedNotification: null,
        Promise: void 0,
        useDeprecatedSynchronousErrorHandling: false,
        useDeprecatedNextContext: false
      };
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduler/timeoutProvider.js
  var require_timeoutProvider = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduler/timeoutProvider.js"(exports) {
      "use strict";
      var __read3 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2)
          return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
            ar.push(r2.value);
        } catch (error) {
          e2 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray3 = exports && exports.__spreadArray || function(to, from3) {
        for (var i2 = 0, il = from3.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from3[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.timeoutProvider = void 0;
      exports.timeoutProvider = {
        setTimeout: function(handler, timeout) {
          var args = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
          }
          var delegate = exports.timeoutProvider.delegate;
          if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
            return delegate.setTimeout.apply(delegate, __spreadArray3([handler, timeout], __read3(args)));
          }
          return setTimeout.apply(void 0, __spreadArray3([handler, timeout], __read3(args)));
        },
        clearTimeout: function(handle) {
          var delegate = exports.timeoutProvider.delegate;
          return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
        },
        delegate: void 0
      };
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/reportUnhandledError.js
  var require_reportUnhandledError = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/reportUnhandledError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.reportUnhandledError = void 0;
      var config_1 = require_config();
      var timeoutProvider_1 = require_timeoutProvider();
      function reportUnhandledError3(err) {
        timeoutProvider_1.timeoutProvider.setTimeout(function() {
          var onUnhandledError = config_1.config.onUnhandledError;
          if (onUnhandledError) {
            onUnhandledError(err);
          } else {
            throw err;
          }
        });
      }
      exports.reportUnhandledError = reportUnhandledError3;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/noop.js
  var require_noop = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/noop.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.noop = void 0;
      function noop4() {
      }
      exports.noop = noop4;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/NotificationFactories.js
  var require_NotificationFactories = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/NotificationFactories.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createNotification = exports.nextNotification = exports.errorNotification = exports.COMPLETE_NOTIFICATION = void 0;
      exports.COMPLETE_NOTIFICATION = function() {
        return createNotification3("C", void 0, void 0);
      }();
      function errorNotification3(error) {
        return createNotification3("E", void 0, error);
      }
      exports.errorNotification = errorNotification3;
      function nextNotification3(value) {
        return createNotification3("N", value, void 0);
      }
      exports.nextNotification = nextNotification3;
      function createNotification3(kind, value, error) {
        return {
          kind,
          value,
          error
        };
      }
      exports.createNotification = createNotification3;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/errorContext.js
  var require_errorContext = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/errorContext.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.captureError = exports.errorContext = void 0;
      var config_1 = require_config();
      var context4 = null;
      function errorContext3(cb) {
        if (config_1.config.useDeprecatedSynchronousErrorHandling) {
          var isRoot = !context4;
          if (isRoot) {
            context4 = { errorThrown: false, error: null };
          }
          cb();
          if (isRoot) {
            var _a = context4, errorThrown = _a.errorThrown, error = _a.error;
            context4 = null;
            if (errorThrown) {
              throw error;
            }
          }
        } else {
          cb();
        }
      }
      exports.errorContext = errorContext3;
      function captureError3(err) {
        if (config_1.config.useDeprecatedSynchronousErrorHandling && context4) {
          context4.errorThrown = true;
          context4.error = err;
        }
      }
      exports.captureError = captureError3;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/Subscriber.js
  var require_Subscriber = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/Subscriber.js"(exports) {
      "use strict";
      var __extends3 = exports && exports.__extends || function() {
        var extendStatics3 = function(d2, b2) {
          extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
            d3.__proto__ = b3;
          } || function(d3, b3) {
            for (var p2 in b3)
              if (Object.prototype.hasOwnProperty.call(b3, p2))
                d3[p2] = b3[p2];
          };
          return extendStatics3(d2, b2);
        };
        return function(d2, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics3(d2, b2);
          function __() {
            this.constructor = d2;
          }
          d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EMPTY_OBSERVER = exports.SafeSubscriber = exports.Subscriber = void 0;
      var isFunction_1 = require_isFunction();
      var Subscription_1 = require_Subscription();
      var config_1 = require_config();
      var reportUnhandledError_1 = require_reportUnhandledError();
      var noop_1 = require_noop();
      var NotificationFactories_1 = require_NotificationFactories();
      var timeoutProvider_1 = require_timeoutProvider();
      var errorContext_1 = require_errorContext();
      var Subscriber3 = function(_super) {
        __extends3(Subscriber4, _super);
        function Subscriber4(destination) {
          var _this = _super.call(this) || this;
          _this.isStopped = false;
          if (destination) {
            _this.destination = destination;
            if (Subscription_1.isSubscription(destination)) {
              destination.add(_this);
            }
          } else {
            _this.destination = exports.EMPTY_OBSERVER;
          }
          return _this;
        }
        Subscriber4.create = function(next, error, complete) {
          return new SafeSubscriber3(next, error, complete);
        };
        Subscriber4.prototype.next = function(value) {
          if (this.isStopped) {
            handleStoppedNotification3(NotificationFactories_1.nextNotification(value), this);
          } else {
            this._next(value);
          }
        };
        Subscriber4.prototype.error = function(err) {
          if (this.isStopped) {
            handleStoppedNotification3(NotificationFactories_1.errorNotification(err), this);
          } else {
            this.isStopped = true;
            this._error(err);
          }
        };
        Subscriber4.prototype.complete = function() {
          if (this.isStopped) {
            handleStoppedNotification3(NotificationFactories_1.COMPLETE_NOTIFICATION, this);
          } else {
            this.isStopped = true;
            this._complete();
          }
        };
        Subscriber4.prototype.unsubscribe = function() {
          if (!this.closed) {
            this.isStopped = true;
            _super.prototype.unsubscribe.call(this);
            this.destination = null;
          }
        };
        Subscriber4.prototype._next = function(value) {
          this.destination.next(value);
        };
        Subscriber4.prototype._error = function(err) {
          try {
            this.destination.error(err);
          } finally {
            this.unsubscribe();
          }
        };
        Subscriber4.prototype._complete = function() {
          try {
            this.destination.complete();
          } finally {
            this.unsubscribe();
          }
        };
        return Subscriber4;
      }(Subscription_1.Subscription);
      exports.Subscriber = Subscriber3;
      var _bind3 = Function.prototype.bind;
      function bind3(fn, thisArg) {
        return _bind3.call(fn, thisArg);
      }
      var ConsumerObserver3 = function() {
        function ConsumerObserver4(partialObserver) {
          this.partialObserver = partialObserver;
        }
        ConsumerObserver4.prototype.next = function(value) {
          var partialObserver = this.partialObserver;
          if (partialObserver.next) {
            try {
              partialObserver.next(value);
            } catch (error) {
              handleUnhandledError3(error);
            }
          }
        };
        ConsumerObserver4.prototype.error = function(err) {
          var partialObserver = this.partialObserver;
          if (partialObserver.error) {
            try {
              partialObserver.error(err);
            } catch (error) {
              handleUnhandledError3(error);
            }
          } else {
            handleUnhandledError3(err);
          }
        };
        ConsumerObserver4.prototype.complete = function() {
          var partialObserver = this.partialObserver;
          if (partialObserver.complete) {
            try {
              partialObserver.complete();
            } catch (error) {
              handleUnhandledError3(error);
            }
          }
        };
        return ConsumerObserver4;
      }();
      var SafeSubscriber3 = function(_super) {
        __extends3(SafeSubscriber4, _super);
        function SafeSubscriber4(observerOrNext, error, complete) {
          var _this = _super.call(this) || this;
          var partialObserver;
          if (isFunction_1.isFunction(observerOrNext) || !observerOrNext) {
            partialObserver = {
              next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
              error: error !== null && error !== void 0 ? error : void 0,
              complete: complete !== null && complete !== void 0 ? complete : void 0
            };
          } else {
            var context_1;
            if (_this && config_1.config.useDeprecatedNextContext) {
              context_1 = Object.create(observerOrNext);
              context_1.unsubscribe = function() {
                return _this.unsubscribe();
              };
              partialObserver = {
                next: observerOrNext.next && bind3(observerOrNext.next, context_1),
                error: observerOrNext.error && bind3(observerOrNext.error, context_1),
                complete: observerOrNext.complete && bind3(observerOrNext.complete, context_1)
              };
            } else {
              partialObserver = observerOrNext;
            }
          }
          _this.destination = new ConsumerObserver3(partialObserver);
          return _this;
        }
        return SafeSubscriber4;
      }(Subscriber3);
      exports.SafeSubscriber = SafeSubscriber3;
      function handleUnhandledError3(error) {
        if (config_1.config.useDeprecatedSynchronousErrorHandling) {
          errorContext_1.captureError(error);
        } else {
          reportUnhandledError_1.reportUnhandledError(error);
        }
      }
      function defaultErrorHandler3(err) {
        throw err;
      }
      function handleStoppedNotification3(notification, subscriber) {
        var onStoppedNotification = config_1.config.onStoppedNotification;
        onStoppedNotification && timeoutProvider_1.timeoutProvider.setTimeout(function() {
          return onStoppedNotification(notification, subscriber);
        });
      }
      exports.EMPTY_OBSERVER = {
        closed: true,
        next: noop_1.noop,
        error: defaultErrorHandler3,
        complete: noop_1.noop
      };
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/symbol/observable.js
  var require_observable = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/symbol/observable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.observable = void 0;
      exports.observable = function() {
        return typeof Symbol === "function" && Symbol.observable || "@@observable";
      }();
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/identity.js
  var require_identity = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/identity.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.identity = void 0;
      function identity4(x2) {
        return x2;
      }
      exports.identity = identity4;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/pipe.js
  var require_pipe = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/pipe.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.pipeFromArray = exports.pipe = void 0;
      var identity_1 = require_identity();
      function pipe() {
        var fns = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          fns[_i] = arguments[_i];
        }
        return pipeFromArray3(fns);
      }
      exports.pipe = pipe;
      function pipeFromArray3(fns) {
        if (fns.length === 0) {
          return identity_1.identity;
        }
        if (fns.length === 1) {
          return fns[0];
        }
        return function piped(input) {
          return fns.reduce(function(prev, fn) {
            return fn(prev);
          }, input);
        };
      }
      exports.pipeFromArray = pipeFromArray3;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/Observable.js
  var require_Observable = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/Observable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Observable = void 0;
      var Subscriber_1 = require_Subscriber();
      var Subscription_1 = require_Subscription();
      var observable_1 = require_observable();
      var pipe_1 = require_pipe();
      var config_1 = require_config();
      var isFunction_1 = require_isFunction();
      var errorContext_1 = require_errorContext();
      var Observable6 = function() {
        function Observable7(subscribe) {
          if (subscribe) {
            this._subscribe = subscribe;
          }
        }
        Observable7.prototype.lift = function(operator) {
          var observable3 = new Observable7();
          observable3.source = this;
          observable3.operator = operator;
          return observable3;
        };
        Observable7.prototype.subscribe = function(observerOrNext, error, complete) {
          var _this = this;
          var subscriber = isSubscriber3(observerOrNext) ? observerOrNext : new Subscriber_1.SafeSubscriber(observerOrNext, error, complete);
          errorContext_1.errorContext(function() {
            var _a = _this, operator = _a.operator, source2 = _a.source;
            subscriber.add(operator ? operator.call(subscriber, source2) : source2 ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
          });
          return subscriber;
        };
        Observable7.prototype._trySubscribe = function(sink) {
          try {
            return this._subscribe(sink);
          } catch (err) {
            sink.error(err);
          }
        };
        Observable7.prototype.forEach = function(next, promiseCtor) {
          var _this = this;
          promiseCtor = getPromiseCtor3(promiseCtor);
          return new promiseCtor(function(resolve, reject) {
            var subscriber = new Subscriber_1.SafeSubscriber({
              next: function(value) {
                try {
                  next(value);
                } catch (err) {
                  reject(err);
                  subscriber.unsubscribe();
                }
              },
              error: reject,
              complete: resolve
            });
            _this.subscribe(subscriber);
          });
        };
        Observable7.prototype._subscribe = function(subscriber) {
          var _a;
          return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
        };
        Observable7.prototype[observable_1.observable] = function() {
          return this;
        };
        Observable7.prototype.pipe = function() {
          var operations = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            operations[_i] = arguments[_i];
          }
          return pipe_1.pipeFromArray(operations)(this);
        };
        Observable7.prototype.toPromise = function(promiseCtor) {
          var _this = this;
          promiseCtor = getPromiseCtor3(promiseCtor);
          return new promiseCtor(function(resolve, reject) {
            var value;
            _this.subscribe(function(x2) {
              return value = x2;
            }, function(err) {
              return reject(err);
            }, function() {
              return resolve(value);
            });
          });
        };
        Observable7.create = function(subscribe) {
          return new Observable7(subscribe);
        };
        return Observable7;
      }();
      exports.Observable = Observable6;
      function getPromiseCtor3(promiseCtor) {
        var _a;
        return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config_1.config.Promise) !== null && _a !== void 0 ? _a : Promise;
      }
      function isObserver3(value) {
        return value && isFunction_1.isFunction(value.next) && isFunction_1.isFunction(value.error) && isFunction_1.isFunction(value.complete);
      }
      function isSubscriber3(value) {
        return value && value instanceof Subscriber_1.Subscriber || isObserver3(value) && Subscription_1.isSubscription(value);
      }
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/lift.js
  var require_lift = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/lift.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.operate = exports.hasLift = void 0;
      var isFunction_1 = require_isFunction();
      function hasLift3(source2) {
        return isFunction_1.isFunction(source2 === null || source2 === void 0 ? void 0 : source2.lift);
      }
      exports.hasLift = hasLift3;
      function operate3(init3) {
        return function(source2) {
          if (hasLift3(source2)) {
            return source2.lift(function(liftedSource) {
              try {
                return init3(liftedSource, this);
              } catch (err) {
                this.error(err);
              }
            });
          }
          throw new TypeError("Unable to lift unknown Observable type");
        };
      }
      exports.operate = operate3;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js
  var require_OperatorSubscriber = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js"(exports) {
      "use strict";
      var __extends3 = exports && exports.__extends || function() {
        var extendStatics3 = function(d2, b2) {
          extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
            d3.__proto__ = b3;
          } || function(d3, b3) {
            for (var p2 in b3)
              if (Object.prototype.hasOwnProperty.call(b3, p2))
                d3[p2] = b3[p2];
          };
          return extendStatics3(d2, b2);
        };
        return function(d2, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics3(d2, b2);
          function __() {
            this.constructor = d2;
          }
          d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.OperatorSubscriber = exports.createOperatorSubscriber = void 0;
      var Subscriber_1 = require_Subscriber();
      function createOperatorSubscriber3(destination, onNext, onComplete, onError, onFinalize) {
        return new OperatorSubscriber3(destination, onNext, onComplete, onError, onFinalize);
      }
      exports.createOperatorSubscriber = createOperatorSubscriber3;
      var OperatorSubscriber3 = function(_super) {
        __extends3(OperatorSubscriber4, _super);
        function OperatorSubscriber4(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
          var _this = _super.call(this, destination) || this;
          _this.onFinalize = onFinalize;
          _this.shouldUnsubscribe = shouldUnsubscribe;
          _this._next = onNext ? function(value) {
            try {
              onNext(value);
            } catch (err) {
              destination.error(err);
            }
          } : _super.prototype._next;
          _this._error = onError ? function(err) {
            try {
              onError(err);
            } catch (err2) {
              destination.error(err2);
            } finally {
              this.unsubscribe();
            }
          } : _super.prototype._error;
          _this._complete = onComplete ? function() {
            try {
              onComplete();
            } catch (err) {
              destination.error(err);
            } finally {
              this.unsubscribe();
            }
          } : _super.prototype._complete;
          return _this;
        }
        OperatorSubscriber4.prototype.unsubscribe = function() {
          var _a;
          if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
            var closed_1 = this.closed;
            _super.prototype.unsubscribe.call(this);
            !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
          }
        };
        return OperatorSubscriber4;
      }(Subscriber_1.Subscriber);
      exports.OperatorSubscriber = OperatorSubscriber3;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/refCount.js
  var require_refCount = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/refCount.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.refCount = void 0;
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function refCount() {
        return lift_1.operate(function(source2, subscriber) {
          var connection = null;
          source2._refCount++;
          var refCounter = OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, void 0, void 0, function() {
            if (!source2 || source2._refCount <= 0 || 0 < --source2._refCount) {
              connection = null;
              return;
            }
            var sharedConnection = source2._connection;
            var conn = connection;
            connection = null;
            if (sharedConnection && (!conn || sharedConnection === conn)) {
              sharedConnection.unsubscribe();
            }
            subscriber.unsubscribe();
          });
          source2.subscribe(refCounter);
          if (!refCounter.closed) {
            connection = source2.connect();
          }
        });
      }
      exports.refCount = refCount;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/ConnectableObservable.js
  var require_ConnectableObservable = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/ConnectableObservable.js"(exports) {
      "use strict";
      var __extends3 = exports && exports.__extends || function() {
        var extendStatics3 = function(d2, b2) {
          extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
            d3.__proto__ = b3;
          } || function(d3, b3) {
            for (var p2 in b3)
              if (Object.prototype.hasOwnProperty.call(b3, p2))
                d3[p2] = b3[p2];
          };
          return extendStatics3(d2, b2);
        };
        return function(d2, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics3(d2, b2);
          function __() {
            this.constructor = d2;
          }
          d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ConnectableObservable = void 0;
      var Observable_1 = require_Observable();
      var Subscription_1 = require_Subscription();
      var refCount_1 = require_refCount();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var lift_1 = require_lift();
      var ConnectableObservable = function(_super) {
        __extends3(ConnectableObservable2, _super);
        function ConnectableObservable2(source2, subjectFactory) {
          var _this = _super.call(this) || this;
          _this.source = source2;
          _this.subjectFactory = subjectFactory;
          _this._subject = null;
          _this._refCount = 0;
          _this._connection = null;
          if (lift_1.hasLift(source2)) {
            _this.lift = source2.lift;
          }
          return _this;
        }
        ConnectableObservable2.prototype._subscribe = function(subscriber) {
          return this.getSubject().subscribe(subscriber);
        };
        ConnectableObservable2.prototype.getSubject = function() {
          var subject = this._subject;
          if (!subject || subject.isStopped) {
            this._subject = this.subjectFactory();
          }
          return this._subject;
        };
        ConnectableObservable2.prototype._teardown = function() {
          this._refCount = 0;
          var _connection = this._connection;
          this._subject = this._connection = null;
          _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
        };
        ConnectableObservable2.prototype.connect = function() {
          var _this = this;
          var connection = this._connection;
          if (!connection) {
            connection = this._connection = new Subscription_1.Subscription();
            var subject_1 = this.getSubject();
            connection.add(this.source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subject_1, void 0, function() {
              _this._teardown();
              subject_1.complete();
            }, function(err) {
              _this._teardown();
              subject_1.error(err);
            }, function() {
              return _this._teardown();
            })));
            if (connection.closed) {
              this._connection = null;
              connection = Subscription_1.Subscription.EMPTY;
            }
          }
          return connection;
        };
        ConnectableObservable2.prototype.refCount = function() {
          return refCount_1.refCount()(this);
        };
        return ConnectableObservable2;
      }(Observable_1.Observable);
      exports.ConnectableObservable = ConnectableObservable;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduler/performanceTimestampProvider.js
  var require_performanceTimestampProvider = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduler/performanceTimestampProvider.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.performanceTimestampProvider = void 0;
      exports.performanceTimestampProvider = {
        now: function() {
          return (exports.performanceTimestampProvider.delegate || performance).now();
        },
        delegate: void 0
      };
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduler/animationFrameProvider.js
  var require_animationFrameProvider = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduler/animationFrameProvider.js"(exports) {
      "use strict";
      var __read3 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2)
          return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
            ar.push(r2.value);
        } catch (error) {
          e2 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray3 = exports && exports.__spreadArray || function(to, from3) {
        for (var i2 = 0, il = from3.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from3[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.animationFrameProvider = void 0;
      var Subscription_1 = require_Subscription();
      exports.animationFrameProvider = {
        schedule: function(callback) {
          var request = requestAnimationFrame;
          var cancel = cancelAnimationFrame;
          var delegate = exports.animationFrameProvider.delegate;
          if (delegate) {
            request = delegate.requestAnimationFrame;
            cancel = delegate.cancelAnimationFrame;
          }
          var handle = request(function(timestamp) {
            cancel = void 0;
            callback(timestamp);
          });
          return new Subscription_1.Subscription(function() {
            return cancel === null || cancel === void 0 ? void 0 : cancel(handle);
          });
        },
        requestAnimationFrame: function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var delegate = exports.animationFrameProvider.delegate;
          return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray3([], __read3(args)));
        },
        cancelAnimationFrame: function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var delegate = exports.animationFrameProvider.delegate;
          return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray3([], __read3(args)));
        },
        delegate: void 0
      };
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/dom/animationFrames.js
  var require_animationFrames = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/dom/animationFrames.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.animationFrames = void 0;
      var Observable_1 = require_Observable();
      var performanceTimestampProvider_1 = require_performanceTimestampProvider();
      var animationFrameProvider_1 = require_animationFrameProvider();
      function animationFrames(timestampProvider) {
        return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;
      }
      exports.animationFrames = animationFrames;
      function animationFramesFactory(timestampProvider) {
        return new Observable_1.Observable(function(subscriber) {
          var provider = timestampProvider || performanceTimestampProvider_1.performanceTimestampProvider;
          var start = provider.now();
          var id = 0;
          var run2 = function() {
            if (!subscriber.closed) {
              id = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function(timestamp) {
                id = 0;
                var now2 = provider.now();
                subscriber.next({
                  timestamp: timestampProvider ? now2 : timestamp,
                  elapsed: now2 - start
                });
                run2();
              });
            }
          };
          run2();
          return function() {
            if (id) {
              animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);
            }
          };
        });
      }
      var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/ObjectUnsubscribedError.js
  var require_ObjectUnsubscribedError = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/ObjectUnsubscribedError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ObjectUnsubscribedError = void 0;
      var createErrorClass_1 = require_createErrorClass();
      exports.ObjectUnsubscribedError = createErrorClass_1.createErrorClass(function(_super) {
        return function ObjectUnsubscribedErrorImpl() {
          _super(this);
          this.name = "ObjectUnsubscribedError";
          this.message = "object unsubscribed";
        };
      });
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/Subject.js
  var require_Subject = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/Subject.js"(exports) {
      "use strict";
      var __extends3 = exports && exports.__extends || function() {
        var extendStatics3 = function(d2, b2) {
          extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
            d3.__proto__ = b3;
          } || function(d3, b3) {
            for (var p2 in b3)
              if (Object.prototype.hasOwnProperty.call(b3, p2))
                d3[p2] = b3[p2];
          };
          return extendStatics3(d2, b2);
        };
        return function(d2, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics3(d2, b2);
          function __() {
            this.constructor = d2;
          }
          d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      }();
      var __values3 = exports && exports.__values || function(o2) {
        var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
        if (m2)
          return m2.call(o2);
        if (o2 && typeof o2.length === "number")
          return {
            next: function() {
              if (o2 && i2 >= o2.length)
                o2 = void 0;
              return { value: o2 && o2[i2++], done: !o2 };
            }
          };
        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AnonymousSubject = exports.Subject = void 0;
      var Observable_1 = require_Observable();
      var Subscription_1 = require_Subscription();
      var ObjectUnsubscribedError_1 = require_ObjectUnsubscribedError();
      var arrRemove_1 = require_arrRemove();
      var errorContext_1 = require_errorContext();
      var Subject3 = function(_super) {
        __extends3(Subject4, _super);
        function Subject4() {
          var _this = _super.call(this) || this;
          _this.closed = false;
          _this.currentObservers = null;
          _this.observers = [];
          _this.isStopped = false;
          _this.hasError = false;
          _this.thrownError = null;
          return _this;
        }
        Subject4.prototype.lift = function(operator) {
          var subject = new AnonymousSubject3(this, this);
          subject.operator = operator;
          return subject;
        };
        Subject4.prototype._throwIfClosed = function() {
          if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
          }
        };
        Subject4.prototype.next = function(value) {
          var _this = this;
          errorContext_1.errorContext(function() {
            var e_1, _a;
            _this._throwIfClosed();
            if (!_this.isStopped) {
              if (!_this.currentObservers) {
                _this.currentObservers = Array.from(_this.observers);
              }
              try {
                for (var _b = __values3(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var observer = _c.value;
                  observer.next(value);
                }
              } catch (e_1_1) {
                e_1 = { error: e_1_1 };
              } finally {
                try {
                  if (_c && !_c.done && (_a = _b.return))
                    _a.call(_b);
                } finally {
                  if (e_1)
                    throw e_1.error;
                }
              }
            }
          });
        };
        Subject4.prototype.error = function(err) {
          var _this = this;
          errorContext_1.errorContext(function() {
            _this._throwIfClosed();
            if (!_this.isStopped) {
              _this.hasError = _this.isStopped = true;
              _this.thrownError = err;
              var observers = _this.observers;
              while (observers.length) {
                observers.shift().error(err);
              }
            }
          });
        };
        Subject4.prototype.complete = function() {
          var _this = this;
          errorContext_1.errorContext(function() {
            _this._throwIfClosed();
            if (!_this.isStopped) {
              _this.isStopped = true;
              var observers = _this.observers;
              while (observers.length) {
                observers.shift().complete();
              }
            }
          });
        };
        Subject4.prototype.unsubscribe = function() {
          this.isStopped = this.closed = true;
          this.observers = this.currentObservers = null;
        };
        Object.defineProperty(Subject4.prototype, "observed", {
          get: function() {
            var _a;
            return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
          },
          enumerable: false,
          configurable: true
        });
        Subject4.prototype._trySubscribe = function(subscriber) {
          this._throwIfClosed();
          return _super.prototype._trySubscribe.call(this, subscriber);
        };
        Subject4.prototype._subscribe = function(subscriber) {
          this._throwIfClosed();
          this._checkFinalizedStatuses(subscriber);
          return this._innerSubscribe(subscriber);
        };
        Subject4.prototype._innerSubscribe = function(subscriber) {
          var _this = this;
          var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
          if (hasError || isStopped) {
            return Subscription_1.EMPTY_SUBSCRIPTION;
          }
          this.currentObservers = null;
          observers.push(subscriber);
          return new Subscription_1.Subscription(function() {
            _this.currentObservers = null;
            arrRemove_1.arrRemove(observers, subscriber);
          });
        };
        Subject4.prototype._checkFinalizedStatuses = function(subscriber) {
          var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
          if (hasError) {
            subscriber.error(thrownError);
          } else if (isStopped) {
            subscriber.complete();
          }
        };
        Subject4.prototype.asObservable = function() {
          var observable3 = new Observable_1.Observable();
          observable3.source = this;
          return observable3;
        };
        Subject4.create = function(destination, source2) {
          return new AnonymousSubject3(destination, source2);
        };
        return Subject4;
      }(Observable_1.Observable);
      exports.Subject = Subject3;
      var AnonymousSubject3 = function(_super) {
        __extends3(AnonymousSubject4, _super);
        function AnonymousSubject4(destination, source2) {
          var _this = _super.call(this) || this;
          _this.destination = destination;
          _this.source = source2;
          return _this;
        }
        AnonymousSubject4.prototype.next = function(value) {
          var _a, _b;
          (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
        };
        AnonymousSubject4.prototype.error = function(err) {
          var _a, _b;
          (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
        };
        AnonymousSubject4.prototype.complete = function() {
          var _a, _b;
          (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
        };
        AnonymousSubject4.prototype._subscribe = function(subscriber) {
          var _a, _b;
          return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : Subscription_1.EMPTY_SUBSCRIPTION;
        };
        return AnonymousSubject4;
      }(Subject3);
      exports.AnonymousSubject = AnonymousSubject3;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/BehaviorSubject.js
  var require_BehaviorSubject = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/BehaviorSubject.js"(exports) {
      "use strict";
      var __extends3 = exports && exports.__extends || function() {
        var extendStatics3 = function(d2, b2) {
          extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
            d3.__proto__ = b3;
          } || function(d3, b3) {
            for (var p2 in b3)
              if (Object.prototype.hasOwnProperty.call(b3, p2))
                d3[p2] = b3[p2];
          };
          return extendStatics3(d2, b2);
        };
        return function(d2, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics3(d2, b2);
          function __() {
            this.constructor = d2;
          }
          d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BehaviorSubject = void 0;
      var Subject_1 = require_Subject();
      var BehaviorSubject = function(_super) {
        __extends3(BehaviorSubject2, _super);
        function BehaviorSubject2(_value) {
          var _this = _super.call(this) || this;
          _this._value = _value;
          return _this;
        }
        Object.defineProperty(BehaviorSubject2.prototype, "value", {
          get: function() {
            return this.getValue();
          },
          enumerable: false,
          configurable: true
        });
        BehaviorSubject2.prototype._subscribe = function(subscriber) {
          var subscription = _super.prototype._subscribe.call(this, subscriber);
          !subscription.closed && subscriber.next(this._value);
          return subscription;
        };
        BehaviorSubject2.prototype.getValue = function() {
          var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
          if (hasError) {
            throw thrownError;
          }
          this._throwIfClosed();
          return _value;
        };
        BehaviorSubject2.prototype.next = function(value) {
          _super.prototype.next.call(this, this._value = value);
        };
        return BehaviorSubject2;
      }(Subject_1.Subject);
      exports.BehaviorSubject = BehaviorSubject;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduler/dateTimestampProvider.js
  var require_dateTimestampProvider = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduler/dateTimestampProvider.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.dateTimestampProvider = void 0;
      exports.dateTimestampProvider = {
        now: function() {
          return (exports.dateTimestampProvider.delegate || Date).now();
        },
        delegate: void 0
      };
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/ReplaySubject.js
  var require_ReplaySubject = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/ReplaySubject.js"(exports) {
      "use strict";
      var __extends3 = exports && exports.__extends || function() {
        var extendStatics3 = function(d2, b2) {
          extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
            d3.__proto__ = b3;
          } || function(d3, b3) {
            for (var p2 in b3)
              if (Object.prototype.hasOwnProperty.call(b3, p2))
                d3[p2] = b3[p2];
          };
          return extendStatics3(d2, b2);
        };
        return function(d2, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics3(d2, b2);
          function __() {
            this.constructor = d2;
          }
          d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ReplaySubject = void 0;
      var Subject_1 = require_Subject();
      var dateTimestampProvider_1 = require_dateTimestampProvider();
      var ReplaySubject = function(_super) {
        __extends3(ReplaySubject2, _super);
        function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
          if (_bufferSize === void 0) {
            _bufferSize = Infinity;
          }
          if (_windowTime === void 0) {
            _windowTime = Infinity;
          }
          if (_timestampProvider === void 0) {
            _timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
          }
          var _this = _super.call(this) || this;
          _this._bufferSize = _bufferSize;
          _this._windowTime = _windowTime;
          _this._timestampProvider = _timestampProvider;
          _this._buffer = [];
          _this._infiniteTimeWindow = true;
          _this._infiniteTimeWindow = _windowTime === Infinity;
          _this._bufferSize = Math.max(1, _bufferSize);
          _this._windowTime = Math.max(1, _windowTime);
          return _this;
        }
        ReplaySubject2.prototype.next = function(value) {
          var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
          if (!isStopped) {
            _buffer.push(value);
            !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
          }
          this._trimBuffer();
          _super.prototype.next.call(this, value);
        };
        ReplaySubject2.prototype._subscribe = function(subscriber) {
          this._throwIfClosed();
          this._trimBuffer();
          var subscription = this._innerSubscribe(subscriber);
          var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
          var copy = _buffer.slice();
          for (var i2 = 0; i2 < copy.length && !subscriber.closed; i2 += _infiniteTimeWindow ? 1 : 2) {
            subscriber.next(copy[i2]);
          }
          this._checkFinalizedStatuses(subscriber);
          return subscription;
        };
        ReplaySubject2.prototype._trimBuffer = function() {
          var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
          var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
          _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
          if (!_infiniteTimeWindow) {
            var now2 = _timestampProvider.now();
            var last3 = 0;
            for (var i2 = 1; i2 < _buffer.length && _buffer[i2] <= now2; i2 += 2) {
              last3 = i2;
            }
            last3 && _buffer.splice(0, last3 + 1);
          }
        };
        return ReplaySubject2;
      }(Subject_1.Subject);
      exports.ReplaySubject = ReplaySubject;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/AsyncSubject.js
  var require_AsyncSubject = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/AsyncSubject.js"(exports) {
      "use strict";
      var __extends3 = exports && exports.__extends || function() {
        var extendStatics3 = function(d2, b2) {
          extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
            d3.__proto__ = b3;
          } || function(d3, b3) {
            for (var p2 in b3)
              if (Object.prototype.hasOwnProperty.call(b3, p2))
                d3[p2] = b3[p2];
          };
          return extendStatics3(d2, b2);
        };
        return function(d2, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics3(d2, b2);
          function __() {
            this.constructor = d2;
          }
          d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AsyncSubject = void 0;
      var Subject_1 = require_Subject();
      var AsyncSubject = function(_super) {
        __extends3(AsyncSubject2, _super);
        function AsyncSubject2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this._value = null;
          _this._hasValue = false;
          _this._isComplete = false;
          return _this;
        }
        AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
          var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
          if (hasError) {
            subscriber.error(thrownError);
          } else if (isStopped || _isComplete) {
            _hasValue && subscriber.next(_value);
            subscriber.complete();
          }
        };
        AsyncSubject2.prototype.next = function(value) {
          if (!this.isStopped) {
            this._value = value;
            this._hasValue = true;
          }
        };
        AsyncSubject2.prototype.complete = function() {
          var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;
          if (!_isComplete) {
            this._isComplete = true;
            _hasValue && _super.prototype.next.call(this, _value);
            _super.prototype.complete.call(this);
          }
        };
        return AsyncSubject2;
      }(Subject_1.Subject);
      exports.AsyncSubject = AsyncSubject;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduler/Action.js
  var require_Action = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduler/Action.js"(exports) {
      "use strict";
      var __extends3 = exports && exports.__extends || function() {
        var extendStatics3 = function(d2, b2) {
          extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
            d3.__proto__ = b3;
          } || function(d3, b3) {
            for (var p2 in b3)
              if (Object.prototype.hasOwnProperty.call(b3, p2))
                d3[p2] = b3[p2];
          };
          return extendStatics3(d2, b2);
        };
        return function(d2, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics3(d2, b2);
          function __() {
            this.constructor = d2;
          }
          d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Action = void 0;
      var Subscription_1 = require_Subscription();
      var Action2 = function(_super) {
        __extends3(Action3, _super);
        function Action3(scheduler, work) {
          return _super.call(this) || this;
        }
        Action3.prototype.schedule = function(state, delay) {
          if (delay === void 0) {
            delay = 0;
          }
          return this;
        };
        return Action3;
      }(Subscription_1.Subscription);
      exports.Action = Action2;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduler/intervalProvider.js
  var require_intervalProvider = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduler/intervalProvider.js"(exports) {
      "use strict";
      var __read3 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2)
          return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
            ar.push(r2.value);
        } catch (error) {
          e2 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray3 = exports && exports.__spreadArray || function(to, from3) {
        for (var i2 = 0, il = from3.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from3[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.intervalProvider = void 0;
      exports.intervalProvider = {
        setInterval: function(handler, timeout) {
          var args = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
          }
          var delegate = exports.intervalProvider.delegate;
          if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
            return delegate.setInterval.apply(delegate, __spreadArray3([handler, timeout], __read3(args)));
          }
          return setInterval.apply(void 0, __spreadArray3([handler, timeout], __read3(args)));
        },
        clearInterval: function(handle) {
          var delegate = exports.intervalProvider.delegate;
          return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
        },
        delegate: void 0
      };
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduler/AsyncAction.js
  var require_AsyncAction = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduler/AsyncAction.js"(exports) {
      "use strict";
      var __extends3 = exports && exports.__extends || function() {
        var extendStatics3 = function(d2, b2) {
          extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
            d3.__proto__ = b3;
          } || function(d3, b3) {
            for (var p2 in b3)
              if (Object.prototype.hasOwnProperty.call(b3, p2))
                d3[p2] = b3[p2];
          };
          return extendStatics3(d2, b2);
        };
        return function(d2, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics3(d2, b2);
          function __() {
            this.constructor = d2;
          }
          d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AsyncAction = void 0;
      var Action_1 = require_Action();
      var intervalProvider_1 = require_intervalProvider();
      var arrRemove_1 = require_arrRemove();
      var AsyncAction2 = function(_super) {
        __extends3(AsyncAction3, _super);
        function AsyncAction3(scheduler, work) {
          var _this = _super.call(this, scheduler, work) || this;
          _this.scheduler = scheduler;
          _this.work = work;
          _this.pending = false;
          return _this;
        }
        AsyncAction3.prototype.schedule = function(state, delay) {
          var _a;
          if (delay === void 0) {
            delay = 0;
          }
          if (this.closed) {
            return this;
          }
          this.state = state;
          var id = this.id;
          var scheduler = this.scheduler;
          if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
          }
          this.pending = true;
          this.delay = delay;
          this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay);
          return this;
        };
        AsyncAction3.prototype.requestAsyncId = function(scheduler, _id, delay) {
          if (delay === void 0) {
            delay = 0;
          }
          return intervalProvider_1.intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
        };
        AsyncAction3.prototype.recycleAsyncId = function(_scheduler, id, delay) {
          if (delay === void 0) {
            delay = 0;
          }
          if (delay != null && this.delay === delay && this.pending === false) {
            return id;
          }
          if (id != null) {
            intervalProvider_1.intervalProvider.clearInterval(id);
          }
          return void 0;
        };
        AsyncAction3.prototype.execute = function(state, delay) {
          if (this.closed) {
            return new Error("executing a cancelled action");
          }
          this.pending = false;
          var error = this._execute(state, delay);
          if (error) {
            return error;
          } else if (this.pending === false && this.id != null) {
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
          }
        };
        AsyncAction3.prototype._execute = function(state, _delay) {
          var errored = false;
          var errorValue;
          try {
            this.work(state);
          } catch (e2) {
            errored = true;
            errorValue = e2 ? e2 : new Error("Scheduled action threw falsy error");
          }
          if (errored) {
            this.unsubscribe();
            return errorValue;
          }
        };
        AsyncAction3.prototype.unsubscribe = function() {
          if (!this.closed) {
            var _a = this, id = _a.id, scheduler = _a.scheduler;
            var actions = scheduler.actions;
            this.work = this.state = this.scheduler = null;
            this.pending = false;
            arrRemove_1.arrRemove(actions, this);
            if (id != null) {
              this.id = this.recycleAsyncId(scheduler, id, null);
            }
            this.delay = null;
            _super.prototype.unsubscribe.call(this);
          }
        };
        return AsyncAction3;
      }(Action_1.Action);
      exports.AsyncAction = AsyncAction2;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/Immediate.js
  var require_Immediate = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/Immediate.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TestTools = exports.Immediate = void 0;
      var nextHandle = 1;
      var resolved;
      var activeHandles = {};
      function findAndClearHandle(handle) {
        if (handle in activeHandles) {
          delete activeHandles[handle];
          return true;
        }
        return false;
      }
      exports.Immediate = {
        setImmediate: function(cb) {
          var handle = nextHandle++;
          activeHandles[handle] = true;
          if (!resolved) {
            resolved = Promise.resolve();
          }
          resolved.then(function() {
            return findAndClearHandle(handle) && cb();
          });
          return handle;
        },
        clearImmediate: function(handle) {
          findAndClearHandle(handle);
        }
      };
      exports.TestTools = {
        pending: function() {
          return Object.keys(activeHandles).length;
        }
      };
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduler/immediateProvider.js
  var require_immediateProvider = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduler/immediateProvider.js"(exports) {
      "use strict";
      var __read3 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2)
          return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
            ar.push(r2.value);
        } catch (error) {
          e2 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray3 = exports && exports.__spreadArray || function(to, from3) {
        for (var i2 = 0, il = from3.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from3[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.immediateProvider = void 0;
      var Immediate_1 = require_Immediate();
      var setImmediate = Immediate_1.Immediate.setImmediate;
      var clearImmediate = Immediate_1.Immediate.clearImmediate;
      exports.immediateProvider = {
        setImmediate: function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var delegate = exports.immediateProvider.delegate;
          return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate).apply(void 0, __spreadArray3([], __read3(args)));
        },
        clearImmediate: function(handle) {
          var delegate = exports.immediateProvider.delegate;
          return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
        },
        delegate: void 0
      };
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduler/AsapAction.js
  var require_AsapAction = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduler/AsapAction.js"(exports) {
      "use strict";
      var __extends3 = exports && exports.__extends || function() {
        var extendStatics3 = function(d2, b2) {
          extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
            d3.__proto__ = b3;
          } || function(d3, b3) {
            for (var p2 in b3)
              if (Object.prototype.hasOwnProperty.call(b3, p2))
                d3[p2] = b3[p2];
          };
          return extendStatics3(d2, b2);
        };
        return function(d2, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics3(d2, b2);
          function __() {
            this.constructor = d2;
          }
          d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AsapAction = void 0;
      var AsyncAction_1 = require_AsyncAction();
      var immediateProvider_1 = require_immediateProvider();
      var AsapAction = function(_super) {
        __extends3(AsapAction2, _super);
        function AsapAction2(scheduler, work) {
          var _this = _super.call(this, scheduler, work) || this;
          _this.scheduler = scheduler;
          _this.work = work;
          return _this;
        }
        AsapAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
          if (delay === void 0) {
            delay = 0;
          }
          if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
          }
          scheduler.actions.push(this);
          return scheduler._scheduled || (scheduler._scheduled = immediateProvider_1.immediateProvider.setImmediate(scheduler.flush.bind(scheduler, void 0)));
        };
        AsapAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
          var _a;
          if (delay === void 0) {
            delay = 0;
          }
          if (delay != null ? delay > 0 : this.delay > 0) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
          }
          var actions = scheduler.actions;
          if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
            immediateProvider_1.immediateProvider.clearImmediate(id);
            if (scheduler._scheduled === id) {
              scheduler._scheduled = void 0;
            }
          }
          return void 0;
        };
        return AsapAction2;
      }(AsyncAction_1.AsyncAction);
      exports.AsapAction = AsapAction;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/Scheduler.js
  var require_Scheduler = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/Scheduler.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Scheduler = void 0;
      var dateTimestampProvider_1 = require_dateTimestampProvider();
      var Scheduler2 = function() {
        function Scheduler3(schedulerActionCtor, now2) {
          if (now2 === void 0) {
            now2 = Scheduler3.now;
          }
          this.schedulerActionCtor = schedulerActionCtor;
          this.now = now2;
        }
        Scheduler3.prototype.schedule = function(work, delay, state) {
          if (delay === void 0) {
            delay = 0;
          }
          return new this.schedulerActionCtor(this, work).schedule(state, delay);
        };
        Scheduler3.now = dateTimestampProvider_1.dateTimestampProvider.now;
        return Scheduler3;
      }();
      exports.Scheduler = Scheduler2;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduler/AsyncScheduler.js
  var require_AsyncScheduler = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduler/AsyncScheduler.js"(exports) {
      "use strict";
      var __extends3 = exports && exports.__extends || function() {
        var extendStatics3 = function(d2, b2) {
          extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
            d3.__proto__ = b3;
          } || function(d3, b3) {
            for (var p2 in b3)
              if (Object.prototype.hasOwnProperty.call(b3, p2))
                d3[p2] = b3[p2];
          };
          return extendStatics3(d2, b2);
        };
        return function(d2, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics3(d2, b2);
          function __() {
            this.constructor = d2;
          }
          d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AsyncScheduler = void 0;
      var Scheduler_1 = require_Scheduler();
      var AsyncScheduler2 = function(_super) {
        __extends3(AsyncScheduler3, _super);
        function AsyncScheduler3(SchedulerAction, now2) {
          if (now2 === void 0) {
            now2 = Scheduler_1.Scheduler.now;
          }
          var _this = _super.call(this, SchedulerAction, now2) || this;
          _this.actions = [];
          _this._active = false;
          return _this;
        }
        AsyncScheduler3.prototype.flush = function(action) {
          var actions = this.actions;
          if (this._active) {
            actions.push(action);
            return;
          }
          var error;
          this._active = true;
          do {
            if (error = action.execute(action.state, action.delay)) {
              break;
            }
          } while (action = actions.shift());
          this._active = false;
          if (error) {
            while (action = actions.shift()) {
              action.unsubscribe();
            }
            throw error;
          }
        };
        return AsyncScheduler3;
      }(Scheduler_1.Scheduler);
      exports.AsyncScheduler = AsyncScheduler2;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduler/AsapScheduler.js
  var require_AsapScheduler = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduler/AsapScheduler.js"(exports) {
      "use strict";
      var __extends3 = exports && exports.__extends || function() {
        var extendStatics3 = function(d2, b2) {
          extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
            d3.__proto__ = b3;
          } || function(d3, b3) {
            for (var p2 in b3)
              if (Object.prototype.hasOwnProperty.call(b3, p2))
                d3[p2] = b3[p2];
          };
          return extendStatics3(d2, b2);
        };
        return function(d2, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics3(d2, b2);
          function __() {
            this.constructor = d2;
          }
          d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AsapScheduler = void 0;
      var AsyncScheduler_1 = require_AsyncScheduler();
      var AsapScheduler = function(_super) {
        __extends3(AsapScheduler2, _super);
        function AsapScheduler2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        AsapScheduler2.prototype.flush = function(action) {
          this._active = true;
          var flushId = this._scheduled;
          this._scheduled = void 0;
          var actions = this.actions;
          var error;
          action = action || actions.shift();
          do {
            if (error = action.execute(action.state, action.delay)) {
              break;
            }
          } while ((action = actions[0]) && action.id === flushId && actions.shift());
          this._active = false;
          if (error) {
            while ((action = actions[0]) && action.id === flushId && actions.shift()) {
              action.unsubscribe();
            }
            throw error;
          }
        };
        return AsapScheduler2;
      }(AsyncScheduler_1.AsyncScheduler);
      exports.AsapScheduler = AsapScheduler;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduler/asap.js
  var require_asap = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduler/asap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.asap = exports.asapScheduler = void 0;
      var AsapAction_1 = require_AsapAction();
      var AsapScheduler_1 = require_AsapScheduler();
      exports.asapScheduler = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);
      exports.asap = exports.asapScheduler;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduler/async.js
  var require_async = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduler/async.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.async = exports.asyncScheduler = void 0;
      var AsyncAction_1 = require_AsyncAction();
      var AsyncScheduler_1 = require_AsyncScheduler();
      exports.asyncScheduler = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);
      exports.async = exports.asyncScheduler;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduler/QueueAction.js
  var require_QueueAction = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduler/QueueAction.js"(exports) {
      "use strict";
      var __extends3 = exports && exports.__extends || function() {
        var extendStatics3 = function(d2, b2) {
          extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
            d3.__proto__ = b3;
          } || function(d3, b3) {
            for (var p2 in b3)
              if (Object.prototype.hasOwnProperty.call(b3, p2))
                d3[p2] = b3[p2];
          };
          return extendStatics3(d2, b2);
        };
        return function(d2, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics3(d2, b2);
          function __() {
            this.constructor = d2;
          }
          d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.QueueAction = void 0;
      var AsyncAction_1 = require_AsyncAction();
      var QueueAction = function(_super) {
        __extends3(QueueAction2, _super);
        function QueueAction2(scheduler, work) {
          var _this = _super.call(this, scheduler, work) || this;
          _this.scheduler = scheduler;
          _this.work = work;
          return _this;
        }
        QueueAction2.prototype.schedule = function(state, delay) {
          if (delay === void 0) {
            delay = 0;
          }
          if (delay > 0) {
            return _super.prototype.schedule.call(this, state, delay);
          }
          this.delay = delay;
          this.state = state;
          this.scheduler.flush(this);
          return this;
        };
        QueueAction2.prototype.execute = function(state, delay) {
          return delay > 0 || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);
        };
        QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
          if (delay === void 0) {
            delay = 0;
          }
          if (delay != null && delay > 0 || delay == null && this.delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
          }
          scheduler.flush(this);
          return 0;
        };
        return QueueAction2;
      }(AsyncAction_1.AsyncAction);
      exports.QueueAction = QueueAction;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduler/QueueScheduler.js
  var require_QueueScheduler = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduler/QueueScheduler.js"(exports) {
      "use strict";
      var __extends3 = exports && exports.__extends || function() {
        var extendStatics3 = function(d2, b2) {
          extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
            d3.__proto__ = b3;
          } || function(d3, b3) {
            for (var p2 in b3)
              if (Object.prototype.hasOwnProperty.call(b3, p2))
                d3[p2] = b3[p2];
          };
          return extendStatics3(d2, b2);
        };
        return function(d2, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics3(d2, b2);
          function __() {
            this.constructor = d2;
          }
          d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.QueueScheduler = void 0;
      var AsyncScheduler_1 = require_AsyncScheduler();
      var QueueScheduler = function(_super) {
        __extends3(QueueScheduler2, _super);
        function QueueScheduler2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        return QueueScheduler2;
      }(AsyncScheduler_1.AsyncScheduler);
      exports.QueueScheduler = QueueScheduler;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduler/queue.js
  var require_queue = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduler/queue.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.queue = exports.queueScheduler = void 0;
      var QueueAction_1 = require_QueueAction();
      var QueueScheduler_1 = require_QueueScheduler();
      exports.queueScheduler = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);
      exports.queue = exports.queueScheduler;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameAction.js
  var require_AnimationFrameAction = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameAction.js"(exports) {
      "use strict";
      var __extends3 = exports && exports.__extends || function() {
        var extendStatics3 = function(d2, b2) {
          extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
            d3.__proto__ = b3;
          } || function(d3, b3) {
            for (var p2 in b3)
              if (Object.prototype.hasOwnProperty.call(b3, p2))
                d3[p2] = b3[p2];
          };
          return extendStatics3(d2, b2);
        };
        return function(d2, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics3(d2, b2);
          function __() {
            this.constructor = d2;
          }
          d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AnimationFrameAction = void 0;
      var AsyncAction_1 = require_AsyncAction();
      var animationFrameProvider_1 = require_animationFrameProvider();
      var AnimationFrameAction = function(_super) {
        __extends3(AnimationFrameAction2, _super);
        function AnimationFrameAction2(scheduler, work) {
          var _this = _super.call(this, scheduler, work) || this;
          _this.scheduler = scheduler;
          _this.work = work;
          return _this;
        }
        AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
          if (delay === void 0) {
            delay = 0;
          }
          if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
          }
          scheduler.actions.push(this);
          return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function() {
            return scheduler.flush(void 0);
          }));
        };
        AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
          var _a;
          if (delay === void 0) {
            delay = 0;
          }
          if (delay != null ? delay > 0 : this.delay > 0) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
          }
          var actions = scheduler.actions;
          if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
            animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);
            scheduler._scheduled = void 0;
          }
          return void 0;
        };
        return AnimationFrameAction2;
      }(AsyncAction_1.AsyncAction);
      exports.AnimationFrameAction = AnimationFrameAction;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameScheduler.js
  var require_AnimationFrameScheduler = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameScheduler.js"(exports) {
      "use strict";
      var __extends3 = exports && exports.__extends || function() {
        var extendStatics3 = function(d2, b2) {
          extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
            d3.__proto__ = b3;
          } || function(d3, b3) {
            for (var p2 in b3)
              if (Object.prototype.hasOwnProperty.call(b3, p2))
                d3[p2] = b3[p2];
          };
          return extendStatics3(d2, b2);
        };
        return function(d2, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics3(d2, b2);
          function __() {
            this.constructor = d2;
          }
          d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AnimationFrameScheduler = void 0;
      var AsyncScheduler_1 = require_AsyncScheduler();
      var AnimationFrameScheduler = function(_super) {
        __extends3(AnimationFrameScheduler2, _super);
        function AnimationFrameScheduler2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        AnimationFrameScheduler2.prototype.flush = function(action) {
          this._active = true;
          var flushId = this._scheduled;
          this._scheduled = void 0;
          var actions = this.actions;
          var error;
          action = action || actions.shift();
          do {
            if (error = action.execute(action.state, action.delay)) {
              break;
            }
          } while ((action = actions[0]) && action.id === flushId && actions.shift());
          this._active = false;
          if (error) {
            while ((action = actions[0]) && action.id === flushId && actions.shift()) {
              action.unsubscribe();
            }
            throw error;
          }
        };
        return AnimationFrameScheduler2;
      }(AsyncScheduler_1.AsyncScheduler);
      exports.AnimationFrameScheduler = AnimationFrameScheduler;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduler/animationFrame.js
  var require_animationFrame = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduler/animationFrame.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.animationFrame = exports.animationFrameScheduler = void 0;
      var AnimationFrameAction_1 = require_AnimationFrameAction();
      var AnimationFrameScheduler_1 = require_AnimationFrameScheduler();
      exports.animationFrameScheduler = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);
      exports.animationFrame = exports.animationFrameScheduler;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduler/VirtualTimeScheduler.js
  var require_VirtualTimeScheduler = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduler/VirtualTimeScheduler.js"(exports) {
      "use strict";
      var __extends3 = exports && exports.__extends || function() {
        var extendStatics3 = function(d2, b2) {
          extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
            d3.__proto__ = b3;
          } || function(d3, b3) {
            for (var p2 in b3)
              if (Object.prototype.hasOwnProperty.call(b3, p2))
                d3[p2] = b3[p2];
          };
          return extendStatics3(d2, b2);
        };
        return function(d2, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics3(d2, b2);
          function __() {
            this.constructor = d2;
          }
          d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.VirtualAction = exports.VirtualTimeScheduler = void 0;
      var AsyncAction_1 = require_AsyncAction();
      var Subscription_1 = require_Subscription();
      var AsyncScheduler_1 = require_AsyncScheduler();
      var VirtualTimeScheduler = function(_super) {
        __extends3(VirtualTimeScheduler2, _super);
        function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
          if (schedulerActionCtor === void 0) {
            schedulerActionCtor = VirtualAction;
          }
          if (maxFrames === void 0) {
            maxFrames = Infinity;
          }
          var _this = _super.call(this, schedulerActionCtor, function() {
            return _this.frame;
          }) || this;
          _this.maxFrames = maxFrames;
          _this.frame = 0;
          _this.index = -1;
          return _this;
        }
        VirtualTimeScheduler2.prototype.flush = function() {
          var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
          var error;
          var action;
          while ((action = actions[0]) && action.delay <= maxFrames) {
            actions.shift();
            this.frame = action.delay;
            if (error = action.execute(action.state, action.delay)) {
              break;
            }
          }
          if (error) {
            while (action = actions.shift()) {
              action.unsubscribe();
            }
            throw error;
          }
        };
        VirtualTimeScheduler2.frameTimeFactor = 10;
        return VirtualTimeScheduler2;
      }(AsyncScheduler_1.AsyncScheduler);
      exports.VirtualTimeScheduler = VirtualTimeScheduler;
      var VirtualAction = function(_super) {
        __extends3(VirtualAction2, _super);
        function VirtualAction2(scheduler, work, index) {
          if (index === void 0) {
            index = scheduler.index += 1;
          }
          var _this = _super.call(this, scheduler, work) || this;
          _this.scheduler = scheduler;
          _this.work = work;
          _this.index = index;
          _this.active = true;
          _this.index = scheduler.index = index;
          return _this;
        }
        VirtualAction2.prototype.schedule = function(state, delay) {
          if (delay === void 0) {
            delay = 0;
          }
          if (Number.isFinite(delay)) {
            if (!this.id) {
              return _super.prototype.schedule.call(this, state, delay);
            }
            this.active = false;
            var action = new VirtualAction2(this.scheduler, this.work);
            this.add(action);
            return action.schedule(state, delay);
          } else {
            return Subscription_1.Subscription.EMPTY;
          }
        };
        VirtualAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
          if (delay === void 0) {
            delay = 0;
          }
          this.delay = scheduler.frame + delay;
          var actions = scheduler.actions;
          actions.push(this);
          actions.sort(VirtualAction2.sortActions);
          return 1;
        };
        VirtualAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
          if (delay === void 0) {
            delay = 0;
          }
          return void 0;
        };
        VirtualAction2.prototype._execute = function(state, delay) {
          if (this.active === true) {
            return _super.prototype._execute.call(this, state, delay);
          }
        };
        VirtualAction2.sortActions = function(a2, b2) {
          if (a2.delay === b2.delay) {
            if (a2.index === b2.index) {
              return 0;
            } else if (a2.index > b2.index) {
              return 1;
            } else {
              return -1;
            }
          } else if (a2.delay > b2.delay) {
            return 1;
          } else {
            return -1;
          }
        };
        return VirtualAction2;
      }(AsyncAction_1.AsyncAction);
      exports.VirtualAction = VirtualAction;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/empty.js
  var require_empty = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/empty.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.empty = exports.EMPTY = void 0;
      var Observable_1 = require_Observable();
      exports.EMPTY = new Observable_1.Observable(function(subscriber) {
        return subscriber.complete();
      });
      function empty(scheduler) {
        return scheduler ? emptyScheduled(scheduler) : exports.EMPTY;
      }
      exports.empty = empty;
      function emptyScheduled(scheduler) {
        return new Observable_1.Observable(function(subscriber) {
          return scheduler.schedule(function() {
            return subscriber.complete();
          });
        });
      }
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/isScheduler.js
  var require_isScheduler = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/isScheduler.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isScheduler = void 0;
      var isFunction_1 = require_isFunction();
      function isScheduler3(value) {
        return value && isFunction_1.isFunction(value.schedule);
      }
      exports.isScheduler = isScheduler3;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/args.js
  var require_args = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/args.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.popNumber = exports.popScheduler = exports.popResultSelector = void 0;
      var isFunction_1 = require_isFunction();
      var isScheduler_1 = require_isScheduler();
      function last3(arr) {
        return arr[arr.length - 1];
      }
      function popResultSelector3(args) {
        return isFunction_1.isFunction(last3(args)) ? args.pop() : void 0;
      }
      exports.popResultSelector = popResultSelector3;
      function popScheduler3(args) {
        return isScheduler_1.isScheduler(last3(args)) ? args.pop() : void 0;
      }
      exports.popScheduler = popScheduler3;
      function popNumber3(args, defaultValue2) {
        return typeof last3(args) === "number" ? args.pop() : defaultValue2;
      }
      exports.popNumber = popNumber3;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/isArrayLike.js
  var require_isArrayLike = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/isArrayLike.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isArrayLike = void 0;
      exports.isArrayLike = function(x2) {
        return x2 && typeof x2.length === "number" && typeof x2 !== "function";
      };
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/isPromise.js
  var require_isPromise = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/isPromise.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isPromise = void 0;
      var isFunction_1 = require_isFunction();
      function isPromise3(value) {
        return isFunction_1.isFunction(value === null || value === void 0 ? void 0 : value.then);
      }
      exports.isPromise = isPromise3;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/isInteropObservable.js
  var require_isInteropObservable = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/isInteropObservable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isInteropObservable = void 0;
      var observable_1 = require_observable();
      var isFunction_1 = require_isFunction();
      function isInteropObservable3(input) {
        return isFunction_1.isFunction(input[observable_1.observable]);
      }
      exports.isInteropObservable = isInteropObservable3;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/isAsyncIterable.js
  var require_isAsyncIterable = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/isAsyncIterable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isAsyncIterable = void 0;
      var isFunction_1 = require_isFunction();
      function isAsyncIterable3(obj) {
        return Symbol.asyncIterator && isFunction_1.isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
      }
      exports.isAsyncIterable = isAsyncIterable3;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/throwUnobservableError.js
  var require_throwUnobservableError = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/throwUnobservableError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createInvalidObservableTypeError = void 0;
      function createInvalidObservableTypeError3(input) {
        return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
      }
      exports.createInvalidObservableTypeError = createInvalidObservableTypeError3;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/symbol/iterator.js
  var require_iterator = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/symbol/iterator.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.iterator = exports.getSymbolIterator = void 0;
      function getSymbolIterator3() {
        if (typeof Symbol !== "function" || !Symbol.iterator) {
          return "@@iterator";
        }
        return Symbol.iterator;
      }
      exports.getSymbolIterator = getSymbolIterator3;
      exports.iterator = getSymbolIterator3();
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/isIterable.js
  var require_isIterable = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/isIterable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isIterable = void 0;
      var iterator_1 = require_iterator();
      var isFunction_1 = require_isFunction();
      function isIterable3(input) {
        return isFunction_1.isFunction(input === null || input === void 0 ? void 0 : input[iterator_1.iterator]);
      }
      exports.isIterable = isIterable3;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/isReadableStreamLike.js
  var require_isReadableStreamLike = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/isReadableStreamLike.js"(exports) {
      "use strict";
      var __generator3 = exports && exports.__generator || function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t2[0] & 1)
            throw t2[1];
          return t2[1];
        }, trys: [], ops: [] }, f2, y2, t2, g2;
        return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
          return this;
        }), g2;
        function verb(n2) {
          return function(v2) {
            return step([n2, v2]);
          };
        }
        function step(op) {
          if (f2)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
                return t2;
              if (y2 = 0, t2)
                op = [op[0] & 2, t2.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t2 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y2 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t2[1]) {
                    _.label = t2[1];
                    t2 = op;
                    break;
                  }
                  if (t2 && _.label < t2[2]) {
                    _.label = t2[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t2[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e2) {
              op = [6, e2];
              y2 = 0;
            } finally {
              f2 = t2 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      var __await3 = exports && exports.__await || function(v2) {
        return this instanceof __await3 ? (this.v = v2, this) : new __await3(v2);
      };
      var __asyncGenerator3 = exports && exports.__asyncGenerator || function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g2 = generator.apply(thisArg, _arguments || []), i2, q = [];
        return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2;
        function verb(n2) {
          if (g2[n2])
            i2[n2] = function(v2) {
              return new Promise(function(a2, b2) {
                q.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
              });
            };
        }
        function resume(n2, v2) {
          try {
            step(g2[n2](v2));
          } catch (e2) {
            settle(q[0][3], e2);
          }
        }
        function step(r2) {
          r2.value instanceof __await3 ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q[0][2], r2);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f2, v2) {
          if (f2(v2), q.shift(), q.length)
            resume(q[0][0], q[0][1]);
        }
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isReadableStreamLike = exports.readableStreamLikeToAsyncGenerator = void 0;
      var isFunction_1 = require_isFunction();
      function readableStreamLikeToAsyncGenerator3(readableStream) {
        return __asyncGenerator3(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
          var reader, _a, value, done;
          return __generator3(this, function(_b) {
            switch (_b.label) {
              case 0:
                reader = readableStream.getReader();
                _b.label = 1;
              case 1:
                _b.trys.push([1, , 9, 10]);
                _b.label = 2;
              case 2:
                if (false)
                  return [3, 8];
                return [4, __await3(reader.read())];
              case 3:
                _a = _b.sent(), value = _a.value, done = _a.done;
                if (!done)
                  return [3, 5];
                return [4, __await3(void 0)];
              case 4:
                return [2, _b.sent()];
              case 5:
                return [4, __await3(value)];
              case 6:
                return [4, _b.sent()];
              case 7:
                _b.sent();
                return [3, 2];
              case 8:
                return [3, 10];
              case 9:
                reader.releaseLock();
                return [7];
              case 10:
                return [2];
            }
          });
        });
      }
      exports.readableStreamLikeToAsyncGenerator = readableStreamLikeToAsyncGenerator3;
      function isReadableStreamLike3(obj) {
        return isFunction_1.isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
      }
      exports.isReadableStreamLike = isReadableStreamLike3;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js
  var require_innerFrom = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js"(exports) {
      "use strict";
      var __awaiter17 = exports && exports.__awaiter || function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e2) {
              reject(e2);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e2) {
              reject(e2);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator3 = exports && exports.__generator || function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t2[0] & 1)
            throw t2[1];
          return t2[1];
        }, trys: [], ops: [] }, f2, y2, t2, g2;
        return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
          return this;
        }), g2;
        function verb(n2) {
          return function(v2) {
            return step([n2, v2]);
          };
        }
        function step(op) {
          if (f2)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
                return t2;
              if (y2 = 0, t2)
                op = [op[0] & 2, t2.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t2 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y2 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t2[1]) {
                    _.label = t2[1];
                    t2 = op;
                    break;
                  }
                  if (t2 && _.label < t2[2]) {
                    _.label = t2[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t2[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e2) {
              op = [6, e2];
              y2 = 0;
            } finally {
              f2 = t2 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      var __asyncValues3 = exports && exports.__asyncValues || function(o2) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m2 = o2[Symbol.asyncIterator], i2;
        return m2 ? m2.call(o2) : (o2 = typeof __values3 === "function" ? __values3(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2);
        function verb(n2) {
          i2[n2] = o2[n2] && function(v2) {
            return new Promise(function(resolve, reject) {
              v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
            });
          };
        }
        function settle(resolve, reject, d2, v2) {
          Promise.resolve(v2).then(function(v3) {
            resolve({ value: v3, done: d2 });
          }, reject);
        }
      };
      var __values3 = exports && exports.__values || function(o2) {
        var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
        if (m2)
          return m2.call(o2);
        if (o2 && typeof o2.length === "number")
          return {
            next: function() {
              if (o2 && i2 >= o2.length)
                o2 = void 0;
              return { value: o2 && o2[i2++], done: !o2 };
            }
          };
        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.fromReadableStreamLike = exports.fromAsyncIterable = exports.fromIterable = exports.fromPromise = exports.fromArrayLike = exports.fromInteropObservable = exports.innerFrom = void 0;
      var isArrayLike_1 = require_isArrayLike();
      var isPromise_1 = require_isPromise();
      var Observable_1 = require_Observable();
      var isInteropObservable_1 = require_isInteropObservable();
      var isAsyncIterable_1 = require_isAsyncIterable();
      var throwUnobservableError_1 = require_throwUnobservableError();
      var isIterable_1 = require_isIterable();
      var isReadableStreamLike_1 = require_isReadableStreamLike();
      var isFunction_1 = require_isFunction();
      var reportUnhandledError_1 = require_reportUnhandledError();
      var observable_1 = require_observable();
      function innerFrom3(input) {
        if (input instanceof Observable_1.Observable) {
          return input;
        }
        if (input != null) {
          if (isInteropObservable_1.isInteropObservable(input)) {
            return fromInteropObservable3(input);
          }
          if (isArrayLike_1.isArrayLike(input)) {
            return fromArrayLike3(input);
          }
          if (isPromise_1.isPromise(input)) {
            return fromPromise3(input);
          }
          if (isAsyncIterable_1.isAsyncIterable(input)) {
            return fromAsyncIterable3(input);
          }
          if (isIterable_1.isIterable(input)) {
            return fromIterable3(input);
          }
          if (isReadableStreamLike_1.isReadableStreamLike(input)) {
            return fromReadableStreamLike3(input);
          }
        }
        throw throwUnobservableError_1.createInvalidObservableTypeError(input);
      }
      exports.innerFrom = innerFrom3;
      function fromInteropObservable3(obj) {
        return new Observable_1.Observable(function(subscriber) {
          var obs = obj[observable_1.observable]();
          if (isFunction_1.isFunction(obs.subscribe)) {
            return obs.subscribe(subscriber);
          }
          throw new TypeError("Provided object does not correctly implement Symbol.observable");
        });
      }
      exports.fromInteropObservable = fromInteropObservable3;
      function fromArrayLike3(array) {
        return new Observable_1.Observable(function(subscriber) {
          for (var i2 = 0; i2 < array.length && !subscriber.closed; i2++) {
            subscriber.next(array[i2]);
          }
          subscriber.complete();
        });
      }
      exports.fromArrayLike = fromArrayLike3;
      function fromPromise3(promise2) {
        return new Observable_1.Observable(function(subscriber) {
          promise2.then(function(value) {
            if (!subscriber.closed) {
              subscriber.next(value);
              subscriber.complete();
            }
          }, function(err) {
            return subscriber.error(err);
          }).then(null, reportUnhandledError_1.reportUnhandledError);
        });
      }
      exports.fromPromise = fromPromise3;
      function fromIterable3(iterable) {
        return new Observable_1.Observable(function(subscriber) {
          var e_1, _a;
          try {
            for (var iterable_1 = __values3(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
              var value = iterable_1_1.value;
              subscriber.next(value);
              if (subscriber.closed) {
                return;
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return))
                _a.call(iterable_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          subscriber.complete();
        });
      }
      exports.fromIterable = fromIterable3;
      function fromAsyncIterable3(asyncIterable) {
        return new Observable_1.Observable(function(subscriber) {
          process3(asyncIterable, subscriber).catch(function(err) {
            return subscriber.error(err);
          });
        });
      }
      exports.fromAsyncIterable = fromAsyncIterable3;
      function fromReadableStreamLike3(readableStream) {
        return fromAsyncIterable3(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(readableStream));
      }
      exports.fromReadableStreamLike = fromReadableStreamLike3;
      function process3(asyncIterable, subscriber) {
        var asyncIterable_1, asyncIterable_1_1;
        var e_2, _a;
        return __awaiter17(this, void 0, void 0, function() {
          var value, e_2_1;
          return __generator3(this, function(_b) {
            switch (_b.label) {
              case 0:
                _b.trys.push([0, 5, 6, 11]);
                asyncIterable_1 = __asyncValues3(asyncIterable);
                _b.label = 1;
              case 1:
                return [4, asyncIterable_1.next()];
              case 2:
                if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
                  return [3, 4];
                value = asyncIterable_1_1.value;
                subscriber.next(value);
                if (subscriber.closed) {
                  return [2];
                }
                _b.label = 3;
              case 3:
                return [3, 1];
              case 4:
                return [3, 11];
              case 5:
                e_2_1 = _b.sent();
                e_2 = { error: e_2_1 };
                return [3, 11];
              case 6:
                _b.trys.push([6, , 9, 10]);
                if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)))
                  return [3, 8];
                return [4, _a.call(asyncIterable_1)];
              case 7:
                _b.sent();
                _b.label = 8;
              case 8:
                return [3, 10];
              case 9:
                if (e_2)
                  throw e_2.error;
                return [7];
              case 10:
                return [7];
              case 11:
                subscriber.complete();
                return [2];
            }
          });
        });
      }
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/executeSchedule.js
  var require_executeSchedule = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/executeSchedule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.executeSchedule = void 0;
      function executeSchedule3(parentSubscription, scheduler, work, delay, repeat) {
        if (delay === void 0) {
          delay = 0;
        }
        if (repeat === void 0) {
          repeat = false;
        }
        var scheduleSubscription = scheduler.schedule(function() {
          work();
          if (repeat) {
            parentSubscription.add(this.schedule(null, delay));
          } else {
            this.unsubscribe();
          }
        }, delay);
        parentSubscription.add(scheduleSubscription);
        if (!repeat) {
          return scheduleSubscription;
        }
      }
      exports.executeSchedule = executeSchedule3;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/observeOn.js
  var require_observeOn = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/observeOn.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.observeOn = void 0;
      var executeSchedule_1 = require_executeSchedule();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function observeOn3(scheduler, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        return lift_1.operate(function(source2, subscriber) {
          source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
              return subscriber.next(value);
            }, delay);
          }, function() {
            return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
              return subscriber.complete();
            }, delay);
          }, function(err) {
            return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
              return subscriber.error(err);
            }, delay);
          }));
        });
      }
      exports.observeOn = observeOn3;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/subscribeOn.js
  var require_subscribeOn = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/subscribeOn.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.subscribeOn = void 0;
      var lift_1 = require_lift();
      function subscribeOn3(scheduler, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        return lift_1.operate(function(source2, subscriber) {
          subscriber.add(scheduler.schedule(function() {
            return source2.subscribe(subscriber);
          }, delay));
        });
      }
      exports.subscribeOn = subscribeOn3;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduled/scheduleObservable.js
  var require_scheduleObservable = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduled/scheduleObservable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.scheduleObservable = void 0;
      var innerFrom_1 = require_innerFrom();
      var observeOn_1 = require_observeOn();
      var subscribeOn_1 = require_subscribeOn();
      function scheduleObservable3(input, scheduler) {
        return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
      }
      exports.scheduleObservable = scheduleObservable3;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduled/schedulePromise.js
  var require_schedulePromise = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduled/schedulePromise.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.schedulePromise = void 0;
      var innerFrom_1 = require_innerFrom();
      var observeOn_1 = require_observeOn();
      var subscribeOn_1 = require_subscribeOn();
      function schedulePromise3(input, scheduler) {
        return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
      }
      exports.schedulePromise = schedulePromise3;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduled/scheduleArray.js
  var require_scheduleArray = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduled/scheduleArray.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.scheduleArray = void 0;
      var Observable_1 = require_Observable();
      function scheduleArray3(input, scheduler) {
        return new Observable_1.Observable(function(subscriber) {
          var i2 = 0;
          return scheduler.schedule(function() {
            if (i2 === input.length) {
              subscriber.complete();
            } else {
              subscriber.next(input[i2++]);
              if (!subscriber.closed) {
                this.schedule();
              }
            }
          });
        });
      }
      exports.scheduleArray = scheduleArray3;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduled/scheduleIterable.js
  var require_scheduleIterable = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduled/scheduleIterable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.scheduleIterable = void 0;
      var Observable_1 = require_Observable();
      var iterator_1 = require_iterator();
      var isFunction_1 = require_isFunction();
      var executeSchedule_1 = require_executeSchedule();
      function scheduleIterable3(input, scheduler) {
        return new Observable_1.Observable(function(subscriber) {
          var iterator3;
          executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            iterator3 = input[iterator_1.iterator]();
            executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
              var _a;
              var value;
              var done;
              try {
                _a = iterator3.next(), value = _a.value, done = _a.done;
              } catch (err) {
                subscriber.error(err);
                return;
              }
              if (done) {
                subscriber.complete();
              } else {
                subscriber.next(value);
              }
            }, 0, true);
          });
          return function() {
            return isFunction_1.isFunction(iterator3 === null || iterator3 === void 0 ? void 0 : iterator3.return) && iterator3.return();
          };
        });
      }
      exports.scheduleIterable = scheduleIterable3;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduled/scheduleAsyncIterable.js
  var require_scheduleAsyncIterable = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduled/scheduleAsyncIterable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.scheduleAsyncIterable = void 0;
      var Observable_1 = require_Observable();
      var executeSchedule_1 = require_executeSchedule();
      function scheduleAsyncIterable3(input, scheduler) {
        if (!input) {
          throw new Error("Iterable cannot be null");
        }
        return new Observable_1.Observable(function(subscriber) {
          executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            var iterator3 = input[Symbol.asyncIterator]();
            executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
              iterator3.next().then(function(result) {
                if (result.done) {
                  subscriber.complete();
                } else {
                  subscriber.next(result.value);
                }
              });
            }, 0, true);
          });
        });
      }
      exports.scheduleAsyncIterable = scheduleAsyncIterable3;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduled/scheduleReadableStreamLike.js
  var require_scheduleReadableStreamLike = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduled/scheduleReadableStreamLike.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.scheduleReadableStreamLike = void 0;
      var scheduleAsyncIterable_1 = require_scheduleAsyncIterable();
      var isReadableStreamLike_1 = require_isReadableStreamLike();
      function scheduleReadableStreamLike3(input, scheduler) {
        return scheduleAsyncIterable_1.scheduleAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(input), scheduler);
      }
      exports.scheduleReadableStreamLike = scheduleReadableStreamLike3;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduled/scheduled.js
  var require_scheduled = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/scheduled/scheduled.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.scheduled = void 0;
      var scheduleObservable_1 = require_scheduleObservable();
      var schedulePromise_1 = require_schedulePromise();
      var scheduleArray_1 = require_scheduleArray();
      var scheduleIterable_1 = require_scheduleIterable();
      var scheduleAsyncIterable_1 = require_scheduleAsyncIterable();
      var isInteropObservable_1 = require_isInteropObservable();
      var isPromise_1 = require_isPromise();
      var isArrayLike_1 = require_isArrayLike();
      var isIterable_1 = require_isIterable();
      var isAsyncIterable_1 = require_isAsyncIterable();
      var throwUnobservableError_1 = require_throwUnobservableError();
      var isReadableStreamLike_1 = require_isReadableStreamLike();
      var scheduleReadableStreamLike_1 = require_scheduleReadableStreamLike();
      function scheduled3(input, scheduler) {
        if (input != null) {
          if (isInteropObservable_1.isInteropObservable(input)) {
            return scheduleObservable_1.scheduleObservable(input, scheduler);
          }
          if (isArrayLike_1.isArrayLike(input)) {
            return scheduleArray_1.scheduleArray(input, scheduler);
          }
          if (isPromise_1.isPromise(input)) {
            return schedulePromise_1.schedulePromise(input, scheduler);
          }
          if (isAsyncIterable_1.isAsyncIterable(input)) {
            return scheduleAsyncIterable_1.scheduleAsyncIterable(input, scheduler);
          }
          if (isIterable_1.isIterable(input)) {
            return scheduleIterable_1.scheduleIterable(input, scheduler);
          }
          if (isReadableStreamLike_1.isReadableStreamLike(input)) {
            return scheduleReadableStreamLike_1.scheduleReadableStreamLike(input, scheduler);
          }
        }
        throw throwUnobservableError_1.createInvalidObservableTypeError(input);
      }
      exports.scheduled = scheduled3;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/from.js
  var require_from = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/from.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.from = void 0;
      var scheduled_1 = require_scheduled();
      var innerFrom_1 = require_innerFrom();
      function from3(input, scheduler) {
        return scheduler ? scheduled_1.scheduled(input, scheduler) : innerFrom_1.innerFrom(input);
      }
      exports.from = from3;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/of.js
  var require_of = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/of.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.of = void 0;
      var args_1 = require_args();
      var from_1 = require_from();
      function of2() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var scheduler = args_1.popScheduler(args);
        return from_1.from(args, scheduler);
      }
      exports.of = of2;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/throwError.js
  var require_throwError = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/throwError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.throwError = void 0;
      var Observable_1 = require_Observable();
      var isFunction_1 = require_isFunction();
      function throwError(errorOrErrorFactory, scheduler) {
        var errorFactory = isFunction_1.isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
          return errorOrErrorFactory;
        };
        var init3 = function(subscriber) {
          return subscriber.error(errorFactory());
        };
        return new Observable_1.Observable(scheduler ? function(subscriber) {
          return scheduler.schedule(init3, 0, subscriber);
        } : init3);
      }
      exports.throwError = throwError;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/Notification.js
  var require_Notification = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/Notification.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.observeNotification = exports.Notification = exports.NotificationKind = void 0;
      var empty_1 = require_empty();
      var of_1 = require_of();
      var throwError_1 = require_throwError();
      var isFunction_1 = require_isFunction();
      var NotificationKind;
      (function(NotificationKind2) {
        NotificationKind2["NEXT"] = "N";
        NotificationKind2["ERROR"] = "E";
        NotificationKind2["COMPLETE"] = "C";
      })(NotificationKind = exports.NotificationKind || (exports.NotificationKind = {}));
      var Notification = function() {
        function Notification2(kind, value, error) {
          this.kind = kind;
          this.value = value;
          this.error = error;
          this.hasValue = kind === "N";
        }
        Notification2.prototype.observe = function(observer) {
          return observeNotification(this, observer);
        };
        Notification2.prototype.do = function(nextHandler, errorHandler, completeHandler) {
          var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
          return kind === "N" ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === "E" ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
        };
        Notification2.prototype.accept = function(nextOrObserver, error, complete) {
          var _a;
          return isFunction_1.isFunction((_a = nextOrObserver) === null || _a === void 0 ? void 0 : _a.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
        };
        Notification2.prototype.toObservable = function() {
          var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
          var result = kind === "N" ? of_1.of(value) : kind === "E" ? throwError_1.throwError(function() {
            return error;
          }) : kind === "C" ? empty_1.EMPTY : 0;
          if (!result) {
            throw new TypeError("Unexpected notification kind " + kind);
          }
          return result;
        };
        Notification2.createNext = function(value) {
          return new Notification2("N", value);
        };
        Notification2.createError = function(err) {
          return new Notification2("E", void 0, err);
        };
        Notification2.createComplete = function() {
          return Notification2.completeNotification;
        };
        Notification2.completeNotification = new Notification2("C");
        return Notification2;
      }();
      exports.Notification = Notification;
      function observeNotification(notification, observer) {
        var _a, _b, _c;
        var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;
        if (typeof kind !== "string") {
          throw new TypeError('Invalid notification, missing "kind"');
        }
        kind === "N" ? (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, value) : kind === "E" ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
      }
      exports.observeNotification = observeNotification;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/isObservable.js
  var require_isObservable = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/isObservable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isObservable = void 0;
      var Observable_1 = require_Observable();
      var isFunction_1 = require_isFunction();
      function isObservable(obj) {
        return !!obj && (obj instanceof Observable_1.Observable || isFunction_1.isFunction(obj.lift) && isFunction_1.isFunction(obj.subscribe));
      }
      exports.isObservable = isObservable;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/EmptyError.js
  var require_EmptyError = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/EmptyError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EmptyError = void 0;
      var createErrorClass_1 = require_createErrorClass();
      exports.EmptyError = createErrorClass_1.createErrorClass(function(_super) {
        return function EmptyErrorImpl() {
          _super(this);
          this.name = "EmptyError";
          this.message = "no elements in sequence";
        };
      });
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/lastValueFrom.js
  var require_lastValueFrom = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/lastValueFrom.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.lastValueFrom = void 0;
      var EmptyError_1 = require_EmptyError();
      function lastValueFrom(source2, config4) {
        var hasConfig = typeof config4 === "object";
        return new Promise(function(resolve, reject) {
          var _hasValue = false;
          var _value;
          source2.subscribe({
            next: function(value) {
              _value = value;
              _hasValue = true;
            },
            error: reject,
            complete: function() {
              if (_hasValue) {
                resolve(_value);
              } else if (hasConfig) {
                resolve(config4.defaultValue);
              } else {
                reject(new EmptyError_1.EmptyError());
              }
            }
          });
        });
      }
      exports.lastValueFrom = lastValueFrom;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/firstValueFrom.js
  var require_firstValueFrom = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/firstValueFrom.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.firstValueFrom = void 0;
      var EmptyError_1 = require_EmptyError();
      var Subscriber_1 = require_Subscriber();
      function firstValueFrom(source2, config4) {
        var hasConfig = typeof config4 === "object";
        return new Promise(function(resolve, reject) {
          var subscriber = new Subscriber_1.SafeSubscriber({
            next: function(value) {
              resolve(value);
              subscriber.unsubscribe();
            },
            error: reject,
            complete: function() {
              if (hasConfig) {
                resolve(config4.defaultValue);
              } else {
                reject(new EmptyError_1.EmptyError());
              }
            }
          });
          source2.subscribe(subscriber);
        });
      }
      exports.firstValueFrom = firstValueFrom;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/ArgumentOutOfRangeError.js
  var require_ArgumentOutOfRangeError = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/ArgumentOutOfRangeError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ArgumentOutOfRangeError = void 0;
      var createErrorClass_1 = require_createErrorClass();
      exports.ArgumentOutOfRangeError = createErrorClass_1.createErrorClass(function(_super) {
        return function ArgumentOutOfRangeErrorImpl() {
          _super(this);
          this.name = "ArgumentOutOfRangeError";
          this.message = "argument out of range";
        };
      });
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/NotFoundError.js
  var require_NotFoundError = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/NotFoundError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.NotFoundError = void 0;
      var createErrorClass_1 = require_createErrorClass();
      exports.NotFoundError = createErrorClass_1.createErrorClass(function(_super) {
        return function NotFoundErrorImpl(message) {
          _super(this);
          this.name = "NotFoundError";
          this.message = message;
        };
      });
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/SequenceError.js
  var require_SequenceError = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/SequenceError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SequenceError = void 0;
      var createErrorClass_1 = require_createErrorClass();
      exports.SequenceError = createErrorClass_1.createErrorClass(function(_super) {
        return function SequenceErrorImpl(message) {
          _super(this);
          this.name = "SequenceError";
          this.message = message;
        };
      });
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/isDate.js
  var require_isDate = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/isDate.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isValidDate = void 0;
      function isValidDate2(value) {
        return value instanceof Date && !isNaN(value);
      }
      exports.isValidDate = isValidDate2;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/timeout.js
  var require_timeout = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/timeout.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.timeout = exports.TimeoutError = void 0;
      var async_1 = require_async();
      var isDate_1 = require_isDate();
      var lift_1 = require_lift();
      var innerFrom_1 = require_innerFrom();
      var createErrorClass_1 = require_createErrorClass();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var executeSchedule_1 = require_executeSchedule();
      exports.TimeoutError = createErrorClass_1.createErrorClass(function(_super) {
        return function TimeoutErrorImpl(info) {
          if (info === void 0) {
            info = null;
          }
          _super(this);
          this.message = "Timeout has occurred";
          this.name = "TimeoutError";
          this.info = info;
        };
      });
      function timeout(config4, schedulerArg) {
        var _a = isDate_1.isValidDate(config4) ? { first: config4 } : typeof config4 === "number" ? { each: config4 } : config4, first2 = _a.first, each = _a.each, _b = _a.with, _with = _b === void 0 ? timeoutErrorFactory : _b, _c = _a.scheduler, scheduler = _c === void 0 ? schedulerArg !== null && schedulerArg !== void 0 ? schedulerArg : async_1.asyncScheduler : _c, _d = _a.meta, meta = _d === void 0 ? null : _d;
        if (first2 == null && each == null) {
          throw new TypeError("No timeout provided.");
        }
        return lift_1.operate(function(source2, subscriber) {
          var originalSourceSubscription;
          var timerSubscription;
          var lastValue = null;
          var seen = 0;
          var startTimer = function(delay) {
            timerSubscription = executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
              try {
                originalSourceSubscription.unsubscribe();
                innerFrom_1.innerFrom(_with({
                  meta,
                  lastValue,
                  seen
                })).subscribe(subscriber);
              } catch (err) {
                subscriber.error(err);
              }
            }, delay);
          };
          originalSourceSubscription = source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
            seen++;
            subscriber.next(lastValue = value);
            each > 0 && startTimer(each);
          }, void 0, void 0, function() {
            if (!(timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.closed)) {
              timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
            }
            lastValue = null;
          }));
          !seen && startTimer(first2 != null ? typeof first2 === "number" ? first2 : +first2 - scheduler.now() : each);
        });
      }
      exports.timeout = timeout;
      function timeoutErrorFactory(info) {
        throw new exports.TimeoutError(info);
      }
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/map.js
  var require_map = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/map.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.map = void 0;
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function map3(project, thisArg) {
        return lift_1.operate(function(source2, subscriber) {
          var index = 0;
          source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            subscriber.next(project.call(thisArg, value, index++));
          }));
        });
      }
      exports.map = map3;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/mapOneOrManyArgs.js
  var require_mapOneOrManyArgs = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/mapOneOrManyArgs.js"(exports) {
      "use strict";
      var __read3 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2)
          return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
            ar.push(r2.value);
        } catch (error) {
          e2 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray3 = exports && exports.__spreadArray || function(to, from3) {
        for (var i2 = 0, il = from3.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from3[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.mapOneOrManyArgs = void 0;
      var map_1 = require_map();
      var isArray3 = Array.isArray;
      function callOrApply2(fn, args) {
        return isArray3(args) ? fn.apply(void 0, __spreadArray3([], __read3(args))) : fn(args);
      }
      function mapOneOrManyArgs2(fn) {
        return map_1.map(function(args) {
          return callOrApply2(fn, args);
        });
      }
      exports.mapOneOrManyArgs = mapOneOrManyArgs2;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/bindCallbackInternals.js
  var require_bindCallbackInternals = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/bindCallbackInternals.js"(exports) {
      "use strict";
      var __read3 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2)
          return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
            ar.push(r2.value);
        } catch (error) {
          e2 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray3 = exports && exports.__spreadArray || function(to, from3) {
        for (var i2 = 0, il = from3.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from3[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.bindCallbackInternals = void 0;
      var isScheduler_1 = require_isScheduler();
      var Observable_1 = require_Observable();
      var subscribeOn_1 = require_subscribeOn();
      var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
      var observeOn_1 = require_observeOn();
      var AsyncSubject_1 = require_AsyncSubject();
      function bindCallbackInternals(isNodeStyle, callbackFunc, resultSelector, scheduler) {
        if (resultSelector) {
          if (isScheduler_1.isScheduler(resultSelector)) {
            scheduler = resultSelector;
          } else {
            return function() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              return bindCallbackInternals(isNodeStyle, callbackFunc, scheduler).apply(this, args).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
            };
          }
        }
        if (scheduler) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return bindCallbackInternals(isNodeStyle, callbackFunc).apply(this, args).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
          };
        }
        return function() {
          var _this = this;
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var subject = new AsyncSubject_1.AsyncSubject();
          var uninitialized = true;
          return new Observable_1.Observable(function(subscriber) {
            var subs = subject.subscribe(subscriber);
            if (uninitialized) {
              uninitialized = false;
              var isAsync_1 = false;
              var isComplete_1 = false;
              callbackFunc.apply(_this, __spreadArray3(__spreadArray3([], __read3(args)), [
                function() {
                  var results = [];
                  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
                    results[_i2] = arguments[_i2];
                  }
                  if (isNodeStyle) {
                    var err = results.shift();
                    if (err != null) {
                      subject.error(err);
                      return;
                    }
                  }
                  subject.next(1 < results.length ? results : results[0]);
                  isComplete_1 = true;
                  if (isAsync_1) {
                    subject.complete();
                  }
                }
              ]));
              if (isComplete_1) {
                subject.complete();
              }
              isAsync_1 = true;
            }
            return subs;
          });
        };
      }
      exports.bindCallbackInternals = bindCallbackInternals;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/bindCallback.js
  var require_bindCallback = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/bindCallback.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.bindCallback = void 0;
      var bindCallbackInternals_1 = require_bindCallbackInternals();
      function bindCallback(callbackFunc, resultSelector, scheduler) {
        return bindCallbackInternals_1.bindCallbackInternals(false, callbackFunc, resultSelector, scheduler);
      }
      exports.bindCallback = bindCallback;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/bindNodeCallback.js
  var require_bindNodeCallback = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/bindNodeCallback.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.bindNodeCallback = void 0;
      var bindCallbackInternals_1 = require_bindCallbackInternals();
      function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
        return bindCallbackInternals_1.bindCallbackInternals(true, callbackFunc, resultSelector, scheduler);
      }
      exports.bindNodeCallback = bindNodeCallback;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/argsArgArrayOrObject.js
  var require_argsArgArrayOrObject = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/argsArgArrayOrObject.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.argsArgArrayOrObject = void 0;
      var isArray3 = Array.isArray;
      var getPrototypeOf2 = Object.getPrototypeOf;
      var objectProto2 = Object.prototype;
      var getKeys2 = Object.keys;
      function argsArgArrayOrObject2(args) {
        if (args.length === 1) {
          var first_1 = args[0];
          if (isArray3(first_1)) {
            return { args: first_1, keys: null };
          }
          if (isPOJO2(first_1)) {
            var keys = getKeys2(first_1);
            return {
              args: keys.map(function(key) {
                return first_1[key];
              }),
              keys
            };
          }
        }
        return { args, keys: null };
      }
      exports.argsArgArrayOrObject = argsArgArrayOrObject2;
      function isPOJO2(obj) {
        return obj && typeof obj === "object" && getPrototypeOf2(obj) === objectProto2;
      }
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/createObject.js
  var require_createObject = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/createObject.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createObject = void 0;
      function createObject2(keys, values) {
        return keys.reduce(function(result, key, i2) {
          return result[key] = values[i2], result;
        }, {});
      }
      exports.createObject = createObject2;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/combineLatest.js
  var require_combineLatest = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/combineLatest.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.combineLatestInit = exports.combineLatest = void 0;
      var Observable_1 = require_Observable();
      var argsArgArrayOrObject_1 = require_argsArgArrayOrObject();
      var from_1 = require_from();
      var identity_1 = require_identity();
      var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
      var args_1 = require_args();
      var createObject_1 = require_createObject();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var executeSchedule_1 = require_executeSchedule();
      function combineLatest3() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var scheduler = args_1.popScheduler(args);
        var resultSelector = args_1.popResultSelector(args);
        var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args), observables = _a.args, keys = _a.keys;
        if (observables.length === 0) {
          return from_1.from([], scheduler);
        }
        var result = new Observable_1.Observable(combineLatestInit2(observables, scheduler, keys ? function(values) {
          return createObject_1.createObject(keys, values);
        } : identity_1.identity));
        return resultSelector ? result.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result;
      }
      exports.combineLatest = combineLatest3;
      function combineLatestInit2(observables, scheduler, valueTransform) {
        if (valueTransform === void 0) {
          valueTransform = identity_1.identity;
        }
        return function(subscriber) {
          maybeSchedule2(scheduler, function() {
            var length = observables.length;
            var values = new Array(length);
            var active = length;
            var remainingFirstValues = length;
            var _loop_1 = function(i3) {
              maybeSchedule2(scheduler, function() {
                var source2 = from_1.from(observables[i3], scheduler);
                var hasFirstValue = false;
                source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                  values[i3] = value;
                  if (!hasFirstValue) {
                    hasFirstValue = true;
                    remainingFirstValues--;
                  }
                  if (!remainingFirstValues) {
                    subscriber.next(valueTransform(values.slice()));
                  }
                }, function() {
                  if (!--active) {
                    subscriber.complete();
                  }
                }));
              }, subscriber);
            };
            for (var i2 = 0; i2 < length; i2++) {
              _loop_1(i2);
            }
          }, subscriber);
        };
      }
      exports.combineLatestInit = combineLatestInit2;
      function maybeSchedule2(scheduler, execute, subscription) {
        if (scheduler) {
          executeSchedule_1.executeSchedule(subscription, scheduler, execute);
        } else {
          execute();
        }
      }
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/mergeInternals.js
  var require_mergeInternals = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/mergeInternals.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.mergeInternals = void 0;
      var innerFrom_1 = require_innerFrom();
      var executeSchedule_1 = require_executeSchedule();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function mergeInternals3(source2, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
        var buffer = [];
        var active = 0;
        var index = 0;
        var isComplete = false;
        var checkComplete = function() {
          if (isComplete && !buffer.length && !active) {
            subscriber.complete();
          }
        };
        var outerNext = function(value) {
          return active < concurrent ? doInnerSub(value) : buffer.push(value);
        };
        var doInnerSub = function(value) {
          expand && subscriber.next(value);
          active++;
          var innerComplete = false;
          innerFrom_1.innerFrom(project(value, index++)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(innerValue) {
            onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
            if (expand) {
              outerNext(innerValue);
            } else {
              subscriber.next(innerValue);
            }
          }, function() {
            innerComplete = true;
          }, void 0, function() {
            if (innerComplete) {
              try {
                active--;
                var _loop_1 = function() {
                  var bufferedValue = buffer.shift();
                  if (innerSubScheduler) {
                    executeSchedule_1.executeSchedule(subscriber, innerSubScheduler, function() {
                      return doInnerSub(bufferedValue);
                    });
                  } else {
                    doInnerSub(bufferedValue);
                  }
                };
                while (buffer.length && active < concurrent) {
                  _loop_1();
                }
                checkComplete();
              } catch (err) {
                subscriber.error(err);
              }
            }
          }));
        };
        source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, outerNext, function() {
          isComplete = true;
          checkComplete();
        }));
        return function() {
          additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
        };
      }
      exports.mergeInternals = mergeInternals3;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/mergeMap.js
  var require_mergeMap = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/mergeMap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.mergeMap = void 0;
      var map_1 = require_map();
      var innerFrom_1 = require_innerFrom();
      var lift_1 = require_lift();
      var mergeInternals_1 = require_mergeInternals();
      var isFunction_1 = require_isFunction();
      function mergeMap3(project, resultSelector, concurrent) {
        if (concurrent === void 0) {
          concurrent = Infinity;
        }
        if (isFunction_1.isFunction(resultSelector)) {
          return mergeMap3(function(a2, i2) {
            return map_1.map(function(b2, ii) {
              return resultSelector(a2, b2, i2, ii);
            })(innerFrom_1.innerFrom(project(a2, i2)));
          }, concurrent);
        } else if (typeof resultSelector === "number") {
          concurrent = resultSelector;
        }
        return lift_1.operate(function(source2, subscriber) {
          return mergeInternals_1.mergeInternals(source2, subscriber, project, concurrent);
        });
      }
      exports.mergeMap = mergeMap3;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/mergeAll.js
  var require_mergeAll = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/mergeAll.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.mergeAll = void 0;
      var mergeMap_1 = require_mergeMap();
      var identity_1 = require_identity();
      function mergeAll3(concurrent) {
        if (concurrent === void 0) {
          concurrent = Infinity;
        }
        return mergeMap_1.mergeMap(identity_1.identity, concurrent);
      }
      exports.mergeAll = mergeAll3;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/concatAll.js
  var require_concatAll = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/concatAll.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.concatAll = void 0;
      var mergeAll_1 = require_mergeAll();
      function concatAll() {
        return mergeAll_1.mergeAll(1);
      }
      exports.concatAll = concatAll;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/concat.js
  var require_concat = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/concat.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.concat = void 0;
      var concatAll_1 = require_concatAll();
      var args_1 = require_args();
      var from_1 = require_from();
      function concat() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return concatAll_1.concatAll()(from_1.from(args, args_1.popScheduler(args)));
      }
      exports.concat = concat;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/defer.js
  var require_defer = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/defer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.defer = void 0;
      var Observable_1 = require_Observable();
      var innerFrom_1 = require_innerFrom();
      function defer(observableFactory) {
        return new Observable_1.Observable(function(subscriber) {
          innerFrom_1.innerFrom(observableFactory()).subscribe(subscriber);
        });
      }
      exports.defer = defer;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/connectable.js
  var require_connectable = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/connectable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.connectable = void 0;
      var Subject_1 = require_Subject();
      var Observable_1 = require_Observable();
      var defer_1 = require_defer();
      var DEFAULT_CONFIG = {
        connector: function() {
          return new Subject_1.Subject();
        },
        resetOnDisconnect: true
      };
      function connectable(source2, config4) {
        if (config4 === void 0) {
          config4 = DEFAULT_CONFIG;
        }
        var connection = null;
        var connector = config4.connector, _a = config4.resetOnDisconnect, resetOnDisconnect = _a === void 0 ? true : _a;
        var subject = connector();
        var result = new Observable_1.Observable(function(subscriber) {
          return subject.subscribe(subscriber);
        });
        result.connect = function() {
          if (!connection || connection.closed) {
            connection = defer_1.defer(function() {
              return source2;
            }).subscribe(subject);
            if (resetOnDisconnect) {
              connection.add(function() {
                return subject = connector();
              });
            }
          }
          return connection;
        };
        return result;
      }
      exports.connectable = connectable;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/forkJoin.js
  var require_forkJoin = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/forkJoin.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.forkJoin = void 0;
      var Observable_1 = require_Observable();
      var argsArgArrayOrObject_1 = require_argsArgArrayOrObject();
      var innerFrom_1 = require_innerFrom();
      var args_1 = require_args();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
      var createObject_1 = require_createObject();
      function forkJoin() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var resultSelector = args_1.popResultSelector(args);
        var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args), sources2 = _a.args, keys = _a.keys;
        var result = new Observable_1.Observable(function(subscriber) {
          var length = sources2.length;
          if (!length) {
            subscriber.complete();
            return;
          }
          var values = new Array(length);
          var remainingCompletions = length;
          var remainingEmissions = length;
          var _loop_1 = function(sourceIndex2) {
            var hasValue = false;
            innerFrom_1.innerFrom(sources2[sourceIndex2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
              if (!hasValue) {
                hasValue = true;
                remainingEmissions--;
              }
              values[sourceIndex2] = value;
            }, function() {
              return remainingCompletions--;
            }, void 0, function() {
              if (!remainingCompletions || !hasValue) {
                if (!remainingEmissions) {
                  subscriber.next(keys ? createObject_1.createObject(keys, values) : values);
                }
                subscriber.complete();
              }
            }));
          };
          for (var sourceIndex = 0; sourceIndex < length; sourceIndex++) {
            _loop_1(sourceIndex);
          }
        });
        return resultSelector ? result.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result;
      }
      exports.forkJoin = forkJoin;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/fromEvent.js
  var require_fromEvent = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/fromEvent.js"(exports) {
      "use strict";
      var __read3 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2)
          return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
            ar.push(r2.value);
        } catch (error) {
          e2 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.fromEvent = void 0;
      var innerFrom_1 = require_innerFrom();
      var Observable_1 = require_Observable();
      var mergeMap_1 = require_mergeMap();
      var isArrayLike_1 = require_isArrayLike();
      var isFunction_1 = require_isFunction();
      var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
      var nodeEventEmitterMethods2 = ["addListener", "removeListener"];
      var eventTargetMethods2 = ["addEventListener", "removeEventListener"];
      var jqueryMethods2 = ["on", "off"];
      function fromEvent2(target, eventName, options, resultSelector) {
        if (isFunction_1.isFunction(options)) {
          resultSelector = options;
          options = void 0;
        }
        if (resultSelector) {
          return fromEvent2(target, eventName, options).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
        }
        var _a = __read3(isEventTarget2(target) ? eventTargetMethods2.map(function(methodName) {
          return function(handler) {
            return target[methodName](eventName, handler, options);
          };
        }) : isNodeStyleEventEmitter2(target) ? nodeEventEmitterMethods2.map(toCommonHandlerRegistry2(target, eventName)) : isJQueryStyleEventEmitter2(target) ? jqueryMethods2.map(toCommonHandlerRegistry2(target, eventName)) : [], 2), add = _a[0], remove = _a[1];
        if (!add) {
          if (isArrayLike_1.isArrayLike(target)) {
            return mergeMap_1.mergeMap(function(subTarget) {
              return fromEvent2(subTarget, eventName, options);
            })(innerFrom_1.innerFrom(target));
          }
        }
        if (!add) {
          throw new TypeError("Invalid event target");
        }
        return new Observable_1.Observable(function(subscriber) {
          var handler = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return subscriber.next(1 < args.length ? args : args[0]);
          };
          add(handler);
          return function() {
            return remove(handler);
          };
        });
      }
      exports.fromEvent = fromEvent2;
      function toCommonHandlerRegistry2(target, eventName) {
        return function(methodName) {
          return function(handler) {
            return target[methodName](eventName, handler);
          };
        };
      }
      function isNodeStyleEventEmitter2(target) {
        return isFunction_1.isFunction(target.addListener) && isFunction_1.isFunction(target.removeListener);
      }
      function isJQueryStyleEventEmitter2(target) {
        return isFunction_1.isFunction(target.on) && isFunction_1.isFunction(target.off);
      }
      function isEventTarget2(target) {
        return isFunction_1.isFunction(target.addEventListener) && isFunction_1.isFunction(target.removeEventListener);
      }
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/fromEventPattern.js
  var require_fromEventPattern = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/fromEventPattern.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.fromEventPattern = void 0;
      var Observable_1 = require_Observable();
      var isFunction_1 = require_isFunction();
      var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
      function fromEventPattern(addHandler, removeHandler, resultSelector) {
        if (resultSelector) {
          return fromEventPattern(addHandler, removeHandler).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
        }
        return new Observable_1.Observable(function(subscriber) {
          var handler = function() {
            var e2 = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              e2[_i] = arguments[_i];
            }
            return subscriber.next(e2.length === 1 ? e2[0] : e2);
          };
          var retValue = addHandler(handler);
          return isFunction_1.isFunction(removeHandler) ? function() {
            return removeHandler(handler, retValue);
          } : void 0;
        });
      }
      exports.fromEventPattern = fromEventPattern;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/generate.js
  var require_generate = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/generate.js"(exports) {
      "use strict";
      var __generator3 = exports && exports.__generator || function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t2[0] & 1)
            throw t2[1];
          return t2[1];
        }, trys: [], ops: [] }, f2, y2, t2, g2;
        return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
          return this;
        }), g2;
        function verb(n2) {
          return function(v2) {
            return step([n2, v2]);
          };
        }
        function step(op) {
          if (f2)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
                return t2;
              if (y2 = 0, t2)
                op = [op[0] & 2, t2.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t2 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y2 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t2[1]) {
                    _.label = t2[1];
                    t2 = op;
                    break;
                  }
                  if (t2 && _.label < t2[2]) {
                    _.label = t2[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t2[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e2) {
              op = [6, e2];
              y2 = 0;
            } finally {
              f2 = t2 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.generate = void 0;
      var identity_1 = require_identity();
      var isScheduler_1 = require_isScheduler();
      var defer_1 = require_defer();
      var scheduleIterable_1 = require_scheduleIterable();
      function generate(initialStateOrOptions, condition, iterate, resultSelectorOrScheduler, scheduler) {
        var _a, _b;
        var resultSelector;
        var initialState;
        if (arguments.length === 1) {
          _a = initialStateOrOptions, initialState = _a.initialState, condition = _a.condition, iterate = _a.iterate, _b = _a.resultSelector, resultSelector = _b === void 0 ? identity_1.identity : _b, scheduler = _a.scheduler;
        } else {
          initialState = initialStateOrOptions;
          if (!resultSelectorOrScheduler || isScheduler_1.isScheduler(resultSelectorOrScheduler)) {
            resultSelector = identity_1.identity;
            scheduler = resultSelectorOrScheduler;
          } else {
            resultSelector = resultSelectorOrScheduler;
          }
        }
        function gen() {
          var state;
          return __generator3(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                state = initialState;
                _a2.label = 1;
              case 1:
                if (!(!condition || condition(state)))
                  return [3, 4];
                return [4, resultSelector(state)];
              case 2:
                _a2.sent();
                _a2.label = 3;
              case 3:
                state = iterate(state);
                return [3, 1];
              case 4:
                return [2];
            }
          });
        }
        return defer_1.defer(scheduler ? function() {
          return scheduleIterable_1.scheduleIterable(gen(), scheduler);
        } : gen);
      }
      exports.generate = generate;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/iif.js
  var require_iif = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/iif.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.iif = void 0;
      var defer_1 = require_defer();
      function iif(condition, trueResult, falseResult) {
        return defer_1.defer(function() {
          return condition() ? trueResult : falseResult;
        });
      }
      exports.iif = iif;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/timer.js
  var require_timer = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/timer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.timer = void 0;
      var Observable_1 = require_Observable();
      var async_1 = require_async();
      var isScheduler_1 = require_isScheduler();
      var isDate_1 = require_isDate();
      function timer2(dueTime, intervalOrScheduler, scheduler) {
        if (dueTime === void 0) {
          dueTime = 0;
        }
        if (scheduler === void 0) {
          scheduler = async_1.async;
        }
        var intervalDuration = -1;
        if (intervalOrScheduler != null) {
          if (isScheduler_1.isScheduler(intervalOrScheduler)) {
            scheduler = intervalOrScheduler;
          } else {
            intervalDuration = intervalOrScheduler;
          }
        }
        return new Observable_1.Observable(function(subscriber) {
          var due = isDate_1.isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
          if (due < 0) {
            due = 0;
          }
          var n2 = 0;
          return scheduler.schedule(function() {
            if (!subscriber.closed) {
              subscriber.next(n2++);
              if (0 <= intervalDuration) {
                this.schedule(void 0, intervalDuration);
              } else {
                subscriber.complete();
              }
            }
          }, due);
        });
      }
      exports.timer = timer2;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/interval.js
  var require_interval = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/interval.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.interval = void 0;
      var async_1 = require_async();
      var timer_1 = require_timer();
      function interval2(period, scheduler) {
        if (period === void 0) {
          period = 0;
        }
        if (scheduler === void 0) {
          scheduler = async_1.asyncScheduler;
        }
        if (period < 0) {
          period = 0;
        }
        return timer_1.timer(period, period, scheduler);
      }
      exports.interval = interval2;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/merge.js
  var require_merge = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/merge.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.merge = void 0;
      var mergeAll_1 = require_mergeAll();
      var innerFrom_1 = require_innerFrom();
      var empty_1 = require_empty();
      var args_1 = require_args();
      var from_1 = require_from();
      function merge3() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var scheduler = args_1.popScheduler(args);
        var concurrent = args_1.popNumber(args, Infinity);
        var sources2 = args;
        return !sources2.length ? empty_1.EMPTY : sources2.length === 1 ? innerFrom_1.innerFrom(sources2[0]) : mergeAll_1.mergeAll(concurrent)(from_1.from(sources2, scheduler));
      }
      exports.merge = merge3;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/never.js
  var require_never = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/never.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.never = exports.NEVER = void 0;
      var Observable_1 = require_Observable();
      var noop_1 = require_noop();
      exports.NEVER = new Observable_1.Observable(noop_1.noop);
      function never() {
        return exports.NEVER;
      }
      exports.never = never;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/argsOrArgArray.js
  var require_argsOrArgArray = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/argsOrArgArray.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.argsOrArgArray = void 0;
      var isArray3 = Array.isArray;
      function argsOrArgArray(args) {
        return args.length === 1 && isArray3(args[0]) ? args[0] : args;
      }
      exports.argsOrArgArray = argsOrArgArray;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/onErrorResumeNext.js
  var require_onErrorResumeNext = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/onErrorResumeNext.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.onErrorResumeNext = void 0;
      var Observable_1 = require_Observable();
      var argsOrArgArray_1 = require_argsOrArgArray();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var noop_1 = require_noop();
      var innerFrom_1 = require_innerFrom();
      function onErrorResumeNext() {
        var sources2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          sources2[_i] = arguments[_i];
        }
        var nextSources = argsOrArgArray_1.argsOrArgArray(sources2);
        return new Observable_1.Observable(function(subscriber) {
          var sourceIndex = 0;
          var subscribeNext = function() {
            if (sourceIndex < nextSources.length) {
              var nextSource = void 0;
              try {
                nextSource = innerFrom_1.innerFrom(nextSources[sourceIndex++]);
              } catch (err) {
                subscribeNext();
                return;
              }
              var innerSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, void 0, noop_1.noop, noop_1.noop);
              nextSource.subscribe(innerSubscriber);
              innerSubscriber.add(subscribeNext);
            } else {
              subscriber.complete();
            }
          };
          subscribeNext();
        });
      }
      exports.onErrorResumeNext = onErrorResumeNext;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/pairs.js
  var require_pairs = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/pairs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.pairs = void 0;
      var from_1 = require_from();
      function pairs(obj, scheduler) {
        return from_1.from(Object.entries(obj), scheduler);
      }
      exports.pairs = pairs;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/not.js
  var require_not = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/util/not.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.not = void 0;
      function not(pred, thisArg) {
        return function(value, index) {
          return !pred.call(thisArg, value, index);
        };
      }
      exports.not = not;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/filter.js
  var require_filter = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/filter.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.filter = void 0;
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function filter2(predicate, thisArg) {
        return lift_1.operate(function(source2, subscriber) {
          var index = 0;
          source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            return predicate.call(thisArg, value, index++) && subscriber.next(value);
          }));
        });
      }
      exports.filter = filter2;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/partition.js
  var require_partition = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/partition.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.partition = void 0;
      var not_1 = require_not();
      var filter_1 = require_filter();
      var innerFrom_1 = require_innerFrom();
      function partition(source2, predicate, thisArg) {
        return [filter_1.filter(predicate, thisArg)(innerFrom_1.innerFrom(source2)), filter_1.filter(not_1.not(predicate, thisArg))(innerFrom_1.innerFrom(source2))];
      }
      exports.partition = partition;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/race.js
  var require_race = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/race.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.raceInit = exports.race = void 0;
      var Observable_1 = require_Observable();
      var innerFrom_1 = require_innerFrom();
      var argsOrArgArray_1 = require_argsOrArgArray();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function race() {
        var sources2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          sources2[_i] = arguments[_i];
        }
        sources2 = argsOrArgArray_1.argsOrArgArray(sources2);
        return sources2.length === 1 ? innerFrom_1.innerFrom(sources2[0]) : new Observable_1.Observable(raceInit(sources2));
      }
      exports.race = race;
      function raceInit(sources2) {
        return function(subscriber) {
          var subscriptions = [];
          var _loop_1 = function(i3) {
            subscriptions.push(innerFrom_1.innerFrom(sources2[i3]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
              if (subscriptions) {
                for (var s2 = 0; s2 < subscriptions.length; s2++) {
                  s2 !== i3 && subscriptions[s2].unsubscribe();
                }
                subscriptions = null;
              }
              subscriber.next(value);
            })));
          };
          for (var i2 = 0; subscriptions && !subscriber.closed && i2 < sources2.length; i2++) {
            _loop_1(i2);
          }
        };
      }
      exports.raceInit = raceInit;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/range.js
  var require_range = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/range.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.range = void 0;
      var Observable_1 = require_Observable();
      var empty_1 = require_empty();
      function range(start, count2, scheduler) {
        if (count2 == null) {
          count2 = start;
          start = 0;
        }
        if (count2 <= 0) {
          return empty_1.EMPTY;
        }
        var end = count2 + start;
        return new Observable_1.Observable(scheduler ? function(subscriber) {
          var n2 = start;
          return scheduler.schedule(function() {
            if (n2 < end) {
              subscriber.next(n2++);
              this.schedule();
            } else {
              subscriber.complete();
            }
          });
        } : function(subscriber) {
          var n2 = start;
          while (n2 < end && !subscriber.closed) {
            subscriber.next(n2++);
          }
          subscriber.complete();
        });
      }
      exports.range = range;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/using.js
  var require_using = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/using.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.using = void 0;
      var Observable_1 = require_Observable();
      var innerFrom_1 = require_innerFrom();
      var empty_1 = require_empty();
      function using(resourceFactory, observableFactory) {
        return new Observable_1.Observable(function(subscriber) {
          var resource = resourceFactory();
          var result = observableFactory(resource);
          var source2 = result ? innerFrom_1.innerFrom(result) : empty_1.EMPTY;
          source2.subscribe(subscriber);
          return function() {
            if (resource) {
              resource.unsubscribe();
            }
          };
        });
      }
      exports.using = using;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/zip.js
  var require_zip = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/zip.js"(exports) {
      "use strict";
      var __read3 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2)
          return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
            ar.push(r2.value);
        } catch (error) {
          e2 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray3 = exports && exports.__spreadArray || function(to, from3) {
        for (var i2 = 0, il = from3.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from3[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.zip = void 0;
      var Observable_1 = require_Observable();
      var innerFrom_1 = require_innerFrom();
      var argsOrArgArray_1 = require_argsOrArgArray();
      var empty_1 = require_empty();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var args_1 = require_args();
      function zip() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var resultSelector = args_1.popResultSelector(args);
        var sources2 = argsOrArgArray_1.argsOrArgArray(args);
        return sources2.length ? new Observable_1.Observable(function(subscriber) {
          var buffers = sources2.map(function() {
            return [];
          });
          var completed = sources2.map(function() {
            return false;
          });
          subscriber.add(function() {
            buffers = completed = null;
          });
          var _loop_1 = function(sourceIndex2) {
            innerFrom_1.innerFrom(sources2[sourceIndex2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
              buffers[sourceIndex2].push(value);
              if (buffers.every(function(buffer) {
                return buffer.length;
              })) {
                var result = buffers.map(function(buffer) {
                  return buffer.shift();
                });
                subscriber.next(resultSelector ? resultSelector.apply(void 0, __spreadArray3([], __read3(result))) : result);
                if (buffers.some(function(buffer, i2) {
                  return !buffer.length && completed[i2];
                })) {
                  subscriber.complete();
                }
              }
            }, function() {
              completed[sourceIndex2] = true;
              !buffers[sourceIndex2].length && subscriber.complete();
            }));
          };
          for (var sourceIndex = 0; !subscriber.closed && sourceIndex < sources2.length; sourceIndex++) {
            _loop_1(sourceIndex);
          }
          return function() {
            buffers = completed = null;
          };
        }) : empty_1.EMPTY;
      }
      exports.zip = zip;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/types.js
  var require_types = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/types.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/audit.js
  var require_audit = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/audit.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.audit = void 0;
      var lift_1 = require_lift();
      var innerFrom_1 = require_innerFrom();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function audit(durationSelector) {
        return lift_1.operate(function(source2, subscriber) {
          var hasValue = false;
          var lastValue = null;
          var durationSubscriber = null;
          var isComplete = false;
          var endDuration = function() {
            durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
            durationSubscriber = null;
            if (hasValue) {
              hasValue = false;
              var value = lastValue;
              lastValue = null;
              subscriber.next(value);
            }
            isComplete && subscriber.complete();
          };
          var cleanupDuration = function() {
            durationSubscriber = null;
            isComplete && subscriber.complete();
          };
          source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            hasValue = true;
            lastValue = value;
            if (!durationSubscriber) {
              innerFrom_1.innerFrom(durationSelector(value)).subscribe(durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, endDuration, cleanupDuration));
            }
          }, function() {
            isComplete = true;
            (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();
          }));
        });
      }
      exports.audit = audit;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/auditTime.js
  var require_auditTime = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/auditTime.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.auditTime = void 0;
      var async_1 = require_async();
      var audit_1 = require_audit();
      var timer_1 = require_timer();
      function auditTime(duration, scheduler) {
        if (scheduler === void 0) {
          scheduler = async_1.asyncScheduler;
        }
        return audit_1.audit(function() {
          return timer_1.timer(duration, scheduler);
        });
      }
      exports.auditTime = auditTime;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/buffer.js
  var require_buffer = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/buffer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.buffer = void 0;
      var lift_1 = require_lift();
      var noop_1 = require_noop();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var innerFrom_1 = require_innerFrom();
      function buffer(closingNotifier) {
        return lift_1.operate(function(source2, subscriber) {
          var currentBuffer = [];
          source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            return currentBuffer.push(value);
          }, function() {
            subscriber.next(currentBuffer);
            subscriber.complete();
          }));
          innerFrom_1.innerFrom(closingNotifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
            var b2 = currentBuffer;
            currentBuffer = [];
            subscriber.next(b2);
          }, noop_1.noop));
          return function() {
            currentBuffer = null;
          };
        });
      }
      exports.buffer = buffer;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/bufferCount.js
  var require_bufferCount = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/bufferCount.js"(exports) {
      "use strict";
      var __values3 = exports && exports.__values || function(o2) {
        var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
        if (m2)
          return m2.call(o2);
        if (o2 && typeof o2.length === "number")
          return {
            next: function() {
              if (o2 && i2 >= o2.length)
                o2 = void 0;
              return { value: o2 && o2[i2++], done: !o2 };
            }
          };
        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.bufferCount = void 0;
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var arrRemove_1 = require_arrRemove();
      function bufferCount(bufferSize, startBufferEvery) {
        if (startBufferEvery === void 0) {
          startBufferEvery = null;
        }
        startBufferEvery = startBufferEvery !== null && startBufferEvery !== void 0 ? startBufferEvery : bufferSize;
        return lift_1.operate(function(source2, subscriber) {
          var buffers = [];
          var count2 = 0;
          source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            var e_1, _a, e_2, _b;
            var toEmit = null;
            if (count2++ % startBufferEvery === 0) {
              buffers.push([]);
            }
            try {
              for (var buffers_1 = __values3(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
                var buffer = buffers_1_1.value;
                buffer.push(value);
                if (bufferSize <= buffer.length) {
                  toEmit = toEmit !== null && toEmit !== void 0 ? toEmit : [];
                  toEmit.push(buffer);
                }
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return))
                  _a.call(buffers_1);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
            if (toEmit) {
              try {
                for (var toEmit_1 = __values3(toEmit), toEmit_1_1 = toEmit_1.next(); !toEmit_1_1.done; toEmit_1_1 = toEmit_1.next()) {
                  var buffer = toEmit_1_1.value;
                  arrRemove_1.arrRemove(buffers, buffer);
                  subscriber.next(buffer);
                }
              } catch (e_2_1) {
                e_2 = { error: e_2_1 };
              } finally {
                try {
                  if (toEmit_1_1 && !toEmit_1_1.done && (_b = toEmit_1.return))
                    _b.call(toEmit_1);
                } finally {
                  if (e_2)
                    throw e_2.error;
                }
              }
            }
          }, function() {
            var e_3, _a;
            try {
              for (var buffers_2 = __values3(buffers), buffers_2_1 = buffers_2.next(); !buffers_2_1.done; buffers_2_1 = buffers_2.next()) {
                var buffer = buffers_2_1.value;
                subscriber.next(buffer);
              }
            } catch (e_3_1) {
              e_3 = { error: e_3_1 };
            } finally {
              try {
                if (buffers_2_1 && !buffers_2_1.done && (_a = buffers_2.return))
                  _a.call(buffers_2);
              } finally {
                if (e_3)
                  throw e_3.error;
              }
            }
            subscriber.complete();
          }, void 0, function() {
            buffers = null;
          }));
        });
      }
      exports.bufferCount = bufferCount;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/bufferTime.js
  var require_bufferTime = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/bufferTime.js"(exports) {
      "use strict";
      var __values3 = exports && exports.__values || function(o2) {
        var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
        if (m2)
          return m2.call(o2);
        if (o2 && typeof o2.length === "number")
          return {
            next: function() {
              if (o2 && i2 >= o2.length)
                o2 = void 0;
              return { value: o2 && o2[i2++], done: !o2 };
            }
          };
        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.bufferTime = void 0;
      var Subscription_1 = require_Subscription();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var arrRemove_1 = require_arrRemove();
      var async_1 = require_async();
      var args_1 = require_args();
      var executeSchedule_1 = require_executeSchedule();
      function bufferTime(bufferTimeSpan) {
        var _a, _b;
        var otherArgs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          otherArgs[_i - 1] = arguments[_i];
        }
        var scheduler = (_a = args_1.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_1.asyncScheduler;
        var bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
        var maxBufferSize = otherArgs[1] || Infinity;
        return lift_1.operate(function(source2, subscriber) {
          var bufferRecords = [];
          var restartOnEmit = false;
          var emit = function(record) {
            var buffer = record.buffer, subs = record.subs;
            subs.unsubscribe();
            arrRemove_1.arrRemove(bufferRecords, record);
            subscriber.next(buffer);
            restartOnEmit && startBuffer();
          };
          var startBuffer = function() {
            if (bufferRecords) {
              var subs = new Subscription_1.Subscription();
              subscriber.add(subs);
              var buffer = [];
              var record_1 = {
                buffer,
                subs
              };
              bufferRecords.push(record_1);
              executeSchedule_1.executeSchedule(subs, scheduler, function() {
                return emit(record_1);
              }, bufferTimeSpan);
            }
          };
          if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
            executeSchedule_1.executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);
          } else {
            restartOnEmit = true;
          }
          startBuffer();
          var bufferTimeSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            var e_1, _a2;
            var recordsCopy = bufferRecords.slice();
            try {
              for (var recordsCopy_1 = __values3(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next(); !recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {
                var record = recordsCopy_1_1.value;
                var buffer = record.buffer;
                buffer.push(value);
                maxBufferSize <= buffer.length && emit(record);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a2 = recordsCopy_1.return))
                  _a2.call(recordsCopy_1);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
          }, function() {
            while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) {
              subscriber.next(bufferRecords.shift().buffer);
            }
            bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 ? void 0 : bufferTimeSubscriber.unsubscribe();
            subscriber.complete();
            subscriber.unsubscribe();
          }, void 0, function() {
            return bufferRecords = null;
          });
          source2.subscribe(bufferTimeSubscriber);
        });
      }
      exports.bufferTime = bufferTime;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/bufferToggle.js
  var require_bufferToggle = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/bufferToggle.js"(exports) {
      "use strict";
      var __values3 = exports && exports.__values || function(o2) {
        var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
        if (m2)
          return m2.call(o2);
        if (o2 && typeof o2.length === "number")
          return {
            next: function() {
              if (o2 && i2 >= o2.length)
                o2 = void 0;
              return { value: o2 && o2[i2++], done: !o2 };
            }
          };
        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.bufferToggle = void 0;
      var Subscription_1 = require_Subscription();
      var lift_1 = require_lift();
      var innerFrom_1 = require_innerFrom();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var noop_1 = require_noop();
      var arrRemove_1 = require_arrRemove();
      function bufferToggle(openings, closingSelector) {
        return lift_1.operate(function(source2, subscriber) {
          var buffers = [];
          innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(openValue) {
            var buffer = [];
            buffers.push(buffer);
            var closingSubscription = new Subscription_1.Subscription();
            var emitBuffer = function() {
              arrRemove_1.arrRemove(buffers, buffer);
              subscriber.next(buffer);
              closingSubscription.unsubscribe();
            };
            closingSubscription.add(innerFrom_1.innerFrom(closingSelector(openValue)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, emitBuffer, noop_1.noop)));
          }, noop_1.noop));
          source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            var e_1, _a;
            try {
              for (var buffers_1 = __values3(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
                var buffer = buffers_1_1.value;
                buffer.push(value);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return))
                  _a.call(buffers_1);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
          }, function() {
            while (buffers.length > 0) {
              subscriber.next(buffers.shift());
            }
            subscriber.complete();
          }));
        });
      }
      exports.bufferToggle = bufferToggle;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/bufferWhen.js
  var require_bufferWhen = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/bufferWhen.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.bufferWhen = void 0;
      var lift_1 = require_lift();
      var noop_1 = require_noop();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var innerFrom_1 = require_innerFrom();
      function bufferWhen(closingSelector) {
        return lift_1.operate(function(source2, subscriber) {
          var buffer = null;
          var closingSubscriber = null;
          var openBuffer = function() {
            closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
            var b2 = buffer;
            buffer = [];
            b2 && subscriber.next(b2);
            innerFrom_1.innerFrom(closingSelector()).subscribe(closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openBuffer, noop_1.noop));
          };
          openBuffer();
          source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            return buffer === null || buffer === void 0 ? void 0 : buffer.push(value);
          }, function() {
            buffer && subscriber.next(buffer);
            subscriber.complete();
          }, void 0, function() {
            return buffer = closingSubscriber = null;
          }));
        });
      }
      exports.bufferWhen = bufferWhen;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/catchError.js
  var require_catchError = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/catchError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.catchError = void 0;
      var innerFrom_1 = require_innerFrom();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var lift_1 = require_lift();
      function catchError(selector) {
        return lift_1.operate(function(source2, subscriber) {
          var innerSub = null;
          var syncUnsub = false;
          var handledResult;
          innerSub = source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
            handledResult = innerFrom_1.innerFrom(selector(err, catchError(selector)(source2)));
            if (innerSub) {
              innerSub.unsubscribe();
              innerSub = null;
              handledResult.subscribe(subscriber);
            } else {
              syncUnsub = true;
            }
          }));
          if (syncUnsub) {
            innerSub.unsubscribe();
            innerSub = null;
            handledResult.subscribe(subscriber);
          }
        });
      }
      exports.catchError = catchError;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/scanInternals.js
  var require_scanInternals = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/scanInternals.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.scanInternals = void 0;
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function scanInternals(accumulator, seed3, hasSeed, emitOnNext, emitBeforeComplete) {
        return function(source2, subscriber) {
          var hasState = hasSeed;
          var state = seed3;
          var index = 0;
          source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            var i2 = index++;
            state = hasState ? accumulator(state, value, i2) : (hasState = true, value);
            emitOnNext && subscriber.next(state);
          }, emitBeforeComplete && function() {
            hasState && subscriber.next(state);
            subscriber.complete();
          }));
        };
      }
      exports.scanInternals = scanInternals;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/reduce.js
  var require_reduce = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/reduce.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.reduce = void 0;
      var scanInternals_1 = require_scanInternals();
      var lift_1 = require_lift();
      function reduce(accumulator, seed3) {
        return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed3, arguments.length >= 2, false, true));
      }
      exports.reduce = reduce;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/toArray.js
  var require_toArray = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/toArray.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toArray = void 0;
      var reduce_1 = require_reduce();
      var lift_1 = require_lift();
      var arrReducer = function(arr, value) {
        return arr.push(value), arr;
      };
      function toArray() {
        return lift_1.operate(function(source2, subscriber) {
          reduce_1.reduce(arrReducer, [])(source2).subscribe(subscriber);
        });
      }
      exports.toArray = toArray;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/joinAllInternals.js
  var require_joinAllInternals = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/joinAllInternals.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.joinAllInternals = void 0;
      var identity_1 = require_identity();
      var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
      var pipe_1 = require_pipe();
      var mergeMap_1 = require_mergeMap();
      var toArray_1 = require_toArray();
      function joinAllInternals(joinFn, project) {
        return pipe_1.pipe(toArray_1.toArray(), mergeMap_1.mergeMap(function(sources2) {
          return joinFn(sources2);
        }), project ? mapOneOrManyArgs_1.mapOneOrManyArgs(project) : identity_1.identity);
      }
      exports.joinAllInternals = joinAllInternals;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/combineLatestAll.js
  var require_combineLatestAll = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/combineLatestAll.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.combineLatestAll = void 0;
      var combineLatest_1 = require_combineLatest();
      var joinAllInternals_1 = require_joinAllInternals();
      function combineLatestAll(project) {
        return joinAllInternals_1.joinAllInternals(combineLatest_1.combineLatest, project);
      }
      exports.combineLatestAll = combineLatestAll;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/combineAll.js
  var require_combineAll = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/combineAll.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.combineAll = void 0;
      var combineLatestAll_1 = require_combineLatestAll();
      exports.combineAll = combineLatestAll_1.combineLatestAll;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/combineLatest.js
  var require_combineLatest2 = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/combineLatest.js"(exports) {
      "use strict";
      var __read3 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2)
          return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
            ar.push(r2.value);
        } catch (error) {
          e2 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray3 = exports && exports.__spreadArray || function(to, from3) {
        for (var i2 = 0, il = from3.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from3[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.combineLatest = void 0;
      var combineLatest_1 = require_combineLatest();
      var lift_1 = require_lift();
      var argsOrArgArray_1 = require_argsOrArgArray();
      var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
      var pipe_1 = require_pipe();
      var args_1 = require_args();
      function combineLatest3() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var resultSelector = args_1.popResultSelector(args);
        return resultSelector ? pipe_1.pipe(combineLatest3.apply(void 0, __spreadArray3([], __read3(args))), mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : lift_1.operate(function(source2, subscriber) {
          combineLatest_1.combineLatestInit(__spreadArray3([source2], __read3(argsOrArgArray_1.argsOrArgArray(args))))(subscriber);
        });
      }
      exports.combineLatest = combineLatest3;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/combineLatestWith.js
  var require_combineLatestWith = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/combineLatestWith.js"(exports) {
      "use strict";
      var __read3 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2)
          return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
            ar.push(r2.value);
        } catch (error) {
          e2 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray3 = exports && exports.__spreadArray || function(to, from3) {
        for (var i2 = 0, il = from3.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from3[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.combineLatestWith = void 0;
      var combineLatest_1 = require_combineLatest2();
      function combineLatestWith() {
        var otherSources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          otherSources[_i] = arguments[_i];
        }
        return combineLatest_1.combineLatest.apply(void 0, __spreadArray3([], __read3(otherSources)));
      }
      exports.combineLatestWith = combineLatestWith;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/concatMap.js
  var require_concatMap = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/concatMap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.concatMap = void 0;
      var mergeMap_1 = require_mergeMap();
      var isFunction_1 = require_isFunction();
      function concatMap(project, resultSelector) {
        return isFunction_1.isFunction(resultSelector) ? mergeMap_1.mergeMap(project, resultSelector, 1) : mergeMap_1.mergeMap(project, 1);
      }
      exports.concatMap = concatMap;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/concatMapTo.js
  var require_concatMapTo = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/concatMapTo.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.concatMapTo = void 0;
      var concatMap_1 = require_concatMap();
      var isFunction_1 = require_isFunction();
      function concatMapTo(innerObservable, resultSelector) {
        return isFunction_1.isFunction(resultSelector) ? concatMap_1.concatMap(function() {
          return innerObservable;
        }, resultSelector) : concatMap_1.concatMap(function() {
          return innerObservable;
        });
      }
      exports.concatMapTo = concatMapTo;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/concat.js
  var require_concat2 = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/concat.js"(exports) {
      "use strict";
      var __read3 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2)
          return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
            ar.push(r2.value);
        } catch (error) {
          e2 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray3 = exports && exports.__spreadArray || function(to, from3) {
        for (var i2 = 0, il = from3.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from3[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.concat = void 0;
      var lift_1 = require_lift();
      var concatAll_1 = require_concatAll();
      var args_1 = require_args();
      var from_1 = require_from();
      function concat() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var scheduler = args_1.popScheduler(args);
        return lift_1.operate(function(source2, subscriber) {
          concatAll_1.concatAll()(from_1.from(__spreadArray3([source2], __read3(args)), scheduler)).subscribe(subscriber);
        });
      }
      exports.concat = concat;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/concatWith.js
  var require_concatWith = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/concatWith.js"(exports) {
      "use strict";
      var __read3 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2)
          return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
            ar.push(r2.value);
        } catch (error) {
          e2 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray3 = exports && exports.__spreadArray || function(to, from3) {
        for (var i2 = 0, il = from3.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from3[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.concatWith = void 0;
      var concat_1 = require_concat2();
      function concatWith() {
        var otherSources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          otherSources[_i] = arguments[_i];
        }
        return concat_1.concat.apply(void 0, __spreadArray3([], __read3(otherSources)));
      }
      exports.concatWith = concatWith;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/fromSubscribable.js
  var require_fromSubscribable = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/observable/fromSubscribable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.fromSubscribable = void 0;
      var Observable_1 = require_Observable();
      function fromSubscribable(subscribable) {
        return new Observable_1.Observable(function(subscriber) {
          return subscribable.subscribe(subscriber);
        });
      }
      exports.fromSubscribable = fromSubscribable;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/connect.js
  var require_connect = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/connect.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.connect = void 0;
      var Subject_1 = require_Subject();
      var innerFrom_1 = require_innerFrom();
      var lift_1 = require_lift();
      var fromSubscribable_1 = require_fromSubscribable();
      var DEFAULT_CONFIG = {
        connector: function() {
          return new Subject_1.Subject();
        }
      };
      function connect(selector, config4) {
        if (config4 === void 0) {
          config4 = DEFAULT_CONFIG;
        }
        var connector = config4.connector;
        return lift_1.operate(function(source2, subscriber) {
          var subject = connector();
          innerFrom_1.innerFrom(selector(fromSubscribable_1.fromSubscribable(subject))).subscribe(subscriber);
          subscriber.add(source2.subscribe(subject));
        });
      }
      exports.connect = connect;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/count.js
  var require_count = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/count.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.count = void 0;
      var reduce_1 = require_reduce();
      function count2(predicate) {
        return reduce_1.reduce(function(total, value, i2) {
          return !predicate || predicate(value, i2) ? total + 1 : total;
        }, 0);
      }
      exports.count = count2;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/debounce.js
  var require_debounce = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/debounce.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.debounce = void 0;
      var lift_1 = require_lift();
      var noop_1 = require_noop();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var innerFrom_1 = require_innerFrom();
      function debounce(durationSelector) {
        return lift_1.operate(function(source2, subscriber) {
          var hasValue = false;
          var lastValue = null;
          var durationSubscriber = null;
          var emit = function() {
            durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
            durationSubscriber = null;
            if (hasValue) {
              hasValue = false;
              var value = lastValue;
              lastValue = null;
              subscriber.next(value);
            }
          };
          source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
            hasValue = true;
            lastValue = value;
            durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, emit, noop_1.noop);
            innerFrom_1.innerFrom(durationSelector(value)).subscribe(durationSubscriber);
          }, function() {
            emit();
            subscriber.complete();
          }, void 0, function() {
            lastValue = durationSubscriber = null;
          }));
        });
      }
      exports.debounce = debounce;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/debounceTime.js
  var require_debounceTime = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/debounceTime.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.debounceTime = void 0;
      var async_1 = require_async();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function debounceTime(dueTime, scheduler) {
        if (scheduler === void 0) {
          scheduler = async_1.asyncScheduler;
        }
        return lift_1.operate(function(source2, subscriber) {
          var activeTask = null;
          var lastValue = null;
          var lastTime = null;
          var emit = function() {
            if (activeTask) {
              activeTask.unsubscribe();
              activeTask = null;
              var value = lastValue;
              lastValue = null;
              subscriber.next(value);
            }
          };
          function emitWhenIdle() {
            var targetTime = lastTime + dueTime;
            var now2 = scheduler.now();
            if (now2 < targetTime) {
              activeTask = this.schedule(void 0, targetTime - now2);
              subscriber.add(activeTask);
              return;
            }
            emit();
          }
          source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            lastValue = value;
            lastTime = scheduler.now();
            if (!activeTask) {
              activeTask = scheduler.schedule(emitWhenIdle, dueTime);
              subscriber.add(activeTask);
            }
          }, function() {
            emit();
            subscriber.complete();
          }, void 0, function() {
            lastValue = activeTask = null;
          }));
        });
      }
      exports.debounceTime = debounceTime;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/defaultIfEmpty.js
  var require_defaultIfEmpty = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/defaultIfEmpty.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.defaultIfEmpty = void 0;
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function defaultIfEmpty2(defaultValue2) {
        return lift_1.operate(function(source2, subscriber) {
          var hasValue = false;
          source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            hasValue = true;
            subscriber.next(value);
          }, function() {
            if (!hasValue) {
              subscriber.next(defaultValue2);
            }
            subscriber.complete();
          }));
        });
      }
      exports.defaultIfEmpty = defaultIfEmpty2;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/take.js
  var require_take = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/take.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.take = void 0;
      var empty_1 = require_empty();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function take2(count2) {
        return count2 <= 0 ? function() {
          return empty_1.EMPTY;
        } : lift_1.operate(function(source2, subscriber) {
          var seen = 0;
          source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            if (++seen <= count2) {
              subscriber.next(value);
              if (count2 <= seen) {
                subscriber.complete();
              }
            }
          }));
        });
      }
      exports.take = take2;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/ignoreElements.js
  var require_ignoreElements = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/ignoreElements.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ignoreElements = void 0;
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var noop_1 = require_noop();
      function ignoreElements() {
        return lift_1.operate(function(source2, subscriber) {
          source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, noop_1.noop));
        });
      }
      exports.ignoreElements = ignoreElements;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/mapTo.js
  var require_mapTo = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/mapTo.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.mapTo = void 0;
      var map_1 = require_map();
      function mapTo2(value) {
        return map_1.map(function() {
          return value;
        });
      }
      exports.mapTo = mapTo2;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/delayWhen.js
  var require_delayWhen = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/delayWhen.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.delayWhen = void 0;
      var concat_1 = require_concat();
      var take_1 = require_take();
      var ignoreElements_1 = require_ignoreElements();
      var mapTo_1 = require_mapTo();
      var mergeMap_1 = require_mergeMap();
      var innerFrom_1 = require_innerFrom();
      function delayWhen(delayDurationSelector, subscriptionDelay) {
        if (subscriptionDelay) {
          return function(source2) {
            return concat_1.concat(subscriptionDelay.pipe(take_1.take(1), ignoreElements_1.ignoreElements()), source2.pipe(delayWhen(delayDurationSelector)));
          };
        }
        return mergeMap_1.mergeMap(function(value, index) {
          return innerFrom_1.innerFrom(delayDurationSelector(value, index)).pipe(take_1.take(1), mapTo_1.mapTo(value));
        });
      }
      exports.delayWhen = delayWhen;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/delay.js
  var require_delay = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/delay.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.delay = void 0;
      var async_1 = require_async();
      var delayWhen_1 = require_delayWhen();
      var timer_1 = require_timer();
      function delay(due, scheduler) {
        if (scheduler === void 0) {
          scheduler = async_1.asyncScheduler;
        }
        var duration = timer_1.timer(due, scheduler);
        return delayWhen_1.delayWhen(function() {
          return duration;
        });
      }
      exports.delay = delay;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/dematerialize.js
  var require_dematerialize = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/dematerialize.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.dematerialize = void 0;
      var Notification_1 = require_Notification();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function dematerialize() {
        return lift_1.operate(function(source2, subscriber) {
          source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(notification) {
            return Notification_1.observeNotification(notification, subscriber);
          }));
        });
      }
      exports.dematerialize = dematerialize;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/distinct.js
  var require_distinct = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/distinct.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.distinct = void 0;
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var noop_1 = require_noop();
      var innerFrom_1 = require_innerFrom();
      function distinct(keySelector, flushes) {
        return lift_1.operate(function(source2, subscriber) {
          var distinctKeys = /* @__PURE__ */ new Set();
          source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            var key = keySelector ? keySelector(value) : value;
            if (!distinctKeys.has(key)) {
              distinctKeys.add(key);
              subscriber.next(value);
            }
          }));
          flushes && innerFrom_1.innerFrom(flushes).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
            return distinctKeys.clear();
          }, noop_1.noop));
        });
      }
      exports.distinct = distinct;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/distinctUntilChanged.js
  var require_distinctUntilChanged = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/distinctUntilChanged.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.distinctUntilChanged = void 0;
      var identity_1 = require_identity();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function distinctUntilChanged(comparator, keySelector) {
        if (keySelector === void 0) {
          keySelector = identity_1.identity;
        }
        comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
        return lift_1.operate(function(source2, subscriber) {
          var previousKey;
          var first2 = true;
          source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            var currentKey = keySelector(value);
            if (first2 || !comparator(previousKey, currentKey)) {
              first2 = false;
              previousKey = currentKey;
              subscriber.next(value);
            }
          }));
        });
      }
      exports.distinctUntilChanged = distinctUntilChanged;
      function defaultCompare(a2, b2) {
        return a2 === b2;
      }
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/distinctUntilKeyChanged.js
  var require_distinctUntilKeyChanged = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/distinctUntilKeyChanged.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.distinctUntilKeyChanged = void 0;
      var distinctUntilChanged_1 = require_distinctUntilChanged();
      function distinctUntilKeyChanged(key, compare) {
        return distinctUntilChanged_1.distinctUntilChanged(function(x2, y2) {
          return compare ? compare(x2[key], y2[key]) : x2[key] === y2[key];
        });
      }
      exports.distinctUntilKeyChanged = distinctUntilKeyChanged;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/throwIfEmpty.js
  var require_throwIfEmpty = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/throwIfEmpty.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.throwIfEmpty = void 0;
      var EmptyError_1 = require_EmptyError();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function throwIfEmpty2(errorFactory) {
        if (errorFactory === void 0) {
          errorFactory = defaultErrorFactory2;
        }
        return lift_1.operate(function(source2, subscriber) {
          var hasValue = false;
          source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            hasValue = true;
            subscriber.next(value);
          }, function() {
            return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
          }));
        });
      }
      exports.throwIfEmpty = throwIfEmpty2;
      function defaultErrorFactory2() {
        return new EmptyError_1.EmptyError();
      }
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/elementAt.js
  var require_elementAt = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/elementAt.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.elementAt = void 0;
      var ArgumentOutOfRangeError_1 = require_ArgumentOutOfRangeError();
      var filter_1 = require_filter();
      var throwIfEmpty_1 = require_throwIfEmpty();
      var defaultIfEmpty_1 = require_defaultIfEmpty();
      var take_1 = require_take();
      function elementAt(index, defaultValue2) {
        if (index < 0) {
          throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
        }
        var hasDefaultValue = arguments.length >= 2;
        return function(source2) {
          return source2.pipe(filter_1.filter(function(v2, i2) {
            return i2 === index;
          }), take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue2) : throwIfEmpty_1.throwIfEmpty(function() {
            return new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
          }));
        };
      }
      exports.elementAt = elementAt;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/endWith.js
  var require_endWith = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/endWith.js"(exports) {
      "use strict";
      var __read3 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2)
          return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
            ar.push(r2.value);
        } catch (error) {
          e2 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray3 = exports && exports.__spreadArray || function(to, from3) {
        for (var i2 = 0, il = from3.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from3[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.endWith = void 0;
      var concat_1 = require_concat();
      var of_1 = require_of();
      function endWith() {
        var values = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          values[_i] = arguments[_i];
        }
        return function(source2) {
          return concat_1.concat(source2, of_1.of.apply(void 0, __spreadArray3([], __read3(values))));
        };
      }
      exports.endWith = endWith;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/every.js
  var require_every = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/every.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.every = void 0;
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function every(predicate, thisArg) {
        return lift_1.operate(function(source2, subscriber) {
          var index = 0;
          source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            if (!predicate.call(thisArg, value, index++, source2)) {
              subscriber.next(false);
              subscriber.complete();
            }
          }, function() {
            subscriber.next(true);
            subscriber.complete();
          }));
        });
      }
      exports.every = every;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/exhaustMap.js
  var require_exhaustMap = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/exhaustMap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.exhaustMap = void 0;
      var map_1 = require_map();
      var innerFrom_1 = require_innerFrom();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function exhaustMap(project, resultSelector) {
        if (resultSelector) {
          return function(source2) {
            return source2.pipe(exhaustMap(function(a2, i2) {
              return innerFrom_1.innerFrom(project(a2, i2)).pipe(map_1.map(function(b2, ii) {
                return resultSelector(a2, b2, i2, ii);
              }));
            }));
          };
        }
        return lift_1.operate(function(source2, subscriber) {
          var index = 0;
          var innerSub = null;
          var isComplete = false;
          source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(outerValue) {
            if (!innerSub) {
              innerSub = OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, function() {
                innerSub = null;
                isComplete && subscriber.complete();
              });
              innerFrom_1.innerFrom(project(outerValue, index++)).subscribe(innerSub);
            }
          }, function() {
            isComplete = true;
            !innerSub && subscriber.complete();
          }));
        });
      }
      exports.exhaustMap = exhaustMap;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/exhaustAll.js
  var require_exhaustAll = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/exhaustAll.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.exhaustAll = void 0;
      var exhaustMap_1 = require_exhaustMap();
      var identity_1 = require_identity();
      function exhaustAll() {
        return exhaustMap_1.exhaustMap(identity_1.identity);
      }
      exports.exhaustAll = exhaustAll;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/exhaust.js
  var require_exhaust = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/exhaust.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.exhaust = void 0;
      var exhaustAll_1 = require_exhaustAll();
      exports.exhaust = exhaustAll_1.exhaustAll;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/expand.js
  var require_expand = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/expand.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.expand = void 0;
      var lift_1 = require_lift();
      var mergeInternals_1 = require_mergeInternals();
      function expand(project, concurrent, scheduler) {
        if (concurrent === void 0) {
          concurrent = Infinity;
        }
        concurrent = (concurrent || 0) < 1 ? Infinity : concurrent;
        return lift_1.operate(function(source2, subscriber) {
          return mergeInternals_1.mergeInternals(source2, subscriber, project, concurrent, void 0, true, scheduler);
        });
      }
      exports.expand = expand;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/finalize.js
  var require_finalize = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/finalize.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.finalize = void 0;
      var lift_1 = require_lift();
      function finalize(callback) {
        return lift_1.operate(function(source2, subscriber) {
          try {
            source2.subscribe(subscriber);
          } finally {
            subscriber.add(callback);
          }
        });
      }
      exports.finalize = finalize;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/find.js
  var require_find = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/find.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createFind = exports.find = void 0;
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function find(predicate, thisArg) {
        return lift_1.operate(createFind(predicate, thisArg, "value"));
      }
      exports.find = find;
      function createFind(predicate, thisArg, emit) {
        var findIndex = emit === "index";
        return function(source2, subscriber) {
          var index = 0;
          source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            var i2 = index++;
            if (predicate.call(thisArg, value, i2, source2)) {
              subscriber.next(findIndex ? i2 : value);
              subscriber.complete();
            }
          }, function() {
            subscriber.next(findIndex ? -1 : void 0);
            subscriber.complete();
          }));
        };
      }
      exports.createFind = createFind;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/findIndex.js
  var require_findIndex = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/findIndex.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.findIndex = void 0;
      var lift_1 = require_lift();
      var find_1 = require_find();
      function findIndex(predicate, thisArg) {
        return lift_1.operate(find_1.createFind(predicate, thisArg, "index"));
      }
      exports.findIndex = findIndex;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/first.js
  var require_first = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/first.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.first = void 0;
      var EmptyError_1 = require_EmptyError();
      var filter_1 = require_filter();
      var take_1 = require_take();
      var defaultIfEmpty_1 = require_defaultIfEmpty();
      var throwIfEmpty_1 = require_throwIfEmpty();
      var identity_1 = require_identity();
      function first2(predicate, defaultValue2) {
        var hasDefaultValue = arguments.length >= 2;
        return function(source2) {
          return source2.pipe(predicate ? filter_1.filter(function(v2, i2) {
            return predicate(v2, i2, source2);
          }) : identity_1.identity, take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue2) : throwIfEmpty_1.throwIfEmpty(function() {
            return new EmptyError_1.EmptyError();
          }));
        };
      }
      exports.first = first2;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/groupBy.js
  var require_groupBy = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/groupBy.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.groupBy = void 0;
      var Observable_1 = require_Observable();
      var innerFrom_1 = require_innerFrom();
      var Subject_1 = require_Subject();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function groupBy(keySelector, elementOrOptions, duration, connector) {
        return lift_1.operate(function(source2, subscriber) {
          var element2;
          if (!elementOrOptions || typeof elementOrOptions === "function") {
            element2 = elementOrOptions;
          } else {
            duration = elementOrOptions.duration, element2 = elementOrOptions.element, connector = elementOrOptions.connector;
          }
          var groups = /* @__PURE__ */ new Map();
          var notify = function(cb) {
            groups.forEach(cb);
            cb(subscriber);
          };
          var handleError = function(err) {
            return notify(function(consumer) {
              return consumer.error(err);
            });
          };
          var activeGroups = 0;
          var teardownAttempted = false;
          var groupBySourceSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, function(value) {
            try {
              var key_1 = keySelector(value);
              var group_1 = groups.get(key_1);
              if (!group_1) {
                groups.set(key_1, group_1 = connector ? connector() : new Subject_1.Subject());
                var grouped = createGroupedObservable(key_1, group_1);
                subscriber.next(grouped);
                if (duration) {
                  var durationSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(group_1, function() {
                    group_1.complete();
                    durationSubscriber_1 === null || durationSubscriber_1 === void 0 ? void 0 : durationSubscriber_1.unsubscribe();
                  }, void 0, void 0, function() {
                    return groups.delete(key_1);
                  });
                  groupBySourceSubscriber.add(innerFrom_1.innerFrom(duration(grouped)).subscribe(durationSubscriber_1));
                }
              }
              group_1.next(element2 ? element2(value) : value);
            } catch (err) {
              handleError(err);
            }
          }, function() {
            return notify(function(consumer) {
              return consumer.complete();
            });
          }, handleError, function() {
            return groups.clear();
          }, function() {
            teardownAttempted = true;
            return activeGroups === 0;
          });
          source2.subscribe(groupBySourceSubscriber);
          function createGroupedObservable(key, groupSubject) {
            var result = new Observable_1.Observable(function(groupSubscriber) {
              activeGroups++;
              var innerSub = groupSubject.subscribe(groupSubscriber);
              return function() {
                innerSub.unsubscribe();
                --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();
              };
            });
            result.key = key;
            return result;
          }
        });
      }
      exports.groupBy = groupBy;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/isEmpty.js
  var require_isEmpty = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/isEmpty.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isEmpty = void 0;
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function isEmpty() {
        return lift_1.operate(function(source2, subscriber) {
          source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
            subscriber.next(false);
            subscriber.complete();
          }, function() {
            subscriber.next(true);
            subscriber.complete();
          }));
        });
      }
      exports.isEmpty = isEmpty;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/takeLast.js
  var require_takeLast = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/takeLast.js"(exports) {
      "use strict";
      var __values3 = exports && exports.__values || function(o2) {
        var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
        if (m2)
          return m2.call(o2);
        if (o2 && typeof o2.length === "number")
          return {
            next: function() {
              if (o2 && i2 >= o2.length)
                o2 = void 0;
              return { value: o2 && o2[i2++], done: !o2 };
            }
          };
        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.takeLast = void 0;
      var empty_1 = require_empty();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function takeLast(count2) {
        return count2 <= 0 ? function() {
          return empty_1.EMPTY;
        } : lift_1.operate(function(source2, subscriber) {
          var buffer = [];
          source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            buffer.push(value);
            count2 < buffer.length && buffer.shift();
          }, function() {
            var e_1, _a;
            try {
              for (var buffer_1 = __values3(buffer), buffer_1_1 = buffer_1.next(); !buffer_1_1.done; buffer_1_1 = buffer_1.next()) {
                var value = buffer_1_1.value;
                subscriber.next(value);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (buffer_1_1 && !buffer_1_1.done && (_a = buffer_1.return))
                  _a.call(buffer_1);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
            subscriber.complete();
          }, void 0, function() {
            buffer = null;
          }));
        });
      }
      exports.takeLast = takeLast;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/last.js
  var require_last = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/last.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.last = void 0;
      var EmptyError_1 = require_EmptyError();
      var filter_1 = require_filter();
      var takeLast_1 = require_takeLast();
      var throwIfEmpty_1 = require_throwIfEmpty();
      var defaultIfEmpty_1 = require_defaultIfEmpty();
      var identity_1 = require_identity();
      function last3(predicate, defaultValue2) {
        var hasDefaultValue = arguments.length >= 2;
        return function(source2) {
          return source2.pipe(predicate ? filter_1.filter(function(v2, i2) {
            return predicate(v2, i2, source2);
          }) : identity_1.identity, takeLast_1.takeLast(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue2) : throwIfEmpty_1.throwIfEmpty(function() {
            return new EmptyError_1.EmptyError();
          }));
        };
      }
      exports.last = last3;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/materialize.js
  var require_materialize = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/materialize.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.materialize = void 0;
      var Notification_1 = require_Notification();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function materialize() {
        return lift_1.operate(function(source2, subscriber) {
          source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            subscriber.next(Notification_1.Notification.createNext(value));
          }, function() {
            subscriber.next(Notification_1.Notification.createComplete());
            subscriber.complete();
          }, function(err) {
            subscriber.next(Notification_1.Notification.createError(err));
            subscriber.complete();
          }));
        });
      }
      exports.materialize = materialize;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/max.js
  var require_max = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/max.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.max = void 0;
      var reduce_1 = require_reduce();
      var isFunction_1 = require_isFunction();
      function max(comparer) {
        return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function(x2, y2) {
          return comparer(x2, y2) > 0 ? x2 : y2;
        } : function(x2, y2) {
          return x2 > y2 ? x2 : y2;
        });
      }
      exports.max = max;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/flatMap.js
  var require_flatMap = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/flatMap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.flatMap = void 0;
      var mergeMap_1 = require_mergeMap();
      exports.flatMap = mergeMap_1.mergeMap;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/mergeMapTo.js
  var require_mergeMapTo = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/mergeMapTo.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.mergeMapTo = void 0;
      var mergeMap_1 = require_mergeMap();
      var isFunction_1 = require_isFunction();
      function mergeMapTo(innerObservable, resultSelector, concurrent) {
        if (concurrent === void 0) {
          concurrent = Infinity;
        }
        if (isFunction_1.isFunction(resultSelector)) {
          return mergeMap_1.mergeMap(function() {
            return innerObservable;
          }, resultSelector, concurrent);
        }
        if (typeof resultSelector === "number") {
          concurrent = resultSelector;
        }
        return mergeMap_1.mergeMap(function() {
          return innerObservable;
        }, concurrent);
      }
      exports.mergeMapTo = mergeMapTo;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/mergeScan.js
  var require_mergeScan = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/mergeScan.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.mergeScan = void 0;
      var lift_1 = require_lift();
      var mergeInternals_1 = require_mergeInternals();
      function mergeScan(accumulator, seed3, concurrent) {
        if (concurrent === void 0) {
          concurrent = Infinity;
        }
        return lift_1.operate(function(source2, subscriber) {
          var state = seed3;
          return mergeInternals_1.mergeInternals(source2, subscriber, function(value, index) {
            return accumulator(state, value, index);
          }, concurrent, function(value) {
            state = value;
          }, false, void 0, function() {
            return state = null;
          });
        });
      }
      exports.mergeScan = mergeScan;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/merge.js
  var require_merge2 = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/merge.js"(exports) {
      "use strict";
      var __read3 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2)
          return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
            ar.push(r2.value);
        } catch (error) {
          e2 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray3 = exports && exports.__spreadArray || function(to, from3) {
        for (var i2 = 0, il = from3.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from3[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.merge = void 0;
      var lift_1 = require_lift();
      var argsOrArgArray_1 = require_argsOrArgArray();
      var mergeAll_1 = require_mergeAll();
      var args_1 = require_args();
      var from_1 = require_from();
      function merge3() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var scheduler = args_1.popScheduler(args);
        var concurrent = args_1.popNumber(args, Infinity);
        args = argsOrArgArray_1.argsOrArgArray(args);
        return lift_1.operate(function(source2, subscriber) {
          mergeAll_1.mergeAll(concurrent)(from_1.from(__spreadArray3([source2], __read3(args)), scheduler)).subscribe(subscriber);
        });
      }
      exports.merge = merge3;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/mergeWith.js
  var require_mergeWith = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/mergeWith.js"(exports) {
      "use strict";
      var __read3 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2)
          return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
            ar.push(r2.value);
        } catch (error) {
          e2 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray3 = exports && exports.__spreadArray || function(to, from3) {
        for (var i2 = 0, il = from3.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from3[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.mergeWith = void 0;
      var merge_1 = require_merge2();
      function mergeWith() {
        var otherSources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          otherSources[_i] = arguments[_i];
        }
        return merge_1.merge.apply(void 0, __spreadArray3([], __read3(otherSources)));
      }
      exports.mergeWith = mergeWith;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/min.js
  var require_min = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/min.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.min = void 0;
      var reduce_1 = require_reduce();
      var isFunction_1 = require_isFunction();
      function min(comparer) {
        return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function(x2, y2) {
          return comparer(x2, y2) < 0 ? x2 : y2;
        } : function(x2, y2) {
          return x2 < y2 ? x2 : y2;
        });
      }
      exports.min = min;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/multicast.js
  var require_multicast = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/multicast.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.multicast = void 0;
      var ConnectableObservable_1 = require_ConnectableObservable();
      var isFunction_1 = require_isFunction();
      var connect_1 = require_connect();
      function multicast(subjectOrSubjectFactory, selector) {
        var subjectFactory = isFunction_1.isFunction(subjectOrSubjectFactory) ? subjectOrSubjectFactory : function() {
          return subjectOrSubjectFactory;
        };
        if (isFunction_1.isFunction(selector)) {
          return connect_1.connect(selector, {
            connector: subjectFactory
          });
        }
        return function(source2) {
          return new ConnectableObservable_1.ConnectableObservable(source2, subjectFactory);
        };
      }
      exports.multicast = multicast;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/onErrorResumeNextWith.js
  var require_onErrorResumeNextWith = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/onErrorResumeNextWith.js"(exports) {
      "use strict";
      var __read3 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2)
          return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
            ar.push(r2.value);
        } catch (error) {
          e2 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray3 = exports && exports.__spreadArray || function(to, from3) {
        for (var i2 = 0, il = from3.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from3[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.onErrorResumeNext = exports.onErrorResumeNextWith = void 0;
      var argsOrArgArray_1 = require_argsOrArgArray();
      var onErrorResumeNext_1 = require_onErrorResumeNext();
      function onErrorResumeNextWith() {
        var sources2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          sources2[_i] = arguments[_i];
        }
        var nextSources = argsOrArgArray_1.argsOrArgArray(sources2);
        return function(source2) {
          return onErrorResumeNext_1.onErrorResumeNext.apply(void 0, __spreadArray3([source2], __read3(nextSources)));
        };
      }
      exports.onErrorResumeNextWith = onErrorResumeNextWith;
      exports.onErrorResumeNext = onErrorResumeNextWith;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/pairwise.js
  var require_pairwise = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/pairwise.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.pairwise = void 0;
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function pairwise() {
        return lift_1.operate(function(source2, subscriber) {
          var prev;
          var hasPrev = false;
          source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            var p2 = prev;
            prev = value;
            hasPrev && subscriber.next([p2, value]);
            hasPrev = true;
          }));
        });
      }
      exports.pairwise = pairwise;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/pluck.js
  var require_pluck = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/pluck.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.pluck = void 0;
      var map_1 = require_map();
      function pluck() {
        var properties = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          properties[_i] = arguments[_i];
        }
        var length = properties.length;
        if (length === 0) {
          throw new Error("list of properties cannot be empty.");
        }
        return map_1.map(function(x2) {
          var currentProp = x2;
          for (var i2 = 0; i2 < length; i2++) {
            var p2 = currentProp === null || currentProp === void 0 ? void 0 : currentProp[properties[i2]];
            if (typeof p2 !== "undefined") {
              currentProp = p2;
            } else {
              return void 0;
            }
          }
          return currentProp;
        });
      }
      exports.pluck = pluck;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/publish.js
  var require_publish = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/publish.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.publish = void 0;
      var Subject_1 = require_Subject();
      var multicast_1 = require_multicast();
      var connect_1 = require_connect();
      function publish(selector) {
        return selector ? function(source2) {
          return connect_1.connect(selector)(source2);
        } : function(source2) {
          return multicast_1.multicast(new Subject_1.Subject())(source2);
        };
      }
      exports.publish = publish;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/publishBehavior.js
  var require_publishBehavior = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/publishBehavior.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.publishBehavior = void 0;
      var BehaviorSubject_1 = require_BehaviorSubject();
      var ConnectableObservable_1 = require_ConnectableObservable();
      function publishBehavior(initialValue) {
        return function(source2) {
          var subject = new BehaviorSubject_1.BehaviorSubject(initialValue);
          return new ConnectableObservable_1.ConnectableObservable(source2, function() {
            return subject;
          });
        };
      }
      exports.publishBehavior = publishBehavior;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/publishLast.js
  var require_publishLast = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/publishLast.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.publishLast = void 0;
      var AsyncSubject_1 = require_AsyncSubject();
      var ConnectableObservable_1 = require_ConnectableObservable();
      function publishLast() {
        return function(source2) {
          var subject = new AsyncSubject_1.AsyncSubject();
          return new ConnectableObservable_1.ConnectableObservable(source2, function() {
            return subject;
          });
        };
      }
      exports.publishLast = publishLast;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/publishReplay.js
  var require_publishReplay = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/publishReplay.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.publishReplay = void 0;
      var ReplaySubject_1 = require_ReplaySubject();
      var multicast_1 = require_multicast();
      var isFunction_1 = require_isFunction();
      function publishReplay(bufferSize, windowTime, selectorOrScheduler, timestampProvider) {
        if (selectorOrScheduler && !isFunction_1.isFunction(selectorOrScheduler)) {
          timestampProvider = selectorOrScheduler;
        }
        var selector = isFunction_1.isFunction(selectorOrScheduler) ? selectorOrScheduler : void 0;
        return function(source2) {
          return multicast_1.multicast(new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, timestampProvider), selector)(source2);
        };
      }
      exports.publishReplay = publishReplay;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/raceWith.js
  var require_raceWith = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/raceWith.js"(exports) {
      "use strict";
      var __read3 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2)
          return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
            ar.push(r2.value);
        } catch (error) {
          e2 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray3 = exports && exports.__spreadArray || function(to, from3) {
        for (var i2 = 0, il = from3.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from3[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.raceWith = void 0;
      var race_1 = require_race();
      var lift_1 = require_lift();
      var identity_1 = require_identity();
      function raceWith() {
        var otherSources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          otherSources[_i] = arguments[_i];
        }
        return !otherSources.length ? identity_1.identity : lift_1.operate(function(source2, subscriber) {
          race_1.raceInit(__spreadArray3([source2], __read3(otherSources)))(subscriber);
        });
      }
      exports.raceWith = raceWith;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/repeat.js
  var require_repeat = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/repeat.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.repeat = void 0;
      var empty_1 = require_empty();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var innerFrom_1 = require_innerFrom();
      var timer_1 = require_timer();
      function repeat(countOrConfig) {
        var _a;
        var count2 = Infinity;
        var delay;
        if (countOrConfig != null) {
          if (typeof countOrConfig === "object") {
            _a = countOrConfig.count, count2 = _a === void 0 ? Infinity : _a, delay = countOrConfig.delay;
          } else {
            count2 = countOrConfig;
          }
        }
        return count2 <= 0 ? function() {
          return empty_1.EMPTY;
        } : lift_1.operate(function(source2, subscriber) {
          var soFar = 0;
          var sourceSub;
          var resubscribe = function() {
            sourceSub === null || sourceSub === void 0 ? void 0 : sourceSub.unsubscribe();
            sourceSub = null;
            if (delay != null) {
              var notifier = typeof delay === "number" ? timer_1.timer(delay) : innerFrom_1.innerFrom(delay(soFar));
              var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                notifierSubscriber_1.unsubscribe();
                subscribeToSource();
              });
              notifier.subscribe(notifierSubscriber_1);
            } else {
              subscribeToSource();
            }
          };
          var subscribeToSource = function() {
            var syncUnsub = false;
            sourceSub = source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, function() {
              if (++soFar < count2) {
                if (sourceSub) {
                  resubscribe();
                } else {
                  syncUnsub = true;
                }
              } else {
                subscriber.complete();
              }
            }));
            if (syncUnsub) {
              resubscribe();
            }
          };
          subscribeToSource();
        });
      }
      exports.repeat = repeat;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/repeatWhen.js
  var require_repeatWhen = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/repeatWhen.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.repeatWhen = void 0;
      var innerFrom_1 = require_innerFrom();
      var Subject_1 = require_Subject();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function repeatWhen(notifier) {
        return lift_1.operate(function(source2, subscriber) {
          var innerSub;
          var syncResub = false;
          var completions$;
          var isNotifierComplete = false;
          var isMainComplete = false;
          var checkComplete = function() {
            return isMainComplete && isNotifierComplete && (subscriber.complete(), true);
          };
          var getCompletionSubject = function() {
            if (!completions$) {
              completions$ = new Subject_1.Subject();
              innerFrom_1.innerFrom(notifier(completions$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                if (innerSub) {
                  subscribeForRepeatWhen();
                } else {
                  syncResub = true;
                }
              }, function() {
                isNotifierComplete = true;
                checkComplete();
              }));
            }
            return completions$;
          };
          var subscribeForRepeatWhen = function() {
            isMainComplete = false;
            innerSub = source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, function() {
              isMainComplete = true;
              !checkComplete() && getCompletionSubject().next();
            }));
            if (syncResub) {
              innerSub.unsubscribe();
              innerSub = null;
              syncResub = false;
              subscribeForRepeatWhen();
            }
          };
          subscribeForRepeatWhen();
        });
      }
      exports.repeatWhen = repeatWhen;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/retry.js
  var require_retry = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/retry.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.retry = void 0;
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var identity_1 = require_identity();
      var timer_1 = require_timer();
      var innerFrom_1 = require_innerFrom();
      function retry(configOrCount) {
        if (configOrCount === void 0) {
          configOrCount = Infinity;
        }
        var config4;
        if (configOrCount && typeof configOrCount === "object") {
          config4 = configOrCount;
        } else {
          config4 = {
            count: configOrCount
          };
        }
        var _a = config4.count, count2 = _a === void 0 ? Infinity : _a, delay = config4.delay, _b = config4.resetOnSuccess, resetOnSuccess = _b === void 0 ? false : _b;
        return count2 <= 0 ? identity_1.identity : lift_1.operate(function(source2, subscriber) {
          var soFar = 0;
          var innerSub;
          var subscribeForRetry = function() {
            var syncUnsub = false;
            innerSub = source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
              if (resetOnSuccess) {
                soFar = 0;
              }
              subscriber.next(value);
            }, void 0, function(err) {
              if (soFar++ < count2) {
                var resub_1 = function() {
                  if (innerSub) {
                    innerSub.unsubscribe();
                    innerSub = null;
                    subscribeForRetry();
                  } else {
                    syncUnsub = true;
                  }
                };
                if (delay != null) {
                  var notifier = typeof delay === "number" ? timer_1.timer(delay) : innerFrom_1.innerFrom(delay(err, soFar));
                  var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                    notifierSubscriber_1.unsubscribe();
                    resub_1();
                  }, function() {
                    subscriber.complete();
                  });
                  notifier.subscribe(notifierSubscriber_1);
                } else {
                  resub_1();
                }
              } else {
                subscriber.error(err);
              }
            }));
            if (syncUnsub) {
              innerSub.unsubscribe();
              innerSub = null;
              subscribeForRetry();
            }
          };
          subscribeForRetry();
        });
      }
      exports.retry = retry;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/retryWhen.js
  var require_retryWhen = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/retryWhen.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.retryWhen = void 0;
      var innerFrom_1 = require_innerFrom();
      var Subject_1 = require_Subject();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function retryWhen(notifier) {
        return lift_1.operate(function(source2, subscriber) {
          var innerSub;
          var syncResub = false;
          var errors$;
          var subscribeForRetryWhen = function() {
            innerSub = source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
              if (!errors$) {
                errors$ = new Subject_1.Subject();
                innerFrom_1.innerFrom(notifier(errors$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                  return innerSub ? subscribeForRetryWhen() : syncResub = true;
                }));
              }
              if (errors$) {
                errors$.next(err);
              }
            }));
            if (syncResub) {
              innerSub.unsubscribe();
              innerSub = null;
              syncResub = false;
              subscribeForRetryWhen();
            }
          };
          subscribeForRetryWhen();
        });
      }
      exports.retryWhen = retryWhen;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/sample.js
  var require_sample = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/sample.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sample = void 0;
      var innerFrom_1 = require_innerFrom();
      var lift_1 = require_lift();
      var noop_1 = require_noop();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function sample(notifier) {
        return lift_1.operate(function(source2, subscriber) {
          var hasValue = false;
          var lastValue = null;
          source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            hasValue = true;
            lastValue = value;
          }));
          innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
            if (hasValue) {
              hasValue = false;
              var value = lastValue;
              lastValue = null;
              subscriber.next(value);
            }
          }, noop_1.noop));
        });
      }
      exports.sample = sample;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/sampleTime.js
  var require_sampleTime = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/sampleTime.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sampleTime = void 0;
      var async_1 = require_async();
      var sample_1 = require_sample();
      var interval_1 = require_interval();
      function sampleTime(period, scheduler) {
        if (scheduler === void 0) {
          scheduler = async_1.asyncScheduler;
        }
        return sample_1.sample(interval_1.interval(period, scheduler));
      }
      exports.sampleTime = sampleTime;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/scan.js
  var require_scan = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/scan.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.scan = void 0;
      var lift_1 = require_lift();
      var scanInternals_1 = require_scanInternals();
      function scan(accumulator, seed3) {
        return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed3, arguments.length >= 2, true));
      }
      exports.scan = scan;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/sequenceEqual.js
  var require_sequenceEqual = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/sequenceEqual.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sequenceEqual = void 0;
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var innerFrom_1 = require_innerFrom();
      function sequenceEqual(compareTo, comparator) {
        if (comparator === void 0) {
          comparator = function(a2, b2) {
            return a2 === b2;
          };
        }
        return lift_1.operate(function(source2, subscriber) {
          var aState = createState();
          var bState = createState();
          var emit = function(isEqual) {
            subscriber.next(isEqual);
            subscriber.complete();
          };
          var createSubscriber = function(selfState, otherState) {
            var sequenceEqualSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(a2) {
              var buffer = otherState.buffer, complete = otherState.complete;
              if (buffer.length === 0) {
                complete ? emit(false) : selfState.buffer.push(a2);
              } else {
                !comparator(a2, buffer.shift()) && emit(false);
              }
            }, function() {
              selfState.complete = true;
              var complete = otherState.complete, buffer = otherState.buffer;
              complete && emit(buffer.length === 0);
              sequenceEqualSubscriber === null || sequenceEqualSubscriber === void 0 ? void 0 : sequenceEqualSubscriber.unsubscribe();
            });
            return sequenceEqualSubscriber;
          };
          source2.subscribe(createSubscriber(aState, bState));
          innerFrom_1.innerFrom(compareTo).subscribe(createSubscriber(bState, aState));
        });
      }
      exports.sequenceEqual = sequenceEqual;
      function createState() {
        return {
          buffer: [],
          complete: false
        };
      }
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/share.js
  var require_share = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/share.js"(exports) {
      "use strict";
      var __read3 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2)
          return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
            ar.push(r2.value);
        } catch (error) {
          e2 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray3 = exports && exports.__spreadArray || function(to, from3) {
        for (var i2 = 0, il = from3.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from3[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.share = void 0;
      var innerFrom_1 = require_innerFrom();
      var Subject_1 = require_Subject();
      var Subscriber_1 = require_Subscriber();
      var lift_1 = require_lift();
      function share2(options) {
        if (options === void 0) {
          options = {};
        }
        var _a = options.connector, connector = _a === void 0 ? function() {
          return new Subject_1.Subject();
        } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
        return function(wrapperSource) {
          var connection;
          var resetConnection;
          var subject;
          var refCount = 0;
          var hasCompleted = false;
          var hasErrored = false;
          var cancelReset = function() {
            resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
            resetConnection = void 0;
          };
          var reset = function() {
            cancelReset();
            connection = subject = void 0;
            hasCompleted = hasErrored = false;
          };
          var resetAndUnsubscribe = function() {
            var conn = connection;
            reset();
            conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
          };
          return lift_1.operate(function(source2, subscriber) {
            refCount++;
            if (!hasErrored && !hasCompleted) {
              cancelReset();
            }
            var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
            subscriber.add(function() {
              refCount--;
              if (refCount === 0 && !hasErrored && !hasCompleted) {
                resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
              }
            });
            dest.subscribe(subscriber);
            if (!connection && refCount > 0) {
              connection = new Subscriber_1.SafeSubscriber({
                next: function(value) {
                  return dest.next(value);
                },
                error: function(err) {
                  hasErrored = true;
                  cancelReset();
                  resetConnection = handleReset(reset, resetOnError, err);
                  dest.error(err);
                },
                complete: function() {
                  hasCompleted = true;
                  cancelReset();
                  resetConnection = handleReset(reset, resetOnComplete);
                  dest.complete();
                }
              });
              innerFrom_1.innerFrom(source2).subscribe(connection);
            }
          })(wrapperSource);
        };
      }
      exports.share = share2;
      function handleReset(reset, on) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
        }
        if (on === true) {
          reset();
          return;
        }
        if (on === false) {
          return;
        }
        var onSubscriber = new Subscriber_1.SafeSubscriber({
          next: function() {
            onSubscriber.unsubscribe();
            reset();
          }
        });
        return innerFrom_1.innerFrom(on.apply(void 0, __spreadArray3([], __read3(args)))).subscribe(onSubscriber);
      }
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/shareReplay.js
  var require_shareReplay = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/shareReplay.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.shareReplay = void 0;
      var ReplaySubject_1 = require_ReplaySubject();
      var share_1 = require_share();
      function shareReplay(configOrBufferSize, windowTime, scheduler) {
        var _a, _b, _c;
        var bufferSize;
        var refCount = false;
        if (configOrBufferSize && typeof configOrBufferSize === "object") {
          _a = configOrBufferSize.bufferSize, bufferSize = _a === void 0 ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler;
        } else {
          bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
        }
        return share_1.share({
          connector: function() {
            return new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);
          },
          resetOnError: true,
          resetOnComplete: false,
          resetOnRefCountZero: refCount
        });
      }
      exports.shareReplay = shareReplay;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/single.js
  var require_single = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/single.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.single = void 0;
      var EmptyError_1 = require_EmptyError();
      var SequenceError_1 = require_SequenceError();
      var NotFoundError_1 = require_NotFoundError();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function single(predicate) {
        return lift_1.operate(function(source2, subscriber) {
          var hasValue = false;
          var singleValue;
          var seenValue = false;
          var index = 0;
          source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            seenValue = true;
            if (!predicate || predicate(value, index++, source2)) {
              hasValue && subscriber.error(new SequenceError_1.SequenceError("Too many matching values"));
              hasValue = true;
              singleValue = value;
            }
          }, function() {
            if (hasValue) {
              subscriber.next(singleValue);
              subscriber.complete();
            } else {
              subscriber.error(seenValue ? new NotFoundError_1.NotFoundError("No matching values") : new EmptyError_1.EmptyError());
            }
          }));
        });
      }
      exports.single = single;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/skip.js
  var require_skip = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/skip.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.skip = void 0;
      var filter_1 = require_filter();
      function skip(count2) {
        return filter_1.filter(function(_, index) {
          return count2 <= index;
        });
      }
      exports.skip = skip;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/skipLast.js
  var require_skipLast = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/skipLast.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.skipLast = void 0;
      var identity_1 = require_identity();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function skipLast(skipCount) {
        return skipCount <= 0 ? identity_1.identity : lift_1.operate(function(source2, subscriber) {
          var ring = new Array(skipCount);
          var seen = 0;
          source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            var valueIndex = seen++;
            if (valueIndex < skipCount) {
              ring[valueIndex] = value;
            } else {
              var index = valueIndex % skipCount;
              var oldValue = ring[index];
              ring[index] = value;
              subscriber.next(oldValue);
            }
          }));
          return function() {
            ring = null;
          };
        });
      }
      exports.skipLast = skipLast;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/skipUntil.js
  var require_skipUntil = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/skipUntil.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.skipUntil = void 0;
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var innerFrom_1 = require_innerFrom();
      var noop_1 = require_noop();
      function skipUntil(notifier) {
        return lift_1.operate(function(source2, subscriber) {
          var taking = false;
          var skipSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
            skipSubscriber === null || skipSubscriber === void 0 ? void 0 : skipSubscriber.unsubscribe();
            taking = true;
          }, noop_1.noop);
          innerFrom_1.innerFrom(notifier).subscribe(skipSubscriber);
          source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            return taking && subscriber.next(value);
          }));
        });
      }
      exports.skipUntil = skipUntil;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/skipWhile.js
  var require_skipWhile = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/skipWhile.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.skipWhile = void 0;
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function skipWhile(predicate) {
        return lift_1.operate(function(source2, subscriber) {
          var taking = false;
          var index = 0;
          source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            return (taking || (taking = !predicate(value, index++))) && subscriber.next(value);
          }));
        });
      }
      exports.skipWhile = skipWhile;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/startWith.js
  var require_startWith = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/startWith.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.startWith = void 0;
      var concat_1 = require_concat();
      var args_1 = require_args();
      var lift_1 = require_lift();
      function startWith() {
        var values = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          values[_i] = arguments[_i];
        }
        var scheduler = args_1.popScheduler(values);
        return lift_1.operate(function(source2, subscriber) {
          (scheduler ? concat_1.concat(values, source2, scheduler) : concat_1.concat(values, source2)).subscribe(subscriber);
        });
      }
      exports.startWith = startWith;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/switchMap.js
  var require_switchMap = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/switchMap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.switchMap = void 0;
      var innerFrom_1 = require_innerFrom();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function switchMap(project, resultSelector) {
        return lift_1.operate(function(source2, subscriber) {
          var innerSubscriber = null;
          var index = 0;
          var isComplete = false;
          var checkComplete = function() {
            return isComplete && !innerSubscriber && subscriber.complete();
          };
          source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
            var innerIndex = 0;
            var outerIndex = index++;
            innerFrom_1.innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(innerValue) {
              return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
            }, function() {
              innerSubscriber = null;
              checkComplete();
            }));
          }, function() {
            isComplete = true;
            checkComplete();
          }));
        });
      }
      exports.switchMap = switchMap;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/switchAll.js
  var require_switchAll = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/switchAll.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.switchAll = void 0;
      var switchMap_1 = require_switchMap();
      var identity_1 = require_identity();
      function switchAll() {
        return switchMap_1.switchMap(identity_1.identity);
      }
      exports.switchAll = switchAll;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/switchMapTo.js
  var require_switchMapTo = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/switchMapTo.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.switchMapTo = void 0;
      var switchMap_1 = require_switchMap();
      var isFunction_1 = require_isFunction();
      function switchMapTo(innerObservable, resultSelector) {
        return isFunction_1.isFunction(resultSelector) ? switchMap_1.switchMap(function() {
          return innerObservable;
        }, resultSelector) : switchMap_1.switchMap(function() {
          return innerObservable;
        });
      }
      exports.switchMapTo = switchMapTo;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/switchScan.js
  var require_switchScan = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/switchScan.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.switchScan = void 0;
      var switchMap_1 = require_switchMap();
      var lift_1 = require_lift();
      function switchScan(accumulator, seed3) {
        return lift_1.operate(function(source2, subscriber) {
          var state = seed3;
          switchMap_1.switchMap(function(value, index) {
            return accumulator(state, value, index);
          }, function(_, innerValue) {
            return state = innerValue, innerValue;
          })(source2).subscribe(subscriber);
          return function() {
            state = null;
          };
        });
      }
      exports.switchScan = switchScan;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/takeUntil.js
  var require_takeUntil = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/takeUntil.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.takeUntil = void 0;
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var innerFrom_1 = require_innerFrom();
      var noop_1 = require_noop();
      function takeUntil(notifier) {
        return lift_1.operate(function(source2, subscriber) {
          innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
            return subscriber.complete();
          }, noop_1.noop));
          !subscriber.closed && source2.subscribe(subscriber);
        });
      }
      exports.takeUntil = takeUntil;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/takeWhile.js
  var require_takeWhile = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/takeWhile.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.takeWhile = void 0;
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function takeWhile(predicate, inclusive) {
        if (inclusive === void 0) {
          inclusive = false;
        }
        return lift_1.operate(function(source2, subscriber) {
          var index = 0;
          source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            var result = predicate(value, index++);
            (result || inclusive) && subscriber.next(value);
            !result && subscriber.complete();
          }));
        });
      }
      exports.takeWhile = takeWhile;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/tap.js
  var require_tap = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/tap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.tap = void 0;
      var isFunction_1 = require_isFunction();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var identity_1 = require_identity();
      function tap3(observerOrNext, error, complete) {
        var tapObserver = isFunction_1.isFunction(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
        return tapObserver ? lift_1.operate(function(source2, subscriber) {
          var _a;
          (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
          var isUnsub = true;
          source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            var _a2;
            (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value);
            subscriber.next(value);
          }, function() {
            var _a2;
            isUnsub = false;
            (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
            subscriber.complete();
          }, function(err) {
            var _a2;
            isUnsub = false;
            (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
            subscriber.error(err);
          }, function() {
            var _a2, _b;
            if (isUnsub) {
              (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
            }
            (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
          }));
        }) : identity_1.identity;
      }
      exports.tap = tap3;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/throttle.js
  var require_throttle = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/throttle.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.throttle = void 0;
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var innerFrom_1 = require_innerFrom();
      function throttle(durationSelector, config4) {
        return lift_1.operate(function(source2, subscriber) {
          var _a = config4 !== null && config4 !== void 0 ? config4 : {}, _b = _a.leading, leading = _b === void 0 ? true : _b, _c = _a.trailing, trailing = _c === void 0 ? false : _c;
          var hasValue = false;
          var sendValue = null;
          var throttled = null;
          var isComplete = false;
          var endThrottling = function() {
            throttled === null || throttled === void 0 ? void 0 : throttled.unsubscribe();
            throttled = null;
            if (trailing) {
              send();
              isComplete && subscriber.complete();
            }
          };
          var cleanupThrottling = function() {
            throttled = null;
            isComplete && subscriber.complete();
          };
          var startThrottle = function(value) {
            return throttled = innerFrom_1.innerFrom(durationSelector(value)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling));
          };
          var send = function() {
            if (hasValue) {
              hasValue = false;
              var value = sendValue;
              sendValue = null;
              subscriber.next(value);
              !isComplete && startThrottle(value);
            }
          };
          source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            hasValue = true;
            sendValue = value;
            !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
          }, function() {
            isComplete = true;
            !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
          }));
        });
      }
      exports.throttle = throttle;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/throttleTime.js
  var require_throttleTime = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/throttleTime.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.throttleTime = void 0;
      var async_1 = require_async();
      var throttle_1 = require_throttle();
      var timer_1 = require_timer();
      function throttleTime(duration, scheduler, config4) {
        if (scheduler === void 0) {
          scheduler = async_1.asyncScheduler;
        }
        var duration$ = timer_1.timer(duration, scheduler);
        return throttle_1.throttle(function() {
          return duration$;
        }, config4);
      }
      exports.throttleTime = throttleTime;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/timeInterval.js
  var require_timeInterval = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/timeInterval.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TimeInterval = exports.timeInterval = void 0;
      var async_1 = require_async();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function timeInterval(scheduler) {
        if (scheduler === void 0) {
          scheduler = async_1.asyncScheduler;
        }
        return lift_1.operate(function(source2, subscriber) {
          var last3 = scheduler.now();
          source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            var now2 = scheduler.now();
            var interval2 = now2 - last3;
            last3 = now2;
            subscriber.next(new TimeInterval(value, interval2));
          }));
        });
      }
      exports.timeInterval = timeInterval;
      var TimeInterval = function() {
        function TimeInterval2(value, interval2) {
          this.value = value;
          this.interval = interval2;
        }
        return TimeInterval2;
      }();
      exports.TimeInterval = TimeInterval;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/timeoutWith.js
  var require_timeoutWith = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/timeoutWith.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.timeoutWith = void 0;
      var async_1 = require_async();
      var isDate_1 = require_isDate();
      var timeout_1 = require_timeout();
      function timeoutWith(due, withObservable, scheduler) {
        var first2;
        var each;
        var _with;
        scheduler = scheduler !== null && scheduler !== void 0 ? scheduler : async_1.async;
        if (isDate_1.isValidDate(due)) {
          first2 = due;
        } else if (typeof due === "number") {
          each = due;
        }
        if (withObservable) {
          _with = function() {
            return withObservable;
          };
        } else {
          throw new TypeError("No observable provided to switch to");
        }
        if (first2 == null && each == null) {
          throw new TypeError("No timeout provided.");
        }
        return timeout_1.timeout({
          first: first2,
          each,
          scheduler,
          with: _with
        });
      }
      exports.timeoutWith = timeoutWith;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/timestamp.js
  var require_timestamp = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/timestamp.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.timestamp = void 0;
      var dateTimestampProvider_1 = require_dateTimestampProvider();
      var map_1 = require_map();
      function timestamp(timestampProvider) {
        if (timestampProvider === void 0) {
          timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
        }
        return map_1.map(function(value) {
          return { value, timestamp: timestampProvider.now() };
        });
      }
      exports.timestamp = timestamp;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/window.js
  var require_window = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/window.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.window = void 0;
      var Subject_1 = require_Subject();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var noop_1 = require_noop();
      var innerFrom_1 = require_innerFrom();
      function window2(windowBoundaries) {
        return lift_1.operate(function(source2, subscriber) {
          var windowSubject = new Subject_1.Subject();
          subscriber.next(windowSubject.asObservable());
          var errorHandler = function(err) {
            windowSubject.error(err);
            subscriber.error(err);
          };
          source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            return windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.next(value);
          }, function() {
            windowSubject.complete();
            subscriber.complete();
          }, errorHandler));
          innerFrom_1.innerFrom(windowBoundaries).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
            windowSubject.complete();
            subscriber.next(windowSubject = new Subject_1.Subject());
          }, noop_1.noop, errorHandler));
          return function() {
            windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.unsubscribe();
            windowSubject = null;
          };
        });
      }
      exports.window = window2;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/windowCount.js
  var require_windowCount = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/windowCount.js"(exports) {
      "use strict";
      var __values3 = exports && exports.__values || function(o2) {
        var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
        if (m2)
          return m2.call(o2);
        if (o2 && typeof o2.length === "number")
          return {
            next: function() {
              if (o2 && i2 >= o2.length)
                o2 = void 0;
              return { value: o2 && o2[i2++], done: !o2 };
            }
          };
        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.windowCount = void 0;
      var Subject_1 = require_Subject();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function windowCount(windowSize, startWindowEvery) {
        if (startWindowEvery === void 0) {
          startWindowEvery = 0;
        }
        var startEvery = startWindowEvery > 0 ? startWindowEvery : windowSize;
        return lift_1.operate(function(source2, subscriber) {
          var windows = [new Subject_1.Subject()];
          var starts = [];
          var count2 = 0;
          subscriber.next(windows[0].asObservable());
          source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            var e_1, _a;
            try {
              for (var windows_1 = __values3(windows), windows_1_1 = windows_1.next(); !windows_1_1.done; windows_1_1 = windows_1.next()) {
                var window_1 = windows_1_1.value;
                window_1.next(value);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (windows_1_1 && !windows_1_1.done && (_a = windows_1.return))
                  _a.call(windows_1);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
            var c2 = count2 - windowSize + 1;
            if (c2 >= 0 && c2 % startEvery === 0) {
              windows.shift().complete();
            }
            if (++count2 % startEvery === 0) {
              var window_2 = new Subject_1.Subject();
              windows.push(window_2);
              subscriber.next(window_2.asObservable());
            }
          }, function() {
            while (windows.length > 0) {
              windows.shift().complete();
            }
            subscriber.complete();
          }, function(err) {
            while (windows.length > 0) {
              windows.shift().error(err);
            }
            subscriber.error(err);
          }, function() {
            starts = null;
            windows = null;
          }));
        });
      }
      exports.windowCount = windowCount;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/windowTime.js
  var require_windowTime = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/windowTime.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.windowTime = void 0;
      var Subject_1 = require_Subject();
      var async_1 = require_async();
      var Subscription_1 = require_Subscription();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var arrRemove_1 = require_arrRemove();
      var args_1 = require_args();
      var executeSchedule_1 = require_executeSchedule();
      function windowTime(windowTimeSpan) {
        var _a, _b;
        var otherArgs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          otherArgs[_i - 1] = arguments[_i];
        }
        var scheduler = (_a = args_1.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_1.asyncScheduler;
        var windowCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
        var maxWindowSize = otherArgs[1] || Infinity;
        return lift_1.operate(function(source2, subscriber) {
          var windowRecords = [];
          var restartOnClose = false;
          var closeWindow = function(record) {
            var window2 = record.window, subs = record.subs;
            window2.complete();
            subs.unsubscribe();
            arrRemove_1.arrRemove(windowRecords, record);
            restartOnClose && startWindow();
          };
          var startWindow = function() {
            if (windowRecords) {
              var subs = new Subscription_1.Subscription();
              subscriber.add(subs);
              var window_1 = new Subject_1.Subject();
              var record_1 = {
                window: window_1,
                subs,
                seen: 0
              };
              windowRecords.push(record_1);
              subscriber.next(window_1.asObservable());
              executeSchedule_1.executeSchedule(subs, scheduler, function() {
                return closeWindow(record_1);
              }, windowTimeSpan);
            }
          };
          if (windowCreationInterval !== null && windowCreationInterval >= 0) {
            executeSchedule_1.executeSchedule(subscriber, scheduler, startWindow, windowCreationInterval, true);
          } else {
            restartOnClose = true;
          }
          startWindow();
          var loop2 = function(cb) {
            return windowRecords.slice().forEach(cb);
          };
          var terminate = function(cb) {
            loop2(function(_a2) {
              var window2 = _a2.window;
              return cb(window2);
            });
            cb(subscriber);
            subscriber.unsubscribe();
          };
          source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            loop2(function(record) {
              record.window.next(value);
              maxWindowSize <= ++record.seen && closeWindow(record);
            });
          }, function() {
            return terminate(function(consumer) {
              return consumer.complete();
            });
          }, function(err) {
            return terminate(function(consumer) {
              return consumer.error(err);
            });
          }));
          return function() {
            windowRecords = null;
          };
        });
      }
      exports.windowTime = windowTime;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/windowToggle.js
  var require_windowToggle = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/windowToggle.js"(exports) {
      "use strict";
      var __values3 = exports && exports.__values || function(o2) {
        var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
        if (m2)
          return m2.call(o2);
        if (o2 && typeof o2.length === "number")
          return {
            next: function() {
              if (o2 && i2 >= o2.length)
                o2 = void 0;
              return { value: o2 && o2[i2++], done: !o2 };
            }
          };
        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.windowToggle = void 0;
      var Subject_1 = require_Subject();
      var Subscription_1 = require_Subscription();
      var lift_1 = require_lift();
      var innerFrom_1 = require_innerFrom();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var noop_1 = require_noop();
      var arrRemove_1 = require_arrRemove();
      function windowToggle(openings, closingSelector) {
        return lift_1.operate(function(source2, subscriber) {
          var windows = [];
          var handleError = function(err) {
            while (0 < windows.length) {
              windows.shift().error(err);
            }
            subscriber.error(err);
          };
          innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(openValue) {
            var window2 = new Subject_1.Subject();
            windows.push(window2);
            var closingSubscription = new Subscription_1.Subscription();
            var closeWindow = function() {
              arrRemove_1.arrRemove(windows, window2);
              window2.complete();
              closingSubscription.unsubscribe();
            };
            var closingNotifier;
            try {
              closingNotifier = innerFrom_1.innerFrom(closingSelector(openValue));
            } catch (err) {
              handleError(err);
              return;
            }
            subscriber.next(window2.asObservable());
            closingSubscription.add(closingNotifier.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, closeWindow, noop_1.noop, handleError)));
          }, noop_1.noop));
          source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            var e_1, _a;
            var windowsCopy = windows.slice();
            try {
              for (var windowsCopy_1 = __values3(windowsCopy), windowsCopy_1_1 = windowsCopy_1.next(); !windowsCopy_1_1.done; windowsCopy_1_1 = windowsCopy_1.next()) {
                var window_1 = windowsCopy_1_1.value;
                window_1.next(value);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (windowsCopy_1_1 && !windowsCopy_1_1.done && (_a = windowsCopy_1.return))
                  _a.call(windowsCopy_1);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
          }, function() {
            while (0 < windows.length) {
              windows.shift().complete();
            }
            subscriber.complete();
          }, handleError, function() {
            while (0 < windows.length) {
              windows.shift().unsubscribe();
            }
          }));
        });
      }
      exports.windowToggle = windowToggle;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/windowWhen.js
  var require_windowWhen = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/windowWhen.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.windowWhen = void 0;
      var Subject_1 = require_Subject();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var innerFrom_1 = require_innerFrom();
      function windowWhen(closingSelector) {
        return lift_1.operate(function(source2, subscriber) {
          var window2;
          var closingSubscriber;
          var handleError = function(err) {
            window2.error(err);
            subscriber.error(err);
          };
          var openWindow = function() {
            closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
            window2 === null || window2 === void 0 ? void 0 : window2.complete();
            window2 = new Subject_1.Subject();
            subscriber.next(window2.asObservable());
            var closingNotifier;
            try {
              closingNotifier = innerFrom_1.innerFrom(closingSelector());
            } catch (err) {
              handleError(err);
              return;
            }
            closingNotifier.subscribe(closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openWindow, openWindow, handleError));
          };
          openWindow();
          source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            return window2.next(value);
          }, function() {
            window2.complete();
            subscriber.complete();
          }, handleError, function() {
            closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
            window2 = null;
          }));
        });
      }
      exports.windowWhen = windowWhen;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/withLatestFrom.js
  var require_withLatestFrom = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/withLatestFrom.js"(exports) {
      "use strict";
      var __read3 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2)
          return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
            ar.push(r2.value);
        } catch (error) {
          e2 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray3 = exports && exports.__spreadArray || function(to, from3) {
        for (var i2 = 0, il = from3.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from3[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.withLatestFrom = void 0;
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var innerFrom_1 = require_innerFrom();
      var identity_1 = require_identity();
      var noop_1 = require_noop();
      var args_1 = require_args();
      function withLatestFrom2() {
        var inputs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          inputs[_i] = arguments[_i];
        }
        var project = args_1.popResultSelector(inputs);
        return lift_1.operate(function(source2, subscriber) {
          var len = inputs.length;
          var otherValues = new Array(len);
          var hasValue = inputs.map(function() {
            return false;
          });
          var ready = false;
          var _loop_1 = function(i3) {
            innerFrom_1.innerFrom(inputs[i3]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
              otherValues[i3] = value;
              if (!ready && !hasValue[i3]) {
                hasValue[i3] = true;
                (ready = hasValue.every(identity_1.identity)) && (hasValue = null);
              }
            }, noop_1.noop));
          };
          for (var i2 = 0; i2 < len; i2++) {
            _loop_1(i2);
          }
          source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            if (ready) {
              var values = __spreadArray3([value], __read3(otherValues));
              subscriber.next(project ? project.apply(void 0, __spreadArray3([], __read3(values))) : values);
            }
          }));
        });
      }
      exports.withLatestFrom = withLatestFrom2;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/zipAll.js
  var require_zipAll = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/zipAll.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.zipAll = void 0;
      var zip_1 = require_zip();
      var joinAllInternals_1 = require_joinAllInternals();
      function zipAll(project) {
        return joinAllInternals_1.joinAllInternals(zip_1.zip, project);
      }
      exports.zipAll = zipAll;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/zip.js
  var require_zip2 = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/zip.js"(exports) {
      "use strict";
      var __read3 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2)
          return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
            ar.push(r2.value);
        } catch (error) {
          e2 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray3 = exports && exports.__spreadArray || function(to, from3) {
        for (var i2 = 0, il = from3.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from3[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.zip = void 0;
      var zip_1 = require_zip();
      var lift_1 = require_lift();
      function zip() {
        var sources2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          sources2[_i] = arguments[_i];
        }
        return lift_1.operate(function(source2, subscriber) {
          zip_1.zip.apply(void 0, __spreadArray3([source2], __read3(sources2))).subscribe(subscriber);
        });
      }
      exports.zip = zip;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/zipWith.js
  var require_zipWith = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/internal/operators/zipWith.js"(exports) {
      "use strict";
      var __read3 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2)
          return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
            ar.push(r2.value);
        } catch (error) {
          e2 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray3 = exports && exports.__spreadArray || function(to, from3) {
        for (var i2 = 0, il = from3.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from3[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.zipWith = void 0;
      var zip_1 = require_zip2();
      function zipWith() {
        var otherInputs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          otherInputs[_i] = arguments[_i];
        }
        return zip_1.zip.apply(void 0, __spreadArray3([], __read3(otherInputs)));
      }
      exports.zipWith = zipWith;
    }
  });

  // ../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/index.js
  var require_cjs = __commonJS({
    "../core/node_modules/blockwise/node_modules/rxjs/dist/cjs/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        Object.defineProperty(o2, k22, { enumerable: true, get: function() {
          return m2[k2];
        } });
      } : function(o2, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o2[k22] = m2[k2];
      });
      var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
        for (var p2 in m2)
          if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
            __createBinding(exports2, m2, p2);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.interval = exports.iif = exports.generate = exports.fromEventPattern = exports.fromEvent = exports.from = exports.forkJoin = exports.empty = exports.defer = exports.connectable = exports.concat = exports.combineLatest = exports.bindNodeCallback = exports.bindCallback = exports.UnsubscriptionError = exports.TimeoutError = exports.SequenceError = exports.ObjectUnsubscribedError = exports.NotFoundError = exports.EmptyError = exports.ArgumentOutOfRangeError = exports.firstValueFrom = exports.lastValueFrom = exports.isObservable = exports.identity = exports.noop = exports.pipe = exports.NotificationKind = exports.Notification = exports.Subscriber = exports.Subscription = exports.Scheduler = exports.VirtualAction = exports.VirtualTimeScheduler = exports.animationFrameScheduler = exports.animationFrame = exports.queueScheduler = exports.queue = exports.asyncScheduler = exports.async = exports.asapScheduler = exports.asap = exports.AsyncSubject = exports.ReplaySubject = exports.BehaviorSubject = exports.Subject = exports.animationFrames = exports.observable = exports.ConnectableObservable = exports.Observable = void 0;
      exports.filter = exports.expand = exports.exhaustMap = exports.exhaustAll = exports.exhaust = exports.every = exports.endWith = exports.elementAt = exports.distinctUntilKeyChanged = exports.distinctUntilChanged = exports.distinct = exports.dematerialize = exports.delayWhen = exports.delay = exports.defaultIfEmpty = exports.debounceTime = exports.debounce = exports.count = exports.connect = exports.concatWith = exports.concatMapTo = exports.concatMap = exports.concatAll = exports.combineLatestWith = exports.combineLatestAll = exports.combineAll = exports.catchError = exports.bufferWhen = exports.bufferToggle = exports.bufferTime = exports.bufferCount = exports.buffer = exports.auditTime = exports.audit = exports.config = exports.NEVER = exports.EMPTY = exports.scheduled = exports.zip = exports.using = exports.timer = exports.throwError = exports.range = exports.race = exports.partition = exports.pairs = exports.onErrorResumeNext = exports.of = exports.never = exports.merge = void 0;
      exports.switchMap = exports.switchAll = exports.subscribeOn = exports.startWith = exports.skipWhile = exports.skipUntil = exports.skipLast = exports.skip = exports.single = exports.shareReplay = exports.share = exports.sequenceEqual = exports.scan = exports.sampleTime = exports.sample = exports.refCount = exports.retryWhen = exports.retry = exports.repeatWhen = exports.repeat = exports.reduce = exports.raceWith = exports.publishReplay = exports.publishLast = exports.publishBehavior = exports.publish = exports.pluck = exports.pairwise = exports.onErrorResumeNextWith = exports.observeOn = exports.multicast = exports.min = exports.mergeWith = exports.mergeScan = exports.mergeMapTo = exports.mergeMap = exports.flatMap = exports.mergeAll = exports.max = exports.materialize = exports.mapTo = exports.map = exports.last = exports.isEmpty = exports.ignoreElements = exports.groupBy = exports.first = exports.findIndex = exports.find = exports.finalize = void 0;
      exports.zipWith = exports.zipAll = exports.withLatestFrom = exports.windowWhen = exports.windowToggle = exports.windowTime = exports.windowCount = exports.window = exports.toArray = exports.timestamp = exports.timeoutWith = exports.timeout = exports.timeInterval = exports.throwIfEmpty = exports.throttleTime = exports.throttle = exports.tap = exports.takeWhile = exports.takeUntil = exports.takeLast = exports.take = exports.switchScan = exports.switchMapTo = void 0;
      var Observable_1 = require_Observable();
      Object.defineProperty(exports, "Observable", { enumerable: true, get: function() {
        return Observable_1.Observable;
      } });
      var ConnectableObservable_1 = require_ConnectableObservable();
      Object.defineProperty(exports, "ConnectableObservable", { enumerable: true, get: function() {
        return ConnectableObservable_1.ConnectableObservable;
      } });
      var observable_1 = require_observable();
      Object.defineProperty(exports, "observable", { enumerable: true, get: function() {
        return observable_1.observable;
      } });
      var animationFrames_1 = require_animationFrames();
      Object.defineProperty(exports, "animationFrames", { enumerable: true, get: function() {
        return animationFrames_1.animationFrames;
      } });
      var Subject_1 = require_Subject();
      Object.defineProperty(exports, "Subject", { enumerable: true, get: function() {
        return Subject_1.Subject;
      } });
      var BehaviorSubject_1 = require_BehaviorSubject();
      Object.defineProperty(exports, "BehaviorSubject", { enumerable: true, get: function() {
        return BehaviorSubject_1.BehaviorSubject;
      } });
      var ReplaySubject_1 = require_ReplaySubject();
      Object.defineProperty(exports, "ReplaySubject", { enumerable: true, get: function() {
        return ReplaySubject_1.ReplaySubject;
      } });
      var AsyncSubject_1 = require_AsyncSubject();
      Object.defineProperty(exports, "AsyncSubject", { enumerable: true, get: function() {
        return AsyncSubject_1.AsyncSubject;
      } });
      var asap_1 = require_asap();
      Object.defineProperty(exports, "asap", { enumerable: true, get: function() {
        return asap_1.asap;
      } });
      Object.defineProperty(exports, "asapScheduler", { enumerable: true, get: function() {
        return asap_1.asapScheduler;
      } });
      var async_1 = require_async();
      Object.defineProperty(exports, "async", { enumerable: true, get: function() {
        return async_1.async;
      } });
      Object.defineProperty(exports, "asyncScheduler", { enumerable: true, get: function() {
        return async_1.asyncScheduler;
      } });
      var queue_1 = require_queue();
      Object.defineProperty(exports, "queue", { enumerable: true, get: function() {
        return queue_1.queue;
      } });
      Object.defineProperty(exports, "queueScheduler", { enumerable: true, get: function() {
        return queue_1.queueScheduler;
      } });
      var animationFrame_1 = require_animationFrame();
      Object.defineProperty(exports, "animationFrame", { enumerable: true, get: function() {
        return animationFrame_1.animationFrame;
      } });
      Object.defineProperty(exports, "animationFrameScheduler", { enumerable: true, get: function() {
        return animationFrame_1.animationFrameScheduler;
      } });
      var VirtualTimeScheduler_1 = require_VirtualTimeScheduler();
      Object.defineProperty(exports, "VirtualTimeScheduler", { enumerable: true, get: function() {
        return VirtualTimeScheduler_1.VirtualTimeScheduler;
      } });
      Object.defineProperty(exports, "VirtualAction", { enumerable: true, get: function() {
        return VirtualTimeScheduler_1.VirtualAction;
      } });
      var Scheduler_1 = require_Scheduler();
      Object.defineProperty(exports, "Scheduler", { enumerable: true, get: function() {
        return Scheduler_1.Scheduler;
      } });
      var Subscription_1 = require_Subscription();
      Object.defineProperty(exports, "Subscription", { enumerable: true, get: function() {
        return Subscription_1.Subscription;
      } });
      var Subscriber_1 = require_Subscriber();
      Object.defineProperty(exports, "Subscriber", { enumerable: true, get: function() {
        return Subscriber_1.Subscriber;
      } });
      var Notification_1 = require_Notification();
      Object.defineProperty(exports, "Notification", { enumerable: true, get: function() {
        return Notification_1.Notification;
      } });
      Object.defineProperty(exports, "NotificationKind", { enumerable: true, get: function() {
        return Notification_1.NotificationKind;
      } });
      var pipe_1 = require_pipe();
      Object.defineProperty(exports, "pipe", { enumerable: true, get: function() {
        return pipe_1.pipe;
      } });
      var noop_1 = require_noop();
      Object.defineProperty(exports, "noop", { enumerable: true, get: function() {
        return noop_1.noop;
      } });
      var identity_1 = require_identity();
      Object.defineProperty(exports, "identity", { enumerable: true, get: function() {
        return identity_1.identity;
      } });
      var isObservable_1 = require_isObservable();
      Object.defineProperty(exports, "isObservable", { enumerable: true, get: function() {
        return isObservable_1.isObservable;
      } });
      var lastValueFrom_1 = require_lastValueFrom();
      Object.defineProperty(exports, "lastValueFrom", { enumerable: true, get: function() {
        return lastValueFrom_1.lastValueFrom;
      } });
      var firstValueFrom_1 = require_firstValueFrom();
      Object.defineProperty(exports, "firstValueFrom", { enumerable: true, get: function() {
        return firstValueFrom_1.firstValueFrom;
      } });
      var ArgumentOutOfRangeError_1 = require_ArgumentOutOfRangeError();
      Object.defineProperty(exports, "ArgumentOutOfRangeError", { enumerable: true, get: function() {
        return ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
      } });
      var EmptyError_1 = require_EmptyError();
      Object.defineProperty(exports, "EmptyError", { enumerable: true, get: function() {
        return EmptyError_1.EmptyError;
      } });
      var NotFoundError_1 = require_NotFoundError();
      Object.defineProperty(exports, "NotFoundError", { enumerable: true, get: function() {
        return NotFoundError_1.NotFoundError;
      } });
      var ObjectUnsubscribedError_1 = require_ObjectUnsubscribedError();
      Object.defineProperty(exports, "ObjectUnsubscribedError", { enumerable: true, get: function() {
        return ObjectUnsubscribedError_1.ObjectUnsubscribedError;
      } });
      var SequenceError_1 = require_SequenceError();
      Object.defineProperty(exports, "SequenceError", { enumerable: true, get: function() {
        return SequenceError_1.SequenceError;
      } });
      var timeout_1 = require_timeout();
      Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function() {
        return timeout_1.TimeoutError;
      } });
      var UnsubscriptionError_1 = require_UnsubscriptionError();
      Object.defineProperty(exports, "UnsubscriptionError", { enumerable: true, get: function() {
        return UnsubscriptionError_1.UnsubscriptionError;
      } });
      var bindCallback_1 = require_bindCallback();
      Object.defineProperty(exports, "bindCallback", { enumerable: true, get: function() {
        return bindCallback_1.bindCallback;
      } });
      var bindNodeCallback_1 = require_bindNodeCallback();
      Object.defineProperty(exports, "bindNodeCallback", { enumerable: true, get: function() {
        return bindNodeCallback_1.bindNodeCallback;
      } });
      var combineLatest_1 = require_combineLatest();
      Object.defineProperty(exports, "combineLatest", { enumerable: true, get: function() {
        return combineLatest_1.combineLatest;
      } });
      var concat_1 = require_concat();
      Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
        return concat_1.concat;
      } });
      var connectable_1 = require_connectable();
      Object.defineProperty(exports, "connectable", { enumerable: true, get: function() {
        return connectable_1.connectable;
      } });
      var defer_1 = require_defer();
      Object.defineProperty(exports, "defer", { enumerable: true, get: function() {
        return defer_1.defer;
      } });
      var empty_1 = require_empty();
      Object.defineProperty(exports, "empty", { enumerable: true, get: function() {
        return empty_1.empty;
      } });
      var forkJoin_1 = require_forkJoin();
      Object.defineProperty(exports, "forkJoin", { enumerable: true, get: function() {
        return forkJoin_1.forkJoin;
      } });
      var from_1 = require_from();
      Object.defineProperty(exports, "from", { enumerable: true, get: function() {
        return from_1.from;
      } });
      var fromEvent_1 = require_fromEvent();
      Object.defineProperty(exports, "fromEvent", { enumerable: true, get: function() {
        return fromEvent_1.fromEvent;
      } });
      var fromEventPattern_1 = require_fromEventPattern();
      Object.defineProperty(exports, "fromEventPattern", { enumerable: true, get: function() {
        return fromEventPattern_1.fromEventPattern;
      } });
      var generate_1 = require_generate();
      Object.defineProperty(exports, "generate", { enumerable: true, get: function() {
        return generate_1.generate;
      } });
      var iif_1 = require_iif();
      Object.defineProperty(exports, "iif", { enumerable: true, get: function() {
        return iif_1.iif;
      } });
      var interval_1 = require_interval();
      Object.defineProperty(exports, "interval", { enumerable: true, get: function() {
        return interval_1.interval;
      } });
      var merge_1 = require_merge();
      Object.defineProperty(exports, "merge", { enumerable: true, get: function() {
        return merge_1.merge;
      } });
      var never_1 = require_never();
      Object.defineProperty(exports, "never", { enumerable: true, get: function() {
        return never_1.never;
      } });
      var of_1 = require_of();
      Object.defineProperty(exports, "of", { enumerable: true, get: function() {
        return of_1.of;
      } });
      var onErrorResumeNext_1 = require_onErrorResumeNext();
      Object.defineProperty(exports, "onErrorResumeNext", { enumerable: true, get: function() {
        return onErrorResumeNext_1.onErrorResumeNext;
      } });
      var pairs_1 = require_pairs();
      Object.defineProperty(exports, "pairs", { enumerable: true, get: function() {
        return pairs_1.pairs;
      } });
      var partition_1 = require_partition();
      Object.defineProperty(exports, "partition", { enumerable: true, get: function() {
        return partition_1.partition;
      } });
      var race_1 = require_race();
      Object.defineProperty(exports, "race", { enumerable: true, get: function() {
        return race_1.race;
      } });
      var range_1 = require_range();
      Object.defineProperty(exports, "range", { enumerable: true, get: function() {
        return range_1.range;
      } });
      var throwError_1 = require_throwError();
      Object.defineProperty(exports, "throwError", { enumerable: true, get: function() {
        return throwError_1.throwError;
      } });
      var timer_1 = require_timer();
      Object.defineProperty(exports, "timer", { enumerable: true, get: function() {
        return timer_1.timer;
      } });
      var using_1 = require_using();
      Object.defineProperty(exports, "using", { enumerable: true, get: function() {
        return using_1.using;
      } });
      var zip_1 = require_zip();
      Object.defineProperty(exports, "zip", { enumerable: true, get: function() {
        return zip_1.zip;
      } });
      var scheduled_1 = require_scheduled();
      Object.defineProperty(exports, "scheduled", { enumerable: true, get: function() {
        return scheduled_1.scheduled;
      } });
      var empty_2 = require_empty();
      Object.defineProperty(exports, "EMPTY", { enumerable: true, get: function() {
        return empty_2.EMPTY;
      } });
      var never_2 = require_never();
      Object.defineProperty(exports, "NEVER", { enumerable: true, get: function() {
        return never_2.NEVER;
      } });
      __exportStar(require_types(), exports);
      var config_1 = require_config();
      Object.defineProperty(exports, "config", { enumerable: true, get: function() {
        return config_1.config;
      } });
      var audit_1 = require_audit();
      Object.defineProperty(exports, "audit", { enumerable: true, get: function() {
        return audit_1.audit;
      } });
      var auditTime_1 = require_auditTime();
      Object.defineProperty(exports, "auditTime", { enumerable: true, get: function() {
        return auditTime_1.auditTime;
      } });
      var buffer_1 = require_buffer();
      Object.defineProperty(exports, "buffer", { enumerable: true, get: function() {
        return buffer_1.buffer;
      } });
      var bufferCount_1 = require_bufferCount();
      Object.defineProperty(exports, "bufferCount", { enumerable: true, get: function() {
        return bufferCount_1.bufferCount;
      } });
      var bufferTime_1 = require_bufferTime();
      Object.defineProperty(exports, "bufferTime", { enumerable: true, get: function() {
        return bufferTime_1.bufferTime;
      } });
      var bufferToggle_1 = require_bufferToggle();
      Object.defineProperty(exports, "bufferToggle", { enumerable: true, get: function() {
        return bufferToggle_1.bufferToggle;
      } });
      var bufferWhen_1 = require_bufferWhen();
      Object.defineProperty(exports, "bufferWhen", { enumerable: true, get: function() {
        return bufferWhen_1.bufferWhen;
      } });
      var catchError_1 = require_catchError();
      Object.defineProperty(exports, "catchError", { enumerable: true, get: function() {
        return catchError_1.catchError;
      } });
      var combineAll_1 = require_combineAll();
      Object.defineProperty(exports, "combineAll", { enumerable: true, get: function() {
        return combineAll_1.combineAll;
      } });
      var combineLatestAll_1 = require_combineLatestAll();
      Object.defineProperty(exports, "combineLatestAll", { enumerable: true, get: function() {
        return combineLatestAll_1.combineLatestAll;
      } });
      var combineLatestWith_1 = require_combineLatestWith();
      Object.defineProperty(exports, "combineLatestWith", { enumerable: true, get: function() {
        return combineLatestWith_1.combineLatestWith;
      } });
      var concatAll_1 = require_concatAll();
      Object.defineProperty(exports, "concatAll", { enumerable: true, get: function() {
        return concatAll_1.concatAll;
      } });
      var concatMap_1 = require_concatMap();
      Object.defineProperty(exports, "concatMap", { enumerable: true, get: function() {
        return concatMap_1.concatMap;
      } });
      var concatMapTo_1 = require_concatMapTo();
      Object.defineProperty(exports, "concatMapTo", { enumerable: true, get: function() {
        return concatMapTo_1.concatMapTo;
      } });
      var concatWith_1 = require_concatWith();
      Object.defineProperty(exports, "concatWith", { enumerable: true, get: function() {
        return concatWith_1.concatWith;
      } });
      var connect_1 = require_connect();
      Object.defineProperty(exports, "connect", { enumerable: true, get: function() {
        return connect_1.connect;
      } });
      var count_1 = require_count();
      Object.defineProperty(exports, "count", { enumerable: true, get: function() {
        return count_1.count;
      } });
      var debounce_1 = require_debounce();
      Object.defineProperty(exports, "debounce", { enumerable: true, get: function() {
        return debounce_1.debounce;
      } });
      var debounceTime_1 = require_debounceTime();
      Object.defineProperty(exports, "debounceTime", { enumerable: true, get: function() {
        return debounceTime_1.debounceTime;
      } });
      var defaultIfEmpty_1 = require_defaultIfEmpty();
      Object.defineProperty(exports, "defaultIfEmpty", { enumerable: true, get: function() {
        return defaultIfEmpty_1.defaultIfEmpty;
      } });
      var delay_1 = require_delay();
      Object.defineProperty(exports, "delay", { enumerable: true, get: function() {
        return delay_1.delay;
      } });
      var delayWhen_1 = require_delayWhen();
      Object.defineProperty(exports, "delayWhen", { enumerable: true, get: function() {
        return delayWhen_1.delayWhen;
      } });
      var dematerialize_1 = require_dematerialize();
      Object.defineProperty(exports, "dematerialize", { enumerable: true, get: function() {
        return dematerialize_1.dematerialize;
      } });
      var distinct_1 = require_distinct();
      Object.defineProperty(exports, "distinct", { enumerable: true, get: function() {
        return distinct_1.distinct;
      } });
      var distinctUntilChanged_1 = require_distinctUntilChanged();
      Object.defineProperty(exports, "distinctUntilChanged", { enumerable: true, get: function() {
        return distinctUntilChanged_1.distinctUntilChanged;
      } });
      var distinctUntilKeyChanged_1 = require_distinctUntilKeyChanged();
      Object.defineProperty(exports, "distinctUntilKeyChanged", { enumerable: true, get: function() {
        return distinctUntilKeyChanged_1.distinctUntilKeyChanged;
      } });
      var elementAt_1 = require_elementAt();
      Object.defineProperty(exports, "elementAt", { enumerable: true, get: function() {
        return elementAt_1.elementAt;
      } });
      var endWith_1 = require_endWith();
      Object.defineProperty(exports, "endWith", { enumerable: true, get: function() {
        return endWith_1.endWith;
      } });
      var every_1 = require_every();
      Object.defineProperty(exports, "every", { enumerable: true, get: function() {
        return every_1.every;
      } });
      var exhaust_1 = require_exhaust();
      Object.defineProperty(exports, "exhaust", { enumerable: true, get: function() {
        return exhaust_1.exhaust;
      } });
      var exhaustAll_1 = require_exhaustAll();
      Object.defineProperty(exports, "exhaustAll", { enumerable: true, get: function() {
        return exhaustAll_1.exhaustAll;
      } });
      var exhaustMap_1 = require_exhaustMap();
      Object.defineProperty(exports, "exhaustMap", { enumerable: true, get: function() {
        return exhaustMap_1.exhaustMap;
      } });
      var expand_1 = require_expand();
      Object.defineProperty(exports, "expand", { enumerable: true, get: function() {
        return expand_1.expand;
      } });
      var filter_1 = require_filter();
      Object.defineProperty(exports, "filter", { enumerable: true, get: function() {
        return filter_1.filter;
      } });
      var finalize_1 = require_finalize();
      Object.defineProperty(exports, "finalize", { enumerable: true, get: function() {
        return finalize_1.finalize;
      } });
      var find_1 = require_find();
      Object.defineProperty(exports, "find", { enumerable: true, get: function() {
        return find_1.find;
      } });
      var findIndex_1 = require_findIndex();
      Object.defineProperty(exports, "findIndex", { enumerable: true, get: function() {
        return findIndex_1.findIndex;
      } });
      var first_1 = require_first();
      Object.defineProperty(exports, "first", { enumerable: true, get: function() {
        return first_1.first;
      } });
      var groupBy_1 = require_groupBy();
      Object.defineProperty(exports, "groupBy", { enumerable: true, get: function() {
        return groupBy_1.groupBy;
      } });
      var ignoreElements_1 = require_ignoreElements();
      Object.defineProperty(exports, "ignoreElements", { enumerable: true, get: function() {
        return ignoreElements_1.ignoreElements;
      } });
      var isEmpty_1 = require_isEmpty();
      Object.defineProperty(exports, "isEmpty", { enumerable: true, get: function() {
        return isEmpty_1.isEmpty;
      } });
      var last_1 = require_last();
      Object.defineProperty(exports, "last", { enumerable: true, get: function() {
        return last_1.last;
      } });
      var map_1 = require_map();
      Object.defineProperty(exports, "map", { enumerable: true, get: function() {
        return map_1.map;
      } });
      var mapTo_1 = require_mapTo();
      Object.defineProperty(exports, "mapTo", { enumerable: true, get: function() {
        return mapTo_1.mapTo;
      } });
      var materialize_1 = require_materialize();
      Object.defineProperty(exports, "materialize", { enumerable: true, get: function() {
        return materialize_1.materialize;
      } });
      var max_1 = require_max();
      Object.defineProperty(exports, "max", { enumerable: true, get: function() {
        return max_1.max;
      } });
      var mergeAll_1 = require_mergeAll();
      Object.defineProperty(exports, "mergeAll", { enumerable: true, get: function() {
        return mergeAll_1.mergeAll;
      } });
      var flatMap_1 = require_flatMap();
      Object.defineProperty(exports, "flatMap", { enumerable: true, get: function() {
        return flatMap_1.flatMap;
      } });
      var mergeMap_1 = require_mergeMap();
      Object.defineProperty(exports, "mergeMap", { enumerable: true, get: function() {
        return mergeMap_1.mergeMap;
      } });
      var mergeMapTo_1 = require_mergeMapTo();
      Object.defineProperty(exports, "mergeMapTo", { enumerable: true, get: function() {
        return mergeMapTo_1.mergeMapTo;
      } });
      var mergeScan_1 = require_mergeScan();
      Object.defineProperty(exports, "mergeScan", { enumerable: true, get: function() {
        return mergeScan_1.mergeScan;
      } });
      var mergeWith_1 = require_mergeWith();
      Object.defineProperty(exports, "mergeWith", { enumerable: true, get: function() {
        return mergeWith_1.mergeWith;
      } });
      var min_1 = require_min();
      Object.defineProperty(exports, "min", { enumerable: true, get: function() {
        return min_1.min;
      } });
      var multicast_1 = require_multicast();
      Object.defineProperty(exports, "multicast", { enumerable: true, get: function() {
        return multicast_1.multicast;
      } });
      var observeOn_1 = require_observeOn();
      Object.defineProperty(exports, "observeOn", { enumerable: true, get: function() {
        return observeOn_1.observeOn;
      } });
      var onErrorResumeNextWith_1 = require_onErrorResumeNextWith();
      Object.defineProperty(exports, "onErrorResumeNextWith", { enumerable: true, get: function() {
        return onErrorResumeNextWith_1.onErrorResumeNextWith;
      } });
      var pairwise_1 = require_pairwise();
      Object.defineProperty(exports, "pairwise", { enumerable: true, get: function() {
        return pairwise_1.pairwise;
      } });
      var pluck_1 = require_pluck();
      Object.defineProperty(exports, "pluck", { enumerable: true, get: function() {
        return pluck_1.pluck;
      } });
      var publish_1 = require_publish();
      Object.defineProperty(exports, "publish", { enumerable: true, get: function() {
        return publish_1.publish;
      } });
      var publishBehavior_1 = require_publishBehavior();
      Object.defineProperty(exports, "publishBehavior", { enumerable: true, get: function() {
        return publishBehavior_1.publishBehavior;
      } });
      var publishLast_1 = require_publishLast();
      Object.defineProperty(exports, "publishLast", { enumerable: true, get: function() {
        return publishLast_1.publishLast;
      } });
      var publishReplay_1 = require_publishReplay();
      Object.defineProperty(exports, "publishReplay", { enumerable: true, get: function() {
        return publishReplay_1.publishReplay;
      } });
      var raceWith_1 = require_raceWith();
      Object.defineProperty(exports, "raceWith", { enumerable: true, get: function() {
        return raceWith_1.raceWith;
      } });
      var reduce_1 = require_reduce();
      Object.defineProperty(exports, "reduce", { enumerable: true, get: function() {
        return reduce_1.reduce;
      } });
      var repeat_1 = require_repeat();
      Object.defineProperty(exports, "repeat", { enumerable: true, get: function() {
        return repeat_1.repeat;
      } });
      var repeatWhen_1 = require_repeatWhen();
      Object.defineProperty(exports, "repeatWhen", { enumerable: true, get: function() {
        return repeatWhen_1.repeatWhen;
      } });
      var retry_1 = require_retry();
      Object.defineProperty(exports, "retry", { enumerable: true, get: function() {
        return retry_1.retry;
      } });
      var retryWhen_1 = require_retryWhen();
      Object.defineProperty(exports, "retryWhen", { enumerable: true, get: function() {
        return retryWhen_1.retryWhen;
      } });
      var refCount_1 = require_refCount();
      Object.defineProperty(exports, "refCount", { enumerable: true, get: function() {
        return refCount_1.refCount;
      } });
      var sample_1 = require_sample();
      Object.defineProperty(exports, "sample", { enumerable: true, get: function() {
        return sample_1.sample;
      } });
      var sampleTime_1 = require_sampleTime();
      Object.defineProperty(exports, "sampleTime", { enumerable: true, get: function() {
        return sampleTime_1.sampleTime;
      } });
      var scan_1 = require_scan();
      Object.defineProperty(exports, "scan", { enumerable: true, get: function() {
        return scan_1.scan;
      } });
      var sequenceEqual_1 = require_sequenceEqual();
      Object.defineProperty(exports, "sequenceEqual", { enumerable: true, get: function() {
        return sequenceEqual_1.sequenceEqual;
      } });
      var share_1 = require_share();
      Object.defineProperty(exports, "share", { enumerable: true, get: function() {
        return share_1.share;
      } });
      var shareReplay_1 = require_shareReplay();
      Object.defineProperty(exports, "shareReplay", { enumerable: true, get: function() {
        return shareReplay_1.shareReplay;
      } });
      var single_1 = require_single();
      Object.defineProperty(exports, "single", { enumerable: true, get: function() {
        return single_1.single;
      } });
      var skip_1 = require_skip();
      Object.defineProperty(exports, "skip", { enumerable: true, get: function() {
        return skip_1.skip;
      } });
      var skipLast_1 = require_skipLast();
      Object.defineProperty(exports, "skipLast", { enumerable: true, get: function() {
        return skipLast_1.skipLast;
      } });
      var skipUntil_1 = require_skipUntil();
      Object.defineProperty(exports, "skipUntil", { enumerable: true, get: function() {
        return skipUntil_1.skipUntil;
      } });
      var skipWhile_1 = require_skipWhile();
      Object.defineProperty(exports, "skipWhile", { enumerable: true, get: function() {
        return skipWhile_1.skipWhile;
      } });
      var startWith_1 = require_startWith();
      Object.defineProperty(exports, "startWith", { enumerable: true, get: function() {
        return startWith_1.startWith;
      } });
      var subscribeOn_1 = require_subscribeOn();
      Object.defineProperty(exports, "subscribeOn", { enumerable: true, get: function() {
        return subscribeOn_1.subscribeOn;
      } });
      var switchAll_1 = require_switchAll();
      Object.defineProperty(exports, "switchAll", { enumerable: true, get: function() {
        return switchAll_1.switchAll;
      } });
      var switchMap_1 = require_switchMap();
      Object.defineProperty(exports, "switchMap", { enumerable: true, get: function() {
        return switchMap_1.switchMap;
      } });
      var switchMapTo_1 = require_switchMapTo();
      Object.defineProperty(exports, "switchMapTo", { enumerable: true, get: function() {
        return switchMapTo_1.switchMapTo;
      } });
      var switchScan_1 = require_switchScan();
      Object.defineProperty(exports, "switchScan", { enumerable: true, get: function() {
        return switchScan_1.switchScan;
      } });
      var take_1 = require_take();
      Object.defineProperty(exports, "take", { enumerable: true, get: function() {
        return take_1.take;
      } });
      var takeLast_1 = require_takeLast();
      Object.defineProperty(exports, "takeLast", { enumerable: true, get: function() {
        return takeLast_1.takeLast;
      } });
      var takeUntil_1 = require_takeUntil();
      Object.defineProperty(exports, "takeUntil", { enumerable: true, get: function() {
        return takeUntil_1.takeUntil;
      } });
      var takeWhile_1 = require_takeWhile();
      Object.defineProperty(exports, "takeWhile", { enumerable: true, get: function() {
        return takeWhile_1.takeWhile;
      } });
      var tap_1 = require_tap();
      Object.defineProperty(exports, "tap", { enumerable: true, get: function() {
        return tap_1.tap;
      } });
      var throttle_1 = require_throttle();
      Object.defineProperty(exports, "throttle", { enumerable: true, get: function() {
        return throttle_1.throttle;
      } });
      var throttleTime_1 = require_throttleTime();
      Object.defineProperty(exports, "throttleTime", { enumerable: true, get: function() {
        return throttleTime_1.throttleTime;
      } });
      var throwIfEmpty_1 = require_throwIfEmpty();
      Object.defineProperty(exports, "throwIfEmpty", { enumerable: true, get: function() {
        return throwIfEmpty_1.throwIfEmpty;
      } });
      var timeInterval_1 = require_timeInterval();
      Object.defineProperty(exports, "timeInterval", { enumerable: true, get: function() {
        return timeInterval_1.timeInterval;
      } });
      var timeout_2 = require_timeout();
      Object.defineProperty(exports, "timeout", { enumerable: true, get: function() {
        return timeout_2.timeout;
      } });
      var timeoutWith_1 = require_timeoutWith();
      Object.defineProperty(exports, "timeoutWith", { enumerable: true, get: function() {
        return timeoutWith_1.timeoutWith;
      } });
      var timestamp_1 = require_timestamp();
      Object.defineProperty(exports, "timestamp", { enumerable: true, get: function() {
        return timestamp_1.timestamp;
      } });
      var toArray_1 = require_toArray();
      Object.defineProperty(exports, "toArray", { enumerable: true, get: function() {
        return toArray_1.toArray;
      } });
      var window_1 = require_window();
      Object.defineProperty(exports, "window", { enumerable: true, get: function() {
        return window_1.window;
      } });
      var windowCount_1 = require_windowCount();
      Object.defineProperty(exports, "windowCount", { enumerable: true, get: function() {
        return windowCount_1.windowCount;
      } });
      var windowTime_1 = require_windowTime();
      Object.defineProperty(exports, "windowTime", { enumerable: true, get: function() {
        return windowTime_1.windowTime;
      } });
      var windowToggle_1 = require_windowToggle();
      Object.defineProperty(exports, "windowToggle", { enumerable: true, get: function() {
        return windowToggle_1.windowToggle;
      } });
      var windowWhen_1 = require_windowWhen();
      Object.defineProperty(exports, "windowWhen", { enumerable: true, get: function() {
        return windowWhen_1.windowWhen;
      } });
      var withLatestFrom_1 = require_withLatestFrom();
      Object.defineProperty(exports, "withLatestFrom", { enumerable: true, get: function() {
        return withLatestFrom_1.withLatestFrom;
      } });
      var zipAll_1 = require_zipAll();
      Object.defineProperty(exports, "zipAll", { enumerable: true, get: function() {
        return zipAll_1.zipAll;
      } });
      var zipWith_1 = require_zipWith();
      Object.defineProperty(exports, "zipWith", { enumerable: true, get: function() {
        return zipWith_1.zipWith;
      } });
    }
  });

  // ../core/node_modules/blockwise/dist/map-positions-to-unitary-movements.js
  var require_map_positions_to_unitary_movements = __commonJS({
    "../core/node_modules/blockwise/dist/map-positions-to-unitary-movements.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.mapPositionsToUnitaryMovements = void 0;
      var blockwise_1 = require_dist();
      var rxjs_1 = require_cjs();
      function mapPositionsToUnitaryMovements() {
        return function(source2) {
          return source2.pipe((0, rxjs_1.pairwise)(), (0, rxjs_1.map)(function([previous, next]) {
            return Object.assign(Object.assign({}, blockwise_1.UNIT_BLOCK), { x: next.x - previous.x, y: next.y - previous.y });
          }), (0, rxjs_1.filter)(function(move) {
            switch (move.x) {
              case -1:
              case 1:
                return move.y === 0;
              case 0:
                switch (move.y) {
                  case -1:
                  case 1:
                    return true;
                }
            }
          }));
        };
      }
      exports.mapPositionsToUnitaryMovements = mapPositionsToUnitaryMovements;
    }
  });

  // ../core/node_modules/blockwise/dist/map-to-view.js
  var require_map_to_view = __commonJS({
    "../core/node_modules/blockwise/dist/map-to-view.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.mapToView = void 0;
      function mapToView4(subject, view, targetView) {
        const hRatio = targetView.w / view.w;
        const vRatio = targetView.h / view.h;
        const x2 = (subject.x - view.x) * hRatio + targetView.x;
        const y2 = (subject.y - view.y) * vRatio + targetView.y;
        const w2 = subject.w * hRatio;
        const h2 = subject.h * vRatio;
        return { x: x2, y: y2, w: w2, h: h2 };
      }
      exports.mapToView = mapToView4;
    }
  });

  // ../core/node_modules/blockwise/dist/origin-position.js
  var require_origin_position = __commonJS({
    "../core/node_modules/blockwise/dist/origin-position.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ORIGIN_POSITION = void 0;
      exports.ORIGIN_POSITION = { x: 0, y: 0, w: 0, h: 0 };
      Object.freeze(exports.ORIGIN_POSITION);
    }
  });

  // ../core/node_modules/blockwise/dist/unit-block.js
  var require_unit_block = __commonJS({
    "../core/node_modules/blockwise/dist/unit-block.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.UNIT_BLOCK = void 0;
      exports.UNIT_BLOCK = { x: 0, y: 0, w: 1, h: 1 };
      Object.freeze(exports.UNIT_BLOCK);
    }
  });

  // ../core/node_modules/blockwise/dist/index.js
  var require_dist = __commonJS({
    "../core/node_modules/blockwise/dist/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.UNIT_BLOCK = exports.ORIGIN_POSITION = exports.mapToView = exports.mapPositionsToUnitaryMovements = exports.isBlockPositionEqual = exports.isBlockNotEqual = exports.isBlockIncluding = exports.isBlockEqual = exports.isBlockColliding = exports.findClosestBlock = exports.CENTERED_UNIT_BLOCK = exports.calculateBlockDistance = exports.calculateBlockCenter = exports.BlockFactory = void 0;
      var block_factory_1 = require_block_factory();
      Object.defineProperty(exports, "BlockFactory", { enumerable: true, get: function() {
        return block_factory_1.BlockFactory;
      } });
      var calculate_block_center_1 = require_calculate_block_center();
      Object.defineProperty(exports, "calculateBlockCenter", { enumerable: true, get: function() {
        return calculate_block_center_1.calculateBlockCenter;
      } });
      var calculate_block_distance_1 = require_calculate_block_distance();
      Object.defineProperty(exports, "calculateBlockDistance", { enumerable: true, get: function() {
        return calculate_block_distance_1.calculateBlockDistance;
      } });
      var centered_unit_block_1 = require_centered_unit_block();
      Object.defineProperty(exports, "CENTERED_UNIT_BLOCK", { enumerable: true, get: function() {
        return centered_unit_block_1.CENTERED_UNIT_BLOCK;
      } });
      var find_closest_block_1 = require_find_closest_block();
      Object.defineProperty(exports, "findClosestBlock", { enumerable: true, get: function() {
        return find_closest_block_1.findClosestBlock;
      } });
      var is_block_colliding_1 = require_is_block_colliding();
      Object.defineProperty(exports, "isBlockColliding", { enumerable: true, get: function() {
        return is_block_colliding_1.isBlockColliding;
      } });
      var is_block_equal_1 = require_is_block_equal();
      Object.defineProperty(exports, "isBlockEqual", { enumerable: true, get: function() {
        return is_block_equal_1.isBlockEqual;
      } });
      var is_block_including_1 = require_is_block_including();
      Object.defineProperty(exports, "isBlockIncluding", { enumerable: true, get: function() {
        return is_block_including_1.isBlockIncluding;
      } });
      var is_block_not_equal_1 = require_is_block_not_equal();
      Object.defineProperty(exports, "isBlockNotEqual", { enumerable: true, get: function() {
        return is_block_not_equal_1.isBlockNotEqual;
      } });
      var is_block_position_equal_1 = require_is_block_position_equal();
      Object.defineProperty(exports, "isBlockPositionEqual", { enumerable: true, get: function() {
        return is_block_position_equal_1.isBlockPositionEqual;
      } });
      var map_positions_to_unitary_movements_1 = require_map_positions_to_unitary_movements();
      Object.defineProperty(exports, "mapPositionsToUnitaryMovements", { enumerable: true, get: function() {
        return map_positions_to_unitary_movements_1.mapPositionsToUnitaryMovements;
      } });
      var map_to_view_1 = require_map_to_view();
      Object.defineProperty(exports, "mapToView", { enumerable: true, get: function() {
        return map_to_view_1.mapToView;
      } });
      var origin_position_1 = require_origin_position();
      Object.defineProperty(exports, "ORIGIN_POSITION", { enumerable: true, get: function() {
        return origin_position_1.ORIGIN_POSITION;
      } });
      var unit_block_1 = require_unit_block();
      Object.defineProperty(exports, "UNIT_BLOCK", { enumerable: true, get: function() {
        return unit_block_1.UNIT_BLOCK;
      } });
    }
  });

  // ../core/node_modules/daily-prng/node_modules/color-name/index.js
  var require_color_name = __commonJS({
    "../core/node_modules/daily-prng/node_modules/color-name/index.js"(exports, module) {
      "use strict";
      module.exports = {
        "aliceblue": [240, 248, 255],
        "antiquewhite": [250, 235, 215],
        "aqua": [0, 255, 255],
        "aquamarine": [127, 255, 212],
        "azure": [240, 255, 255],
        "beige": [245, 245, 220],
        "bisque": [255, 228, 196],
        "black": [0, 0, 0],
        "blanchedalmond": [255, 235, 205],
        "blue": [0, 0, 255],
        "blueviolet": [138, 43, 226],
        "brown": [165, 42, 42],
        "burlywood": [222, 184, 135],
        "cadetblue": [95, 158, 160],
        "chartreuse": [127, 255, 0],
        "chocolate": [210, 105, 30],
        "coral": [255, 127, 80],
        "cornflowerblue": [100, 149, 237],
        "cornsilk": [255, 248, 220],
        "crimson": [220, 20, 60],
        "cyan": [0, 255, 255],
        "darkblue": [0, 0, 139],
        "darkcyan": [0, 139, 139],
        "darkgoldenrod": [184, 134, 11],
        "darkgray": [169, 169, 169],
        "darkgreen": [0, 100, 0],
        "darkgrey": [169, 169, 169],
        "darkkhaki": [189, 183, 107],
        "darkmagenta": [139, 0, 139],
        "darkolivegreen": [85, 107, 47],
        "darkorange": [255, 140, 0],
        "darkorchid": [153, 50, 204],
        "darkred": [139, 0, 0],
        "darksalmon": [233, 150, 122],
        "darkseagreen": [143, 188, 143],
        "darkslateblue": [72, 61, 139],
        "darkslategray": [47, 79, 79],
        "darkslategrey": [47, 79, 79],
        "darkturquoise": [0, 206, 209],
        "darkviolet": [148, 0, 211],
        "deeppink": [255, 20, 147],
        "deepskyblue": [0, 191, 255],
        "dimgray": [105, 105, 105],
        "dimgrey": [105, 105, 105],
        "dodgerblue": [30, 144, 255],
        "firebrick": [178, 34, 34],
        "floralwhite": [255, 250, 240],
        "forestgreen": [34, 139, 34],
        "fuchsia": [255, 0, 255],
        "gainsboro": [220, 220, 220],
        "ghostwhite": [248, 248, 255],
        "gold": [255, 215, 0],
        "goldenrod": [218, 165, 32],
        "gray": [128, 128, 128],
        "green": [0, 128, 0],
        "greenyellow": [173, 255, 47],
        "grey": [128, 128, 128],
        "honeydew": [240, 255, 240],
        "hotpink": [255, 105, 180],
        "indianred": [205, 92, 92],
        "indigo": [75, 0, 130],
        "ivory": [255, 255, 240],
        "khaki": [240, 230, 140],
        "lavender": [230, 230, 250],
        "lavenderblush": [255, 240, 245],
        "lawngreen": [124, 252, 0],
        "lemonchiffon": [255, 250, 205],
        "lightblue": [173, 216, 230],
        "lightcoral": [240, 128, 128],
        "lightcyan": [224, 255, 255],
        "lightgoldenrodyellow": [250, 250, 210],
        "lightgray": [211, 211, 211],
        "lightgreen": [144, 238, 144],
        "lightgrey": [211, 211, 211],
        "lightpink": [255, 182, 193],
        "lightsalmon": [255, 160, 122],
        "lightseagreen": [32, 178, 170],
        "lightskyblue": [135, 206, 250],
        "lightslategray": [119, 136, 153],
        "lightslategrey": [119, 136, 153],
        "lightsteelblue": [176, 196, 222],
        "lightyellow": [255, 255, 224],
        "lime": [0, 255, 0],
        "limegreen": [50, 205, 50],
        "linen": [250, 240, 230],
        "magenta": [255, 0, 255],
        "maroon": [128, 0, 0],
        "mediumaquamarine": [102, 205, 170],
        "mediumblue": [0, 0, 205],
        "mediumorchid": [186, 85, 211],
        "mediumpurple": [147, 112, 219],
        "mediumseagreen": [60, 179, 113],
        "mediumslateblue": [123, 104, 238],
        "mediumspringgreen": [0, 250, 154],
        "mediumturquoise": [72, 209, 204],
        "mediumvioletred": [199, 21, 133],
        "midnightblue": [25, 25, 112],
        "mintcream": [245, 255, 250],
        "mistyrose": [255, 228, 225],
        "moccasin": [255, 228, 181],
        "navajowhite": [255, 222, 173],
        "navy": [0, 0, 128],
        "oldlace": [253, 245, 230],
        "olive": [128, 128, 0],
        "olivedrab": [107, 142, 35],
        "orange": [255, 165, 0],
        "orangered": [255, 69, 0],
        "orchid": [218, 112, 214],
        "palegoldenrod": [238, 232, 170],
        "palegreen": [152, 251, 152],
        "paleturquoise": [175, 238, 238],
        "palevioletred": [219, 112, 147],
        "papayawhip": [255, 239, 213],
        "peachpuff": [255, 218, 185],
        "peru": [205, 133, 63],
        "pink": [255, 192, 203],
        "plum": [221, 160, 221],
        "powderblue": [176, 224, 230],
        "purple": [128, 0, 128],
        "rebeccapurple": [102, 51, 153],
        "red": [255, 0, 0],
        "rosybrown": [188, 143, 143],
        "royalblue": [65, 105, 225],
        "saddlebrown": [139, 69, 19],
        "salmon": [250, 128, 114],
        "sandybrown": [244, 164, 96],
        "seagreen": [46, 139, 87],
        "seashell": [255, 245, 238],
        "sienna": [160, 82, 45],
        "silver": [192, 192, 192],
        "skyblue": [135, 206, 235],
        "slateblue": [106, 90, 205],
        "slategray": [112, 128, 144],
        "slategrey": [112, 128, 144],
        "snow": [255, 250, 250],
        "springgreen": [0, 255, 127],
        "steelblue": [70, 130, 180],
        "tan": [210, 180, 140],
        "teal": [0, 128, 128],
        "thistle": [216, 191, 216],
        "tomato": [255, 99, 71],
        "turquoise": [64, 224, 208],
        "violet": [238, 130, 238],
        "wheat": [245, 222, 179],
        "white": [255, 255, 255],
        "whitesmoke": [245, 245, 245],
        "yellow": [255, 255, 0],
        "yellowgreen": [154, 205, 50]
      };
    }
  });

  // ../core/node_modules/daily-prng/node_modules/is-arrayish/index.js
  var require_is_arrayish = __commonJS({
    "../core/node_modules/daily-prng/node_modules/is-arrayish/index.js"(exports, module) {
      module.exports = function isArrayish(obj) {
        if (!obj || typeof obj === "string") {
          return false;
        }
        return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
      };
    }
  });

  // ../core/node_modules/daily-prng/node_modules/simple-swizzle/index.js
  var require_simple_swizzle = __commonJS({
    "../core/node_modules/daily-prng/node_modules/simple-swizzle/index.js"(exports, module) {
      "use strict";
      var isArrayish = require_is_arrayish();
      var concat = Array.prototype.concat;
      var slice = Array.prototype.slice;
      var swizzle = module.exports = function swizzle2(args) {
        var results = [];
        for (var i2 = 0, len = args.length; i2 < len; i2++) {
          var arg = args[i2];
          if (isArrayish(arg)) {
            results = concat.call(results, slice.call(arg));
          } else {
            results.push(arg);
          }
        }
        return results;
      };
      swizzle.wrap = function(fn) {
        return function() {
          return fn(swizzle(arguments));
        };
      };
    }
  });

  // ../core/node_modules/daily-prng/node_modules/color-string/index.js
  var require_color_string = __commonJS({
    "../core/node_modules/daily-prng/node_modules/color-string/index.js"(exports, module) {
      var colorNames = require_color_name();
      var swizzle = require_simple_swizzle();
      var hasOwnProperty = Object.hasOwnProperty;
      var reverseNames = /* @__PURE__ */ Object.create(null);
      for (name in colorNames) {
        if (hasOwnProperty.call(colorNames, name)) {
          reverseNames[colorNames[name]] = name;
        }
      }
      var name;
      var cs = module.exports = {
        to: {},
        get: {}
      };
      cs.get = function(string) {
        var prefix = string.substring(0, 3).toLowerCase();
        var val;
        var model;
        switch (prefix) {
          case "hsl":
            val = cs.get.hsl(string);
            model = "hsl";
            break;
          case "hwb":
            val = cs.get.hwb(string);
            model = "hwb";
            break;
          default:
            val = cs.get.rgb(string);
            model = "rgb";
            break;
        }
        if (!val) {
          return null;
        }
        return { model, value: val };
      };
      cs.get.rgb = function(string) {
        if (!string) {
          return null;
        }
        var abbr = /^#([a-f0-9]{3,4})$/i;
        var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
        var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
        var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
        var keyword = /^(\w+)$/;
        var rgb = [0, 0, 0, 1];
        var match;
        var i2;
        var hexAlpha;
        if (match = string.match(hex)) {
          hexAlpha = match[2];
          match = match[1];
          for (i2 = 0; i2 < 3; i2++) {
            var i22 = i2 * 2;
            rgb[i2] = parseInt(match.slice(i22, i22 + 2), 16);
          }
          if (hexAlpha) {
            rgb[3] = parseInt(hexAlpha, 16) / 255;
          }
        } else if (match = string.match(abbr)) {
          match = match[1];
          hexAlpha = match[3];
          for (i2 = 0; i2 < 3; i2++) {
            rgb[i2] = parseInt(match[i2] + match[i2], 16);
          }
          if (hexAlpha) {
            rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
          }
        } else if (match = string.match(rgba)) {
          for (i2 = 0; i2 < 3; i2++) {
            rgb[i2] = parseInt(match[i2 + 1], 0);
          }
          if (match[4]) {
            if (match[5]) {
              rgb[3] = parseFloat(match[4]) * 0.01;
            } else {
              rgb[3] = parseFloat(match[4]);
            }
          }
        } else if (match = string.match(per)) {
          for (i2 = 0; i2 < 3; i2++) {
            rgb[i2] = Math.round(parseFloat(match[i2 + 1]) * 2.55);
          }
          if (match[4]) {
            if (match[5]) {
              rgb[3] = parseFloat(match[4]) * 0.01;
            } else {
              rgb[3] = parseFloat(match[4]);
            }
          }
        } else if (match = string.match(keyword)) {
          if (match[1] === "transparent") {
            return [0, 0, 0, 0];
          }
          if (!hasOwnProperty.call(colorNames, match[1])) {
            return null;
          }
          rgb = colorNames[match[1]];
          rgb[3] = 1;
          return rgb;
        } else {
          return null;
        }
        for (i2 = 0; i2 < 3; i2++) {
          rgb[i2] = clamp(rgb[i2], 0, 255);
        }
        rgb[3] = clamp(rgb[3], 0, 1);
        return rgb;
      };
      cs.get.hsl = function(string) {
        if (!string) {
          return null;
        }
        var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
        var match = string.match(hsl);
        if (match) {
          var alpha = parseFloat(match[4]);
          var h2 = (parseFloat(match[1]) % 360 + 360) % 360;
          var s2 = clamp(parseFloat(match[2]), 0, 100);
          var l2 = clamp(parseFloat(match[3]), 0, 100);
          var a2 = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
          return [h2, s2, l2, a2];
        }
        return null;
      };
      cs.get.hwb = function(string) {
        if (!string) {
          return null;
        }
        var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
        var match = string.match(hwb);
        if (match) {
          var alpha = parseFloat(match[4]);
          var h2 = (parseFloat(match[1]) % 360 + 360) % 360;
          var w2 = clamp(parseFloat(match[2]), 0, 100);
          var b2 = clamp(parseFloat(match[3]), 0, 100);
          var a2 = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
          return [h2, w2, b2, a2];
        }
        return null;
      };
      cs.to.hex = function() {
        var rgba = swizzle(arguments);
        return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
      };
      cs.to.rgb = function() {
        var rgba = swizzle(arguments);
        return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
      };
      cs.to.rgb.percent = function() {
        var rgba = swizzle(arguments);
        var r2 = Math.round(rgba[0] / 255 * 100);
        var g2 = Math.round(rgba[1] / 255 * 100);
        var b2 = Math.round(rgba[2] / 255 * 100);
        return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r2 + "%, " + g2 + "%, " + b2 + "%)" : "rgba(" + r2 + "%, " + g2 + "%, " + b2 + "%, " + rgba[3] + ")";
      };
      cs.to.hsl = function() {
        var hsla = swizzle(arguments);
        return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
      };
      cs.to.hwb = function() {
        var hwba = swizzle(arguments);
        var a2 = "";
        if (hwba.length >= 4 && hwba[3] !== 1) {
          a2 = ", " + hwba[3];
        }
        return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a2 + ")";
      };
      cs.to.keyword = function(rgb) {
        return reverseNames[rgb.slice(0, 3)];
      };
      function clamp(num, min, max) {
        return Math.min(Math.max(min, num), max);
      }
      function hexDouble(num) {
        var str = Math.round(num).toString(16).toUpperCase();
        return str.length < 2 ? "0" + str : str;
      }
    }
  });

  // ../core/node_modules/daily-prng/node_modules/color-convert/conversions.js
  var require_conversions = __commonJS({
    "../core/node_modules/daily-prng/node_modules/color-convert/conversions.js"(exports, module) {
      var cssKeywords = require_color_name();
      var reverseKeywords = {};
      for (const key of Object.keys(cssKeywords)) {
        reverseKeywords[cssKeywords[key]] = key;
      }
      var convert = {
        rgb: { channels: 3, labels: "rgb" },
        hsl: { channels: 3, labels: "hsl" },
        hsv: { channels: 3, labels: "hsv" },
        hwb: { channels: 3, labels: "hwb" },
        cmyk: { channels: 4, labels: "cmyk" },
        xyz: { channels: 3, labels: "xyz" },
        lab: { channels: 3, labels: "lab" },
        lch: { channels: 3, labels: "lch" },
        hex: { channels: 1, labels: ["hex"] },
        keyword: { channels: 1, labels: ["keyword"] },
        ansi16: { channels: 1, labels: ["ansi16"] },
        ansi256: { channels: 1, labels: ["ansi256"] },
        hcg: { channels: 3, labels: ["h", "c", "g"] },
        apple: { channels: 3, labels: ["r16", "g16", "b16"] },
        gray: { channels: 1, labels: ["gray"] }
      };
      module.exports = convert;
      for (const model of Object.keys(convert)) {
        if (!("channels" in convert[model])) {
          throw new Error("missing channels property: " + model);
        }
        if (!("labels" in convert[model])) {
          throw new Error("missing channel labels property: " + model);
        }
        if (convert[model].labels.length !== convert[model].channels) {
          throw new Error("channel and label counts mismatch: " + model);
        }
        const { channels, labels } = convert[model];
        delete convert[model].channels;
        delete convert[model].labels;
        Object.defineProperty(convert[model], "channels", { value: channels });
        Object.defineProperty(convert[model], "labels", { value: labels });
      }
      convert.rgb.hsl = function(rgb) {
        const r2 = rgb[0] / 255;
        const g2 = rgb[1] / 255;
        const b2 = rgb[2] / 255;
        const min = Math.min(r2, g2, b2);
        const max = Math.max(r2, g2, b2);
        const delta = max - min;
        let h2;
        let s2;
        if (max === min) {
          h2 = 0;
        } else if (r2 === max) {
          h2 = (g2 - b2) / delta;
        } else if (g2 === max) {
          h2 = 2 + (b2 - r2) / delta;
        } else if (b2 === max) {
          h2 = 4 + (r2 - g2) / delta;
        }
        h2 = Math.min(h2 * 60, 360);
        if (h2 < 0) {
          h2 += 360;
        }
        const l2 = (min + max) / 2;
        if (max === min) {
          s2 = 0;
        } else if (l2 <= 0.5) {
          s2 = delta / (max + min);
        } else {
          s2 = delta / (2 - max - min);
        }
        return [h2, s2 * 100, l2 * 100];
      };
      convert.rgb.hsv = function(rgb) {
        let rdif;
        let gdif;
        let bdif;
        let h2;
        let s2;
        const r2 = rgb[0] / 255;
        const g2 = rgb[1] / 255;
        const b2 = rgb[2] / 255;
        const v2 = Math.max(r2, g2, b2);
        const diff = v2 - Math.min(r2, g2, b2);
        const diffc = function(c2) {
          return (v2 - c2) / 6 / diff + 1 / 2;
        };
        if (diff === 0) {
          h2 = 0;
          s2 = 0;
        } else {
          s2 = diff / v2;
          rdif = diffc(r2);
          gdif = diffc(g2);
          bdif = diffc(b2);
          if (r2 === v2) {
            h2 = bdif - gdif;
          } else if (g2 === v2) {
            h2 = 1 / 3 + rdif - bdif;
          } else if (b2 === v2) {
            h2 = 2 / 3 + gdif - rdif;
          }
          if (h2 < 0) {
            h2 += 1;
          } else if (h2 > 1) {
            h2 -= 1;
          }
        }
        return [
          h2 * 360,
          s2 * 100,
          v2 * 100
        ];
      };
      convert.rgb.hwb = function(rgb) {
        const r2 = rgb[0];
        const g2 = rgb[1];
        let b2 = rgb[2];
        const h2 = convert.rgb.hsl(rgb)[0];
        const w2 = 1 / 255 * Math.min(r2, Math.min(g2, b2));
        b2 = 1 - 1 / 255 * Math.max(r2, Math.max(g2, b2));
        return [h2, w2 * 100, b2 * 100];
      };
      convert.rgb.cmyk = function(rgb) {
        const r2 = rgb[0] / 255;
        const g2 = rgb[1] / 255;
        const b2 = rgb[2] / 255;
        const k2 = Math.min(1 - r2, 1 - g2, 1 - b2);
        const c2 = (1 - r2 - k2) / (1 - k2) || 0;
        const m2 = (1 - g2 - k2) / (1 - k2) || 0;
        const y2 = (1 - b2 - k2) / (1 - k2) || 0;
        return [c2 * 100, m2 * 100, y2 * 100, k2 * 100];
      };
      function comparativeDistance(x2, y2) {
        return (x2[0] - y2[0]) ** 2 + (x2[1] - y2[1]) ** 2 + (x2[2] - y2[2]) ** 2;
      }
      convert.rgb.keyword = function(rgb) {
        const reversed = reverseKeywords[rgb];
        if (reversed) {
          return reversed;
        }
        let currentClosestDistance = Infinity;
        let currentClosestKeyword;
        for (const keyword of Object.keys(cssKeywords)) {
          const value = cssKeywords[keyword];
          const distance = comparativeDistance(rgb, value);
          if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
          }
        }
        return currentClosestKeyword;
      };
      convert.keyword.rgb = function(keyword) {
        return cssKeywords[keyword];
      };
      convert.rgb.xyz = function(rgb) {
        let r2 = rgb[0] / 255;
        let g2 = rgb[1] / 255;
        let b2 = rgb[2] / 255;
        r2 = r2 > 0.04045 ? ((r2 + 0.055) / 1.055) ** 2.4 : r2 / 12.92;
        g2 = g2 > 0.04045 ? ((g2 + 0.055) / 1.055) ** 2.4 : g2 / 12.92;
        b2 = b2 > 0.04045 ? ((b2 + 0.055) / 1.055) ** 2.4 : b2 / 12.92;
        const x2 = r2 * 0.4124 + g2 * 0.3576 + b2 * 0.1805;
        const y2 = r2 * 0.2126 + g2 * 0.7152 + b2 * 0.0722;
        const z = r2 * 0.0193 + g2 * 0.1192 + b2 * 0.9505;
        return [x2 * 100, y2 * 100, z * 100];
      };
      convert.rgb.lab = function(rgb) {
        const xyz = convert.rgb.xyz(rgb);
        let x2 = xyz[0];
        let y2 = xyz[1];
        let z = xyz[2];
        x2 /= 95.047;
        y2 /= 100;
        z /= 108.883;
        x2 = x2 > 8856e-6 ? x2 ** (1 / 3) : 7.787 * x2 + 16 / 116;
        y2 = y2 > 8856e-6 ? y2 ** (1 / 3) : 7.787 * y2 + 16 / 116;
        z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
        const l2 = 116 * y2 - 16;
        const a2 = 500 * (x2 - y2);
        const b2 = 200 * (y2 - z);
        return [l2, a2, b2];
      };
      convert.hsl.rgb = function(hsl) {
        const h2 = hsl[0] / 360;
        const s2 = hsl[1] / 100;
        const l2 = hsl[2] / 100;
        let t2;
        let t3;
        let val;
        if (s2 === 0) {
          val = l2 * 255;
          return [val, val, val];
        }
        if (l2 < 0.5) {
          t2 = l2 * (1 + s2);
        } else {
          t2 = l2 + s2 - l2 * s2;
        }
        const t1 = 2 * l2 - t2;
        const rgb = [0, 0, 0];
        for (let i2 = 0; i2 < 3; i2++) {
          t3 = h2 + 1 / 3 * -(i2 - 1);
          if (t3 < 0) {
            t3++;
          }
          if (t3 > 1) {
            t3--;
          }
          if (6 * t3 < 1) {
            val = t1 + (t2 - t1) * 6 * t3;
          } else if (2 * t3 < 1) {
            val = t2;
          } else if (3 * t3 < 2) {
            val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
          } else {
            val = t1;
          }
          rgb[i2] = val * 255;
        }
        return rgb;
      };
      convert.hsl.hsv = function(hsl) {
        const h2 = hsl[0];
        let s2 = hsl[1] / 100;
        let l2 = hsl[2] / 100;
        let smin = s2;
        const lmin = Math.max(l2, 0.01);
        l2 *= 2;
        s2 *= l2 <= 1 ? l2 : 2 - l2;
        smin *= lmin <= 1 ? lmin : 2 - lmin;
        const v2 = (l2 + s2) / 2;
        const sv = l2 === 0 ? 2 * smin / (lmin + smin) : 2 * s2 / (l2 + s2);
        return [h2, sv * 100, v2 * 100];
      };
      convert.hsv.rgb = function(hsv) {
        const h2 = hsv[0] / 60;
        const s2 = hsv[1] / 100;
        let v2 = hsv[2] / 100;
        const hi = Math.floor(h2) % 6;
        const f2 = h2 - Math.floor(h2);
        const p2 = 255 * v2 * (1 - s2);
        const q = 255 * v2 * (1 - s2 * f2);
        const t2 = 255 * v2 * (1 - s2 * (1 - f2));
        v2 *= 255;
        switch (hi) {
          case 0:
            return [v2, t2, p2];
          case 1:
            return [q, v2, p2];
          case 2:
            return [p2, v2, t2];
          case 3:
            return [p2, q, v2];
          case 4:
            return [t2, p2, v2];
          case 5:
            return [v2, p2, q];
        }
      };
      convert.hsv.hsl = function(hsv) {
        const h2 = hsv[0];
        const s2 = hsv[1] / 100;
        const v2 = hsv[2] / 100;
        const vmin = Math.max(v2, 0.01);
        let sl;
        let l2;
        l2 = (2 - s2) * v2;
        const lmin = (2 - s2) * vmin;
        sl = s2 * vmin;
        sl /= lmin <= 1 ? lmin : 2 - lmin;
        sl = sl || 0;
        l2 /= 2;
        return [h2, sl * 100, l2 * 100];
      };
      convert.hwb.rgb = function(hwb) {
        const h2 = hwb[0] / 360;
        let wh = hwb[1] / 100;
        let bl = hwb[2] / 100;
        const ratio = wh + bl;
        let f2;
        if (ratio > 1) {
          wh /= ratio;
          bl /= ratio;
        }
        const i2 = Math.floor(6 * h2);
        const v2 = 1 - bl;
        f2 = 6 * h2 - i2;
        if ((i2 & 1) !== 0) {
          f2 = 1 - f2;
        }
        const n2 = wh + f2 * (v2 - wh);
        let r2;
        let g2;
        let b2;
        switch (i2) {
          default:
          case 6:
          case 0:
            r2 = v2;
            g2 = n2;
            b2 = wh;
            break;
          case 1:
            r2 = n2;
            g2 = v2;
            b2 = wh;
            break;
          case 2:
            r2 = wh;
            g2 = v2;
            b2 = n2;
            break;
          case 3:
            r2 = wh;
            g2 = n2;
            b2 = v2;
            break;
          case 4:
            r2 = n2;
            g2 = wh;
            b2 = v2;
            break;
          case 5:
            r2 = v2;
            g2 = wh;
            b2 = n2;
            break;
        }
        return [r2 * 255, g2 * 255, b2 * 255];
      };
      convert.cmyk.rgb = function(cmyk) {
        const c2 = cmyk[0] / 100;
        const m2 = cmyk[1] / 100;
        const y2 = cmyk[2] / 100;
        const k2 = cmyk[3] / 100;
        const r2 = 1 - Math.min(1, c2 * (1 - k2) + k2);
        const g2 = 1 - Math.min(1, m2 * (1 - k2) + k2);
        const b2 = 1 - Math.min(1, y2 * (1 - k2) + k2);
        return [r2 * 255, g2 * 255, b2 * 255];
      };
      convert.xyz.rgb = function(xyz) {
        const x2 = xyz[0] / 100;
        const y2 = xyz[1] / 100;
        const z = xyz[2] / 100;
        let r2;
        let g2;
        let b2;
        r2 = x2 * 3.2406 + y2 * -1.5372 + z * -0.4986;
        g2 = x2 * -0.9689 + y2 * 1.8758 + z * 0.0415;
        b2 = x2 * 0.0557 + y2 * -0.204 + z * 1.057;
        r2 = r2 > 31308e-7 ? 1.055 * r2 ** (1 / 2.4) - 0.055 : r2 * 12.92;
        g2 = g2 > 31308e-7 ? 1.055 * g2 ** (1 / 2.4) - 0.055 : g2 * 12.92;
        b2 = b2 > 31308e-7 ? 1.055 * b2 ** (1 / 2.4) - 0.055 : b2 * 12.92;
        r2 = Math.min(Math.max(0, r2), 1);
        g2 = Math.min(Math.max(0, g2), 1);
        b2 = Math.min(Math.max(0, b2), 1);
        return [r2 * 255, g2 * 255, b2 * 255];
      };
      convert.xyz.lab = function(xyz) {
        let x2 = xyz[0];
        let y2 = xyz[1];
        let z = xyz[2];
        x2 /= 95.047;
        y2 /= 100;
        z /= 108.883;
        x2 = x2 > 8856e-6 ? x2 ** (1 / 3) : 7.787 * x2 + 16 / 116;
        y2 = y2 > 8856e-6 ? y2 ** (1 / 3) : 7.787 * y2 + 16 / 116;
        z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
        const l2 = 116 * y2 - 16;
        const a2 = 500 * (x2 - y2);
        const b2 = 200 * (y2 - z);
        return [l2, a2, b2];
      };
      convert.lab.xyz = function(lab) {
        const l2 = lab[0];
        const a2 = lab[1];
        const b2 = lab[2];
        let x2;
        let y2;
        let z;
        y2 = (l2 + 16) / 116;
        x2 = a2 / 500 + y2;
        z = y2 - b2 / 200;
        const y22 = y2 ** 3;
        const x22 = x2 ** 3;
        const z2 = z ** 3;
        y2 = y22 > 8856e-6 ? y22 : (y2 - 16 / 116) / 7.787;
        x2 = x22 > 8856e-6 ? x22 : (x2 - 16 / 116) / 7.787;
        z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
        x2 *= 95.047;
        y2 *= 100;
        z *= 108.883;
        return [x2, y2, z];
      };
      convert.lab.lch = function(lab) {
        const l2 = lab[0];
        const a2 = lab[1];
        const b2 = lab[2];
        let h2;
        const hr = Math.atan2(b2, a2);
        h2 = hr * 360 / 2 / Math.PI;
        if (h2 < 0) {
          h2 += 360;
        }
        const c2 = Math.sqrt(a2 * a2 + b2 * b2);
        return [l2, c2, h2];
      };
      convert.lch.lab = function(lch) {
        const l2 = lch[0];
        const c2 = lch[1];
        const h2 = lch[2];
        const hr = h2 / 360 * 2 * Math.PI;
        const a2 = c2 * Math.cos(hr);
        const b2 = c2 * Math.sin(hr);
        return [l2, a2, b2];
      };
      convert.rgb.ansi16 = function(args, saturation = null) {
        const [r2, g2, b2] = args;
        let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
        value = Math.round(value / 50);
        if (value === 0) {
          return 30;
        }
        let ansi = 30 + (Math.round(b2 / 255) << 2 | Math.round(g2 / 255) << 1 | Math.round(r2 / 255));
        if (value === 2) {
          ansi += 60;
        }
        return ansi;
      };
      convert.hsv.ansi16 = function(args) {
        return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
      };
      convert.rgb.ansi256 = function(args) {
        const r2 = args[0];
        const g2 = args[1];
        const b2 = args[2];
        if (r2 === g2 && g2 === b2) {
          if (r2 < 8) {
            return 16;
          }
          if (r2 > 248) {
            return 231;
          }
          return Math.round((r2 - 8) / 247 * 24) + 232;
        }
        const ansi = 16 + 36 * Math.round(r2 / 255 * 5) + 6 * Math.round(g2 / 255 * 5) + Math.round(b2 / 255 * 5);
        return ansi;
      };
      convert.ansi16.rgb = function(args) {
        let color3 = args % 10;
        if (color3 === 0 || color3 === 7) {
          if (args > 50) {
            color3 += 3.5;
          }
          color3 = color3 / 10.5 * 255;
          return [color3, color3, color3];
        }
        const mult = (~~(args > 50) + 1) * 0.5;
        const r2 = (color3 & 1) * mult * 255;
        const g2 = (color3 >> 1 & 1) * mult * 255;
        const b2 = (color3 >> 2 & 1) * mult * 255;
        return [r2, g2, b2];
      };
      convert.ansi256.rgb = function(args) {
        if (args >= 232) {
          const c2 = (args - 232) * 10 + 8;
          return [c2, c2, c2];
        }
        args -= 16;
        let rem;
        const r2 = Math.floor(args / 36) / 5 * 255;
        const g2 = Math.floor((rem = args % 36) / 6) / 5 * 255;
        const b2 = rem % 6 / 5 * 255;
        return [r2, g2, b2];
      };
      convert.rgb.hex = function(args) {
        const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
        const string = integer.toString(16).toUpperCase();
        return "000000".substring(string.length) + string;
      };
      convert.hex.rgb = function(args) {
        const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
        if (!match) {
          return [0, 0, 0];
        }
        let colorString = match[0];
        if (match[0].length === 3) {
          colorString = colorString.split("").map((char) => {
            return char + char;
          }).join("");
        }
        const integer = parseInt(colorString, 16);
        const r2 = integer >> 16 & 255;
        const g2 = integer >> 8 & 255;
        const b2 = integer & 255;
        return [r2, g2, b2];
      };
      convert.rgb.hcg = function(rgb) {
        const r2 = rgb[0] / 255;
        const g2 = rgb[1] / 255;
        const b2 = rgb[2] / 255;
        const max = Math.max(Math.max(r2, g2), b2);
        const min = Math.min(Math.min(r2, g2), b2);
        const chroma = max - min;
        let grayscale;
        let hue;
        if (chroma < 1) {
          grayscale = min / (1 - chroma);
        } else {
          grayscale = 0;
        }
        if (chroma <= 0) {
          hue = 0;
        } else if (max === r2) {
          hue = (g2 - b2) / chroma % 6;
        } else if (max === g2) {
          hue = 2 + (b2 - r2) / chroma;
        } else {
          hue = 4 + (r2 - g2) / chroma;
        }
        hue /= 6;
        hue %= 1;
        return [hue * 360, chroma * 100, grayscale * 100];
      };
      convert.hsl.hcg = function(hsl) {
        const s2 = hsl[1] / 100;
        const l2 = hsl[2] / 100;
        const c2 = l2 < 0.5 ? 2 * s2 * l2 : 2 * s2 * (1 - l2);
        let f2 = 0;
        if (c2 < 1) {
          f2 = (l2 - 0.5 * c2) / (1 - c2);
        }
        return [hsl[0], c2 * 100, f2 * 100];
      };
      convert.hsv.hcg = function(hsv) {
        const s2 = hsv[1] / 100;
        const v2 = hsv[2] / 100;
        const c2 = s2 * v2;
        let f2 = 0;
        if (c2 < 1) {
          f2 = (v2 - c2) / (1 - c2);
        }
        return [hsv[0], c2 * 100, f2 * 100];
      };
      convert.hcg.rgb = function(hcg) {
        const h2 = hcg[0] / 360;
        const c2 = hcg[1] / 100;
        const g2 = hcg[2] / 100;
        if (c2 === 0) {
          return [g2 * 255, g2 * 255, g2 * 255];
        }
        const pure = [0, 0, 0];
        const hi = h2 % 1 * 6;
        const v2 = hi % 1;
        const w2 = 1 - v2;
        let mg = 0;
        switch (Math.floor(hi)) {
          case 0:
            pure[0] = 1;
            pure[1] = v2;
            pure[2] = 0;
            break;
          case 1:
            pure[0] = w2;
            pure[1] = 1;
            pure[2] = 0;
            break;
          case 2:
            pure[0] = 0;
            pure[1] = 1;
            pure[2] = v2;
            break;
          case 3:
            pure[0] = 0;
            pure[1] = w2;
            pure[2] = 1;
            break;
          case 4:
            pure[0] = v2;
            pure[1] = 0;
            pure[2] = 1;
            break;
          default:
            pure[0] = 1;
            pure[1] = 0;
            pure[2] = w2;
        }
        mg = (1 - c2) * g2;
        return [
          (c2 * pure[0] + mg) * 255,
          (c2 * pure[1] + mg) * 255,
          (c2 * pure[2] + mg) * 255
        ];
      };
      convert.hcg.hsv = function(hcg) {
        const c2 = hcg[1] / 100;
        const g2 = hcg[2] / 100;
        const v2 = c2 + g2 * (1 - c2);
        let f2 = 0;
        if (v2 > 0) {
          f2 = c2 / v2;
        }
        return [hcg[0], f2 * 100, v2 * 100];
      };
      convert.hcg.hsl = function(hcg) {
        const c2 = hcg[1] / 100;
        const g2 = hcg[2] / 100;
        const l2 = g2 * (1 - c2) + 0.5 * c2;
        let s2 = 0;
        if (l2 > 0 && l2 < 0.5) {
          s2 = c2 / (2 * l2);
        } else if (l2 >= 0.5 && l2 < 1) {
          s2 = c2 / (2 * (1 - l2));
        }
        return [hcg[0], s2 * 100, l2 * 100];
      };
      convert.hcg.hwb = function(hcg) {
        const c2 = hcg[1] / 100;
        const g2 = hcg[2] / 100;
        const v2 = c2 + g2 * (1 - c2);
        return [hcg[0], (v2 - c2) * 100, (1 - v2) * 100];
      };
      convert.hwb.hcg = function(hwb) {
        const w2 = hwb[1] / 100;
        const b2 = hwb[2] / 100;
        const v2 = 1 - b2;
        const c2 = v2 - w2;
        let g2 = 0;
        if (c2 < 1) {
          g2 = (v2 - c2) / (1 - c2);
        }
        return [hwb[0], c2 * 100, g2 * 100];
      };
      convert.apple.rgb = function(apple) {
        return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
      };
      convert.rgb.apple = function(rgb) {
        return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
      };
      convert.gray.rgb = function(args) {
        return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
      };
      convert.gray.hsl = function(args) {
        return [0, 0, args[0]];
      };
      convert.gray.hsv = convert.gray.hsl;
      convert.gray.hwb = function(gray) {
        return [0, 100, gray[0]];
      };
      convert.gray.cmyk = function(gray) {
        return [0, 0, 0, gray[0]];
      };
      convert.gray.lab = function(gray) {
        return [gray[0], 0, 0];
      };
      convert.gray.hex = function(gray) {
        const val = Math.round(gray[0] / 100 * 255) & 255;
        const integer = (val << 16) + (val << 8) + val;
        const string = integer.toString(16).toUpperCase();
        return "000000".substring(string.length) + string;
      };
      convert.rgb.gray = function(rgb) {
        const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
        return [val / 255 * 100];
      };
    }
  });

  // ../core/node_modules/daily-prng/node_modules/color-convert/route.js
  var require_route = __commonJS({
    "../core/node_modules/daily-prng/node_modules/color-convert/route.js"(exports, module) {
      var conversions = require_conversions();
      function buildGraph() {
        const graph = {};
        const models = Object.keys(conversions);
        for (let len = models.length, i2 = 0; i2 < len; i2++) {
          graph[models[i2]] = {
            // http://jsperf.com/1-vs-infinity
            // micro-opt, but this is simple.
            distance: -1,
            parent: null
          };
        }
        return graph;
      }
      function deriveBFS(fromModel) {
        const graph = buildGraph();
        const queue = [fromModel];
        graph[fromModel].distance = 0;
        while (queue.length) {
          const current = queue.pop();
          const adjacents = Object.keys(conversions[current]);
          for (let len = adjacents.length, i2 = 0; i2 < len; i2++) {
            const adjacent = adjacents[i2];
            const node = graph[adjacent];
            if (node.distance === -1) {
              node.distance = graph[current].distance + 1;
              node.parent = current;
              queue.unshift(adjacent);
            }
          }
        }
        return graph;
      }
      function link(from3, to) {
        return function(args) {
          return to(from3(args));
        };
      }
      function wrapConversion(toModel, graph) {
        const path2 = [graph[toModel].parent, toModel];
        let fn = conversions[graph[toModel].parent][toModel];
        let cur = graph[toModel].parent;
        while (graph[cur].parent) {
          path2.unshift(graph[cur].parent);
          fn = link(conversions[graph[cur].parent][cur], fn);
          cur = graph[cur].parent;
        }
        fn.conversion = path2;
        return fn;
      }
      module.exports = function(fromModel) {
        const graph = deriveBFS(fromModel);
        const conversion = {};
        const models = Object.keys(graph);
        for (let len = models.length, i2 = 0; i2 < len; i2++) {
          const toModel = models[i2];
          const node = graph[toModel];
          if (node.parent === null) {
            continue;
          }
          conversion[toModel] = wrapConversion(toModel, graph);
        }
        return conversion;
      };
    }
  });

  // ../core/node_modules/daily-prng/node_modules/color-convert/index.js
  var require_color_convert = __commonJS({
    "../core/node_modules/daily-prng/node_modules/color-convert/index.js"(exports, module) {
      var conversions = require_conversions();
      var route = require_route();
      var convert = {};
      var models = Object.keys(conversions);
      function wrapRaw(fn) {
        const wrappedFn = function(...args) {
          const arg0 = args[0];
          if (arg0 === void 0 || arg0 === null) {
            return arg0;
          }
          if (arg0.length > 1) {
            args = arg0;
          }
          return fn(args);
        };
        if ("conversion" in fn) {
          wrappedFn.conversion = fn.conversion;
        }
        return wrappedFn;
      }
      function wrapRounded(fn) {
        const wrappedFn = function(...args) {
          const arg0 = args[0];
          if (arg0 === void 0 || arg0 === null) {
            return arg0;
          }
          if (arg0.length > 1) {
            args = arg0;
          }
          const result = fn(args);
          if (typeof result === "object") {
            for (let len = result.length, i2 = 0; i2 < len; i2++) {
              result[i2] = Math.round(result[i2]);
            }
          }
          return result;
        };
        if ("conversion" in fn) {
          wrappedFn.conversion = fn.conversion;
        }
        return wrappedFn;
      }
      models.forEach((fromModel) => {
        convert[fromModel] = {};
        Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
        Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
        const routes = route(fromModel);
        const routeModels = Object.keys(routes);
        routeModels.forEach((toModel) => {
          const fn = routes[toModel];
          convert[fromModel][toModel] = wrapRounded(fn);
          convert[fromModel][toModel].raw = wrapRaw(fn);
        });
      });
      module.exports = convert;
    }
  });

  // ../core/node_modules/daily-prng/node_modules/color/index.js
  var require_color = __commonJS({
    "../core/node_modules/daily-prng/node_modules/color/index.js"(exports, module) {
      var colorString = require_color_string();
      var convert = require_color_convert();
      var skippedModels = [
        // To be honest, I don't really feel like keyword belongs in color convert, but eh.
        "keyword",
        // Gray conflicts with some method names, and has its own method defined.
        "gray",
        // Shouldn't really be in color-convert either...
        "hex"
      ];
      var hashedModelKeys = {};
      for (const model of Object.keys(convert)) {
        hashedModelKeys[[...convert[model].labels].sort().join("")] = model;
      }
      var limiters = {};
      function Color2(object, model) {
        if (!(this instanceof Color2)) {
          return new Color2(object, model);
        }
        if (model && model in skippedModels) {
          model = null;
        }
        if (model && !(model in convert)) {
          throw new Error("Unknown model: " + model);
        }
        let i2;
        let channels;
        if (object == null) {
          this.model = "rgb";
          this.color = [0, 0, 0];
          this.valpha = 1;
        } else if (object instanceof Color2) {
          this.model = object.model;
          this.color = [...object.color];
          this.valpha = object.valpha;
        } else if (typeof object === "string") {
          const result = colorString.get(object);
          if (result === null) {
            throw new Error("Unable to parse color from string: " + object);
          }
          this.model = result.model;
          channels = convert[this.model].channels;
          this.color = result.value.slice(0, channels);
          this.valpha = typeof result.value[channels] === "number" ? result.value[channels] : 1;
        } else if (object.length > 0) {
          this.model = model || "rgb";
          channels = convert[this.model].channels;
          const newArray = Array.prototype.slice.call(object, 0, channels);
          this.color = zeroArray(newArray, channels);
          this.valpha = typeof object[channels] === "number" ? object[channels] : 1;
        } else if (typeof object === "number") {
          this.model = "rgb";
          this.color = [
            object >> 16 & 255,
            object >> 8 & 255,
            object & 255
          ];
          this.valpha = 1;
        } else {
          this.valpha = 1;
          const keys = Object.keys(object);
          if ("alpha" in object) {
            keys.splice(keys.indexOf("alpha"), 1);
            this.valpha = typeof object.alpha === "number" ? object.alpha : 0;
          }
          const hashedKeys = keys.sort().join("");
          if (!(hashedKeys in hashedModelKeys)) {
            throw new Error("Unable to parse color from object: " + JSON.stringify(object));
          }
          this.model = hashedModelKeys[hashedKeys];
          const { labels } = convert[this.model];
          const color3 = [];
          for (i2 = 0; i2 < labels.length; i2++) {
            color3.push(object[labels[i2]]);
          }
          this.color = zeroArray(color3);
        }
        if (limiters[this.model]) {
          channels = convert[this.model].channels;
          for (i2 = 0; i2 < channels; i2++) {
            const limit = limiters[this.model][i2];
            if (limit) {
              this.color[i2] = limit(this.color[i2]);
            }
          }
        }
        this.valpha = Math.max(0, Math.min(1, this.valpha));
        if (Object.freeze) {
          Object.freeze(this);
        }
      }
      Color2.prototype = {
        toString() {
          return this.string();
        },
        toJSON() {
          return this[this.model]();
        },
        string(places) {
          let self2 = this.model in colorString.to ? this : this.rgb();
          self2 = self2.round(typeof places === "number" ? places : 1);
          const args = self2.valpha === 1 ? self2.color : [...self2.color, this.valpha];
          return colorString.to[self2.model](args);
        },
        percentString(places) {
          const self2 = this.rgb().round(typeof places === "number" ? places : 1);
          const args = self2.valpha === 1 ? self2.color : [...self2.color, this.valpha];
          return colorString.to.rgb.percent(args);
        },
        array() {
          return this.valpha === 1 ? [...this.color] : [...this.color, this.valpha];
        },
        object() {
          const result = {};
          const { channels } = convert[this.model];
          const { labels } = convert[this.model];
          for (let i2 = 0; i2 < channels; i2++) {
            result[labels[i2]] = this.color[i2];
          }
          if (this.valpha !== 1) {
            result.alpha = this.valpha;
          }
          return result;
        },
        unitArray() {
          const rgb = this.rgb().color;
          rgb[0] /= 255;
          rgb[1] /= 255;
          rgb[2] /= 255;
          if (this.valpha !== 1) {
            rgb.push(this.valpha);
          }
          return rgb;
        },
        unitObject() {
          const rgb = this.rgb().object();
          rgb.r /= 255;
          rgb.g /= 255;
          rgb.b /= 255;
          if (this.valpha !== 1) {
            rgb.alpha = this.valpha;
          }
          return rgb;
        },
        round(places) {
          places = Math.max(places || 0, 0);
          return new Color2([...this.color.map(roundToPlace(places)), this.valpha], this.model);
        },
        alpha(value) {
          if (value !== void 0) {
            return new Color2([...this.color, Math.max(0, Math.min(1, value))], this.model);
          }
          return this.valpha;
        },
        // Rgb
        red: getset("rgb", 0, maxfn(255)),
        green: getset("rgb", 1, maxfn(255)),
        blue: getset("rgb", 2, maxfn(255)),
        hue: getset(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, (value) => (value % 360 + 360) % 360),
        saturationl: getset("hsl", 1, maxfn(100)),
        lightness: getset("hsl", 2, maxfn(100)),
        saturationv: getset("hsv", 1, maxfn(100)),
        value: getset("hsv", 2, maxfn(100)),
        chroma: getset("hcg", 1, maxfn(100)),
        gray: getset("hcg", 2, maxfn(100)),
        white: getset("hwb", 1, maxfn(100)),
        wblack: getset("hwb", 2, maxfn(100)),
        cyan: getset("cmyk", 0, maxfn(100)),
        magenta: getset("cmyk", 1, maxfn(100)),
        yellow: getset("cmyk", 2, maxfn(100)),
        black: getset("cmyk", 3, maxfn(100)),
        x: getset("xyz", 0, maxfn(95.047)),
        y: getset("xyz", 1, maxfn(100)),
        z: getset("xyz", 2, maxfn(108.833)),
        l: getset("lab", 0, maxfn(100)),
        a: getset("lab", 1),
        b: getset("lab", 2),
        keyword(value) {
          if (value !== void 0) {
            return new Color2(value);
          }
          return convert[this.model].keyword(this.color);
        },
        hex(value) {
          if (value !== void 0) {
            return new Color2(value);
          }
          return colorString.to.hex(this.rgb().round().color);
        },
        hexa(value) {
          if (value !== void 0) {
            return new Color2(value);
          }
          const rgbArray = this.rgb().round().color;
          let alphaHex = Math.round(this.valpha * 255).toString(16).toUpperCase();
          if (alphaHex.length === 1) {
            alphaHex = "0" + alphaHex;
          }
          return colorString.to.hex(rgbArray) + alphaHex;
        },
        rgbNumber() {
          const rgb = this.rgb().color;
          return (rgb[0] & 255) << 16 | (rgb[1] & 255) << 8 | rgb[2] & 255;
        },
        luminosity() {
          const rgb = this.rgb().color;
          const lum = [];
          for (const [i2, element2] of rgb.entries()) {
            const chan = element2 / 255;
            lum[i2] = chan <= 0.04045 ? chan / 12.92 : ((chan + 0.055) / 1.055) ** 2.4;
          }
          return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
        },
        contrast(color22) {
          const lum1 = this.luminosity();
          const lum2 = color22.luminosity();
          if (lum1 > lum2) {
            return (lum1 + 0.05) / (lum2 + 0.05);
          }
          return (lum2 + 0.05) / (lum1 + 0.05);
        },
        level(color22) {
          const contrastRatio = this.contrast(color22);
          if (contrastRatio >= 7) {
            return "AAA";
          }
          return contrastRatio >= 4.5 ? "AA" : "";
        },
        isDark() {
          const rgb = this.rgb().color;
          const yiq = (rgb[0] * 2126 + rgb[1] * 7152 + rgb[2] * 722) / 1e4;
          return yiq < 128;
        },
        isLight() {
          return !this.isDark();
        },
        negate() {
          const rgb = this.rgb();
          for (let i2 = 0; i2 < 3; i2++) {
            rgb.color[i2] = 255 - rgb.color[i2];
          }
          return rgb;
        },
        lighten(ratio) {
          const hsl = this.hsl();
          hsl.color[2] += hsl.color[2] * ratio;
          return hsl;
        },
        darken(ratio) {
          const hsl = this.hsl();
          hsl.color[2] -= hsl.color[2] * ratio;
          return hsl;
        },
        saturate(ratio) {
          const hsl = this.hsl();
          hsl.color[1] += hsl.color[1] * ratio;
          return hsl;
        },
        desaturate(ratio) {
          const hsl = this.hsl();
          hsl.color[1] -= hsl.color[1] * ratio;
          return hsl;
        },
        whiten(ratio) {
          const hwb = this.hwb();
          hwb.color[1] += hwb.color[1] * ratio;
          return hwb;
        },
        blacken(ratio) {
          const hwb = this.hwb();
          hwb.color[2] += hwb.color[2] * ratio;
          return hwb;
        },
        grayscale() {
          const rgb = this.rgb().color;
          const value = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
          return Color2.rgb(value, value, value);
        },
        fade(ratio) {
          return this.alpha(this.valpha - this.valpha * ratio);
        },
        opaquer(ratio) {
          return this.alpha(this.valpha + this.valpha * ratio);
        },
        rotate(degrees) {
          const hsl = this.hsl();
          let hue = hsl.color[0];
          hue = (hue + degrees) % 360;
          hue = hue < 0 ? 360 + hue : hue;
          hsl.color[0] = hue;
          return hsl;
        },
        mix(mixinColor, weight) {
          if (!mixinColor || !mixinColor.rgb) {
            throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
          }
          const color1 = mixinColor.rgb();
          const color22 = this.rgb();
          const p2 = weight === void 0 ? 0.5 : weight;
          const w2 = 2 * p2 - 1;
          const a2 = color1.alpha() - color22.alpha();
          const w1 = ((w2 * a2 === -1 ? w2 : (w2 + a2) / (1 + w2 * a2)) + 1) / 2;
          const w22 = 1 - w1;
          return Color2.rgb(
            w1 * color1.red() + w22 * color22.red(),
            w1 * color1.green() + w22 * color22.green(),
            w1 * color1.blue() + w22 * color22.blue(),
            color1.alpha() * p2 + color22.alpha() * (1 - p2)
          );
        }
      };
      for (const model of Object.keys(convert)) {
        if (skippedModels.includes(model)) {
          continue;
        }
        const { channels } = convert[model];
        Color2.prototype[model] = function(...args) {
          if (this.model === model) {
            return new Color2(this);
          }
          if (args.length > 0) {
            return new Color2(args, model);
          }
          return new Color2([...assertArray(convert[this.model][model].raw(this.color)), this.valpha], model);
        };
        Color2[model] = function(...args) {
          let color3 = args[0];
          if (typeof color3 === "number") {
            color3 = zeroArray(args, channels);
          }
          return new Color2(color3, model);
        };
      }
      function roundTo(number, places) {
        return Number(number.toFixed(places));
      }
      function roundToPlace(places) {
        return function(number) {
          return roundTo(number, places);
        };
      }
      function getset(model, channel, modifier) {
        model = Array.isArray(model) ? model : [model];
        for (const m2 of model) {
          (limiters[m2] || (limiters[m2] = []))[channel] = modifier;
        }
        model = model[0];
        return function(value) {
          let result;
          if (value !== void 0) {
            if (modifier) {
              value = modifier(value);
            }
            result = this[model]();
            result.color[channel] = value;
            return result;
          }
          result = this[model]().color[channel];
          if (modifier) {
            result = modifier(result);
          }
          return result;
        };
      }
      function maxfn(max) {
        return function(v2) {
          return Math.max(0, Math.min(max, v2));
        };
      }
      function assertArray(value) {
        return Array.isArray(value) ? value : [value];
      }
      function zeroArray(array, length) {
        for (let i2 = 0; i2 < length; i2++) {
          if (typeof array[i2] !== "number") {
            array[i2] = 0;
          }
        }
        return array;
      }
      module.exports = Color2;
    }
  });

  // ../core/node_modules/color-name/index.js
  var require_color_name2 = __commonJS({
    "../core/node_modules/color-name/index.js"(exports, module) {
      "use strict";
      module.exports = {
        "aliceblue": [240, 248, 255],
        "antiquewhite": [250, 235, 215],
        "aqua": [0, 255, 255],
        "aquamarine": [127, 255, 212],
        "azure": [240, 255, 255],
        "beige": [245, 245, 220],
        "bisque": [255, 228, 196],
        "black": [0, 0, 0],
        "blanchedalmond": [255, 235, 205],
        "blue": [0, 0, 255],
        "blueviolet": [138, 43, 226],
        "brown": [165, 42, 42],
        "burlywood": [222, 184, 135],
        "cadetblue": [95, 158, 160],
        "chartreuse": [127, 255, 0],
        "chocolate": [210, 105, 30],
        "coral": [255, 127, 80],
        "cornflowerblue": [100, 149, 237],
        "cornsilk": [255, 248, 220],
        "crimson": [220, 20, 60],
        "cyan": [0, 255, 255],
        "darkblue": [0, 0, 139],
        "darkcyan": [0, 139, 139],
        "darkgoldenrod": [184, 134, 11],
        "darkgray": [169, 169, 169],
        "darkgreen": [0, 100, 0],
        "darkgrey": [169, 169, 169],
        "darkkhaki": [189, 183, 107],
        "darkmagenta": [139, 0, 139],
        "darkolivegreen": [85, 107, 47],
        "darkorange": [255, 140, 0],
        "darkorchid": [153, 50, 204],
        "darkred": [139, 0, 0],
        "darksalmon": [233, 150, 122],
        "darkseagreen": [143, 188, 143],
        "darkslateblue": [72, 61, 139],
        "darkslategray": [47, 79, 79],
        "darkslategrey": [47, 79, 79],
        "darkturquoise": [0, 206, 209],
        "darkviolet": [148, 0, 211],
        "deeppink": [255, 20, 147],
        "deepskyblue": [0, 191, 255],
        "dimgray": [105, 105, 105],
        "dimgrey": [105, 105, 105],
        "dodgerblue": [30, 144, 255],
        "firebrick": [178, 34, 34],
        "floralwhite": [255, 250, 240],
        "forestgreen": [34, 139, 34],
        "fuchsia": [255, 0, 255],
        "gainsboro": [220, 220, 220],
        "ghostwhite": [248, 248, 255],
        "gold": [255, 215, 0],
        "goldenrod": [218, 165, 32],
        "gray": [128, 128, 128],
        "green": [0, 128, 0],
        "greenyellow": [173, 255, 47],
        "grey": [128, 128, 128],
        "honeydew": [240, 255, 240],
        "hotpink": [255, 105, 180],
        "indianred": [205, 92, 92],
        "indigo": [75, 0, 130],
        "ivory": [255, 255, 240],
        "khaki": [240, 230, 140],
        "lavender": [230, 230, 250],
        "lavenderblush": [255, 240, 245],
        "lawngreen": [124, 252, 0],
        "lemonchiffon": [255, 250, 205],
        "lightblue": [173, 216, 230],
        "lightcoral": [240, 128, 128],
        "lightcyan": [224, 255, 255],
        "lightgoldenrodyellow": [250, 250, 210],
        "lightgray": [211, 211, 211],
        "lightgreen": [144, 238, 144],
        "lightgrey": [211, 211, 211],
        "lightpink": [255, 182, 193],
        "lightsalmon": [255, 160, 122],
        "lightseagreen": [32, 178, 170],
        "lightskyblue": [135, 206, 250],
        "lightslategray": [119, 136, 153],
        "lightslategrey": [119, 136, 153],
        "lightsteelblue": [176, 196, 222],
        "lightyellow": [255, 255, 224],
        "lime": [0, 255, 0],
        "limegreen": [50, 205, 50],
        "linen": [250, 240, 230],
        "magenta": [255, 0, 255],
        "maroon": [128, 0, 0],
        "mediumaquamarine": [102, 205, 170],
        "mediumblue": [0, 0, 205],
        "mediumorchid": [186, 85, 211],
        "mediumpurple": [147, 112, 219],
        "mediumseagreen": [60, 179, 113],
        "mediumslateblue": [123, 104, 238],
        "mediumspringgreen": [0, 250, 154],
        "mediumturquoise": [72, 209, 204],
        "mediumvioletred": [199, 21, 133],
        "midnightblue": [25, 25, 112],
        "mintcream": [245, 255, 250],
        "mistyrose": [255, 228, 225],
        "moccasin": [255, 228, 181],
        "navajowhite": [255, 222, 173],
        "navy": [0, 0, 128],
        "oldlace": [253, 245, 230],
        "olive": [128, 128, 0],
        "olivedrab": [107, 142, 35],
        "orange": [255, 165, 0],
        "orangered": [255, 69, 0],
        "orchid": [218, 112, 214],
        "palegoldenrod": [238, 232, 170],
        "palegreen": [152, 251, 152],
        "paleturquoise": [175, 238, 238],
        "palevioletred": [219, 112, 147],
        "papayawhip": [255, 239, 213],
        "peachpuff": [255, 218, 185],
        "peru": [205, 133, 63],
        "pink": [255, 192, 203],
        "plum": [221, 160, 221],
        "powderblue": [176, 224, 230],
        "purple": [128, 0, 128],
        "rebeccapurple": [102, 51, 153],
        "red": [255, 0, 0],
        "rosybrown": [188, 143, 143],
        "royalblue": [65, 105, 225],
        "saddlebrown": [139, 69, 19],
        "salmon": [250, 128, 114],
        "sandybrown": [244, 164, 96],
        "seagreen": [46, 139, 87],
        "seashell": [255, 245, 238],
        "sienna": [160, 82, 45],
        "silver": [192, 192, 192],
        "skyblue": [135, 206, 235],
        "slateblue": [106, 90, 205],
        "slategray": [112, 128, 144],
        "slategrey": [112, 128, 144],
        "snow": [255, 250, 250],
        "springgreen": [0, 255, 127],
        "steelblue": [70, 130, 180],
        "tan": [210, 180, 140],
        "teal": [0, 128, 128],
        "thistle": [216, 191, 216],
        "tomato": [255, 99, 71],
        "turquoise": [64, 224, 208],
        "violet": [238, 130, 238],
        "wheat": [245, 222, 179],
        "white": [255, 255, 255],
        "whitesmoke": [245, 245, 245],
        "yellow": [255, 255, 0],
        "yellowgreen": [154, 205, 50]
      };
    }
  });

  // ../core/node_modules/is-arrayish/index.js
  var require_is_arrayish2 = __commonJS({
    "../core/node_modules/is-arrayish/index.js"(exports, module) {
      module.exports = function isArrayish(obj) {
        if (!obj || typeof obj === "string") {
          return false;
        }
        return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
      };
    }
  });

  // ../core/node_modules/simple-swizzle/index.js
  var require_simple_swizzle2 = __commonJS({
    "../core/node_modules/simple-swizzle/index.js"(exports, module) {
      "use strict";
      var isArrayish = require_is_arrayish2();
      var concat = Array.prototype.concat;
      var slice = Array.prototype.slice;
      var swizzle = module.exports = function swizzle2(args) {
        var results = [];
        for (var i2 = 0, len = args.length; i2 < len; i2++) {
          var arg = args[i2];
          if (isArrayish(arg)) {
            results = concat.call(results, slice.call(arg));
          } else {
            results.push(arg);
          }
        }
        return results;
      };
      swizzle.wrap = function(fn) {
        return function() {
          return fn(swizzle(arguments));
        };
      };
    }
  });

  // ../core/node_modules/color-string/index.js
  var require_color_string2 = __commonJS({
    "../core/node_modules/color-string/index.js"(exports, module) {
      var colorNames = require_color_name2();
      var swizzle = require_simple_swizzle2();
      var hasOwnProperty = Object.hasOwnProperty;
      var reverseNames = /* @__PURE__ */ Object.create(null);
      for (name in colorNames) {
        if (hasOwnProperty.call(colorNames, name)) {
          reverseNames[colorNames[name]] = name;
        }
      }
      var name;
      var cs = module.exports = {
        to: {},
        get: {}
      };
      cs.get = function(string) {
        var prefix = string.substring(0, 3).toLowerCase();
        var val;
        var model;
        switch (prefix) {
          case "hsl":
            val = cs.get.hsl(string);
            model = "hsl";
            break;
          case "hwb":
            val = cs.get.hwb(string);
            model = "hwb";
            break;
          default:
            val = cs.get.rgb(string);
            model = "rgb";
            break;
        }
        if (!val) {
          return null;
        }
        return { model, value: val };
      };
      cs.get.rgb = function(string) {
        if (!string) {
          return null;
        }
        var abbr = /^#([a-f0-9]{3,4})$/i;
        var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
        var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
        var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
        var keyword = /^(\w+)$/;
        var rgb = [0, 0, 0, 1];
        var match;
        var i2;
        var hexAlpha;
        if (match = string.match(hex)) {
          hexAlpha = match[2];
          match = match[1];
          for (i2 = 0; i2 < 3; i2++) {
            var i22 = i2 * 2;
            rgb[i2] = parseInt(match.slice(i22, i22 + 2), 16);
          }
          if (hexAlpha) {
            rgb[3] = parseInt(hexAlpha, 16) / 255;
          }
        } else if (match = string.match(abbr)) {
          match = match[1];
          hexAlpha = match[3];
          for (i2 = 0; i2 < 3; i2++) {
            rgb[i2] = parseInt(match[i2] + match[i2], 16);
          }
          if (hexAlpha) {
            rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
          }
        } else if (match = string.match(rgba)) {
          for (i2 = 0; i2 < 3; i2++) {
            rgb[i2] = parseInt(match[i2 + 1], 0);
          }
          if (match[4]) {
            if (match[5]) {
              rgb[3] = parseFloat(match[4]) * 0.01;
            } else {
              rgb[3] = parseFloat(match[4]);
            }
          }
        } else if (match = string.match(per)) {
          for (i2 = 0; i2 < 3; i2++) {
            rgb[i2] = Math.round(parseFloat(match[i2 + 1]) * 2.55);
          }
          if (match[4]) {
            if (match[5]) {
              rgb[3] = parseFloat(match[4]) * 0.01;
            } else {
              rgb[3] = parseFloat(match[4]);
            }
          }
        } else if (match = string.match(keyword)) {
          if (match[1] === "transparent") {
            return [0, 0, 0, 0];
          }
          if (!hasOwnProperty.call(colorNames, match[1])) {
            return null;
          }
          rgb = colorNames[match[1]];
          rgb[3] = 1;
          return rgb;
        } else {
          return null;
        }
        for (i2 = 0; i2 < 3; i2++) {
          rgb[i2] = clamp(rgb[i2], 0, 255);
        }
        rgb[3] = clamp(rgb[3], 0, 1);
        return rgb;
      };
      cs.get.hsl = function(string) {
        if (!string) {
          return null;
        }
        var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
        var match = string.match(hsl);
        if (match) {
          var alpha = parseFloat(match[4]);
          var h2 = (parseFloat(match[1]) % 360 + 360) % 360;
          var s2 = clamp(parseFloat(match[2]), 0, 100);
          var l2 = clamp(parseFloat(match[3]), 0, 100);
          var a2 = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
          return [h2, s2, l2, a2];
        }
        return null;
      };
      cs.get.hwb = function(string) {
        if (!string) {
          return null;
        }
        var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
        var match = string.match(hwb);
        if (match) {
          var alpha = parseFloat(match[4]);
          var h2 = (parseFloat(match[1]) % 360 + 360) % 360;
          var w2 = clamp(parseFloat(match[2]), 0, 100);
          var b2 = clamp(parseFloat(match[3]), 0, 100);
          var a2 = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
          return [h2, w2, b2, a2];
        }
        return null;
      };
      cs.to.hex = function() {
        var rgba = swizzle(arguments);
        return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
      };
      cs.to.rgb = function() {
        var rgba = swizzle(arguments);
        return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
      };
      cs.to.rgb.percent = function() {
        var rgba = swizzle(arguments);
        var r2 = Math.round(rgba[0] / 255 * 100);
        var g2 = Math.round(rgba[1] / 255 * 100);
        var b2 = Math.round(rgba[2] / 255 * 100);
        return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r2 + "%, " + g2 + "%, " + b2 + "%)" : "rgba(" + r2 + "%, " + g2 + "%, " + b2 + "%, " + rgba[3] + ")";
      };
      cs.to.hsl = function() {
        var hsla = swizzle(arguments);
        return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
      };
      cs.to.hwb = function() {
        var hwba = swizzle(arguments);
        var a2 = "";
        if (hwba.length >= 4 && hwba[3] !== 1) {
          a2 = ", " + hwba[3];
        }
        return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a2 + ")";
      };
      cs.to.keyword = function(rgb) {
        return reverseNames[rgb.slice(0, 3)];
      };
      function clamp(num, min, max) {
        return Math.min(Math.max(min, num), max);
      }
      function hexDouble(num) {
        var str = Math.round(num).toString(16).toUpperCase();
        return str.length < 2 ? "0" + str : str;
      }
    }
  });

  // ../core/node_modules/color-convert/conversions.js
  var require_conversions2 = __commonJS({
    "../core/node_modules/color-convert/conversions.js"(exports, module) {
      var cssKeywords = require_color_name2();
      var reverseKeywords = {};
      for (const key of Object.keys(cssKeywords)) {
        reverseKeywords[cssKeywords[key]] = key;
      }
      var convert = {
        rgb: { channels: 3, labels: "rgb" },
        hsl: { channels: 3, labels: "hsl" },
        hsv: { channels: 3, labels: "hsv" },
        hwb: { channels: 3, labels: "hwb" },
        cmyk: { channels: 4, labels: "cmyk" },
        xyz: { channels: 3, labels: "xyz" },
        lab: { channels: 3, labels: "lab" },
        lch: { channels: 3, labels: "lch" },
        hex: { channels: 1, labels: ["hex"] },
        keyword: { channels: 1, labels: ["keyword"] },
        ansi16: { channels: 1, labels: ["ansi16"] },
        ansi256: { channels: 1, labels: ["ansi256"] },
        hcg: { channels: 3, labels: ["h", "c", "g"] },
        apple: { channels: 3, labels: ["r16", "g16", "b16"] },
        gray: { channels: 1, labels: ["gray"] }
      };
      module.exports = convert;
      for (const model of Object.keys(convert)) {
        if (!("channels" in convert[model])) {
          throw new Error("missing channels property: " + model);
        }
        if (!("labels" in convert[model])) {
          throw new Error("missing channel labels property: " + model);
        }
        if (convert[model].labels.length !== convert[model].channels) {
          throw new Error("channel and label counts mismatch: " + model);
        }
        const { channels, labels } = convert[model];
        delete convert[model].channels;
        delete convert[model].labels;
        Object.defineProperty(convert[model], "channels", { value: channels });
        Object.defineProperty(convert[model], "labels", { value: labels });
      }
      convert.rgb.hsl = function(rgb) {
        const r2 = rgb[0] / 255;
        const g2 = rgb[1] / 255;
        const b2 = rgb[2] / 255;
        const min = Math.min(r2, g2, b2);
        const max = Math.max(r2, g2, b2);
        const delta = max - min;
        let h2;
        let s2;
        if (max === min) {
          h2 = 0;
        } else if (r2 === max) {
          h2 = (g2 - b2) / delta;
        } else if (g2 === max) {
          h2 = 2 + (b2 - r2) / delta;
        } else if (b2 === max) {
          h2 = 4 + (r2 - g2) / delta;
        }
        h2 = Math.min(h2 * 60, 360);
        if (h2 < 0) {
          h2 += 360;
        }
        const l2 = (min + max) / 2;
        if (max === min) {
          s2 = 0;
        } else if (l2 <= 0.5) {
          s2 = delta / (max + min);
        } else {
          s2 = delta / (2 - max - min);
        }
        return [h2, s2 * 100, l2 * 100];
      };
      convert.rgb.hsv = function(rgb) {
        let rdif;
        let gdif;
        let bdif;
        let h2;
        let s2;
        const r2 = rgb[0] / 255;
        const g2 = rgb[1] / 255;
        const b2 = rgb[2] / 255;
        const v2 = Math.max(r2, g2, b2);
        const diff = v2 - Math.min(r2, g2, b2);
        const diffc = function(c2) {
          return (v2 - c2) / 6 / diff + 1 / 2;
        };
        if (diff === 0) {
          h2 = 0;
          s2 = 0;
        } else {
          s2 = diff / v2;
          rdif = diffc(r2);
          gdif = diffc(g2);
          bdif = diffc(b2);
          if (r2 === v2) {
            h2 = bdif - gdif;
          } else if (g2 === v2) {
            h2 = 1 / 3 + rdif - bdif;
          } else if (b2 === v2) {
            h2 = 2 / 3 + gdif - rdif;
          }
          if (h2 < 0) {
            h2 += 1;
          } else if (h2 > 1) {
            h2 -= 1;
          }
        }
        return [
          h2 * 360,
          s2 * 100,
          v2 * 100
        ];
      };
      convert.rgb.hwb = function(rgb) {
        const r2 = rgb[0];
        const g2 = rgb[1];
        let b2 = rgb[2];
        const h2 = convert.rgb.hsl(rgb)[0];
        const w2 = 1 / 255 * Math.min(r2, Math.min(g2, b2));
        b2 = 1 - 1 / 255 * Math.max(r2, Math.max(g2, b2));
        return [h2, w2 * 100, b2 * 100];
      };
      convert.rgb.cmyk = function(rgb) {
        const r2 = rgb[0] / 255;
        const g2 = rgb[1] / 255;
        const b2 = rgb[2] / 255;
        const k2 = Math.min(1 - r2, 1 - g2, 1 - b2);
        const c2 = (1 - r2 - k2) / (1 - k2) || 0;
        const m2 = (1 - g2 - k2) / (1 - k2) || 0;
        const y2 = (1 - b2 - k2) / (1 - k2) || 0;
        return [c2 * 100, m2 * 100, y2 * 100, k2 * 100];
      };
      function comparativeDistance(x2, y2) {
        return (x2[0] - y2[0]) ** 2 + (x2[1] - y2[1]) ** 2 + (x2[2] - y2[2]) ** 2;
      }
      convert.rgb.keyword = function(rgb) {
        const reversed = reverseKeywords[rgb];
        if (reversed) {
          return reversed;
        }
        let currentClosestDistance = Infinity;
        let currentClosestKeyword;
        for (const keyword of Object.keys(cssKeywords)) {
          const value = cssKeywords[keyword];
          const distance = comparativeDistance(rgb, value);
          if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
          }
        }
        return currentClosestKeyword;
      };
      convert.keyword.rgb = function(keyword) {
        return cssKeywords[keyword];
      };
      convert.rgb.xyz = function(rgb) {
        let r2 = rgb[0] / 255;
        let g2 = rgb[1] / 255;
        let b2 = rgb[2] / 255;
        r2 = r2 > 0.04045 ? ((r2 + 0.055) / 1.055) ** 2.4 : r2 / 12.92;
        g2 = g2 > 0.04045 ? ((g2 + 0.055) / 1.055) ** 2.4 : g2 / 12.92;
        b2 = b2 > 0.04045 ? ((b2 + 0.055) / 1.055) ** 2.4 : b2 / 12.92;
        const x2 = r2 * 0.4124 + g2 * 0.3576 + b2 * 0.1805;
        const y2 = r2 * 0.2126 + g2 * 0.7152 + b2 * 0.0722;
        const z = r2 * 0.0193 + g2 * 0.1192 + b2 * 0.9505;
        return [x2 * 100, y2 * 100, z * 100];
      };
      convert.rgb.lab = function(rgb) {
        const xyz = convert.rgb.xyz(rgb);
        let x2 = xyz[0];
        let y2 = xyz[1];
        let z = xyz[2];
        x2 /= 95.047;
        y2 /= 100;
        z /= 108.883;
        x2 = x2 > 8856e-6 ? x2 ** (1 / 3) : 7.787 * x2 + 16 / 116;
        y2 = y2 > 8856e-6 ? y2 ** (1 / 3) : 7.787 * y2 + 16 / 116;
        z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
        const l2 = 116 * y2 - 16;
        const a2 = 500 * (x2 - y2);
        const b2 = 200 * (y2 - z);
        return [l2, a2, b2];
      };
      convert.hsl.rgb = function(hsl) {
        const h2 = hsl[0] / 360;
        const s2 = hsl[1] / 100;
        const l2 = hsl[2] / 100;
        let t2;
        let t3;
        let val;
        if (s2 === 0) {
          val = l2 * 255;
          return [val, val, val];
        }
        if (l2 < 0.5) {
          t2 = l2 * (1 + s2);
        } else {
          t2 = l2 + s2 - l2 * s2;
        }
        const t1 = 2 * l2 - t2;
        const rgb = [0, 0, 0];
        for (let i2 = 0; i2 < 3; i2++) {
          t3 = h2 + 1 / 3 * -(i2 - 1);
          if (t3 < 0) {
            t3++;
          }
          if (t3 > 1) {
            t3--;
          }
          if (6 * t3 < 1) {
            val = t1 + (t2 - t1) * 6 * t3;
          } else if (2 * t3 < 1) {
            val = t2;
          } else if (3 * t3 < 2) {
            val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
          } else {
            val = t1;
          }
          rgb[i2] = val * 255;
        }
        return rgb;
      };
      convert.hsl.hsv = function(hsl) {
        const h2 = hsl[0];
        let s2 = hsl[1] / 100;
        let l2 = hsl[2] / 100;
        let smin = s2;
        const lmin = Math.max(l2, 0.01);
        l2 *= 2;
        s2 *= l2 <= 1 ? l2 : 2 - l2;
        smin *= lmin <= 1 ? lmin : 2 - lmin;
        const v2 = (l2 + s2) / 2;
        const sv = l2 === 0 ? 2 * smin / (lmin + smin) : 2 * s2 / (l2 + s2);
        return [h2, sv * 100, v2 * 100];
      };
      convert.hsv.rgb = function(hsv) {
        const h2 = hsv[0] / 60;
        const s2 = hsv[1] / 100;
        let v2 = hsv[2] / 100;
        const hi = Math.floor(h2) % 6;
        const f2 = h2 - Math.floor(h2);
        const p2 = 255 * v2 * (1 - s2);
        const q = 255 * v2 * (1 - s2 * f2);
        const t2 = 255 * v2 * (1 - s2 * (1 - f2));
        v2 *= 255;
        switch (hi) {
          case 0:
            return [v2, t2, p2];
          case 1:
            return [q, v2, p2];
          case 2:
            return [p2, v2, t2];
          case 3:
            return [p2, q, v2];
          case 4:
            return [t2, p2, v2];
          case 5:
            return [v2, p2, q];
        }
      };
      convert.hsv.hsl = function(hsv) {
        const h2 = hsv[0];
        const s2 = hsv[1] / 100;
        const v2 = hsv[2] / 100;
        const vmin = Math.max(v2, 0.01);
        let sl;
        let l2;
        l2 = (2 - s2) * v2;
        const lmin = (2 - s2) * vmin;
        sl = s2 * vmin;
        sl /= lmin <= 1 ? lmin : 2 - lmin;
        sl = sl || 0;
        l2 /= 2;
        return [h2, sl * 100, l2 * 100];
      };
      convert.hwb.rgb = function(hwb) {
        const h2 = hwb[0] / 360;
        let wh = hwb[1] / 100;
        let bl = hwb[2] / 100;
        const ratio = wh + bl;
        let f2;
        if (ratio > 1) {
          wh /= ratio;
          bl /= ratio;
        }
        const i2 = Math.floor(6 * h2);
        const v2 = 1 - bl;
        f2 = 6 * h2 - i2;
        if ((i2 & 1) !== 0) {
          f2 = 1 - f2;
        }
        const n2 = wh + f2 * (v2 - wh);
        let r2;
        let g2;
        let b2;
        switch (i2) {
          default:
          case 6:
          case 0:
            r2 = v2;
            g2 = n2;
            b2 = wh;
            break;
          case 1:
            r2 = n2;
            g2 = v2;
            b2 = wh;
            break;
          case 2:
            r2 = wh;
            g2 = v2;
            b2 = n2;
            break;
          case 3:
            r2 = wh;
            g2 = n2;
            b2 = v2;
            break;
          case 4:
            r2 = n2;
            g2 = wh;
            b2 = v2;
            break;
          case 5:
            r2 = v2;
            g2 = wh;
            b2 = n2;
            break;
        }
        return [r2 * 255, g2 * 255, b2 * 255];
      };
      convert.cmyk.rgb = function(cmyk) {
        const c2 = cmyk[0] / 100;
        const m2 = cmyk[1] / 100;
        const y2 = cmyk[2] / 100;
        const k2 = cmyk[3] / 100;
        const r2 = 1 - Math.min(1, c2 * (1 - k2) + k2);
        const g2 = 1 - Math.min(1, m2 * (1 - k2) + k2);
        const b2 = 1 - Math.min(1, y2 * (1 - k2) + k2);
        return [r2 * 255, g2 * 255, b2 * 255];
      };
      convert.xyz.rgb = function(xyz) {
        const x2 = xyz[0] / 100;
        const y2 = xyz[1] / 100;
        const z = xyz[2] / 100;
        let r2;
        let g2;
        let b2;
        r2 = x2 * 3.2406 + y2 * -1.5372 + z * -0.4986;
        g2 = x2 * -0.9689 + y2 * 1.8758 + z * 0.0415;
        b2 = x2 * 0.0557 + y2 * -0.204 + z * 1.057;
        r2 = r2 > 31308e-7 ? 1.055 * r2 ** (1 / 2.4) - 0.055 : r2 * 12.92;
        g2 = g2 > 31308e-7 ? 1.055 * g2 ** (1 / 2.4) - 0.055 : g2 * 12.92;
        b2 = b2 > 31308e-7 ? 1.055 * b2 ** (1 / 2.4) - 0.055 : b2 * 12.92;
        r2 = Math.min(Math.max(0, r2), 1);
        g2 = Math.min(Math.max(0, g2), 1);
        b2 = Math.min(Math.max(0, b2), 1);
        return [r2 * 255, g2 * 255, b2 * 255];
      };
      convert.xyz.lab = function(xyz) {
        let x2 = xyz[0];
        let y2 = xyz[1];
        let z = xyz[2];
        x2 /= 95.047;
        y2 /= 100;
        z /= 108.883;
        x2 = x2 > 8856e-6 ? x2 ** (1 / 3) : 7.787 * x2 + 16 / 116;
        y2 = y2 > 8856e-6 ? y2 ** (1 / 3) : 7.787 * y2 + 16 / 116;
        z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
        const l2 = 116 * y2 - 16;
        const a2 = 500 * (x2 - y2);
        const b2 = 200 * (y2 - z);
        return [l2, a2, b2];
      };
      convert.lab.xyz = function(lab) {
        const l2 = lab[0];
        const a2 = lab[1];
        const b2 = lab[2];
        let x2;
        let y2;
        let z;
        y2 = (l2 + 16) / 116;
        x2 = a2 / 500 + y2;
        z = y2 - b2 / 200;
        const y22 = y2 ** 3;
        const x22 = x2 ** 3;
        const z2 = z ** 3;
        y2 = y22 > 8856e-6 ? y22 : (y2 - 16 / 116) / 7.787;
        x2 = x22 > 8856e-6 ? x22 : (x2 - 16 / 116) / 7.787;
        z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
        x2 *= 95.047;
        y2 *= 100;
        z *= 108.883;
        return [x2, y2, z];
      };
      convert.lab.lch = function(lab) {
        const l2 = lab[0];
        const a2 = lab[1];
        const b2 = lab[2];
        let h2;
        const hr = Math.atan2(b2, a2);
        h2 = hr * 360 / 2 / Math.PI;
        if (h2 < 0) {
          h2 += 360;
        }
        const c2 = Math.sqrt(a2 * a2 + b2 * b2);
        return [l2, c2, h2];
      };
      convert.lch.lab = function(lch) {
        const l2 = lch[0];
        const c2 = lch[1];
        const h2 = lch[2];
        const hr = h2 / 360 * 2 * Math.PI;
        const a2 = c2 * Math.cos(hr);
        const b2 = c2 * Math.sin(hr);
        return [l2, a2, b2];
      };
      convert.rgb.ansi16 = function(args, saturation = null) {
        const [r2, g2, b2] = args;
        let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
        value = Math.round(value / 50);
        if (value === 0) {
          return 30;
        }
        let ansi = 30 + (Math.round(b2 / 255) << 2 | Math.round(g2 / 255) << 1 | Math.round(r2 / 255));
        if (value === 2) {
          ansi += 60;
        }
        return ansi;
      };
      convert.hsv.ansi16 = function(args) {
        return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
      };
      convert.rgb.ansi256 = function(args) {
        const r2 = args[0];
        const g2 = args[1];
        const b2 = args[2];
        if (r2 === g2 && g2 === b2) {
          if (r2 < 8) {
            return 16;
          }
          if (r2 > 248) {
            return 231;
          }
          return Math.round((r2 - 8) / 247 * 24) + 232;
        }
        const ansi = 16 + 36 * Math.round(r2 / 255 * 5) + 6 * Math.round(g2 / 255 * 5) + Math.round(b2 / 255 * 5);
        return ansi;
      };
      convert.ansi16.rgb = function(args) {
        let color3 = args % 10;
        if (color3 === 0 || color3 === 7) {
          if (args > 50) {
            color3 += 3.5;
          }
          color3 = color3 / 10.5 * 255;
          return [color3, color3, color3];
        }
        const mult = (~~(args > 50) + 1) * 0.5;
        const r2 = (color3 & 1) * mult * 255;
        const g2 = (color3 >> 1 & 1) * mult * 255;
        const b2 = (color3 >> 2 & 1) * mult * 255;
        return [r2, g2, b2];
      };
      convert.ansi256.rgb = function(args) {
        if (args >= 232) {
          const c2 = (args - 232) * 10 + 8;
          return [c2, c2, c2];
        }
        args -= 16;
        let rem;
        const r2 = Math.floor(args / 36) / 5 * 255;
        const g2 = Math.floor((rem = args % 36) / 6) / 5 * 255;
        const b2 = rem % 6 / 5 * 255;
        return [r2, g2, b2];
      };
      convert.rgb.hex = function(args) {
        const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
        const string = integer.toString(16).toUpperCase();
        return "000000".substring(string.length) + string;
      };
      convert.hex.rgb = function(args) {
        const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
        if (!match) {
          return [0, 0, 0];
        }
        let colorString = match[0];
        if (match[0].length === 3) {
          colorString = colorString.split("").map((char) => {
            return char + char;
          }).join("");
        }
        const integer = parseInt(colorString, 16);
        const r2 = integer >> 16 & 255;
        const g2 = integer >> 8 & 255;
        const b2 = integer & 255;
        return [r2, g2, b2];
      };
      convert.rgb.hcg = function(rgb) {
        const r2 = rgb[0] / 255;
        const g2 = rgb[1] / 255;
        const b2 = rgb[2] / 255;
        const max = Math.max(Math.max(r2, g2), b2);
        const min = Math.min(Math.min(r2, g2), b2);
        const chroma = max - min;
        let grayscale;
        let hue;
        if (chroma < 1) {
          grayscale = min / (1 - chroma);
        } else {
          grayscale = 0;
        }
        if (chroma <= 0) {
          hue = 0;
        } else if (max === r2) {
          hue = (g2 - b2) / chroma % 6;
        } else if (max === g2) {
          hue = 2 + (b2 - r2) / chroma;
        } else {
          hue = 4 + (r2 - g2) / chroma;
        }
        hue /= 6;
        hue %= 1;
        return [hue * 360, chroma * 100, grayscale * 100];
      };
      convert.hsl.hcg = function(hsl) {
        const s2 = hsl[1] / 100;
        const l2 = hsl[2] / 100;
        const c2 = l2 < 0.5 ? 2 * s2 * l2 : 2 * s2 * (1 - l2);
        let f2 = 0;
        if (c2 < 1) {
          f2 = (l2 - 0.5 * c2) / (1 - c2);
        }
        return [hsl[0], c2 * 100, f2 * 100];
      };
      convert.hsv.hcg = function(hsv) {
        const s2 = hsv[1] / 100;
        const v2 = hsv[2] / 100;
        const c2 = s2 * v2;
        let f2 = 0;
        if (c2 < 1) {
          f2 = (v2 - c2) / (1 - c2);
        }
        return [hsv[0], c2 * 100, f2 * 100];
      };
      convert.hcg.rgb = function(hcg) {
        const h2 = hcg[0] / 360;
        const c2 = hcg[1] / 100;
        const g2 = hcg[2] / 100;
        if (c2 === 0) {
          return [g2 * 255, g2 * 255, g2 * 255];
        }
        const pure = [0, 0, 0];
        const hi = h2 % 1 * 6;
        const v2 = hi % 1;
        const w2 = 1 - v2;
        let mg = 0;
        switch (Math.floor(hi)) {
          case 0:
            pure[0] = 1;
            pure[1] = v2;
            pure[2] = 0;
            break;
          case 1:
            pure[0] = w2;
            pure[1] = 1;
            pure[2] = 0;
            break;
          case 2:
            pure[0] = 0;
            pure[1] = 1;
            pure[2] = v2;
            break;
          case 3:
            pure[0] = 0;
            pure[1] = w2;
            pure[2] = 1;
            break;
          case 4:
            pure[0] = v2;
            pure[1] = 0;
            pure[2] = 1;
            break;
          default:
            pure[0] = 1;
            pure[1] = 0;
            pure[2] = w2;
        }
        mg = (1 - c2) * g2;
        return [
          (c2 * pure[0] + mg) * 255,
          (c2 * pure[1] + mg) * 255,
          (c2 * pure[2] + mg) * 255
        ];
      };
      convert.hcg.hsv = function(hcg) {
        const c2 = hcg[1] / 100;
        const g2 = hcg[2] / 100;
        const v2 = c2 + g2 * (1 - c2);
        let f2 = 0;
        if (v2 > 0) {
          f2 = c2 / v2;
        }
        return [hcg[0], f2 * 100, v2 * 100];
      };
      convert.hcg.hsl = function(hcg) {
        const c2 = hcg[1] / 100;
        const g2 = hcg[2] / 100;
        const l2 = g2 * (1 - c2) + 0.5 * c2;
        let s2 = 0;
        if (l2 > 0 && l2 < 0.5) {
          s2 = c2 / (2 * l2);
        } else if (l2 >= 0.5 && l2 < 1) {
          s2 = c2 / (2 * (1 - l2));
        }
        return [hcg[0], s2 * 100, l2 * 100];
      };
      convert.hcg.hwb = function(hcg) {
        const c2 = hcg[1] / 100;
        const g2 = hcg[2] / 100;
        const v2 = c2 + g2 * (1 - c2);
        return [hcg[0], (v2 - c2) * 100, (1 - v2) * 100];
      };
      convert.hwb.hcg = function(hwb) {
        const w2 = hwb[1] / 100;
        const b2 = hwb[2] / 100;
        const v2 = 1 - b2;
        const c2 = v2 - w2;
        let g2 = 0;
        if (c2 < 1) {
          g2 = (v2 - c2) / (1 - c2);
        }
        return [hwb[0], c2 * 100, g2 * 100];
      };
      convert.apple.rgb = function(apple) {
        return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
      };
      convert.rgb.apple = function(rgb) {
        return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
      };
      convert.gray.rgb = function(args) {
        return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
      };
      convert.gray.hsl = function(args) {
        return [0, 0, args[0]];
      };
      convert.gray.hsv = convert.gray.hsl;
      convert.gray.hwb = function(gray) {
        return [0, 100, gray[0]];
      };
      convert.gray.cmyk = function(gray) {
        return [0, 0, 0, gray[0]];
      };
      convert.gray.lab = function(gray) {
        return [gray[0], 0, 0];
      };
      convert.gray.hex = function(gray) {
        const val = Math.round(gray[0] / 100 * 255) & 255;
        const integer = (val << 16) + (val << 8) + val;
        const string = integer.toString(16).toUpperCase();
        return "000000".substring(string.length) + string;
      };
      convert.rgb.gray = function(rgb) {
        const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
        return [val / 255 * 100];
      };
    }
  });

  // ../core/node_modules/color-convert/route.js
  var require_route2 = __commonJS({
    "../core/node_modules/color-convert/route.js"(exports, module) {
      var conversions = require_conversions2();
      function buildGraph() {
        const graph = {};
        const models = Object.keys(conversions);
        for (let len = models.length, i2 = 0; i2 < len; i2++) {
          graph[models[i2]] = {
            // http://jsperf.com/1-vs-infinity
            // micro-opt, but this is simple.
            distance: -1,
            parent: null
          };
        }
        return graph;
      }
      function deriveBFS(fromModel) {
        const graph = buildGraph();
        const queue = [fromModel];
        graph[fromModel].distance = 0;
        while (queue.length) {
          const current = queue.pop();
          const adjacents = Object.keys(conversions[current]);
          for (let len = adjacents.length, i2 = 0; i2 < len; i2++) {
            const adjacent = adjacents[i2];
            const node = graph[adjacent];
            if (node.distance === -1) {
              node.distance = graph[current].distance + 1;
              node.parent = current;
              queue.unshift(adjacent);
            }
          }
        }
        return graph;
      }
      function link(from3, to) {
        return function(args) {
          return to(from3(args));
        };
      }
      function wrapConversion(toModel, graph) {
        const path2 = [graph[toModel].parent, toModel];
        let fn = conversions[graph[toModel].parent][toModel];
        let cur = graph[toModel].parent;
        while (graph[cur].parent) {
          path2.unshift(graph[cur].parent);
          fn = link(conversions[graph[cur].parent][cur], fn);
          cur = graph[cur].parent;
        }
        fn.conversion = path2;
        return fn;
      }
      module.exports = function(fromModel) {
        const graph = deriveBFS(fromModel);
        const conversion = {};
        const models = Object.keys(graph);
        for (let len = models.length, i2 = 0; i2 < len; i2++) {
          const toModel = models[i2];
          const node = graph[toModel];
          if (node.parent === null) {
            continue;
          }
          conversion[toModel] = wrapConversion(toModel, graph);
        }
        return conversion;
      };
    }
  });

  // ../core/node_modules/color-convert/index.js
  var require_color_convert2 = __commonJS({
    "../core/node_modules/color-convert/index.js"(exports, module) {
      var conversions = require_conversions2();
      var route = require_route2();
      var convert = {};
      var models = Object.keys(conversions);
      function wrapRaw(fn) {
        const wrappedFn = function(...args) {
          const arg0 = args[0];
          if (arg0 === void 0 || arg0 === null) {
            return arg0;
          }
          if (arg0.length > 1) {
            args = arg0;
          }
          return fn(args);
        };
        if ("conversion" in fn) {
          wrappedFn.conversion = fn.conversion;
        }
        return wrappedFn;
      }
      function wrapRounded(fn) {
        const wrappedFn = function(...args) {
          const arg0 = args[0];
          if (arg0 === void 0 || arg0 === null) {
            return arg0;
          }
          if (arg0.length > 1) {
            args = arg0;
          }
          const result = fn(args);
          if (typeof result === "object") {
            for (let len = result.length, i2 = 0; i2 < len; i2++) {
              result[i2] = Math.round(result[i2]);
            }
          }
          return result;
        };
        if ("conversion" in fn) {
          wrappedFn.conversion = fn.conversion;
        }
        return wrappedFn;
      }
      models.forEach((fromModel) => {
        convert[fromModel] = {};
        Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
        Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
        const routes = route(fromModel);
        const routeModels = Object.keys(routes);
        routeModels.forEach((toModel) => {
          const fn = routes[toModel];
          convert[fromModel][toModel] = wrapRounded(fn);
          convert[fromModel][toModel].raw = wrapRaw(fn);
        });
      });
      module.exports = convert;
    }
  });

  // ../core/node_modules/color/index.js
  var require_color2 = __commonJS({
    "../core/node_modules/color/index.js"(exports, module) {
      var colorString = require_color_string2();
      var convert = require_color_convert2();
      var skippedModels = [
        // To be honest, I don't really feel like keyword belongs in color convert, but eh.
        "keyword",
        // Gray conflicts with some method names, and has its own method defined.
        "gray",
        // Shouldn't really be in color-convert either...
        "hex"
      ];
      var hashedModelKeys = {};
      for (const model of Object.keys(convert)) {
        hashedModelKeys[[...convert[model].labels].sort().join("")] = model;
      }
      var limiters = {};
      function Color2(object, model) {
        if (!(this instanceof Color2)) {
          return new Color2(object, model);
        }
        if (model && model in skippedModels) {
          model = null;
        }
        if (model && !(model in convert)) {
          throw new Error("Unknown model: " + model);
        }
        let i2;
        let channels;
        if (object == null) {
          this.model = "rgb";
          this.color = [0, 0, 0];
          this.valpha = 1;
        } else if (object instanceof Color2) {
          this.model = object.model;
          this.color = [...object.color];
          this.valpha = object.valpha;
        } else if (typeof object === "string") {
          const result = colorString.get(object);
          if (result === null) {
            throw new Error("Unable to parse color from string: " + object);
          }
          this.model = result.model;
          channels = convert[this.model].channels;
          this.color = result.value.slice(0, channels);
          this.valpha = typeof result.value[channels] === "number" ? result.value[channels] : 1;
        } else if (object.length > 0) {
          this.model = model || "rgb";
          channels = convert[this.model].channels;
          const newArray = Array.prototype.slice.call(object, 0, channels);
          this.color = zeroArray(newArray, channels);
          this.valpha = typeof object[channels] === "number" ? object[channels] : 1;
        } else if (typeof object === "number") {
          this.model = "rgb";
          this.color = [
            object >> 16 & 255,
            object >> 8 & 255,
            object & 255
          ];
          this.valpha = 1;
        } else {
          this.valpha = 1;
          const keys = Object.keys(object);
          if ("alpha" in object) {
            keys.splice(keys.indexOf("alpha"), 1);
            this.valpha = typeof object.alpha === "number" ? object.alpha : 0;
          }
          const hashedKeys = keys.sort().join("");
          if (!(hashedKeys in hashedModelKeys)) {
            throw new Error("Unable to parse color from object: " + JSON.stringify(object));
          }
          this.model = hashedModelKeys[hashedKeys];
          const { labels } = convert[this.model];
          const color3 = [];
          for (i2 = 0; i2 < labels.length; i2++) {
            color3.push(object[labels[i2]]);
          }
          this.color = zeroArray(color3);
        }
        if (limiters[this.model]) {
          channels = convert[this.model].channels;
          for (i2 = 0; i2 < channels; i2++) {
            const limit = limiters[this.model][i2];
            if (limit) {
              this.color[i2] = limit(this.color[i2]);
            }
          }
        }
        this.valpha = Math.max(0, Math.min(1, this.valpha));
        if (Object.freeze) {
          Object.freeze(this);
        }
      }
      Color2.prototype = {
        toString() {
          return this.string();
        },
        toJSON() {
          return this[this.model]();
        },
        string(places) {
          let self2 = this.model in colorString.to ? this : this.rgb();
          self2 = self2.round(typeof places === "number" ? places : 1);
          const args = self2.valpha === 1 ? self2.color : [...self2.color, this.valpha];
          return colorString.to[self2.model](args);
        },
        percentString(places) {
          const self2 = this.rgb().round(typeof places === "number" ? places : 1);
          const args = self2.valpha === 1 ? self2.color : [...self2.color, this.valpha];
          return colorString.to.rgb.percent(args);
        },
        array() {
          return this.valpha === 1 ? [...this.color] : [...this.color, this.valpha];
        },
        object() {
          const result = {};
          const { channels } = convert[this.model];
          const { labels } = convert[this.model];
          for (let i2 = 0; i2 < channels; i2++) {
            result[labels[i2]] = this.color[i2];
          }
          if (this.valpha !== 1) {
            result.alpha = this.valpha;
          }
          return result;
        },
        unitArray() {
          const rgb = this.rgb().color;
          rgb[0] /= 255;
          rgb[1] /= 255;
          rgb[2] /= 255;
          if (this.valpha !== 1) {
            rgb.push(this.valpha);
          }
          return rgb;
        },
        unitObject() {
          const rgb = this.rgb().object();
          rgb.r /= 255;
          rgb.g /= 255;
          rgb.b /= 255;
          if (this.valpha !== 1) {
            rgb.alpha = this.valpha;
          }
          return rgb;
        },
        round(places) {
          places = Math.max(places || 0, 0);
          return new Color2([...this.color.map(roundToPlace(places)), this.valpha], this.model);
        },
        alpha(value) {
          if (value !== void 0) {
            return new Color2([...this.color, Math.max(0, Math.min(1, value))], this.model);
          }
          return this.valpha;
        },
        // Rgb
        red: getset("rgb", 0, maxfn(255)),
        green: getset("rgb", 1, maxfn(255)),
        blue: getset("rgb", 2, maxfn(255)),
        hue: getset(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, (value) => (value % 360 + 360) % 360),
        saturationl: getset("hsl", 1, maxfn(100)),
        lightness: getset("hsl", 2, maxfn(100)),
        saturationv: getset("hsv", 1, maxfn(100)),
        value: getset("hsv", 2, maxfn(100)),
        chroma: getset("hcg", 1, maxfn(100)),
        gray: getset("hcg", 2, maxfn(100)),
        white: getset("hwb", 1, maxfn(100)),
        wblack: getset("hwb", 2, maxfn(100)),
        cyan: getset("cmyk", 0, maxfn(100)),
        magenta: getset("cmyk", 1, maxfn(100)),
        yellow: getset("cmyk", 2, maxfn(100)),
        black: getset("cmyk", 3, maxfn(100)),
        x: getset("xyz", 0, maxfn(95.047)),
        y: getset("xyz", 1, maxfn(100)),
        z: getset("xyz", 2, maxfn(108.833)),
        l: getset("lab", 0, maxfn(100)),
        a: getset("lab", 1),
        b: getset("lab", 2),
        keyword(value) {
          if (value !== void 0) {
            return new Color2(value);
          }
          return convert[this.model].keyword(this.color);
        },
        hex(value) {
          if (value !== void 0) {
            return new Color2(value);
          }
          return colorString.to.hex(this.rgb().round().color);
        },
        hexa(value) {
          if (value !== void 0) {
            return new Color2(value);
          }
          const rgbArray = this.rgb().round().color;
          let alphaHex = Math.round(this.valpha * 255).toString(16).toUpperCase();
          if (alphaHex.length === 1) {
            alphaHex = "0" + alphaHex;
          }
          return colorString.to.hex(rgbArray) + alphaHex;
        },
        rgbNumber() {
          const rgb = this.rgb().color;
          return (rgb[0] & 255) << 16 | (rgb[1] & 255) << 8 | rgb[2] & 255;
        },
        luminosity() {
          const rgb = this.rgb().color;
          const lum = [];
          for (const [i2, element2] of rgb.entries()) {
            const chan = element2 / 255;
            lum[i2] = chan <= 0.04045 ? chan / 12.92 : ((chan + 0.055) / 1.055) ** 2.4;
          }
          return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
        },
        contrast(color22) {
          const lum1 = this.luminosity();
          const lum2 = color22.luminosity();
          if (lum1 > lum2) {
            return (lum1 + 0.05) / (lum2 + 0.05);
          }
          return (lum2 + 0.05) / (lum1 + 0.05);
        },
        level(color22) {
          const contrastRatio = this.contrast(color22);
          if (contrastRatio >= 7) {
            return "AAA";
          }
          return contrastRatio >= 4.5 ? "AA" : "";
        },
        isDark() {
          const rgb = this.rgb().color;
          const yiq = (rgb[0] * 2126 + rgb[1] * 7152 + rgb[2] * 722) / 1e4;
          return yiq < 128;
        },
        isLight() {
          return !this.isDark();
        },
        negate() {
          const rgb = this.rgb();
          for (let i2 = 0; i2 < 3; i2++) {
            rgb.color[i2] = 255 - rgb.color[i2];
          }
          return rgb;
        },
        lighten(ratio) {
          const hsl = this.hsl();
          hsl.color[2] += hsl.color[2] * ratio;
          return hsl;
        },
        darken(ratio) {
          const hsl = this.hsl();
          hsl.color[2] -= hsl.color[2] * ratio;
          return hsl;
        },
        saturate(ratio) {
          const hsl = this.hsl();
          hsl.color[1] += hsl.color[1] * ratio;
          return hsl;
        },
        desaturate(ratio) {
          const hsl = this.hsl();
          hsl.color[1] -= hsl.color[1] * ratio;
          return hsl;
        },
        whiten(ratio) {
          const hwb = this.hwb();
          hwb.color[1] += hwb.color[1] * ratio;
          return hwb;
        },
        blacken(ratio) {
          const hwb = this.hwb();
          hwb.color[2] += hwb.color[2] * ratio;
          return hwb;
        },
        grayscale() {
          const rgb = this.rgb().color;
          const value = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
          return Color2.rgb(value, value, value);
        },
        fade(ratio) {
          return this.alpha(this.valpha - this.valpha * ratio);
        },
        opaquer(ratio) {
          return this.alpha(this.valpha + this.valpha * ratio);
        },
        rotate(degrees) {
          const hsl = this.hsl();
          let hue = hsl.color[0];
          hue = (hue + degrees) % 360;
          hue = hue < 0 ? 360 + hue : hue;
          hsl.color[0] = hue;
          return hsl;
        },
        mix(mixinColor, weight) {
          if (!mixinColor || !mixinColor.rgb) {
            throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
          }
          const color1 = mixinColor.rgb();
          const color22 = this.rgb();
          const p2 = weight === void 0 ? 0.5 : weight;
          const w2 = 2 * p2 - 1;
          const a2 = color1.alpha() - color22.alpha();
          const w1 = ((w2 * a2 === -1 ? w2 : (w2 + a2) / (1 + w2 * a2)) + 1) / 2;
          const w22 = 1 - w1;
          return Color2.rgb(
            w1 * color1.red() + w22 * color22.red(),
            w1 * color1.green() + w22 * color22.green(),
            w1 * color1.blue() + w22 * color22.blue(),
            color1.alpha() * p2 + color22.alpha() * (1 - p2)
          );
        }
      };
      for (const model of Object.keys(convert)) {
        if (skippedModels.includes(model)) {
          continue;
        }
        const { channels } = convert[model];
        Color2.prototype[model] = function(...args) {
          if (this.model === model) {
            return new Color2(this);
          }
          if (args.length > 0) {
            return new Color2(args, model);
          }
          return new Color2([...assertArray(convert[this.model][model].raw(this.color)), this.valpha], model);
        };
        Color2[model] = function(...args) {
          let color3 = args[0];
          if (typeof color3 === "number") {
            color3 = zeroArray(args, channels);
          }
          return new Color2(color3, model);
        };
      }
      function roundTo(number, places) {
        return Number(number.toFixed(places));
      }
      function roundToPlace(places) {
        return function(number) {
          return roundTo(number, places);
        };
      }
      function getset(model, channel, modifier) {
        model = Array.isArray(model) ? model : [model];
        for (const m2 of model) {
          (limiters[m2] || (limiters[m2] = []))[channel] = modifier;
        }
        model = model[0];
        return function(value) {
          let result;
          if (value !== void 0) {
            if (modifier) {
              value = modifier(value);
            }
            result = this[model]();
            result.color[channel] = value;
            return result;
          }
          result = this[model]().color[channel];
          if (modifier) {
            result = modifier(result);
          }
          return result;
        };
      }
      function maxfn(max) {
        return function(v2) {
          return Math.max(0, Math.min(max, v2));
        };
      }
      function assertArray(value) {
        return Array.isArray(value) ? value : [value];
      }
      function zeroArray(array, length) {
        for (let i2 = 0; i2 < length; i2++) {
          if (typeof array[i2] !== "number") {
            array[i2] = 0;
          }
        }
        return array;
      }
      module.exports = Color2;
    }
  });

  // ../core/node_modules/svelte/src/runtime/internal/utils.js
  function noop() {
  }
  function run(fn) {
    return fn();
  }
  function blank_object() {
    return /* @__PURE__ */ Object.create(null);
  }
  function run_all(fns) {
    fns.forEach(run);
  }
  function is_function(thing) {
    return typeof thing === "function";
  }
  function safe_not_equal(a2, b2) {
    return a2 != a2 ? b2 == b2 : a2 !== b2 || a2 && typeof a2 === "object" || typeof a2 === "function";
  }
  function is_empty(obj) {
    return Object.keys(obj).length === 0;
  }

  // ../core/node_modules/svelte/src/runtime/internal/globals.js
  var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
    // @ts-ignore Node typings have this
    global
  );

  // ../core/node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js
  var ResizeObserverSingleton = class {
    /**
     * @private
     * @readonly
     * @type {WeakMap<Element, import('./private.js').Listener>}
     */
    _listeners = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;
    /**
     * @private
     * @type {ResizeObserver}
     */
    _observer = void 0;
    /** @type {ResizeObserverOptions} */
    options;
    /** @param {ResizeObserverOptions} options */
    constructor(options) {
      this.options = options;
    }
    /**
     * @param {Element} element
     * @param {import('./private.js').Listener} listener
     * @returns {() => void}
     */
    observe(element2, listener) {
      this._listeners.set(element2, listener);
      this._getObserver().observe(element2, this.options);
      return () => {
        this._listeners.delete(element2);
        this._observer.unobserve(element2);
      };
    }
    /**
     * @private
     */
    _getObserver() {
      return this._observer ?? (this._observer = new ResizeObserver((entries) => {
        for (const entry of entries) {
          ResizeObserverSingleton.entries.set(entry.target, entry);
          this._listeners.get(entry.target)?.(entry);
        }
      }));
    }
  };
  ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;

  // ../core/node_modules/svelte/src/runtime/internal/dom.js
  var is_hydrating = false;
  function start_hydrating() {
    is_hydrating = true;
  }
  function end_hydrating() {
    is_hydrating = false;
  }
  function append(target, node) {
    target.appendChild(node);
  }
  function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
  }
  function detach(node) {
    if (node.parentNode) {
      node.parentNode.removeChild(node);
    }
  }
  function element(name) {
    return document.createElement(name);
  }
  function text(data) {
    return document.createTextNode(data);
  }
  function space() {
    return text(" ");
  }
  function listen(node, event, handler, options) {
    node.addEventListener(event, handler, options);
    return () => node.removeEventListener(event, handler, options);
  }
  function attr(node, attribute, value) {
    if (value == null)
      node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
      node.setAttribute(attribute, value);
  }
  function set_custom_element_data(node, prop, value) {
    const lower = prop.toLowerCase();
    if (lower in node) {
      node[lower] = typeof node[lower] === "boolean" && value === "" ? true : value;
    } else if (prop in node) {
      node[prop] = typeof node[prop] === "boolean" && value === "" ? true : value;
    } else {
      attr(node, prop, value);
    }
  }
  function children(element2) {
    return Array.from(element2.childNodes);
  }
  function set_style(node, key, value, important) {
    if (value == null) {
      node.style.removeProperty(key);
    } else {
      node.style.setProperty(key, value, important ? "important" : "");
    }
  }
  function get_custom_elements_slots(element2) {
    const result = {};
    element2.childNodes.forEach(
      /** @param {Element} node */
      (node) => {
        result[node.slot || "default"] = true;
      }
    );
    return result;
  }

  // ../core/node_modules/svelte/src/runtime/internal/lifecycle.js
  var current_component;
  function set_current_component(component) {
    current_component = component;
  }
  function get_current_component() {
    if (!current_component)
      throw new Error("Function called outside component initialization");
    return current_component;
  }
  function onMount(fn) {
    get_current_component().$$.on_mount.push(fn);
  }
  function onDestroy(fn) {
    get_current_component().$$.on_destroy.push(fn);
  }

  // ../core/node_modules/svelte/src/runtime/internal/scheduler.js
  var dirty_components = [];
  var binding_callbacks = [];
  var render_callbacks = [];
  var flush_callbacks = [];
  var resolved_promise = /* @__PURE__ */ Promise.resolve();
  var update_scheduled = false;
  function schedule_update() {
    if (!update_scheduled) {
      update_scheduled = true;
      resolved_promise.then(flush);
    }
  }
  function add_render_callback(fn) {
    render_callbacks.push(fn);
  }
  var seen_callbacks = /* @__PURE__ */ new Set();
  var flushidx = 0;
  function flush() {
    if (flushidx !== 0) {
      return;
    }
    const saved_component = current_component;
    do {
      try {
        while (flushidx < dirty_components.length) {
          const component = dirty_components[flushidx];
          flushidx++;
          set_current_component(component);
          update(component.$$);
        }
      } catch (e2) {
        dirty_components.length = 0;
        flushidx = 0;
        throw e2;
      }
      set_current_component(null);
      dirty_components.length = 0;
      flushidx = 0;
      while (binding_callbacks.length)
        binding_callbacks.pop()();
      for (let i2 = 0; i2 < render_callbacks.length; i2 += 1) {
        const callback = render_callbacks[i2];
        if (!seen_callbacks.has(callback)) {
          seen_callbacks.add(callback);
          callback();
        }
      }
      render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
      flush_callbacks.pop()();
    }
    update_scheduled = false;
    seen_callbacks.clear();
    set_current_component(saved_component);
  }
  function update($$) {
    if ($$.fragment !== null) {
      $$.update();
      run_all($$.before_update);
      const dirty = $$.dirty;
      $$.dirty = [-1];
      $$.fragment && $$.fragment.p($$.ctx, dirty);
      $$.after_update.forEach(add_render_callback);
    }
  }
  function flush_render_callbacks(fns) {
    const filtered = [];
    const targets = [];
    render_callbacks.forEach((c2) => fns.indexOf(c2) === -1 ? filtered.push(c2) : targets.push(c2));
    targets.forEach((c2) => c2());
    render_callbacks = filtered;
  }

  // ../core/node_modules/svelte/src/runtime/internal/transitions.js
  var outroing = /* @__PURE__ */ new Set();
  function transition_in(block, local) {
    if (block && block.i) {
      outroing.delete(block);
      block.i(local);
    }
  }

  // ../core/node_modules/svelte/src/shared/boolean_attributes.js
  var _boolean_attributes = (
    /** @type {const} */
    [
      "allowfullscreen",
      "allowpaymentrequest",
      "async",
      "autofocus",
      "autoplay",
      "checked",
      "controls",
      "default",
      "defer",
      "disabled",
      "formnovalidate",
      "hidden",
      "inert",
      "ismap",
      "loop",
      "multiple",
      "muted",
      "nomodule",
      "novalidate",
      "open",
      "playsinline",
      "readonly",
      "required",
      "reversed",
      "selected"
    ]
  );
  var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);

  // ../core/node_modules/svelte/src/runtime/internal/Component.js
  function mount_component(component, target, anchor) {
    const { fragment: fragment2, after_update } = component.$$;
    fragment2 && fragment2.m(target, anchor);
    add_render_callback(() => {
      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
      if (component.$$.on_destroy) {
        component.$$.on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
    after_update.forEach(add_render_callback);
  }
  function destroy_component(component, detaching) {
    const $$ = component.$$;
    if ($$.fragment !== null) {
      flush_render_callbacks($$.after_update);
      run_all($$.on_destroy);
      $$.fragment && $$.fragment.d(detaching);
      $$.on_destroy = $$.fragment = null;
      $$.ctx = [];
    }
  }
  function make_dirty(component, i2) {
    if (component.$$.dirty[0] === -1) {
      dirty_components.push(component);
      schedule_update();
      component.$$.dirty.fill(0);
    }
    component.$$.dirty[i2 / 31 | 0] |= 1 << i2 % 31;
  }
  function init(component, options, instance2, create_fragment2, not_equal, props, append_styles = null, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const $$ = component.$$ = {
      fragment: null,
      ctx: [],
      // state
      props,
      update: noop,
      not_equal,
      bound: blank_object(),
      // lifecycle
      on_mount: [],
      on_destroy: [],
      on_disconnect: [],
      before_update: [],
      after_update: [],
      context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
      // everything else
      callbacks: blank_object(),
      dirty,
      skip_bound: false,
      root: options.target || parent_component.$$.root
    };
    append_styles && append_styles($$.root);
    let ready = false;
    $$.ctx = instance2 ? instance2(component, options.props || {}, (i2, ret, ...rest) => {
      const value = rest.length ? rest[0] : ret;
      if ($$.ctx && not_equal($$.ctx[i2], $$.ctx[i2] = value)) {
        if (!$$.skip_bound && $$.bound[i2])
          $$.bound[i2](value);
        if (ready)
          make_dirty(component, i2);
      }
      return ret;
    }) : [];
    $$.update();
    ready = true;
    run_all($$.before_update);
    $$.fragment = create_fragment2 ? create_fragment2($$.ctx) : false;
    if (options.target) {
      if (options.hydrate) {
        start_hydrating();
        const nodes = children(options.target);
        $$.fragment && $$.fragment.l(nodes);
        nodes.forEach(detach);
      } else {
        $$.fragment && $$.fragment.c();
      }
      if (options.intro)
        transition_in(component.$$.fragment);
      mount_component(component, options.target, options.anchor);
      end_hydrating();
      flush();
    }
    set_current_component(parent_component);
  }
  var SvelteElement;
  if (typeof HTMLElement === "function") {
    SvelteElement = class extends HTMLElement {
      /** The Svelte component constructor */
      $$ctor;
      /** Slots */
      $$s;
      /** The Svelte component instance */
      $$c;
      /** Whether or not the custom element is connected */
      $$cn = false;
      /** Component props data */
      $$d = {};
      /** `true` if currently in the process of reflecting component props back to attributes */
      $$r = false;
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      $$p_d = {};
      /** @type {Record<string, Function[]>} Event listeners */
      $$l = {};
      /** @type {Map<Function, Function>} Event listener unsubscribe functions */
      $$l_u = /* @__PURE__ */ new Map();
      constructor($$componentCtor, $$slots, use_shadow_dom) {
        super();
        this.$$ctor = $$componentCtor;
        this.$$s = $$slots;
        if (use_shadow_dom) {
          this.attachShadow({ mode: "open" });
        }
      }
      addEventListener(type, listener, options) {
        this.$$l[type] = this.$$l[type] || [];
        this.$$l[type].push(listener);
        if (this.$$c) {
          const unsub = this.$$c.$on(type, listener);
          this.$$l_u.set(listener, unsub);
        }
        super.addEventListener(type, listener, options);
      }
      removeEventListener(type, listener, options) {
        super.removeEventListener(type, listener, options);
        if (this.$$c) {
          const unsub = this.$$l_u.get(listener);
          if (unsub) {
            unsub();
            this.$$l_u.delete(listener);
          }
        }
      }
      async connectedCallback() {
        this.$$cn = true;
        if (!this.$$c) {
          let create_slot = function(name) {
            return () => {
              let node;
              const obj = {
                c: function create() {
                  node = element("slot");
                  if (name !== "default") {
                    attr(node, "name", name);
                  }
                },
                /**
                 * @param {HTMLElement} target
                 * @param {HTMLElement} [anchor]
                 */
                m: function mount(target, anchor) {
                  insert(target, node, anchor);
                },
                d: function destroy(detaching) {
                  if (detaching) {
                    detach(node);
                  }
                }
              };
              return obj;
            };
          };
          await Promise.resolve();
          if (!this.$$cn || this.$$c) {
            return;
          }
          const $$slots = {};
          const existing_slots = get_custom_elements_slots(this);
          for (const name of this.$$s) {
            if (name in existing_slots) {
              $$slots[name] = [create_slot(name)];
            }
          }
          for (const attribute of this.attributes) {
            const name = this.$$g_p(attribute.name);
            if (!(name in this.$$d)) {
              this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
            }
          }
          for (const key in this.$$p_d) {
            if (!(key in this.$$d) && this[key] !== void 0) {
              this.$$d[key] = this[key];
              delete this[key];
            }
          }
          this.$$c = new this.$$ctor({
            target: this.shadowRoot || this,
            props: {
              ...this.$$d,
              $$slots,
              $$scope: {
                ctx: []
              }
            }
          });
          const reflect_attributes = () => {
            this.$$r = true;
            for (const key in this.$$p_d) {
              this.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];
              if (this.$$p_d[key].reflect) {
                const attribute_value = get_custom_element_value(
                  key,
                  this.$$d[key],
                  this.$$p_d,
                  "toAttribute"
                );
                if (attribute_value == null) {
                  this.removeAttribute(this.$$p_d[key].attribute || key);
                } else {
                  this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
                }
              }
            }
            this.$$r = false;
          };
          this.$$c.$$.after_update.push(reflect_attributes);
          reflect_attributes();
          for (const type in this.$$l) {
            for (const listener of this.$$l[type]) {
              const unsub = this.$$c.$on(type, listener);
              this.$$l_u.set(listener, unsub);
            }
          }
          this.$$l = {};
        }
      }
      // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
      // and setting attributes through setAttribute etc, this is helpful
      attributeChangedCallback(attr2, _oldValue, newValue) {
        if (this.$$r)
          return;
        attr2 = this.$$g_p(attr2);
        this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
        this.$$c?.$set({ [attr2]: this.$$d[attr2] });
      }
      disconnectedCallback() {
        this.$$cn = false;
        Promise.resolve().then(() => {
          if (!this.$$cn && this.$$c) {
            this.$$c.$destroy();
            this.$$c = void 0;
          }
        });
      }
      $$g_p(attribute_name) {
        return Object.keys(this.$$p_d).find(
          (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
        ) || attribute_name;
      }
    };
  }
  function get_custom_element_value(prop, value, props_definition, transform2) {
    const type = props_definition[prop]?.type;
    value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
    if (!transform2 || !props_definition[prop]) {
      return value;
    } else if (transform2 === "toAttribute") {
      switch (type) {
        case "Object":
        case "Array":
          return value == null ? null : JSON.stringify(value);
        case "Boolean":
          return value ? "" : null;
        case "Number":
          return value == null ? null : value;
        default:
          return value;
      }
    } else {
      switch (type) {
        case "Object":
        case "Array":
          return value && JSON.parse(value);
        case "Boolean":
          return value;
        case "Number":
          return value != null ? +value : value;
        default:
          return value;
      }
    }
  }
  var SvelteComponent = class {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    $$ = void 0;
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    $$set = void 0;
    /** @returns {void} */
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    /**
     * @template {Extract<keyof Events, string>} K
     * @param {K} type
     * @param {((e: Events[K]) => void) | null | undefined} callback
     * @returns {() => void}
     */
    $on(type, callback) {
      if (!is_function(callback)) {
        return noop;
      }
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    /**
     * @param {Partial<Props>} props
     * @returns {void}
     */
    $set(props) {
      if (this.$$set && !is_empty(props)) {
        this.$$.skip_bound = true;
        this.$$set(props);
        this.$$.skip_bound = false;
      }
    }
  };

  // ../core/node_modules/svelte/src/shared/version.js
  var PUBLIC_VERSION = "4";

  // ../core/src/config.ts
  var config = {
    puzzleMinWidth: 4,
    puzzleMaxWidth: 5,
    puzzleMinHeight: 4,
    puzzleMaxHeight: 6,
    playgroundWidthPx: 600,
    playgroundHeightPx: 600,
    pieceInitialOpacity: 80 / 100,
    pieceDraggedOpacity: 50 / 100,
    margin: 1 / 5,
    snapDistance: 5 / 100,
    bumpiness: 50
  };

  // ../core/src/create-graphics.ts
  function createGraphics(puzzleStorage, application) {
    const puzzle = puzzleStorage.read();
    return puzzle.pieces.map(function(piece) {
      application.stage.addChild(piece.graphic);
      return piece.graphic;
    });
  }

  // ../core/node_modules/pixi.js/lib/environment-browser/browserExt.mjs
  init_Extensions();
  var browserExt = {
    extension: {
      type: ExtensionType.Environment,
      name: "browser",
      priority: -1
    },
    test: () => true,
    load: async () => {
      await Promise.resolve().then(() => (init_browserAll(), browserAll_exports));
    }
  };

  // ../core/node_modules/pixi.js/lib/environment-webworker/webworkerExt.mjs
  init_Extensions();
  var webworkerExt = {
    extension: {
      type: ExtensionType.Environment,
      name: "webworker",
      priority: 0
    },
    test: () => typeof self !== "undefined" && self.WorkerGlobalScope !== void 0,
    load: async () => {
      await Promise.resolve().then(() => (init_webworkerAll(), webworkerAll_exports));
    }
  };

  // ../core/node_modules/pixi.js/lib/index.mjs
  init_Extensions();
  init_init5();
  init_init4();

  // ../core/node_modules/pixi.js/lib/app/Application.mjs
  init_Extensions();

  // ../core/node_modules/pixi.js/lib/environment/autoDetectEnvironment.mjs
  init_Extensions();
  var environments = [];
  extensions.handleByNamedList(ExtensionType.Environment, environments);
  async function autoDetectEnvironment(manageImports) {
    if (!manageImports)
      return;
    for (let i2 = 0; i2 < environments.length; i2++) {
      const env = environments[i2];
      if (env.value.test()) {
        await env.value.load();
        return;
      }
    }
  }

  // ../core/node_modules/pixi.js/lib/utils/browser/isWebGLSupported.mjs
  init_adapter();
  init_AbstractRenderer();
  var _isWebGLSupported;
  function isWebGLSupported(failIfMajorPerformanceCaveat) {
    if (_isWebGLSupported !== void 0)
      return _isWebGLSupported;
    _isWebGLSupported = (() => {
      const contextOptions = {
        stencil: true,
        failIfMajorPerformanceCaveat: failIfMajorPerformanceCaveat ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat
      };
      try {
        if (!DOMAdapter.get().getWebGLRenderingContext()) {
          return false;
        }
        const canvas = DOMAdapter.get().createCanvas();
        let gl = canvas.getContext("webgl", contextOptions);
        const success = !!gl?.getContextAttributes()?.stencil;
        if (gl) {
          const loseContext = gl.getExtension("WEBGL_lose_context");
          if (loseContext) {
            loseContext.loseContext();
          }
        }
        gl = null;
        return success;
      } catch (e2) {
        return false;
      }
    })();
    return _isWebGLSupported;
  }

  // ../core/node_modules/pixi.js/lib/utils/browser/isWebGPUSupported.mjs
  init_adapter();
  var _isWebGPUSupported;
  async function isWebGPUSupported(options = {}) {
    if (_isWebGPUSupported !== void 0)
      return _isWebGPUSupported;
    _isWebGPUSupported = await (async () => {
      const gpu = DOMAdapter.get().getNavigator().gpu;
      if (!gpu) {
        return false;
      }
      try {
        const adapter = await navigator.gpu.requestAdapter(options);
        await adapter.requestDevice();
        return true;
      } catch (e2) {
        return false;
      }
    })();
    return _isWebGPUSupported;
  }

  // ../core/node_modules/pixi.js/lib/rendering/renderers/autoDetectRenderer.mjs
  init_AbstractRenderer();
  var renderPriority = ["webgl", "webgpu", "canvas"];
  async function autoDetectRenderer(options) {
    let preferredOrder = [];
    if (options.preference) {
      preferredOrder.push(options.preference);
      renderPriority.forEach((item) => {
        if (item !== options.preference) {
          preferredOrder.push(item);
        }
      });
    } else {
      preferredOrder = renderPriority.slice();
    }
    let RendererClass;
    await autoDetectEnvironment(
      options.manageImports ?? true
    );
    let finalOptions = {};
    for (let i2 = 0; i2 < preferredOrder.length; i2++) {
      const rendererType = preferredOrder[i2];
      if (rendererType === "webgpu" && await isWebGPUSupported()) {
        const { WebGPURenderer: WebGPURenderer2 } = await Promise.resolve().then(() => (init_WebGPURenderer(), WebGPURenderer_exports));
        RendererClass = WebGPURenderer2;
        finalOptions = { ...options, ...options.webgpu };
        break;
      } else if (rendererType === "webgl" && isWebGLSupported(
        options.failIfMajorPerformanceCaveat ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat
      )) {
        const { WebGLRenderer: WebGLRenderer2 } = await Promise.resolve().then(() => (init_WebGLRenderer(), WebGLRenderer_exports));
        RendererClass = WebGLRenderer2;
        finalOptions = { ...options, ...options.webgl };
        break;
      } else if (rendererType === "canvas") {
        finalOptions = { ...options };
        throw new Error("CanvasRenderer is not yet implemented");
      }
    }
    delete finalOptions.webgpu;
    delete finalOptions.webgl;
    if (!RendererClass) {
      throw new Error("No available renderer for the current environment");
    }
    const renderer = new RendererClass();
    await renderer.init(finalOptions);
    return renderer;
  }

  // ../core/node_modules/pixi.js/lib/app/Application.mjs
  init_Container();
  init_deprecation();
  var _Application = class _Application2 {
    /** @ignore */
    constructor(...args) {
      this.stage = new Container();
      if (args[0] !== void 0) {
        deprecation(v8_0_0, "Application constructor options are deprecated, please use Application.init() instead.");
      }
    }
    /**
     * @param options - The optional application and renderer parameters.
     */
    async init(options) {
      options = { ...options };
      this.renderer = await autoDetectRenderer(options);
      _Application2._plugins.forEach((plugin) => {
        plugin.init.call(this, options);
      });
    }
    /** Render the current stage. */
    render() {
      this.renderer.render({ container: this.stage });
    }
    /**
     * Reference to the renderer's canvas element.
     * @readonly
     * @member {HTMLCanvasElement}
     */
    get canvas() {
      return this.renderer.canvas;
    }
    /**
     * Reference to the renderer's canvas element.
     * @member {HTMLCanvasElement}
     * @deprecated since 8.0.0
     */
    get view() {
      deprecation(v8_0_0, "Application.view is deprecated, please use Application.canvas instead.");
      return this.renderer.canvas;
    }
    /**
     * Reference to the renderer's screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.
     * @readonly
     */
    get screen() {
      return this.renderer.screen;
    }
    /**
     * Destroys the application and all of its resources.
     * @param {object|boolean}[rendererDestroyOptions=false] - The options for destroying the renderer.
     * @param {boolean}[rendererDestroyOptions.removeView=false] - Removes the Canvas element from the DOM.
     * @param {object|boolean} [options=false] - The options for destroying the stage.
     * @param {boolean} [options.children=false] - If set to true, all the children will have their destroy method
     * called as well. `options` will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites.
     * If options.children is set to true,
     * it should destroy the texture of the child sprite.
     * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.
     *  If options.children is set to true,
     * it should destroy the texture source of the child sprite.
     * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.
     * If options.children is set to true,
     * it should destroy the context of the child graphics.
     */
    destroy(rendererDestroyOptions = false, options = false) {
      const plugins = _Application2._plugins.slice(0);
      plugins.reverse();
      plugins.forEach((plugin) => {
        plugin.destroy.call(this);
      });
      this.stage.destroy(options);
      this.stage = null;
      this.renderer.destroy(rendererDestroyOptions);
      this.renderer = null;
    }
  };
  _Application._plugins = [];
  var Application = _Application;
  extensions.handleByList(ExtensionType.Application, Application._plugins);

  // ../core/node_modules/pixi.js/lib/index.mjs
  init_textureFrom();
  init_Graphics();
  init_eventemitter3();
  var import_earcut2 = __toESM(require_earcut(), 1);
  extensions.add(browserExt, webworkerExt);

  // ../core/node_modules/tslib/tslib.es6.mjs
  var extendStatics = function(d2, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics(d2, b2);
  };
  function __extends(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  }
  function __awaiter(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f2, y2, t2, g2;
    return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
      return this;
    }), g2;
    function verb(n2) {
      return function(v2) {
        return step([n2, v2]);
      };
    }
    function step(op) {
      if (f2)
        throw new TypeError("Generator is already executing.");
      while (g2 && (g2 = 0, op[0] && (_ = 0)), _)
        try {
          if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
            return t2;
          if (y2 = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y2 = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t2[1]) {
                _.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _.label < t2[2]) {
                _.label = t2[2];
                _.ops.push(op);
                break;
              }
              if (t2[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e2) {
          op = [6, e2];
          y2 = 0;
        } finally {
          f2 = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  }
  function __values(o2) {
    var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
    if (m2)
      return m2.call(o2);
    if (o2 && typeof o2.length === "number")
      return {
        next: function() {
          if (o2 && i2 >= o2.length)
            o2 = void 0;
          return { value: o2 && o2[i2++], done: !o2 };
        }
      };
    throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o2, n2) {
    var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
    if (!m2)
      return o2;
    var i2 = m2.call(o2), r2, ar = [], e2;
    try {
      while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
        ar.push(r2.value);
    } catch (error) {
      e2 = { error };
    } finally {
      try {
        if (r2 && !r2.done && (m2 = i2["return"]))
          m2.call(i2);
      } finally {
        if (e2)
          throw e2.error;
      }
    }
    return ar;
  }
  function __spreadArray(to, from3, pack) {
    if (pack || arguments.length === 2)
      for (var i2 = 0, l2 = from3.length, ar; i2 < l2; i2++) {
        if (ar || !(i2 in from3)) {
          if (!ar)
            ar = Array.prototype.slice.call(from3, 0, i2);
          ar[i2] = from3[i2];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from3));
  }
  function __await(v2) {
    return this instanceof __await ? (this.v = v2, this) : new __await(v2);
  }
  function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g2 = generator.apply(thisArg, _arguments || []), i2, q = [];
    return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2;
    function verb(n2) {
      if (g2[n2])
        i2[n2] = function(v2) {
          return new Promise(function(a2, b2) {
            q.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
          });
        };
    }
    function resume(n2, v2) {
      try {
        step(g2[n2](v2));
      } catch (e2) {
        settle(q[0][3], e2);
      }
    }
    function step(r2) {
      r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q[0][2], r2);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f2, v2) {
      if (f2(v2), q.shift(), q.length)
        resume(q[0][0], q[0][1]);
    }
  }
  function __asyncValues(o2) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m2 = o2[Symbol.asyncIterator], i2;
    return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2);
    function verb(n2) {
      i2[n2] = o2[n2] && function(v2) {
        return new Promise(function(resolve, reject) {
          v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
        });
      };
    }
    function settle(resolve, reject, d2, v2) {
      Promise.resolve(v2).then(function(v3) {
        resolve({ value: v3, done: d2 });
      }, reject);
    }
  }

  // ../core/node_modules/rxjs/dist/esm5/internal/util/isFunction.js
  function isFunction(value) {
    return typeof value === "function";
  }

  // ../core/node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
  function createErrorClass(createImpl) {
    var _super = function(instance2) {
      Error.call(instance2);
      instance2.stack = new Error().stack;
    };
    var ctorFunc = createImpl(_super);
    ctorFunc.prototype = Object.create(Error.prototype);
    ctorFunc.prototype.constructor = ctorFunc;
    return ctorFunc;
  }

  // ../core/node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
  var UnsubscriptionError = createErrorClass(function(_super) {
    return function UnsubscriptionErrorImpl(errors) {
      _super(this);
      this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i2) {
        return i2 + 1 + ") " + err.toString();
      }).join("\n  ") : "";
      this.name = "UnsubscriptionError";
      this.errors = errors;
    };
  });

  // ../core/node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
  function arrRemove(arr, item) {
    if (arr) {
      var index = arr.indexOf(item);
      0 <= index && arr.splice(index, 1);
    }
  }

  // ../core/node_modules/rxjs/dist/esm5/internal/Subscription.js
  var Subscription = function() {
    function Subscription3(initialTeardown) {
      this.initialTeardown = initialTeardown;
      this.closed = false;
      this._parentage = null;
      this._finalizers = null;
    }
    Subscription3.prototype.unsubscribe = function() {
      var e_1, _a, e_2, _b;
      var errors;
      if (!this.closed) {
        this.closed = true;
        var _parentage = this._parentage;
        if (_parentage) {
          this._parentage = null;
          if (Array.isArray(_parentage)) {
            try {
              for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                var parent_1 = _parentage_1_1.value;
                parent_1.remove(this);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                  _a.call(_parentage_1);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
          } else {
            _parentage.remove(this);
          }
        }
        var initialFinalizer = this.initialTeardown;
        if (isFunction(initialFinalizer)) {
          try {
            initialFinalizer();
          } catch (e2) {
            errors = e2 instanceof UnsubscriptionError ? e2.errors : [e2];
          }
        }
        var _finalizers = this._finalizers;
        if (_finalizers) {
          this._finalizers = null;
          try {
            for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
              var finalizer = _finalizers_1_1.value;
              try {
                execFinalizer(finalizer);
              } catch (err) {
                errors = errors !== null && errors !== void 0 ? errors : [];
                if (err instanceof UnsubscriptionError) {
                  errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
                } else {
                  errors.push(err);
                }
              }
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
                _b.call(_finalizers_1);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        }
        if (errors) {
          throw new UnsubscriptionError(errors);
        }
      }
    };
    Subscription3.prototype.add = function(teardown) {
      var _a;
      if (teardown && teardown !== this) {
        if (this.closed) {
          execFinalizer(teardown);
        } else {
          if (teardown instanceof Subscription3) {
            if (teardown.closed || teardown._hasParent(this)) {
              return;
            }
            teardown._addParent(this);
          }
          (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
        }
      }
    };
    Subscription3.prototype._hasParent = function(parent) {
      var _parentage = this._parentage;
      return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
    };
    Subscription3.prototype._addParent = function(parent) {
      var _parentage = this._parentage;
      this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
    };
    Subscription3.prototype._removeParent = function(parent) {
      var _parentage = this._parentage;
      if (_parentage === parent) {
        this._parentage = null;
      } else if (Array.isArray(_parentage)) {
        arrRemove(_parentage, parent);
      }
    };
    Subscription3.prototype.remove = function(teardown) {
      var _finalizers = this._finalizers;
      _finalizers && arrRemove(_finalizers, teardown);
      if (teardown instanceof Subscription3) {
        teardown._removeParent(this);
      }
    };
    Subscription3.EMPTY = function() {
      var empty = new Subscription3();
      empty.closed = true;
      return empty;
    }();
    return Subscription3;
  }();
  var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
  function isSubscription(value) {
    return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
  }
  function execFinalizer(finalizer) {
    if (isFunction(finalizer)) {
      finalizer();
    } else {
      finalizer.unsubscribe();
    }
  }

  // ../core/node_modules/rxjs/dist/esm5/internal/config.js
  var config2 = {
    onUnhandledError: null,
    onStoppedNotification: null,
    Promise: void 0,
    useDeprecatedSynchronousErrorHandling: false,
    useDeprecatedNextContext: false
  };

  // ../core/node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
  var timeoutProvider = {
    setTimeout: function(handler, timeout) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      var delegate = timeoutProvider.delegate;
      if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
        return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));
      }
      return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
    },
    clearTimeout: function(handle) {
      var delegate = timeoutProvider.delegate;
      return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
    },
    delegate: void 0
  };

  // ../core/node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
  function reportUnhandledError(err) {
    timeoutProvider.setTimeout(function() {
      var onUnhandledError = config2.onUnhandledError;
      if (onUnhandledError) {
        onUnhandledError(err);
      } else {
        throw err;
      }
    });
  }

  // ../core/node_modules/rxjs/dist/esm5/internal/util/noop.js
  function noop2() {
  }

  // ../core/node_modules/rxjs/dist/esm5/internal/NotificationFactories.js
  var COMPLETE_NOTIFICATION = function() {
    return createNotification("C", void 0, void 0);
  }();
  function errorNotification(error) {
    return createNotification("E", void 0, error);
  }
  function nextNotification(value) {
    return createNotification("N", value, void 0);
  }
  function createNotification(kind, value, error) {
    return {
      kind,
      value,
      error
    };
  }

  // ../core/node_modules/rxjs/dist/esm5/internal/util/errorContext.js
  var context2 = null;
  function errorContext(cb) {
    if (config2.useDeprecatedSynchronousErrorHandling) {
      var isRoot = !context2;
      if (isRoot) {
        context2 = { errorThrown: false, error: null };
      }
      cb();
      if (isRoot) {
        var _a = context2, errorThrown = _a.errorThrown, error = _a.error;
        context2 = null;
        if (errorThrown) {
          throw error;
        }
      }
    } else {
      cb();
    }
  }
  function captureError(err) {
    if (config2.useDeprecatedSynchronousErrorHandling && context2) {
      context2.errorThrown = true;
      context2.error = err;
    }
  }

  // ../core/node_modules/rxjs/dist/esm5/internal/Subscriber.js
  var Subscriber = function(_super) {
    __extends(Subscriber3, _super);
    function Subscriber3(destination) {
      var _this = _super.call(this) || this;
      _this.isStopped = false;
      if (destination) {
        _this.destination = destination;
        if (isSubscription(destination)) {
          destination.add(_this);
        }
      } else {
        _this.destination = EMPTY_OBSERVER;
      }
      return _this;
    }
    Subscriber3.create = function(next, error, complete) {
      return new SafeSubscriber(next, error, complete);
    };
    Subscriber3.prototype.next = function(value) {
      if (this.isStopped) {
        handleStoppedNotification(nextNotification(value), this);
      } else {
        this._next(value);
      }
    };
    Subscriber3.prototype.error = function(err) {
      if (this.isStopped) {
        handleStoppedNotification(errorNotification(err), this);
      } else {
        this.isStopped = true;
        this._error(err);
      }
    };
    Subscriber3.prototype.complete = function() {
      if (this.isStopped) {
        handleStoppedNotification(COMPLETE_NOTIFICATION, this);
      } else {
        this.isStopped = true;
        this._complete();
      }
    };
    Subscriber3.prototype.unsubscribe = function() {
      if (!this.closed) {
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
        this.destination = null;
      }
    };
    Subscriber3.prototype._next = function(value) {
      this.destination.next(value);
    };
    Subscriber3.prototype._error = function(err) {
      try {
        this.destination.error(err);
      } finally {
        this.unsubscribe();
      }
    };
    Subscriber3.prototype._complete = function() {
      try {
        this.destination.complete();
      } finally {
        this.unsubscribe();
      }
    };
    return Subscriber3;
  }(Subscription);
  var _bind = Function.prototype.bind;
  function bind(fn, thisArg) {
    return _bind.call(fn, thisArg);
  }
  var ConsumerObserver = function() {
    function ConsumerObserver3(partialObserver) {
      this.partialObserver = partialObserver;
    }
    ConsumerObserver3.prototype.next = function(value) {
      var partialObserver = this.partialObserver;
      if (partialObserver.next) {
        try {
          partialObserver.next(value);
        } catch (error) {
          handleUnhandledError(error);
        }
      }
    };
    ConsumerObserver3.prototype.error = function(err) {
      var partialObserver = this.partialObserver;
      if (partialObserver.error) {
        try {
          partialObserver.error(err);
        } catch (error) {
          handleUnhandledError(error);
        }
      } else {
        handleUnhandledError(err);
      }
    };
    ConsumerObserver3.prototype.complete = function() {
      var partialObserver = this.partialObserver;
      if (partialObserver.complete) {
        try {
          partialObserver.complete();
        } catch (error) {
          handleUnhandledError(error);
        }
      }
    };
    return ConsumerObserver3;
  }();
  var SafeSubscriber = function(_super) {
    __extends(SafeSubscriber3, _super);
    function SafeSubscriber3(observerOrNext, error, complete) {
      var _this = _super.call(this) || this;
      var partialObserver;
      if (isFunction(observerOrNext) || !observerOrNext) {
        partialObserver = {
          next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
          error: error !== null && error !== void 0 ? error : void 0,
          complete: complete !== null && complete !== void 0 ? complete : void 0
        };
      } else {
        var context_1;
        if (_this && config2.useDeprecatedNextContext) {
          context_1 = Object.create(observerOrNext);
          context_1.unsubscribe = function() {
            return _this.unsubscribe();
          };
          partialObserver = {
            next: observerOrNext.next && bind(observerOrNext.next, context_1),
            error: observerOrNext.error && bind(observerOrNext.error, context_1),
            complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
          };
        } else {
          partialObserver = observerOrNext;
        }
      }
      _this.destination = new ConsumerObserver(partialObserver);
      return _this;
    }
    return SafeSubscriber3;
  }(Subscriber);
  function handleUnhandledError(error) {
    if (config2.useDeprecatedSynchronousErrorHandling) {
      captureError(error);
    } else {
      reportUnhandledError(error);
    }
  }
  function defaultErrorHandler(err) {
    throw err;
  }
  function handleStoppedNotification(notification, subscriber) {
    var onStoppedNotification = config2.onStoppedNotification;
    onStoppedNotification && timeoutProvider.setTimeout(function() {
      return onStoppedNotification(notification, subscriber);
    });
  }
  var EMPTY_OBSERVER = {
    closed: true,
    next: noop2,
    error: defaultErrorHandler,
    complete: noop2
  };

  // ../core/node_modules/rxjs/dist/esm5/internal/symbol/observable.js
  var observable = function() {
    return typeof Symbol === "function" && Symbol.observable || "@@observable";
  }();

  // ../core/node_modules/rxjs/dist/esm5/internal/util/identity.js
  function identity2(x2) {
    return x2;
  }

  // ../core/node_modules/rxjs/dist/esm5/internal/util/pipe.js
  function pipeFromArray(fns) {
    if (fns.length === 0) {
      return identity2;
    }
    if (fns.length === 1) {
      return fns[0];
    }
    return function piped(input) {
      return fns.reduce(function(prev, fn) {
        return fn(prev);
      }, input);
    };
  }

  // ../core/node_modules/rxjs/dist/esm5/internal/Observable.js
  var Observable = function() {
    function Observable6(subscribe) {
      if (subscribe) {
        this._subscribe = subscribe;
      }
    }
    Observable6.prototype.lift = function(operator) {
      var observable3 = new Observable6();
      observable3.source = this;
      observable3.operator = operator;
      return observable3;
    };
    Observable6.prototype.subscribe = function(observerOrNext, error, complete) {
      var _this = this;
      var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
      errorContext(function() {
        var _a = _this, operator = _a.operator, source2 = _a.source;
        subscriber.add(operator ? operator.call(subscriber, source2) : source2 ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
      });
      return subscriber;
    };
    Observable6.prototype._trySubscribe = function(sink) {
      try {
        return this._subscribe(sink);
      } catch (err) {
        sink.error(err);
      }
    };
    Observable6.prototype.forEach = function(next, promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve, reject) {
        var subscriber = new SafeSubscriber({
          next: function(value) {
            try {
              next(value);
            } catch (err) {
              reject(err);
              subscriber.unsubscribe();
            }
          },
          error: reject,
          complete: resolve
        });
        _this.subscribe(subscriber);
      });
    };
    Observable6.prototype._subscribe = function(subscriber) {
      var _a;
      return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
    };
    Observable6.prototype[observable] = function() {
      return this;
    };
    Observable6.prototype.pipe = function() {
      var operations = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        operations[_i] = arguments[_i];
      }
      return pipeFromArray(operations)(this);
    };
    Observable6.prototype.toPromise = function(promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve, reject) {
        var value;
        _this.subscribe(function(x2) {
          return value = x2;
        }, function(err) {
          return reject(err);
        }, function() {
          return resolve(value);
        });
      });
    };
    Observable6.create = function(subscribe) {
      return new Observable6(subscribe);
    };
    return Observable6;
  }();
  function getPromiseCtor(promiseCtor) {
    var _a;
    return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config2.Promise) !== null && _a !== void 0 ? _a : Promise;
  }
  function isObserver(value) {
    return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
  }
  function isSubscriber(value) {
    return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
  }

  // ../core/node_modules/rxjs/dist/esm5/internal/util/lift.js
  function hasLift(source2) {
    return isFunction(source2 === null || source2 === void 0 ? void 0 : source2.lift);
  }
  function operate(init3) {
    return function(source2) {
      if (hasLift(source2)) {
        return source2.lift(function(liftedSource) {
          try {
            return init3(liftedSource, this);
          } catch (err) {
            this.error(err);
          }
        });
      }
      throw new TypeError("Unable to lift unknown Observable type");
    };
  }

  // ../core/node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js
  function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
    return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
  }
  var OperatorSubscriber = function(_super) {
    __extends(OperatorSubscriber3, _super);
    function OperatorSubscriber3(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
      var _this = _super.call(this, destination) || this;
      _this.onFinalize = onFinalize;
      _this.shouldUnsubscribe = shouldUnsubscribe;
      _this._next = onNext ? function(value) {
        try {
          onNext(value);
        } catch (err) {
          destination.error(err);
        }
      } : _super.prototype._next;
      _this._error = onError ? function(err) {
        try {
          onError(err);
        } catch (err2) {
          destination.error(err2);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._error;
      _this._complete = onComplete ? function() {
        try {
          onComplete();
        } catch (err) {
          destination.error(err);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._complete;
      return _this;
    }
    OperatorSubscriber3.prototype.unsubscribe = function() {
      var _a;
      if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
        var closed_1 = this.closed;
        _super.prototype.unsubscribe.call(this);
        !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
      }
    };
    return OperatorSubscriber3;
  }(Subscriber);

  // ../core/node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js
  var ObjectUnsubscribedError = createErrorClass(function(_super) {
    return function ObjectUnsubscribedErrorImpl() {
      _super(this);
      this.name = "ObjectUnsubscribedError";
      this.message = "object unsubscribed";
    };
  });

  // ../core/node_modules/rxjs/dist/esm5/internal/Subject.js
  var Subject = function(_super) {
    __extends(Subject3, _super);
    function Subject3() {
      var _this = _super.call(this) || this;
      _this.closed = false;
      _this.currentObservers = null;
      _this.observers = [];
      _this.isStopped = false;
      _this.hasError = false;
      _this.thrownError = null;
      return _this;
    }
    Subject3.prototype.lift = function(operator) {
      var subject = new AnonymousSubject(this, this);
      subject.operator = operator;
      return subject;
    };
    Subject3.prototype._throwIfClosed = function() {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      }
    };
    Subject3.prototype.next = function(value) {
      var _this = this;
      errorContext(function() {
        var e_1, _a;
        _this._throwIfClosed();
        if (!_this.isStopped) {
          if (!_this.currentObservers) {
            _this.currentObservers = Array.from(_this.observers);
          }
          try {
            for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
              var observer = _c.value;
              observer.next(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return))
                _a.call(_b);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }
      });
    };
    Subject3.prototype.error = function(err) {
      var _this = this;
      errorContext(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.hasError = _this.isStopped = true;
          _this.thrownError = err;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().error(err);
          }
        }
      });
    };
    Subject3.prototype.complete = function() {
      var _this = this;
      errorContext(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.isStopped = true;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().complete();
          }
        }
      });
    };
    Subject3.prototype.unsubscribe = function() {
      this.isStopped = this.closed = true;
      this.observers = this.currentObservers = null;
    };
    Object.defineProperty(Subject3.prototype, "observed", {
      get: function() {
        var _a;
        return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
      },
      enumerable: false,
      configurable: true
    });
    Subject3.prototype._trySubscribe = function(subscriber) {
      this._throwIfClosed();
      return _super.prototype._trySubscribe.call(this, subscriber);
    };
    Subject3.prototype._subscribe = function(subscriber) {
      this._throwIfClosed();
      this._checkFinalizedStatuses(subscriber);
      return this._innerSubscribe(subscriber);
    };
    Subject3.prototype._innerSubscribe = function(subscriber) {
      var _this = this;
      var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
      if (hasError || isStopped) {
        return EMPTY_SUBSCRIPTION;
      }
      this.currentObservers = null;
      observers.push(subscriber);
      return new Subscription(function() {
        _this.currentObservers = null;
        arrRemove(observers, subscriber);
      });
    };
    Subject3.prototype._checkFinalizedStatuses = function(subscriber) {
      var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
      if (hasError) {
        subscriber.error(thrownError);
      } else if (isStopped) {
        subscriber.complete();
      }
    };
    Subject3.prototype.asObservable = function() {
      var observable3 = new Observable();
      observable3.source = this;
      return observable3;
    };
    Subject3.create = function(destination, source2) {
      return new AnonymousSubject(destination, source2);
    };
    return Subject3;
  }(Observable);
  var AnonymousSubject = function(_super) {
    __extends(AnonymousSubject3, _super);
    function AnonymousSubject3(destination, source2) {
      var _this = _super.call(this) || this;
      _this.destination = destination;
      _this.source = source2;
      return _this;
    }
    AnonymousSubject3.prototype.next = function(value) {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
    };
    AnonymousSubject3.prototype.error = function(err) {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
    };
    AnonymousSubject3.prototype.complete = function() {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
    };
    AnonymousSubject3.prototype._subscribe = function(subscriber) {
      var _a, _b;
      return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
    };
    return AnonymousSubject3;
  }(Subject);

  // ../core/node_modules/rxjs/dist/esm5/internal/observable/empty.js
  var EMPTY = new Observable(function(subscriber) {
    return subscriber.complete();
  });

  // ../core/node_modules/rxjs/dist/esm5/internal/util/isScheduler.js
  function isScheduler(value) {
    return value && isFunction(value.schedule);
  }

  // ../core/node_modules/rxjs/dist/esm5/internal/util/args.js
  function last(arr) {
    return arr[arr.length - 1];
  }
  function popResultSelector(args) {
    return isFunction(last(args)) ? args.pop() : void 0;
  }
  function popScheduler(args) {
    return isScheduler(last(args)) ? args.pop() : void 0;
  }
  function popNumber(args, defaultValue2) {
    return typeof last(args) === "number" ? args.pop() : defaultValue2;
  }

  // ../core/node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js
  var isArrayLike = function(x2) {
    return x2 && typeof x2.length === "number" && typeof x2 !== "function";
  };

  // ../core/node_modules/rxjs/dist/esm5/internal/util/isPromise.js
  function isPromise(value) {
    return isFunction(value === null || value === void 0 ? void 0 : value.then);
  }

  // ../core/node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js
  function isInteropObservable(input) {
    return isFunction(input[observable]);
  }

  // ../core/node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js
  function isAsyncIterable(obj) {
    return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
  }

  // ../core/node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js
  function createInvalidObservableTypeError(input) {
    return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
  }

  // ../core/node_modules/rxjs/dist/esm5/internal/symbol/iterator.js
  function getSymbolIterator() {
    if (typeof Symbol !== "function" || !Symbol.iterator) {
      return "@@iterator";
    }
    return Symbol.iterator;
  }
  var iterator = getSymbolIterator();

  // ../core/node_modules/rxjs/dist/esm5/internal/util/isIterable.js
  function isIterable(input) {
    return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
  }

  // ../core/node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js
  function readableStreamLikeToAsyncGenerator(readableStream) {
    return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
      var reader, _a, value, done;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            reader = readableStream.getReader();
            _b.label = 1;
          case 1:
            _b.trys.push([1, , 9, 10]);
            _b.label = 2;
          case 2:
            if (false)
              return [3, 8];
            return [4, __await(reader.read())];
          case 3:
            _a = _b.sent(), value = _a.value, done = _a.done;
            if (!done)
              return [3, 5];
            return [4, __await(void 0)];
          case 4:
            return [2, _b.sent()];
          case 5:
            return [4, __await(value)];
          case 6:
            return [4, _b.sent()];
          case 7:
            _b.sent();
            return [3, 2];
          case 8:
            return [3, 10];
          case 9:
            reader.releaseLock();
            return [7];
          case 10:
            return [2];
        }
      });
    });
  }
  function isReadableStreamLike(obj) {
    return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
  }

  // ../core/node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js
  function innerFrom(input) {
    if (input instanceof Observable) {
      return input;
    }
    if (input != null) {
      if (isInteropObservable(input)) {
        return fromInteropObservable(input);
      }
      if (isArrayLike(input)) {
        return fromArrayLike(input);
      }
      if (isPromise(input)) {
        return fromPromise(input);
      }
      if (isAsyncIterable(input)) {
        return fromAsyncIterable(input);
      }
      if (isIterable(input)) {
        return fromIterable(input);
      }
      if (isReadableStreamLike(input)) {
        return fromReadableStreamLike(input);
      }
    }
    throw createInvalidObservableTypeError(input);
  }
  function fromInteropObservable(obj) {
    return new Observable(function(subscriber) {
      var obs = obj[observable]();
      if (isFunction(obs.subscribe)) {
        return obs.subscribe(subscriber);
      }
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    });
  }
  function fromArrayLike(array) {
    return new Observable(function(subscriber) {
      for (var i2 = 0; i2 < array.length && !subscriber.closed; i2++) {
        subscriber.next(array[i2]);
      }
      subscriber.complete();
    });
  }
  function fromPromise(promise2) {
    return new Observable(function(subscriber) {
      promise2.then(function(value) {
        if (!subscriber.closed) {
          subscriber.next(value);
          subscriber.complete();
        }
      }, function(err) {
        return subscriber.error(err);
      }).then(null, reportUnhandledError);
    });
  }
  function fromIterable(iterable) {
    return new Observable(function(subscriber) {
      var e_1, _a;
      try {
        for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
          var value = iterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return;
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return))
            _a.call(iterable_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      subscriber.complete();
    });
  }
  function fromAsyncIterable(asyncIterable) {
    return new Observable(function(subscriber) {
      process(asyncIterable, subscriber).catch(function(err) {
        return subscriber.error(err);
      });
    });
  }
  function fromReadableStreamLike(readableStream) {
    return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
  }
  function process(asyncIterable, subscriber) {
    var asyncIterable_1, asyncIterable_1_1;
    var e_2, _a;
    return __awaiter(this, void 0, void 0, function() {
      var value, e_2_1;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            _b.trys.push([0, 5, 6, 11]);
            asyncIterable_1 = __asyncValues(asyncIterable);
            _b.label = 1;
          case 1:
            return [4, asyncIterable_1.next()];
          case 2:
            if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
              return [3, 4];
            value = asyncIterable_1_1.value;
            subscriber.next(value);
            if (subscriber.closed) {
              return [2];
            }
            _b.label = 3;
          case 3:
            return [3, 1];
          case 4:
            return [3, 11];
          case 5:
            e_2_1 = _b.sent();
            e_2 = { error: e_2_1 };
            return [3, 11];
          case 6:
            _b.trys.push([6, , 9, 10]);
            if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)))
              return [3, 8];
            return [4, _a.call(asyncIterable_1)];
          case 7:
            _b.sent();
            _b.label = 8;
          case 8:
            return [3, 10];
          case 9:
            if (e_2)
              throw e_2.error;
            return [7];
          case 10:
            return [7];
          case 11:
            subscriber.complete();
            return [2];
        }
      });
    });
  }

  // ../core/node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js
  function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
    if (delay === void 0) {
      delay = 0;
    }
    if (repeat === void 0) {
      repeat = false;
    }
    var scheduleSubscription = scheduler.schedule(function() {
      work();
      if (repeat) {
        parentSubscription.add(this.schedule(null, delay));
      } else {
        this.unsubscribe();
      }
    }, delay);
    parentSubscription.add(scheduleSubscription);
    if (!repeat) {
      return scheduleSubscription;
    }
  }

  // ../core/node_modules/rxjs/dist/esm5/internal/operators/observeOn.js
  function observeOn(scheduler, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    return operate(function(source2, subscriber) {
      source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
        return executeSchedule(subscriber, scheduler, function() {
          return subscriber.next(value);
        }, delay);
      }, function() {
        return executeSchedule(subscriber, scheduler, function() {
          return subscriber.complete();
        }, delay);
      }, function(err) {
        return executeSchedule(subscriber, scheduler, function() {
          return subscriber.error(err);
        }, delay);
      }));
    });
  }

  // ../core/node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js
  function subscribeOn(scheduler, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    return operate(function(source2, subscriber) {
      subscriber.add(scheduler.schedule(function() {
        return source2.subscribe(subscriber);
      }, delay));
    });
  }

  // ../core/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js
  function scheduleObservable(input, scheduler) {
    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
  }

  // ../core/node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js
  function schedulePromise(input, scheduler) {
    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
  }

  // ../core/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js
  function scheduleArray(input, scheduler) {
    return new Observable(function(subscriber) {
      var i2 = 0;
      return scheduler.schedule(function() {
        if (i2 === input.length) {
          subscriber.complete();
        } else {
          subscriber.next(input[i2++]);
          if (!subscriber.closed) {
            this.schedule();
          }
        }
      });
    });
  }

  // ../core/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js
  function scheduleIterable(input, scheduler) {
    return new Observable(function(subscriber) {
      var iterator3;
      executeSchedule(subscriber, scheduler, function() {
        iterator3 = input[iterator]();
        executeSchedule(subscriber, scheduler, function() {
          var _a;
          var value;
          var done;
          try {
            _a = iterator3.next(), value = _a.value, done = _a.done;
          } catch (err) {
            subscriber.error(err);
            return;
          }
          if (done) {
            subscriber.complete();
          } else {
            subscriber.next(value);
          }
        }, 0, true);
      });
      return function() {
        return isFunction(iterator3 === null || iterator3 === void 0 ? void 0 : iterator3.return) && iterator3.return();
      };
    });
  }

  // ../core/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js
  function scheduleAsyncIterable(input, scheduler) {
    if (!input) {
      throw new Error("Iterable cannot be null");
    }
    return new Observable(function(subscriber) {
      executeSchedule(subscriber, scheduler, function() {
        var iterator3 = input[Symbol.asyncIterator]();
        executeSchedule(subscriber, scheduler, function() {
          iterator3.next().then(function(result) {
            if (result.done) {
              subscriber.complete();
            } else {
              subscriber.next(result.value);
            }
          });
        }, 0, true);
      });
    });
  }

  // ../core/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js
  function scheduleReadableStreamLike(input, scheduler) {
    return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
  }

  // ../core/node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js
  function scheduled(input, scheduler) {
    if (input != null) {
      if (isInteropObservable(input)) {
        return scheduleObservable(input, scheduler);
      }
      if (isArrayLike(input)) {
        return scheduleArray(input, scheduler);
      }
      if (isPromise(input)) {
        return schedulePromise(input, scheduler);
      }
      if (isAsyncIterable(input)) {
        return scheduleAsyncIterable(input, scheduler);
      }
      if (isIterable(input)) {
        return scheduleIterable(input, scheduler);
      }
      if (isReadableStreamLike(input)) {
        return scheduleReadableStreamLike(input, scheduler);
      }
    }
    throw createInvalidObservableTypeError(input);
  }

  // ../core/node_modules/rxjs/dist/esm5/internal/observable/from.js
  function from(input, scheduler) {
    return scheduler ? scheduled(input, scheduler) : innerFrom(input);
  }

  // ../core/node_modules/rxjs/dist/esm5/internal/observable/of.js
  function of() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = popScheduler(args);
    return from(args, scheduler);
  }

  // ../core/node_modules/rxjs/dist/esm5/internal/operators/map.js
  function map(project, thisArg) {
    return operate(function(source2, subscriber) {
      var index = 0;
      source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
        subscriber.next(project.call(thisArg, value, index++));
      }));
    });
  }

  // ../core/node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js
  function mergeInternals(source2, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
    var buffer = [];
    var active = 0;
    var index = 0;
    var isComplete = false;
    var checkComplete = function() {
      if (isComplete && !buffer.length && !active) {
        subscriber.complete();
      }
    };
    var outerNext = function(value) {
      return active < concurrent ? doInnerSub(value) : buffer.push(value);
    };
    var doInnerSub = function(value) {
      expand && subscriber.next(value);
      active++;
      var innerComplete = false;
      innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, function(innerValue) {
        onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
        if (expand) {
          outerNext(innerValue);
        } else {
          subscriber.next(innerValue);
        }
      }, function() {
        innerComplete = true;
      }, void 0, function() {
        if (innerComplete) {
          try {
            active--;
            var _loop_1 = function() {
              var bufferedValue = buffer.shift();
              if (innerSubScheduler) {
                executeSchedule(subscriber, innerSubScheduler, function() {
                  return doInnerSub(bufferedValue);
                });
              } else {
                doInnerSub(bufferedValue);
              }
            };
            while (buffer.length && active < concurrent) {
              _loop_1();
            }
            checkComplete();
          } catch (err) {
            subscriber.error(err);
          }
        }
      }));
    };
    source2.subscribe(createOperatorSubscriber(subscriber, outerNext, function() {
      isComplete = true;
      checkComplete();
    }));
    return function() {
      additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
    };
  }

  // ../core/node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js
  function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) {
      concurrent = Infinity;
    }
    if (isFunction(resultSelector)) {
      return mergeMap(function(a2, i2) {
        return map(function(b2, ii) {
          return resultSelector(a2, b2, i2, ii);
        })(innerFrom(project(a2, i2)));
      }, concurrent);
    } else if (typeof resultSelector === "number") {
      concurrent = resultSelector;
    }
    return operate(function(source2, subscriber) {
      return mergeInternals(source2, subscriber, project, concurrent);
    });
  }

  // ../core/node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js
  function mergeAll(concurrent) {
    if (concurrent === void 0) {
      concurrent = Infinity;
    }
    return mergeMap(identity2, concurrent);
  }

  // ../core/node_modules/rxjs/dist/esm5/internal/observable/merge.js
  function merge() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = popScheduler(args);
    var concurrent = popNumber(args, Infinity);
    var sources2 = args;
    return !sources2.length ? EMPTY : sources2.length === 1 ? innerFrom(sources2[0]) : mergeAll(concurrent)(from(sources2, scheduler));
  }

  // ../core/node_modules/rxjs/dist/esm5/internal/operators/tap.js
  function tap(observerOrNext, error, complete) {
    var tapObserver = isFunction(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
    return tapObserver ? operate(function(source2, subscriber) {
      var _a;
      (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
      var isUnsub = true;
      source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
        var _a2;
        (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value);
        subscriber.next(value);
      }, function() {
        var _a2;
        isUnsub = false;
        (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
        subscriber.complete();
      }, function(err) {
        var _a2;
        isUnsub = false;
        (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
        subscriber.error(err);
      }, function() {
        var _a2, _b;
        if (isUnsub) {
          (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
        }
        (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
      }));
    }) : identity2;
  }

  // ../core/node_modules/rxjs/dist/esm5/internal/operators/withLatestFrom.js
  function withLatestFrom() {
    var inputs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      inputs[_i] = arguments[_i];
    }
    var project = popResultSelector(inputs);
    return operate(function(source2, subscriber) {
      var len = inputs.length;
      var otherValues = new Array(len);
      var hasValue = inputs.map(function() {
        return false;
      });
      var ready = false;
      var _loop_1 = function(i3) {
        innerFrom(inputs[i3]).subscribe(createOperatorSubscriber(subscriber, function(value) {
          otherValues[i3] = value;
          if (!ready && !hasValue[i3]) {
            hasValue[i3] = true;
            (ready = hasValue.every(identity2)) && (hasValue = null);
          }
        }, noop2));
      };
      for (var i2 = 0; i2 < len; i2++) {
        _loop_1(i2);
      }
      source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
        if (ready) {
          var values = __spreadArray([value], __read(otherValues));
          subscriber.next(project ? project.apply(void 0, __spreadArray([], __read(values))) : values);
        }
      }));
    });
  }

  // ../core/src/create-pixi-application.ts
  var import_blockwise = __toESM(require_dist(), 1);
  async function createPixiApplication(puzzleStorage) {
    const application = new Application();
    await application.init({
      width: config.playgroundWidthPx,
      height: config.playgroundHeightPx,
      antialias: true,
      backgroundColor: 1087931
    });
    let puzzle = puzzleStorage.read();
    const puzzleGraphic = new Graphics();
    const mappedPuzzleBlock = (0, import_blockwise.mapToView)(puzzle.block, puzzle.block, screenBlock);
    puzzleGraphic.rect(mappedPuzzleBlock.x, mappedPuzzleBlock.y, mappedPuzzleBlock.w, mappedPuzzleBlock.h);
    puzzleGraphic.fill(1087931);
    puzzleGraphic.stroke({ width: 2, color: 0 });
    application.stage.addChild(puzzleGraphic);
    const graphics = createGraphics(puzzleStorage, application);
    renderGraphics(puzzle);
    const dragEnd$ = makeGraphicsDraggable(graphics, application, puzzleStorage);
    dragEnd$.subscribe(function([id, block]) {
      incrementMoveCount();
      const currentPuzzle = puzzleStorage.read();
      const newPuzzle = {
        ...currentPuzzle,
        pieces: currentPuzzle.pieces.map(function(piece) {
          if (piece.id === id) {
            return snapToFinalPosition(currentPuzzle, {
              ...piece,
              block: {
                ...piece.block,
                x: block.x,
                y: block.y
              }
            });
          }
          return piece;
        })
      };
      puzzleStorage.save(newPuzzle);
    });
    puzzleStorage.watch().pipe(
      tap((p2) => renderGraphics(p2))
    ).subscribe();
    return application;
  }

  // ../core/node_modules/daily-prng/dist/get-seed.js
  function getSeed() {
    const today = /* @__PURE__ */ new Date();
    const date = today.getDate();
    const month = today.getMonth();
    const year = today.getFullYear();
    return date + "-" + month + "-" + year;
  }

  // ../core/node_modules/daily-prng/node_modules/park-miller/index.js
  var MAX_INT32 = 2147483647;
  var MINSTD = 16807;
  var ParkMiller = class {
    constructor(seed3) {
      if (!Number.isInteger(seed3)) {
        throw new TypeError("Expected `seed` to be a `integer`");
      }
      this._seed = seed3 % MAX_INT32;
      if (this._seed <= 0) {
        this._seed += MAX_INT32 - 1;
      }
    }
    integer() {
      this._seed *= MINSTD;
      this._seed %= MAX_INT32;
      return this._seed;
    }
    integerInRange(min, max) {
      return Math.round(this.floatInRange(min, max));
    }
    float() {
      return (this.integer() - 1) / (MAX_INT32 - 1);
    }
    floatInRange(min, max) {
      return min + (max - min) * this.float();
    }
    boolean() {
      return this.integer() % 2 === 0;
    }
  };

  // ../core/node_modules/daily-prng/node_modules/@sindresorhus/fnv1a/index.js
  var FNV_PRIMES = {
    32: 16777619n,
    64: 1099511628211n,
    128: 309485009821345068724781371n,
    256: 374144419156711147060143317175368453031918731002211n,
    512: 35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,
    1024: 5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n
  };
  var FNV_OFFSETS = {
    32: 2166136261n,
    64: 14695981039346656037n,
    128: 144066263297769815596495629667062367629n,
    256: 100029257958052580907070968620625704837092796014241193945225284501741471925557n,
    512: 9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,
    1024: 14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n
  };
  var cachedEncoder = new globalThis.TextEncoder();
  function fnv1aUint8Array(uint8Array, size) {
    const fnvPrime = FNV_PRIMES[size];
    let hash = FNV_OFFSETS[size];
    for (let index = 0; index < uint8Array.length; index++) {
      hash ^= BigInt(uint8Array[index]);
      hash = BigInt.asUintN(size, hash * fnvPrime);
    }
    return hash;
  }
  function fnv1aEncodeInto(string, size, utf8Buffer) {
    if (utf8Buffer.length === 0) {
      throw new Error("The `utf8Buffer` option must have a length greater than zero");
    }
    const fnvPrime = FNV_PRIMES[size];
    let hash = FNV_OFFSETS[size];
    let remaining = string;
    while (remaining.length > 0) {
      const result = cachedEncoder.encodeInto(remaining, utf8Buffer);
      remaining = remaining.slice(result.read);
      for (let index = 0; index < result.written; index++) {
        hash ^= BigInt(utf8Buffer[index]);
        hash = BigInt.asUintN(size, hash * fnvPrime);
      }
    }
    return hash;
  }
  function fnv1a(value, { size = 32, utf8Buffer } = {}) {
    if (!FNV_PRIMES[size]) {
      throw new Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");
    }
    if (typeof value === "string") {
      if (utf8Buffer) {
        return fnv1aEncodeInto(value, size, utf8Buffer);
      }
      value = cachedEncoder.encode(value);
    }
    return fnv1aUint8Array(value, size);
  }

  // ../core/node_modules/daily-prng/node_modules/@sindresorhus/string-hash/index.js
  function stringHash(string) {
    return Number(fnv1a(string));
  }

  // ../core/node_modules/daily-prng/node_modules/randoma/index.js
  var import_color = __toESM(require_color(), 1);
  var MAX_INT322 = 2147483647;
  var GOLDEN_RATIO_CONJUGATE = 0.618033988749895;
  var Randoma = class {
    static seed() {
      return Math.floor(Math.random() * MAX_INT322);
    }
    #random;
    constructor({ seed: seed3 }) {
      if (typeof seed3 === "string") {
        seed3 = stringHash(seed3);
      }
      if (!Number.isInteger(seed3)) {
        throw new TypeError("Expected `seed` to be a `integer`");
      }
      this.#random = new ParkMiller(seed3);
    }
    integer() {
      return this.#random.integer();
    }
    integerInRange(minimum, maximum) {
      return this.#random.integerInRange(minimum, maximum);
    }
    float() {
      return this.#random.float();
    }
    floatInRange(minimum, maximum) {
      return this.#random.floatInRange(minimum, maximum);
    }
    boolean() {
      return this.#random.boolean();
    }
    arrayItem(array) {
      return array[Math.floor(this.float() * array.length)];
    }
    date() {
      return new Date(Date.now() * this.float());
    }
    dateInRange(startDate, endDate) {
      return new Date(this.integerInRange(startDate.getTime(), endDate.getTime()));
    }
    color(saturation = 0.5) {
      let hue = this.float();
      hue += GOLDEN_RATIO_CONJUGATE;
      hue %= 1;
      return (0, import_color.default)({
        h: hue * 360,
        s: saturation * 100,
        v: 95
      });
    }
  };

  // ../core/node_modules/daily-prng/dist/random-float.js
  var seed = getSeed();
  var random = new Randoma({ seed });
  function randomFloat(min, max) {
    return random.floatInRange(min, max);
  }

  // ../core/node_modules/daily-prng/dist/random-integer.js
  var seed2 = getSeed();
  var random2 = new Randoma({ seed: seed2 });
  function randomInteger(min, max) {
    return random2.integerInRange(min, max - 1);
  }

  // ../core/src/generate-puzzle.ts
  var import_blockwise2 = __toESM(require_dist(), 1);

  // ../core/node_modules/uid/dist/index.mjs
  var IDX = 256;
  var HEX = [];
  var SIZE = 256;
  var BUFFER;
  while (IDX--)
    HEX[IDX] = (IDX + 256).toString(16).substring(1);
  function uid2(len) {
    var i2 = 0, tmp = len || 11;
    if (!BUFFER || IDX + tmp > SIZE * 2) {
      for (BUFFER = "", IDX = 0; i2 < SIZE; i2++) {
        BUFFER += HEX[Math.random() * 256 | 0];
      }
    }
    return BUFFER.substring(IDX, IDX++ + tmp);
  }

  // ../core/src/generate-puzzle.ts
  function generatePuzzle() {
    const w2 = randomInteger(config.puzzleMinWidth, config.puzzleMaxWidth + 1);
    const h2 = randomInteger(config.puzzleMinHeight, config.puzzleMaxHeight + 1);
    const block = { x: 0, y: 0, w: w2, h: h2 };
    const pieces = [];
    const piecesQty = w2 * h2;
    const minBlockDistance = 0.25;
    while (pieces.length < piecesQty) {
      const piece = {
        id: uid2(),
        graphic: new Graphics(),
        block: {
          x: randomFloat(-0.5, w2 - 0.5),
          y: randomFloat(-0.5, h2 - 0.5),
          //x: pieces.length % w,
          //y: Math.floor(pieces.length / w),
          w: 1,
          h: 1
        }
      };
      if (pieces.length) {
        const blocks = pieces.map((p2) => p2.block);
        const closestPiece = (0, import_blockwise2.findClosestBlock)(blocks, piece.block);
        const distance = (0, import_blockwise2.calculateBlockDistance)(closestPiece, piece.block);
        if (distance < minBlockDistance) {
          continue;
        }
      }
      pieces.push(piece);
    }
    return { block, pieces };
  }

  // ../core/src/create-puzzle-storage.ts
  function createPuzzleStorage() {
    let puzzle = generatePuzzle();
    const _puzzle$ = new Subject();
    return {
      read: () => ({ ...puzzle }),
      save: (p2) => {
        puzzle = p2;
        _puzzle$.next(puzzle);
      },
      watch: () => {
        return _puzzle$.asObservable();
      }
    };
  }

  // ../core/src/create-win-observable.ts
  var import_blockwise3 = __toESM(require_dist(), 1);
  function createWinObservable(puzzleStorage) {
    return puzzleStorage.watch().pipe(
      map(function(puzzle) {
        return puzzle.pieces.every(function(piece) {
          const finalPosition = getPieceFinalPosition(puzzle, piece);
          return (0, import_blockwise3.isBlockPositionEqual)(piece.block, finalPosition);
        });
      })
    );
  }

  // ../core/node_modules/svelte/src/runtime/internal/disclose-version/index.js
  if (typeof window !== "undefined")
    (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);

  // ../core/src/playground.svelte.js
  function create_if_block(ctx) {
    let cookies_p;
    let t0;
    let br;
    let t1;
    let cookies_button;
    let mounted;
    let dispose;
    return {
      c() {
        cookies_p = element("cookies-p");
        t0 = text("\u{1F389} C'est gagn\xE9 pour aujourd'hui ! \u{1F973} ");
        br = element("br");
        t1 = space();
        cookies_button = element("cookies-button");
        cookies_button.textContent = "Partager";
        set_custom_element_data(cookies_button, "title", "Copier dans le presse-papier");
        set_style(cookies_p, "text-align", "center");
      },
      m(target, anchor) {
        insert(target, cookies_p, anchor);
        append(cookies_p, t0);
        append(cookies_p, br);
        append(cookies_p, t1);
        append(cookies_p, cookies_button);
        if (!mounted) {
          dispose = listen(cookies_button, "click", share);
          mounted = true;
        }
      },
      d(detaching) {
        if (detaching) {
          detach(cookies_p);
        }
        mounted = false;
        dispose();
      }
    };
  }
  function create_fragment(ctx) {
    let cookies_panel;
    let div;
    let t2;
    let if_block = (
      /*win*/
      ctx[0] && create_if_block(ctx)
    );
    return {
      c() {
        cookies_panel = element("cookies-panel");
        div = element("div");
        t2 = space();
        if (if_block)
          if_block.c();
        set_custom_element_data(cookies_panel, "panel-title", "unsplit");
      },
      m(target, anchor) {
        insert(target, cookies_panel, anchor);
        append(cookies_panel, div);
        ctx[2](div);
        append(cookies_panel, t2);
        if (if_block)
          if_block.m(cookies_panel, null);
      },
      p(ctx2, [dirty]) {
        if (
          /*win*/
          ctx2[0]
        ) {
          if (if_block) {
          } else {
            if_block = create_if_block(ctx2);
            if_block.c();
            if_block.m(cookies_panel, null);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(cookies_panel);
        }
        ctx[2](null);
        if (if_block)
          if_block.d();
      }
    };
  }
  function instance($$self, $$props, $$invalidate) {
    const puzzleStorage = createPuzzleStorage();
    const win$ = createWinObservable(puzzleStorage);
    let puzzle = puzzleStorage.read();
    const puzzleObservable = puzzleStorage.watch();
    const sub = puzzleObservable.subscribe((value) => puzzle = value);
    let win = false;
    const winSub = win$.subscribe((value) => $$invalidate(0, win = value));
    let canvasContainer;
    onMount(async function() {
      const app = await createPixiApplication(puzzleStorage);
      canvasContainer.appendChild(app.canvas);
    });
    onDestroy(() => sub.unsubscribe());
    onDestroy(() => winSub.unsubscribe());
    function div_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        canvasContainer = $$value;
        $$invalidate(1, canvasContainer);
      });
    }
    return [win, canvasContainer, div_binding];
  }
  var Playground = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance, create_fragment, safe_not_equal, {});
    }
  };
  var playground_svelte_default = Playground;

  // ../core/src/get-piece-final-position.ts
  var memo = /* @__PURE__ */ new Map();
  function getPieceFinalPosition(puzzle, piece) {
    const dateOfMonth = (/* @__PURE__ */ new Date()).getDate();
    const key = `${piece.id}-${dateOfMonth}`;
    if (memo.has(key)) {
      return memo.get(key);
    }
    const piecePos = puzzle.pieces.findIndex((p2) => p2.id === piece.id);
    const w2 = piece.block.w;
    const h2 = piece.block.h;
    const x2 = piecePos % puzzle.block.w;
    const y2 = Math.floor(piecePos / puzzle.block.w);
    const block = { x: x2, y: y2, w: w2, h: h2 };
    memo.set(key, block);
    return block;
  }

  // ../core/src/move-count.ts
  var moveCount = 0;
  function incrementMoveCount() {
    moveCount++;
  }
  function getMoveCount() {
    return moveCount;
  }

  // ../core/src/make-graphics-draggable.ts
  var import_blockwise4 = __toESM(require_dist(), 1);
  function makeGraphicsDraggable(graphics, application, puzzleStorage) {
    let dragTarget = null;
    application.stage.eventMode = "static";
    application.stage.hitArea = application.screen;
    for (const graphic of graphics) {
      graphic.eventMode = "static";
      graphic.cursor = "pointer";
      graphic.on("pointerdown", onDragStart, graphic);
    }
    application.stage.on("pointerup", onDragEnd);
    function onDragStart() {
      this.alpha = config.pieceDraggedOpacity;
      dragTarget = this;
      application.stage.setChildIndex(dragTarget, application.stage.children.length - 1);
      application.stage.on("pointermove", onDragMove);
    }
    function onDragMove(event) {
      if (dragTarget) {
        dragTarget.parent.toLocal(event.global, null, dragTarget.position);
      }
    }
    const _dragged$ = new Subject();
    function onDragEnd() {
      if (dragTarget) {
        application.stage.off("pointermove", onDragMove);
        dragTarget.alpha = config.pieceInitialOpacity;
        const block = {
          x: dragTarget.x - dragTarget.width / 2,
          y: dragTarget.y - dragTarget.height / 2,
          w: 0,
          h: 0
        };
        _dragged$.next(block);
        dragTarget = null;
      }
    }
    return _dragged$.asObservable().pipe(
      withLatestFrom(
        merge(
          of(puzzleStorage.read()),
          puzzleStorage.watch()
        )
      ),
      map(function([dragEndPosition, puzzle]) {
        const draggedPiece = puzzle.pieces.find((p2) => p2.graphic === dragTarget);
        return [
          draggedPiece.id || "unknown",
          (0, import_blockwise4.mapToView)(dragEndPosition, screenBlock, puzzle.block)
        ];
      })
    );
  }

  // ../core/src/render-graphics.ts
  var import_blockwise5 = __toESM(require_dist(), 1);

  // ../core/node_modules/park-miller/index.js
  var MAX_INT323 = 2147483647;
  var MINSTD2 = 16807;
  var ParkMiller2 = class {
    constructor(seed3) {
      if (!Number.isInteger(seed3)) {
        throw new TypeError("Expected `seed` to be a `integer`");
      }
      this._seed = seed3 % MAX_INT323;
      if (this._seed <= 0) {
        this._seed += MAX_INT323 - 1;
      }
    }
    integer() {
      this._seed *= MINSTD2;
      this._seed %= MAX_INT323;
      return this._seed;
    }
    integerInRange(min, max) {
      return Math.round(this.floatInRange(min, max));
    }
    float() {
      return (this.integer() - 1) / (MAX_INT323 - 1);
    }
    floatInRange(min, max) {
      return min + (max - min) * this.float();
    }
    boolean() {
      return this.integer() % 2 === 0;
    }
  };

  // ../core/node_modules/@sindresorhus/fnv1a/index.js
  var FNV_PRIMES2 = {
    32: 16777619n,
    64: 1099511628211n,
    128: 309485009821345068724781371n,
    256: 374144419156711147060143317175368453031918731002211n,
    512: 35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,
    1024: 5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n
  };
  var FNV_OFFSETS2 = {
    32: 2166136261n,
    64: 14695981039346656037n,
    128: 144066263297769815596495629667062367629n,
    256: 100029257958052580907070968620625704837092796014241193945225284501741471925557n,
    512: 9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,
    1024: 14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n
  };
  var cachedEncoder2 = new globalThis.TextEncoder();
  function fnv1aUint8Array2(uint8Array, size) {
    const fnvPrime = FNV_PRIMES2[size];
    let hash = FNV_OFFSETS2[size];
    for (let index = 0; index < uint8Array.length; index++) {
      hash ^= BigInt(uint8Array[index]);
      hash = BigInt.asUintN(size, hash * fnvPrime);
    }
    return hash;
  }
  function fnv1aEncodeInto2(string, size, utf8Buffer) {
    if (utf8Buffer.length === 0) {
      throw new Error("The `utf8Buffer` option must have a length greater than zero");
    }
    const fnvPrime = FNV_PRIMES2[size];
    let hash = FNV_OFFSETS2[size];
    let remaining = string;
    while (remaining.length > 0) {
      const result = cachedEncoder2.encodeInto(remaining, utf8Buffer);
      remaining = remaining.slice(result.read);
      for (let index = 0; index < result.written; index++) {
        hash ^= BigInt(utf8Buffer[index]);
        hash = BigInt.asUintN(size, hash * fnvPrime);
      }
    }
    return hash;
  }
  function fnv1a2(value, { size = 32, utf8Buffer } = {}) {
    if (!FNV_PRIMES2[size]) {
      throw new Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");
    }
    if (typeof value === "string") {
      if (utf8Buffer) {
        return fnv1aEncodeInto2(value, size, utf8Buffer);
      }
      value = cachedEncoder2.encode(value);
    }
    return fnv1aUint8Array2(value, size);
  }

  // ../core/node_modules/@sindresorhus/string-hash/index.js
  function stringHash2(string) {
    return Number(fnv1a2(string));
  }

  // ../core/node_modules/randoma/index.js
  var import_color2 = __toESM(require_color2(), 1);
  var MAX_INT324 = 2147483647;
  var GOLDEN_RATIO_CONJUGATE2 = 0.618033988749895;
  var Randoma2 = class {
    static seed() {
      return Math.floor(Math.random() * MAX_INT324);
    }
    #random;
    constructor({ seed: seed3 }) {
      if (typeof seed3 === "string") {
        seed3 = stringHash2(seed3);
      }
      if (!Number.isInteger(seed3)) {
        throw new TypeError("Expected `seed` to be a `integer`");
      }
      this.#random = new ParkMiller2(seed3);
    }
    integer() {
      return this.#random.integer();
    }
    integerInRange(minimum, maximum) {
      return this.#random.integerInRange(minimum, maximum);
    }
    float() {
      return this.#random.float();
    }
    floatInRange(minimum, maximum) {
      return this.#random.floatInRange(minimum, maximum);
    }
    boolean() {
      return this.#random.boolean();
    }
    arrayItem(array) {
      return array[Math.floor(this.float() * array.length)];
    }
    date() {
      return new Date(Date.now() * this.float());
    }
    dateInRange(startDate, endDate) {
      return new Date(this.integerInRange(startDate.getTime(), endDate.getTime()));
    }
    color(saturation = 0.5) {
      let hue = this.float();
      hue += GOLDEN_RATIO_CONJUGATE2;
      hue %= 1;
      return (0, import_color2.default)({
        h: hue * 360,
        s: saturation * 100,
        v: 95
      });
    }
  };

  // ../core/src/render-graphics.ts
  function getSeed2() {
    const today = /* @__PURE__ */ new Date();
    const date = today.getDate();
    const month = today.getMonth();
    const year = today.getFullYear();
    return date + "-" + month + "-" + year;
  }
  function renderGraphics(puzzle) {
    for (const piece of puzzle.pieces) {
      const graphic = piece.graphic;
      graphic.alpha = config.pieceInitialOpacity;
      graphic.clear();
      const mappedBlock = (0, import_blockwise5.mapToView)(piece.block, puzzle.block, screenBlock);
      graphic.x = mappedBlock.x + mappedBlock.w / 2;
      graphic.y = mappedBlock.y + mappedBlock.h / 2;
      const finalPosition = getPieceFinalPosition(puzzle, piece);
      graphic.moveTo(-mappedBlock.w / 2, -mappedBlock.h / 2);
      const isTopRow = finalPosition.y === 0;
      const topKey = `${getSeed2()}-vertical-${finalPosition.x}-${finalPosition.y}`;
      const randomTop = new Randoma2({ seed: topKey });
      if (isTopRow) {
        graphic.lineTo(-mappedBlock.w / 2 + mappedBlock.w, -mappedBlock.h / 2);
      } else {
        const float1 = randomTop.float();
        const float2 = randomTop.float();
        const float3 = randomTop.float();
        const float4 = randomTop.float();
        graphic.bezierCurveTo(
          -mappedBlock.w / 2 + float1 * config.bumpiness,
          -mappedBlock.h / 2 + (float2 - 0.5) * config.bumpiness,
          -mappedBlock.w / 2 + float3 * config.bumpiness,
          -mappedBlock.h / 2 + (float4 - 0.5) * config.bumpiness,
          -mappedBlock.w / 2 + mappedBlock.w,
          -mappedBlock.h / 2
        );
      }
      const isRightColumn = finalPosition.x === puzzle.block.w - 1;
      if (isRightColumn) {
        graphic.lineTo(mappedBlock.w / 2, -mappedBlock.h / 2 + mappedBlock.h);
      } else {
        const rightKey = `${getSeed2()}-horizontal-${finalPosition.x + 1}-${finalPosition.y}`;
        const randomRight = new Randoma2({ seed: rightKey });
        const float1 = randomRight.float();
        const float2 = randomRight.float();
        const float3 = randomRight.float();
        const float4 = randomRight.float();
        graphic.bezierCurveTo(
          mappedBlock.w / 2 + (float1 - 0.5) * config.bumpiness,
          -mappedBlock.h / 2 + float2 * config.bumpiness,
          mappedBlock.w / 2 + (float3 - 0.5) * config.bumpiness,
          -mappedBlock.h / 2 + float4 * config.bumpiness,
          mappedBlock.w / 2,
          -mappedBlock.h / 2 + mappedBlock.h
        );
      }
      const isBottomRow = finalPosition.y === puzzle.block.h - 1;
      if (isBottomRow) {
        graphic.lineTo(-mappedBlock.w / 2, -mappedBlock.h / 2 + mappedBlock.h);
      } else {
        const bottomKey = `${getSeed2()}-vertical-${finalPosition.x}-${finalPosition.y + 1}`;
        const randomBottom = new Randoma2({ seed: bottomKey });
        const float1 = randomBottom.float();
        const float2 = randomBottom.float();
        const float3 = randomBottom.float();
        const float4 = randomBottom.float();
        graphic.bezierCurveTo(
          -mappedBlock.w / 2 + float3 * config.bumpiness,
          mappedBlock.h / 2 + (float4 - 0.5) * config.bumpiness,
          -mappedBlock.w / 2 + float1 * config.bumpiness,
          mappedBlock.h / 2 + (float2 - 0.5) * config.bumpiness,
          -mappedBlock.w / 2,
          -mappedBlock.h / 2 + mappedBlock.h
        );
      }
      const isLeftColumn = finalPosition.x === 0;
      if (isLeftColumn) {
        graphic.lineTo(-mappedBlock.w / 2, -mappedBlock.h / 2);
      } else {
        const leftKey = `${getSeed2()}-horizontal-${finalPosition.x}-${finalPosition.y}`;
        const randomLeft = new Randoma2({ seed: leftKey });
        const float1 = randomLeft.float();
        const float2 = randomLeft.float();
        const float3 = randomLeft.float();
        const float4 = randomLeft.float();
        graphic.bezierCurveTo(
          -mappedBlock.w / 2 + (float3 - 0.5) * config.bumpiness,
          -mappedBlock.h / 2 + float4 * config.bumpiness,
          -mappedBlock.w / 2 + (float1 - 0.5) * config.bumpiness,
          -mappedBlock.h / 2 + float2 * config.bumpiness,
          -mappedBlock.w / 2,
          -mappedBlock.h / 2
        );
      }
      graphic.fill(10074896);
      graphic.stroke({ width: 2, color: 0 });
    }
  }

  // ../core/src/screen-block.ts
  var screenBlock = {
    x: config.playgroundWidthPx * config.margin,
    y: config.playgroundHeightPx * config.margin,
    w: config.playgroundWidthPx * (1 - config.margin * 2),
    h: config.playgroundHeightPx * (1 - config.margin * 2)
  };

  // ../core/src/share.ts
  function share() {
    const date = /* @__PURE__ */ new Date();
    const year = date.getFullYear();
    const month = ("0" + (date.getMonth() + 1)).slice(-2);
    const day = ("0" + date.getDate()).slice(-2);
    const formattedDate = `${year}/${month}/${day}`;
    let text2 = `Unsplit ${formattedDate}`;
    text2 += `

Puzzle r\xE9ussi en ${getMoveCount()} mouvements.`;
    text2 += `

https://ferdodo.github.io/unsplit`;
    navigator.clipboard.writeText(text2);
  }

  // ../core/src/snap-to-final-position.ts
  var import_blockwise6 = __toESM(require_dist(), 1);
  function snapToFinalPosition(puzzle, piece) {
    const finalPosition = getPieceFinalPosition(puzzle, piece);
    const blockDistance = (0, import_blockwise6.calculateBlockDistance)(piece.block, finalPosition);
    const puzzleHypothenus = Math.sqrt(Math.pow(puzzle.block.w, 2) + Math.pow(puzzle.block.h, 2));
    const isCloseToFinalPosition = blockDistance < puzzleHypothenus * config.snapDistance;
    if (isCloseToFinalPosition) {
      return {
        ...piece,
        block: finalPosition
      };
    }
    return piece;
  }

  // node_modules/cookies-ds/dist/components/padlock/template.js
  var template_default = '<style>\n	:host {\n		display: block;\n	}\n\n	#lock {\n		height: 100%;\n		min-height: 5rem;\n		display: grid;\n		grid-template-columns: 1fr;\n		grid-template-rows: 1fr;\n		grid-column-gap: 0px;\n		grid-row-gap: 0px;\n	}\n\n	#padlock-body {\n		grid-area: 1 / 1 / 2 / 2;\n		background-size: 100% 100%;\n	}\n\n	#shackle {\n		grid-area: 1 / 1 / 2 / 2;\n		background-size: 100% 100%;\n		position: relative;\n		transition: top 0.3s cubic-bezier(.19,1,.22,1);\n		z-index: -1;\n	}\n\n	#shackle-click-zone {\n		grid-area: 1 / 1 / 2 / 2;\n		display: grid;\n		grid-template-columns: 2.9fr 1fr 1fr 3.5fr 1fr 1fr 2.9fr;\n		grid-template-rows: 0.4fr 1.3fr 1fr 4.6fr 9.3fr;\n		grid-column-gap: 0px;\n		grid-row-gap: 0px;\n		position: relative;\n		transition: top 0.3s cubic-bezier(.19,1,.22,1);\n		z-index: 1;\n	}\n\n	#shackle-part-1 {\n		grid-area: 3 / 2 / 5 / 4;\n	}\n\n	#shackle-part-2 {\n		grid-area: 2 / 3 / 4 / 6;\n	}\n\n	#shackle-part-3 {\n		grid-area: 3 / 5 / 5 / 7;\n	} \n</style>\n\n<div id="lock">\n	<div id="padlock-body"></div>\n	<div id="shackle"></div>\n\n	<div id="shackle-click-zone">\n		<div id="shackle-part-1" title="verrouiller"></div>\n		<div id="shackle-part-2" title="verrouiller"></div>\n		<div id="shackle-part-3" title="verrouiller"></div>\n	</div>\n</div>\n';

  // node_modules/cookies-ds/node_modules/tslib/tslib.es6.js
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics2(d2, b2);
  };
  function __extends2(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  }
  function __awaiter2(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function __generator2(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f2, y2, t2, g2;
    return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
      return this;
    }), g2;
    function verb(n2) {
      return function(v2) {
        return step([n2, v2]);
      };
    }
    function step(op) {
      if (f2)
        throw new TypeError("Generator is already executing.");
      while (g2 && (g2 = 0, op[0] && (_ = 0)), _)
        try {
          if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
            return t2;
          if (y2 = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y2 = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t2[1]) {
                _.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _.label < t2[2]) {
                _.label = t2[2];
                _.ops.push(op);
                break;
              }
              if (t2[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e2) {
          op = [6, e2];
          y2 = 0;
        } finally {
          f2 = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  }
  function __values2(o2) {
    var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
    if (m2)
      return m2.call(o2);
    if (o2 && typeof o2.length === "number")
      return {
        next: function() {
          if (o2 && i2 >= o2.length)
            o2 = void 0;
          return { value: o2 && o2[i2++], done: !o2 };
        }
      };
    throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read2(o2, n2) {
    var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
    if (!m2)
      return o2;
    var i2 = m2.call(o2), r2, ar = [], e2;
    try {
      while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
        ar.push(r2.value);
    } catch (error) {
      e2 = { error };
    } finally {
      try {
        if (r2 && !r2.done && (m2 = i2["return"]))
          m2.call(i2);
      } finally {
        if (e2)
          throw e2.error;
      }
    }
    return ar;
  }
  function __spreadArray2(to, from3, pack) {
    if (pack || arguments.length === 2)
      for (var i2 = 0, l2 = from3.length, ar; i2 < l2; i2++) {
        if (ar || !(i2 in from3)) {
          if (!ar)
            ar = Array.prototype.slice.call(from3, 0, i2);
          ar[i2] = from3[i2];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from3));
  }
  function __await2(v2) {
    return this instanceof __await2 ? (this.v = v2, this) : new __await2(v2);
  }
  function __asyncGenerator2(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g2 = generator.apply(thisArg, _arguments || []), i2, q = [];
    return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2;
    function verb(n2) {
      if (g2[n2])
        i2[n2] = function(v2) {
          return new Promise(function(a2, b2) {
            q.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
          });
        };
    }
    function resume(n2, v2) {
      try {
        step(g2[n2](v2));
      } catch (e2) {
        settle(q[0][3], e2);
      }
    }
    function step(r2) {
      r2.value instanceof __await2 ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q[0][2], r2);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f2, v2) {
      if (f2(v2), q.shift(), q.length)
        resume(q[0][0], q[0][1]);
    }
  }
  function __asyncValues2(o2) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m2 = o2[Symbol.asyncIterator], i2;
    return m2 ? m2.call(o2) : (o2 = typeof __values2 === "function" ? __values2(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2);
    function verb(n2) {
      i2[n2] = o2[n2] && function(v2) {
        return new Promise(function(resolve, reject) {
          v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
        });
      };
    }
    function settle(resolve, reject, d2, v2) {
      Promise.resolve(v2).then(function(v3) {
        resolve({ value: v3, done: d2 });
      }, reject);
    }
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/util/isFunction.js
  function isFunction2(value) {
    return typeof value === "function";
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
  function createErrorClass2(createImpl) {
    var _super = function(instance2) {
      Error.call(instance2);
      instance2.stack = new Error().stack;
    };
    var ctorFunc = createImpl(_super);
    ctorFunc.prototype = Object.create(Error.prototype);
    ctorFunc.prototype.constructor = ctorFunc;
    return ctorFunc;
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
  var UnsubscriptionError2 = createErrorClass2(function(_super) {
    return function UnsubscriptionErrorImpl(errors) {
      _super(this);
      this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i2) {
        return i2 + 1 + ") " + err.toString();
      }).join("\n  ") : "";
      this.name = "UnsubscriptionError";
      this.errors = errors;
    };
  });

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
  function arrRemove2(arr, item) {
    if (arr) {
      var index = arr.indexOf(item);
      0 <= index && arr.splice(index, 1);
    }
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/Subscription.js
  var Subscription2 = function() {
    function Subscription3(initialTeardown) {
      this.initialTeardown = initialTeardown;
      this.closed = false;
      this._parentage = null;
      this._finalizers = null;
    }
    Subscription3.prototype.unsubscribe = function() {
      var e_1, _a, e_2, _b;
      var errors;
      if (!this.closed) {
        this.closed = true;
        var _parentage = this._parentage;
        if (_parentage) {
          this._parentage = null;
          if (Array.isArray(_parentage)) {
            try {
              for (var _parentage_1 = __values2(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                var parent_1 = _parentage_1_1.value;
                parent_1.remove(this);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                  _a.call(_parentage_1);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
          } else {
            _parentage.remove(this);
          }
        }
        var initialFinalizer = this.initialTeardown;
        if (isFunction2(initialFinalizer)) {
          try {
            initialFinalizer();
          } catch (e2) {
            errors = e2 instanceof UnsubscriptionError2 ? e2.errors : [e2];
          }
        }
        var _finalizers = this._finalizers;
        if (_finalizers) {
          this._finalizers = null;
          try {
            for (var _finalizers_1 = __values2(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
              var finalizer = _finalizers_1_1.value;
              try {
                execFinalizer2(finalizer);
              } catch (err) {
                errors = errors !== null && errors !== void 0 ? errors : [];
                if (err instanceof UnsubscriptionError2) {
                  errors = __spreadArray2(__spreadArray2([], __read2(errors)), __read2(err.errors));
                } else {
                  errors.push(err);
                }
              }
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
                _b.call(_finalizers_1);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        }
        if (errors) {
          throw new UnsubscriptionError2(errors);
        }
      }
    };
    Subscription3.prototype.add = function(teardown) {
      var _a;
      if (teardown && teardown !== this) {
        if (this.closed) {
          execFinalizer2(teardown);
        } else {
          if (teardown instanceof Subscription3) {
            if (teardown.closed || teardown._hasParent(this)) {
              return;
            }
            teardown._addParent(this);
          }
          (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
        }
      }
    };
    Subscription3.prototype._hasParent = function(parent) {
      var _parentage = this._parentage;
      return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
    };
    Subscription3.prototype._addParent = function(parent) {
      var _parentage = this._parentage;
      this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
    };
    Subscription3.prototype._removeParent = function(parent) {
      var _parentage = this._parentage;
      if (_parentage === parent) {
        this._parentage = null;
      } else if (Array.isArray(_parentage)) {
        arrRemove2(_parentage, parent);
      }
    };
    Subscription3.prototype.remove = function(teardown) {
      var _finalizers = this._finalizers;
      _finalizers && arrRemove2(_finalizers, teardown);
      if (teardown instanceof Subscription3) {
        teardown._removeParent(this);
      }
    };
    Subscription3.EMPTY = function() {
      var empty = new Subscription3();
      empty.closed = true;
      return empty;
    }();
    return Subscription3;
  }();
  var EMPTY_SUBSCRIPTION2 = Subscription2.EMPTY;
  function isSubscription2(value) {
    return value instanceof Subscription2 || value && "closed" in value && isFunction2(value.remove) && isFunction2(value.add) && isFunction2(value.unsubscribe);
  }
  function execFinalizer2(finalizer) {
    if (isFunction2(finalizer)) {
      finalizer();
    } else {
      finalizer.unsubscribe();
    }
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/config.js
  var config3 = {
    onUnhandledError: null,
    onStoppedNotification: null,
    Promise: void 0,
    useDeprecatedSynchronousErrorHandling: false,
    useDeprecatedNextContext: false
  };

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
  var timeoutProvider2 = {
    setTimeout: function(handler, timeout) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      var delegate = timeoutProvider2.delegate;
      if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
        return delegate.setTimeout.apply(delegate, __spreadArray2([handler, timeout], __read2(args)));
      }
      return setTimeout.apply(void 0, __spreadArray2([handler, timeout], __read2(args)));
    },
    clearTimeout: function(handle) {
      var delegate = timeoutProvider2.delegate;
      return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
    },
    delegate: void 0
  };

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
  function reportUnhandledError2(err) {
    timeoutProvider2.setTimeout(function() {
      var onUnhandledError = config3.onUnhandledError;
      if (onUnhandledError) {
        onUnhandledError(err);
      } else {
        throw err;
      }
    });
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/util/noop.js
  function noop3() {
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/NotificationFactories.js
  var COMPLETE_NOTIFICATION2 = function() {
    return createNotification2("C", void 0, void 0);
  }();
  function errorNotification2(error) {
    return createNotification2("E", void 0, error);
  }
  function nextNotification2(value) {
    return createNotification2("N", value, void 0);
  }
  function createNotification2(kind, value, error) {
    return {
      kind,
      value,
      error
    };
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/util/errorContext.js
  var context3 = null;
  function errorContext2(cb) {
    if (config3.useDeprecatedSynchronousErrorHandling) {
      var isRoot = !context3;
      if (isRoot) {
        context3 = { errorThrown: false, error: null };
      }
      cb();
      if (isRoot) {
        var _a = context3, errorThrown = _a.errorThrown, error = _a.error;
        context3 = null;
        if (errorThrown) {
          throw error;
        }
      }
    } else {
      cb();
    }
  }
  function captureError2(err) {
    if (config3.useDeprecatedSynchronousErrorHandling && context3) {
      context3.errorThrown = true;
      context3.error = err;
    }
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/Subscriber.js
  var Subscriber2 = function(_super) {
    __extends2(Subscriber3, _super);
    function Subscriber3(destination) {
      var _this = _super.call(this) || this;
      _this.isStopped = false;
      if (destination) {
        _this.destination = destination;
        if (isSubscription2(destination)) {
          destination.add(_this);
        }
      } else {
        _this.destination = EMPTY_OBSERVER2;
      }
      return _this;
    }
    Subscriber3.create = function(next, error, complete) {
      return new SafeSubscriber2(next, error, complete);
    };
    Subscriber3.prototype.next = function(value) {
      if (this.isStopped) {
        handleStoppedNotification2(nextNotification2(value), this);
      } else {
        this._next(value);
      }
    };
    Subscriber3.prototype.error = function(err) {
      if (this.isStopped) {
        handleStoppedNotification2(errorNotification2(err), this);
      } else {
        this.isStopped = true;
        this._error(err);
      }
    };
    Subscriber3.prototype.complete = function() {
      if (this.isStopped) {
        handleStoppedNotification2(COMPLETE_NOTIFICATION2, this);
      } else {
        this.isStopped = true;
        this._complete();
      }
    };
    Subscriber3.prototype.unsubscribe = function() {
      if (!this.closed) {
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
        this.destination = null;
      }
    };
    Subscriber3.prototype._next = function(value) {
      this.destination.next(value);
    };
    Subscriber3.prototype._error = function(err) {
      try {
        this.destination.error(err);
      } finally {
        this.unsubscribe();
      }
    };
    Subscriber3.prototype._complete = function() {
      try {
        this.destination.complete();
      } finally {
        this.unsubscribe();
      }
    };
    return Subscriber3;
  }(Subscription2);
  var _bind2 = Function.prototype.bind;
  function bind2(fn, thisArg) {
    return _bind2.call(fn, thisArg);
  }
  var ConsumerObserver2 = function() {
    function ConsumerObserver3(partialObserver) {
      this.partialObserver = partialObserver;
    }
    ConsumerObserver3.prototype.next = function(value) {
      var partialObserver = this.partialObserver;
      if (partialObserver.next) {
        try {
          partialObserver.next(value);
        } catch (error) {
          handleUnhandledError2(error);
        }
      }
    };
    ConsumerObserver3.prototype.error = function(err) {
      var partialObserver = this.partialObserver;
      if (partialObserver.error) {
        try {
          partialObserver.error(err);
        } catch (error) {
          handleUnhandledError2(error);
        }
      } else {
        handleUnhandledError2(err);
      }
    };
    ConsumerObserver3.prototype.complete = function() {
      var partialObserver = this.partialObserver;
      if (partialObserver.complete) {
        try {
          partialObserver.complete();
        } catch (error) {
          handleUnhandledError2(error);
        }
      }
    };
    return ConsumerObserver3;
  }();
  var SafeSubscriber2 = function(_super) {
    __extends2(SafeSubscriber3, _super);
    function SafeSubscriber3(observerOrNext, error, complete) {
      var _this = _super.call(this) || this;
      var partialObserver;
      if (isFunction2(observerOrNext) || !observerOrNext) {
        partialObserver = {
          next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
          error: error !== null && error !== void 0 ? error : void 0,
          complete: complete !== null && complete !== void 0 ? complete : void 0
        };
      } else {
        var context_1;
        if (_this && config3.useDeprecatedNextContext) {
          context_1 = Object.create(observerOrNext);
          context_1.unsubscribe = function() {
            return _this.unsubscribe();
          };
          partialObserver = {
            next: observerOrNext.next && bind2(observerOrNext.next, context_1),
            error: observerOrNext.error && bind2(observerOrNext.error, context_1),
            complete: observerOrNext.complete && bind2(observerOrNext.complete, context_1)
          };
        } else {
          partialObserver = observerOrNext;
        }
      }
      _this.destination = new ConsumerObserver2(partialObserver);
      return _this;
    }
    return SafeSubscriber3;
  }(Subscriber2);
  function handleUnhandledError2(error) {
    if (config3.useDeprecatedSynchronousErrorHandling) {
      captureError2(error);
    } else {
      reportUnhandledError2(error);
    }
  }
  function defaultErrorHandler2(err) {
    throw err;
  }
  function handleStoppedNotification2(notification, subscriber) {
    var onStoppedNotification = config3.onStoppedNotification;
    onStoppedNotification && timeoutProvider2.setTimeout(function() {
      return onStoppedNotification(notification, subscriber);
    });
  }
  var EMPTY_OBSERVER2 = {
    closed: true,
    next: noop3,
    error: defaultErrorHandler2,
    complete: noop3
  };

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/symbol/observable.js
  var observable2 = function() {
    return typeof Symbol === "function" && Symbol.observable || "@@observable";
  }();

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/util/identity.js
  function identity3(x2) {
    return x2;
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/util/pipe.js
  function pipeFromArray2(fns) {
    if (fns.length === 0) {
      return identity3;
    }
    if (fns.length === 1) {
      return fns[0];
    }
    return function piped(input) {
      return fns.reduce(function(prev, fn) {
        return fn(prev);
      }, input);
    };
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/Observable.js
  var Observable5 = function() {
    function Observable6(subscribe) {
      if (subscribe) {
        this._subscribe = subscribe;
      }
    }
    Observable6.prototype.lift = function(operator) {
      var observable3 = new Observable6();
      observable3.source = this;
      observable3.operator = operator;
      return observable3;
    };
    Observable6.prototype.subscribe = function(observerOrNext, error, complete) {
      var _this = this;
      var subscriber = isSubscriber2(observerOrNext) ? observerOrNext : new SafeSubscriber2(observerOrNext, error, complete);
      errorContext2(function() {
        var _a = _this, operator = _a.operator, source2 = _a.source;
        subscriber.add(operator ? operator.call(subscriber, source2) : source2 ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
      });
      return subscriber;
    };
    Observable6.prototype._trySubscribe = function(sink) {
      try {
        return this._subscribe(sink);
      } catch (err) {
        sink.error(err);
      }
    };
    Observable6.prototype.forEach = function(next, promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor2(promiseCtor);
      return new promiseCtor(function(resolve, reject) {
        var subscriber = new SafeSubscriber2({
          next: function(value) {
            try {
              next(value);
            } catch (err) {
              reject(err);
              subscriber.unsubscribe();
            }
          },
          error: reject,
          complete: resolve
        });
        _this.subscribe(subscriber);
      });
    };
    Observable6.prototype._subscribe = function(subscriber) {
      var _a;
      return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
    };
    Observable6.prototype[observable2] = function() {
      return this;
    };
    Observable6.prototype.pipe = function() {
      var operations = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        operations[_i] = arguments[_i];
      }
      return pipeFromArray2(operations)(this);
    };
    Observable6.prototype.toPromise = function(promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor2(promiseCtor);
      return new promiseCtor(function(resolve, reject) {
        var value;
        _this.subscribe(function(x2) {
          return value = x2;
        }, function(err) {
          return reject(err);
        }, function() {
          return resolve(value);
        });
      });
    };
    Observable6.create = function(subscribe) {
      return new Observable6(subscribe);
    };
    return Observable6;
  }();
  function getPromiseCtor2(promiseCtor) {
    var _a;
    return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config3.Promise) !== null && _a !== void 0 ? _a : Promise;
  }
  function isObserver2(value) {
    return value && isFunction2(value.next) && isFunction2(value.error) && isFunction2(value.complete);
  }
  function isSubscriber2(value) {
    return value && value instanceof Subscriber2 || isObserver2(value) && isSubscription2(value);
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/util/lift.js
  function hasLift2(source2) {
    return isFunction2(source2 === null || source2 === void 0 ? void 0 : source2.lift);
  }
  function operate2(init3) {
    return function(source2) {
      if (hasLift2(source2)) {
        return source2.lift(function(liftedSource) {
          try {
            return init3(liftedSource, this);
          } catch (err) {
            this.error(err);
          }
        });
      }
      throw new TypeError("Unable to lift unknown Observable type");
    };
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js
  function createOperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize) {
    return new OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize);
  }
  var OperatorSubscriber2 = function(_super) {
    __extends2(OperatorSubscriber3, _super);
    function OperatorSubscriber3(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
      var _this = _super.call(this, destination) || this;
      _this.onFinalize = onFinalize;
      _this.shouldUnsubscribe = shouldUnsubscribe;
      _this._next = onNext ? function(value) {
        try {
          onNext(value);
        } catch (err) {
          destination.error(err);
        }
      } : _super.prototype._next;
      _this._error = onError ? function(err) {
        try {
          onError(err);
        } catch (err2) {
          destination.error(err2);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._error;
      _this._complete = onComplete ? function() {
        try {
          onComplete();
        } catch (err) {
          destination.error(err);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._complete;
      return _this;
    }
    OperatorSubscriber3.prototype.unsubscribe = function() {
      var _a;
      if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
        var closed_1 = this.closed;
        _super.prototype.unsubscribe.call(this);
        !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
      }
    };
    return OperatorSubscriber3;
  }(Subscriber2);

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js
  var ObjectUnsubscribedError2 = createErrorClass2(function(_super) {
    return function ObjectUnsubscribedErrorImpl() {
      _super(this);
      this.name = "ObjectUnsubscribedError";
      this.message = "object unsubscribed";
    };
  });

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/Subject.js
  var Subject2 = function(_super) {
    __extends2(Subject3, _super);
    function Subject3() {
      var _this = _super.call(this) || this;
      _this.closed = false;
      _this.currentObservers = null;
      _this.observers = [];
      _this.isStopped = false;
      _this.hasError = false;
      _this.thrownError = null;
      return _this;
    }
    Subject3.prototype.lift = function(operator) {
      var subject = new AnonymousSubject2(this, this);
      subject.operator = operator;
      return subject;
    };
    Subject3.prototype._throwIfClosed = function() {
      if (this.closed) {
        throw new ObjectUnsubscribedError2();
      }
    };
    Subject3.prototype.next = function(value) {
      var _this = this;
      errorContext2(function() {
        var e_1, _a;
        _this._throwIfClosed();
        if (!_this.isStopped) {
          if (!_this.currentObservers) {
            _this.currentObservers = Array.from(_this.observers);
          }
          try {
            for (var _b = __values2(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
              var observer = _c.value;
              observer.next(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return))
                _a.call(_b);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }
      });
    };
    Subject3.prototype.error = function(err) {
      var _this = this;
      errorContext2(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.hasError = _this.isStopped = true;
          _this.thrownError = err;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().error(err);
          }
        }
      });
    };
    Subject3.prototype.complete = function() {
      var _this = this;
      errorContext2(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.isStopped = true;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().complete();
          }
        }
      });
    };
    Subject3.prototype.unsubscribe = function() {
      this.isStopped = this.closed = true;
      this.observers = this.currentObservers = null;
    };
    Object.defineProperty(Subject3.prototype, "observed", {
      get: function() {
        var _a;
        return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
      },
      enumerable: false,
      configurable: true
    });
    Subject3.prototype._trySubscribe = function(subscriber) {
      this._throwIfClosed();
      return _super.prototype._trySubscribe.call(this, subscriber);
    };
    Subject3.prototype._subscribe = function(subscriber) {
      this._throwIfClosed();
      this._checkFinalizedStatuses(subscriber);
      return this._innerSubscribe(subscriber);
    };
    Subject3.prototype._innerSubscribe = function(subscriber) {
      var _this = this;
      var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
      if (hasError || isStopped) {
        return EMPTY_SUBSCRIPTION2;
      }
      this.currentObservers = null;
      observers.push(subscriber);
      return new Subscription2(function() {
        _this.currentObservers = null;
        arrRemove2(observers, subscriber);
      });
    };
    Subject3.prototype._checkFinalizedStatuses = function(subscriber) {
      var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
      if (hasError) {
        subscriber.error(thrownError);
      } else if (isStopped) {
        subscriber.complete();
      }
    };
    Subject3.prototype.asObservable = function() {
      var observable3 = new Observable5();
      observable3.source = this;
      return observable3;
    };
    Subject3.create = function(destination, source2) {
      return new AnonymousSubject2(destination, source2);
    };
    return Subject3;
  }(Observable5);
  var AnonymousSubject2 = function(_super) {
    __extends2(AnonymousSubject3, _super);
    function AnonymousSubject3(destination, source2) {
      var _this = _super.call(this) || this;
      _this.destination = destination;
      _this.source = source2;
      return _this;
    }
    AnonymousSubject3.prototype.next = function(value) {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
    };
    AnonymousSubject3.prototype.error = function(err) {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
    };
    AnonymousSubject3.prototype.complete = function() {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
    };
    AnonymousSubject3.prototype._subscribe = function(subscriber) {
      var _a, _b;
      return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION2;
    };
    return AnonymousSubject3;
  }(Subject2);

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js
  var dateTimestampProvider = {
    now: function() {
      return (dateTimestampProvider.delegate || Date).now();
    },
    delegate: void 0
  };

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/scheduler/Action.js
  var Action = function(_super) {
    __extends2(Action2, _super);
    function Action2(scheduler, work) {
      return _super.call(this) || this;
    }
    Action2.prototype.schedule = function(state, delay) {
      if (delay === void 0) {
        delay = 0;
      }
      return this;
    };
    return Action2;
  }(Subscription2);

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/scheduler/intervalProvider.js
  var intervalProvider = {
    setInterval: function(handler, timeout) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      var delegate = intervalProvider.delegate;
      if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
        return delegate.setInterval.apply(delegate, __spreadArray2([handler, timeout], __read2(args)));
      }
      return setInterval.apply(void 0, __spreadArray2([handler, timeout], __read2(args)));
    },
    clearInterval: function(handle) {
      var delegate = intervalProvider.delegate;
      return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
    },
    delegate: void 0
  };

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js
  var AsyncAction = function(_super) {
    __extends2(AsyncAction2, _super);
    function AsyncAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      _this.pending = false;
      return _this;
    }
    AsyncAction2.prototype.schedule = function(state, delay) {
      var _a;
      if (delay === void 0) {
        delay = 0;
      }
      if (this.closed) {
        return this;
      }
      this.state = state;
      var id = this.id;
      var scheduler = this.scheduler;
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, delay);
      }
      this.pending = true;
      this.delay = delay;
      this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay);
      return this;
    };
    AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay) {
      if (delay === void 0) {
        delay = 0;
      }
      return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay) {
      if (delay === void 0) {
        delay = 0;
      }
      if (delay != null && this.delay === delay && this.pending === false) {
        return id;
      }
      if (id != null) {
        intervalProvider.clearInterval(id);
      }
      return void 0;
    };
    AsyncAction2.prototype.execute = function(state, delay) {
      if (this.closed) {
        return new Error("executing a cancelled action");
      }
      this.pending = false;
      var error = this._execute(state, delay);
      if (error) {
        return error;
      } else if (this.pending === false && this.id != null) {
        this.id = this.recycleAsyncId(this.scheduler, this.id, null);
      }
    };
    AsyncAction2.prototype._execute = function(state, _delay) {
      var errored = false;
      var errorValue;
      try {
        this.work(state);
      } catch (e2) {
        errored = true;
        errorValue = e2 ? e2 : new Error("Scheduled action threw falsy error");
      }
      if (errored) {
        this.unsubscribe();
        return errorValue;
      }
    };
    AsyncAction2.prototype.unsubscribe = function() {
      if (!this.closed) {
        var _a = this, id = _a.id, scheduler = _a.scheduler;
        var actions = scheduler.actions;
        this.work = this.state = this.scheduler = null;
        this.pending = false;
        arrRemove2(actions, this);
        if (id != null) {
          this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
        _super.prototype.unsubscribe.call(this);
      }
    };
    return AsyncAction2;
  }(Action);

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/Scheduler.js
  var Scheduler = function() {
    function Scheduler2(schedulerActionCtor, now2) {
      if (now2 === void 0) {
        now2 = Scheduler2.now;
      }
      this.schedulerActionCtor = schedulerActionCtor;
      this.now = now2;
    }
    Scheduler2.prototype.schedule = function(work, delay, state) {
      if (delay === void 0) {
        delay = 0;
      }
      return new this.schedulerActionCtor(this, work).schedule(state, delay);
    };
    Scheduler2.now = dateTimestampProvider.now;
    return Scheduler2;
  }();

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js
  var AsyncScheduler = function(_super) {
    __extends2(AsyncScheduler2, _super);
    function AsyncScheduler2(SchedulerAction, now2) {
      if (now2 === void 0) {
        now2 = Scheduler.now;
      }
      var _this = _super.call(this, SchedulerAction, now2) || this;
      _this.actions = [];
      _this._active = false;
      return _this;
    }
    AsyncScheduler2.prototype.flush = function(action) {
      var actions = this.actions;
      if (this._active) {
        actions.push(action);
        return;
      }
      var error;
      this._active = true;
      do {
        if (error = action.execute(action.state, action.delay)) {
          break;
        }
      } while (action = actions.shift());
      this._active = false;
      if (error) {
        while (action = actions.shift()) {
          action.unsubscribe();
        }
        throw error;
      }
    };
    return AsyncScheduler2;
  }(Scheduler);

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/scheduler/async.js
  var asyncScheduler = new AsyncScheduler(AsyncAction);
  var async = asyncScheduler;

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/observable/empty.js
  var EMPTY2 = new Observable5(function(subscriber) {
    return subscriber.complete();
  });

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/util/isScheduler.js
  function isScheduler2(value) {
    return value && isFunction2(value.schedule);
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/util/args.js
  function last2(arr) {
    return arr[arr.length - 1];
  }
  function popResultSelector2(args) {
    return isFunction2(last2(args)) ? args.pop() : void 0;
  }
  function popScheduler2(args) {
    return isScheduler2(last2(args)) ? args.pop() : void 0;
  }
  function popNumber2(args, defaultValue2) {
    return typeof last2(args) === "number" ? args.pop() : defaultValue2;
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js
  var isArrayLike2 = function(x2) {
    return x2 && typeof x2.length === "number" && typeof x2 !== "function";
  };

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/util/isPromise.js
  function isPromise2(value) {
    return isFunction2(value === null || value === void 0 ? void 0 : value.then);
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js
  function isInteropObservable2(input) {
    return isFunction2(input[observable2]);
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js
  function isAsyncIterable2(obj) {
    return Symbol.asyncIterator && isFunction2(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js
  function createInvalidObservableTypeError2(input) {
    return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/symbol/iterator.js
  function getSymbolIterator2() {
    if (typeof Symbol !== "function" || !Symbol.iterator) {
      return "@@iterator";
    }
    return Symbol.iterator;
  }
  var iterator2 = getSymbolIterator2();

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/util/isIterable.js
  function isIterable2(input) {
    return isFunction2(input === null || input === void 0 ? void 0 : input[iterator2]);
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js
  function readableStreamLikeToAsyncGenerator2(readableStream) {
    return __asyncGenerator2(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
      var reader, _a, value, done;
      return __generator2(this, function(_b) {
        switch (_b.label) {
          case 0:
            reader = readableStream.getReader();
            _b.label = 1;
          case 1:
            _b.trys.push([1, , 9, 10]);
            _b.label = 2;
          case 2:
            if (false)
              return [3, 8];
            return [4, __await2(reader.read())];
          case 3:
            _a = _b.sent(), value = _a.value, done = _a.done;
            if (!done)
              return [3, 5];
            return [4, __await2(void 0)];
          case 4:
            return [2, _b.sent()];
          case 5:
            return [4, __await2(value)];
          case 6:
            return [4, _b.sent()];
          case 7:
            _b.sent();
            return [3, 2];
          case 8:
            return [3, 10];
          case 9:
            reader.releaseLock();
            return [7];
          case 10:
            return [2];
        }
      });
    });
  }
  function isReadableStreamLike2(obj) {
    return isFunction2(obj === null || obj === void 0 ? void 0 : obj.getReader);
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js
  function innerFrom2(input) {
    if (input instanceof Observable5) {
      return input;
    }
    if (input != null) {
      if (isInteropObservable2(input)) {
        return fromInteropObservable2(input);
      }
      if (isArrayLike2(input)) {
        return fromArrayLike2(input);
      }
      if (isPromise2(input)) {
        return fromPromise2(input);
      }
      if (isAsyncIterable2(input)) {
        return fromAsyncIterable2(input);
      }
      if (isIterable2(input)) {
        return fromIterable2(input);
      }
      if (isReadableStreamLike2(input)) {
        return fromReadableStreamLike2(input);
      }
    }
    throw createInvalidObservableTypeError2(input);
  }
  function fromInteropObservable2(obj) {
    return new Observable5(function(subscriber) {
      var obs = obj[observable2]();
      if (isFunction2(obs.subscribe)) {
        return obs.subscribe(subscriber);
      }
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    });
  }
  function fromArrayLike2(array) {
    return new Observable5(function(subscriber) {
      for (var i2 = 0; i2 < array.length && !subscriber.closed; i2++) {
        subscriber.next(array[i2]);
      }
      subscriber.complete();
    });
  }
  function fromPromise2(promise2) {
    return new Observable5(function(subscriber) {
      promise2.then(function(value) {
        if (!subscriber.closed) {
          subscriber.next(value);
          subscriber.complete();
        }
      }, function(err) {
        return subscriber.error(err);
      }).then(null, reportUnhandledError2);
    });
  }
  function fromIterable2(iterable) {
    return new Observable5(function(subscriber) {
      var e_1, _a;
      try {
        for (var iterable_1 = __values2(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
          var value = iterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return;
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return))
            _a.call(iterable_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      subscriber.complete();
    });
  }
  function fromAsyncIterable2(asyncIterable) {
    return new Observable5(function(subscriber) {
      process2(asyncIterable, subscriber).catch(function(err) {
        return subscriber.error(err);
      });
    });
  }
  function fromReadableStreamLike2(readableStream) {
    return fromAsyncIterable2(readableStreamLikeToAsyncGenerator2(readableStream));
  }
  function process2(asyncIterable, subscriber) {
    var asyncIterable_1, asyncIterable_1_1;
    var e_2, _a;
    return __awaiter2(this, void 0, void 0, function() {
      var value, e_2_1;
      return __generator2(this, function(_b) {
        switch (_b.label) {
          case 0:
            _b.trys.push([0, 5, 6, 11]);
            asyncIterable_1 = __asyncValues2(asyncIterable);
            _b.label = 1;
          case 1:
            return [4, asyncIterable_1.next()];
          case 2:
            if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
              return [3, 4];
            value = asyncIterable_1_1.value;
            subscriber.next(value);
            if (subscriber.closed) {
              return [2];
            }
            _b.label = 3;
          case 3:
            return [3, 1];
          case 4:
            return [3, 11];
          case 5:
            e_2_1 = _b.sent();
            e_2 = { error: e_2_1 };
            return [3, 11];
          case 6:
            _b.trys.push([6, , 9, 10]);
            if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)))
              return [3, 8];
            return [4, _a.call(asyncIterable_1)];
          case 7:
            _b.sent();
            _b.label = 8;
          case 8:
            return [3, 10];
          case 9:
            if (e_2)
              throw e_2.error;
            return [7];
          case 10:
            return [7];
          case 11:
            subscriber.complete();
            return [2];
        }
      });
    });
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js
  function executeSchedule2(parentSubscription, scheduler, work, delay, repeat) {
    if (delay === void 0) {
      delay = 0;
    }
    if (repeat === void 0) {
      repeat = false;
    }
    var scheduleSubscription = scheduler.schedule(function() {
      work();
      if (repeat) {
        parentSubscription.add(this.schedule(null, delay));
      } else {
        this.unsubscribe();
      }
    }, delay);
    parentSubscription.add(scheduleSubscription);
    if (!repeat) {
      return scheduleSubscription;
    }
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/operators/observeOn.js
  function observeOn2(scheduler, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    return operate2(function(source2, subscriber) {
      source2.subscribe(createOperatorSubscriber2(subscriber, function(value) {
        return executeSchedule2(subscriber, scheduler, function() {
          return subscriber.next(value);
        }, delay);
      }, function() {
        return executeSchedule2(subscriber, scheduler, function() {
          return subscriber.complete();
        }, delay);
      }, function(err) {
        return executeSchedule2(subscriber, scheduler, function() {
          return subscriber.error(err);
        }, delay);
      }));
    });
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js
  function subscribeOn2(scheduler, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    return operate2(function(source2, subscriber) {
      subscriber.add(scheduler.schedule(function() {
        return source2.subscribe(subscriber);
      }, delay));
    });
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js
  function scheduleObservable2(input, scheduler) {
    return innerFrom2(input).pipe(subscribeOn2(scheduler), observeOn2(scheduler));
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js
  function schedulePromise2(input, scheduler) {
    return innerFrom2(input).pipe(subscribeOn2(scheduler), observeOn2(scheduler));
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js
  function scheduleArray2(input, scheduler) {
    return new Observable5(function(subscriber) {
      var i2 = 0;
      return scheduler.schedule(function() {
        if (i2 === input.length) {
          subscriber.complete();
        } else {
          subscriber.next(input[i2++]);
          if (!subscriber.closed) {
            this.schedule();
          }
        }
      });
    });
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js
  function scheduleIterable2(input, scheduler) {
    return new Observable5(function(subscriber) {
      var iterator3;
      executeSchedule2(subscriber, scheduler, function() {
        iterator3 = input[iterator2]();
        executeSchedule2(subscriber, scheduler, function() {
          var _a;
          var value;
          var done;
          try {
            _a = iterator3.next(), value = _a.value, done = _a.done;
          } catch (err) {
            subscriber.error(err);
            return;
          }
          if (done) {
            subscriber.complete();
          } else {
            subscriber.next(value);
          }
        }, 0, true);
      });
      return function() {
        return isFunction2(iterator3 === null || iterator3 === void 0 ? void 0 : iterator3.return) && iterator3.return();
      };
    });
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js
  function scheduleAsyncIterable2(input, scheduler) {
    if (!input) {
      throw new Error("Iterable cannot be null");
    }
    return new Observable5(function(subscriber) {
      executeSchedule2(subscriber, scheduler, function() {
        var iterator3 = input[Symbol.asyncIterator]();
        executeSchedule2(subscriber, scheduler, function() {
          iterator3.next().then(function(result) {
            if (result.done) {
              subscriber.complete();
            } else {
              subscriber.next(result.value);
            }
          });
        }, 0, true);
      });
    });
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js
  function scheduleReadableStreamLike2(input, scheduler) {
    return scheduleAsyncIterable2(readableStreamLikeToAsyncGenerator2(input), scheduler);
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js
  function scheduled2(input, scheduler) {
    if (input != null) {
      if (isInteropObservable2(input)) {
        return scheduleObservable2(input, scheduler);
      }
      if (isArrayLike2(input)) {
        return scheduleArray2(input, scheduler);
      }
      if (isPromise2(input)) {
        return schedulePromise2(input, scheduler);
      }
      if (isAsyncIterable2(input)) {
        return scheduleAsyncIterable2(input, scheduler);
      }
      if (isIterable2(input)) {
        return scheduleIterable2(input, scheduler);
      }
      if (isReadableStreamLike2(input)) {
        return scheduleReadableStreamLike2(input, scheduler);
      }
    }
    throw createInvalidObservableTypeError2(input);
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/observable/from.js
  function from2(input, scheduler) {
    return scheduler ? scheduled2(input, scheduler) : innerFrom2(input);
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/util/EmptyError.js
  var EmptyError = createErrorClass2(function(_super) {
    return function EmptyErrorImpl() {
      _super(this);
      this.name = "EmptyError";
      this.message = "no elements in sequence";
    };
  });

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/util/isDate.js
  function isValidDate(value) {
    return value instanceof Date && !isNaN(value);
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/operators/map.js
  function map2(project, thisArg) {
    return operate2(function(source2, subscriber) {
      var index = 0;
      source2.subscribe(createOperatorSubscriber2(subscriber, function(value) {
        subscriber.next(project.call(thisArg, value, index++));
      }));
    });
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js
  var isArray = Array.isArray;
  function callOrApply(fn, args) {
    return isArray(args) ? fn.apply(void 0, __spreadArray2([], __read2(args))) : fn(args);
  }
  function mapOneOrManyArgs(fn) {
    return map2(function(args) {
      return callOrApply(fn, args);
    });
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/util/argsArgArrayOrObject.js
  var isArray2 = Array.isArray;
  var getPrototypeOf = Object.getPrototypeOf;
  var objectProto = Object.prototype;
  var getKeys = Object.keys;
  function argsArgArrayOrObject(args) {
    if (args.length === 1) {
      var first_1 = args[0];
      if (isArray2(first_1)) {
        return { args: first_1, keys: null };
      }
      if (isPOJO(first_1)) {
        var keys = getKeys(first_1);
        return {
          args: keys.map(function(key) {
            return first_1[key];
          }),
          keys
        };
      }
    }
    return { args, keys: null };
  }
  function isPOJO(obj) {
    return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/util/createObject.js
  function createObject(keys, values) {
    return keys.reduce(function(result, key, i2) {
      return result[key] = values[i2], result;
    }, {});
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js
  function combineLatest2() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = popScheduler2(args);
    var resultSelector = popResultSelector2(args);
    var _a = argsArgArrayOrObject(args), observables = _a.args, keys = _a.keys;
    if (observables.length === 0) {
      return from2([], scheduler);
    }
    var result = new Observable5(combineLatestInit(observables, scheduler, keys ? function(values) {
      return createObject(keys, values);
    } : identity3));
    return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
  }
  function combineLatestInit(observables, scheduler, valueTransform) {
    if (valueTransform === void 0) {
      valueTransform = identity3;
    }
    return function(subscriber) {
      maybeSchedule(scheduler, function() {
        var length = observables.length;
        var values = new Array(length);
        var active = length;
        var remainingFirstValues = length;
        var _loop_1 = function(i3) {
          maybeSchedule(scheduler, function() {
            var source2 = from2(observables[i3], scheduler);
            var hasFirstValue = false;
            source2.subscribe(createOperatorSubscriber2(subscriber, function(value) {
              values[i3] = value;
              if (!hasFirstValue) {
                hasFirstValue = true;
                remainingFirstValues--;
              }
              if (!remainingFirstValues) {
                subscriber.next(valueTransform(values.slice()));
              }
            }, function() {
              if (!--active) {
                subscriber.complete();
              }
            }));
          }, subscriber);
        };
        for (var i2 = 0; i2 < length; i2++) {
          _loop_1(i2);
        }
      }, subscriber);
    };
  }
  function maybeSchedule(scheduler, execute, subscription) {
    if (scheduler) {
      executeSchedule2(subscription, scheduler, execute);
    } else {
      execute();
    }
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js
  function mergeInternals2(source2, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
    var buffer = [];
    var active = 0;
    var index = 0;
    var isComplete = false;
    var checkComplete = function() {
      if (isComplete && !buffer.length && !active) {
        subscriber.complete();
      }
    };
    var outerNext = function(value) {
      return active < concurrent ? doInnerSub(value) : buffer.push(value);
    };
    var doInnerSub = function(value) {
      expand && subscriber.next(value);
      active++;
      var innerComplete = false;
      innerFrom2(project(value, index++)).subscribe(createOperatorSubscriber2(subscriber, function(innerValue) {
        onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
        if (expand) {
          outerNext(innerValue);
        } else {
          subscriber.next(innerValue);
        }
      }, function() {
        innerComplete = true;
      }, void 0, function() {
        if (innerComplete) {
          try {
            active--;
            var _loop_1 = function() {
              var bufferedValue = buffer.shift();
              if (innerSubScheduler) {
                executeSchedule2(subscriber, innerSubScheduler, function() {
                  return doInnerSub(bufferedValue);
                });
              } else {
                doInnerSub(bufferedValue);
              }
            };
            while (buffer.length && active < concurrent) {
              _loop_1();
            }
            checkComplete();
          } catch (err) {
            subscriber.error(err);
          }
        }
      }));
    };
    source2.subscribe(createOperatorSubscriber2(subscriber, outerNext, function() {
      isComplete = true;
      checkComplete();
    }));
    return function() {
      additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
    };
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js
  function mergeMap2(project, resultSelector, concurrent) {
    if (concurrent === void 0) {
      concurrent = Infinity;
    }
    if (isFunction2(resultSelector)) {
      return mergeMap2(function(a2, i2) {
        return map2(function(b2, ii) {
          return resultSelector(a2, b2, i2, ii);
        })(innerFrom2(project(a2, i2)));
      }, concurrent);
    } else if (typeof resultSelector === "number") {
      concurrent = resultSelector;
    }
    return operate2(function(source2, subscriber) {
      return mergeInternals2(source2, subscriber, project, concurrent);
    });
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js
  function mergeAll2(concurrent) {
    if (concurrent === void 0) {
      concurrent = Infinity;
    }
    return mergeMap2(identity3, concurrent);
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/observable/fromEvent.js
  var nodeEventEmitterMethods = ["addListener", "removeListener"];
  var eventTargetMethods = ["addEventListener", "removeEventListener"];
  var jqueryMethods = ["on", "off"];
  function fromEvent(target, eventName, options, resultSelector) {
    if (isFunction2(options)) {
      resultSelector = options;
      options = void 0;
    }
    if (resultSelector) {
      return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));
    }
    var _a = __read2(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
      return function(handler) {
        return target[methodName](eventName, handler, options);
      };
    }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add = _a[0], remove = _a[1];
    if (!add) {
      if (isArrayLike2(target)) {
        return mergeMap2(function(subTarget) {
          return fromEvent(subTarget, eventName, options);
        })(innerFrom2(target));
      }
    }
    if (!add) {
      throw new TypeError("Invalid event target");
    }
    return new Observable5(function(subscriber) {
      var handler = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return subscriber.next(1 < args.length ? args : args[0]);
      };
      add(handler);
      return function() {
        return remove(handler);
      };
    });
  }
  function toCommonHandlerRegistry(target, eventName) {
    return function(methodName) {
      return function(handler) {
        return target[methodName](eventName, handler);
      };
    };
  }
  function isNodeStyleEventEmitter(target) {
    return isFunction2(target.addListener) && isFunction2(target.removeListener);
  }
  function isJQueryStyleEventEmitter(target) {
    return isFunction2(target.on) && isFunction2(target.off);
  }
  function isEventTarget(target) {
    return isFunction2(target.addEventListener) && isFunction2(target.removeEventListener);
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/observable/timer.js
  function timer(dueTime, intervalOrScheduler, scheduler) {
    if (dueTime === void 0) {
      dueTime = 0;
    }
    if (scheduler === void 0) {
      scheduler = async;
    }
    var intervalDuration = -1;
    if (intervalOrScheduler != null) {
      if (isScheduler2(intervalOrScheduler)) {
        scheduler = intervalOrScheduler;
      } else {
        intervalDuration = intervalOrScheduler;
      }
    }
    return new Observable5(function(subscriber) {
      var due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
      if (due < 0) {
        due = 0;
      }
      var n2 = 0;
      return scheduler.schedule(function() {
        if (!subscriber.closed) {
          subscriber.next(n2++);
          if (0 <= intervalDuration) {
            this.schedule(void 0, intervalDuration);
          } else {
            subscriber.complete();
          }
        }
      }, due);
    });
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/observable/interval.js
  function interval(period, scheduler) {
    if (period === void 0) {
      period = 0;
    }
    if (scheduler === void 0) {
      scheduler = asyncScheduler;
    }
    if (period < 0) {
      period = 0;
    }
    return timer(period, period, scheduler);
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/observable/merge.js
  function merge2() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = popScheduler2(args);
    var concurrent = popNumber2(args, Infinity);
    var sources2 = args;
    return !sources2.length ? EMPTY2 : sources2.length === 1 ? innerFrom2(sources2[0]) : mergeAll2(concurrent)(from2(sources2, scheduler));
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/operators/filter.js
  function filter(predicate, thisArg) {
    return operate2(function(source2, subscriber) {
      var index = 0;
      source2.subscribe(createOperatorSubscriber2(subscriber, function(value) {
        return predicate.call(thisArg, value, index++) && subscriber.next(value);
      }));
    });
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/operators/defaultIfEmpty.js
  function defaultIfEmpty(defaultValue2) {
    return operate2(function(source2, subscriber) {
      var hasValue = false;
      source2.subscribe(createOperatorSubscriber2(subscriber, function(value) {
        hasValue = true;
        subscriber.next(value);
      }, function() {
        if (!hasValue) {
          subscriber.next(defaultValue2);
        }
        subscriber.complete();
      }));
    });
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/operators/take.js
  function take(count2) {
    return count2 <= 0 ? function() {
      return EMPTY2;
    } : operate2(function(source2, subscriber) {
      var seen = 0;
      source2.subscribe(createOperatorSubscriber2(subscriber, function(value) {
        if (++seen <= count2) {
          subscriber.next(value);
          if (count2 <= seen) {
            subscriber.complete();
          }
        }
      }));
    });
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/operators/mapTo.js
  function mapTo(value) {
    return map2(function() {
      return value;
    });
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/operators/throwIfEmpty.js
  function throwIfEmpty(errorFactory) {
    if (errorFactory === void 0) {
      errorFactory = defaultErrorFactory;
    }
    return operate2(function(source2, subscriber) {
      var hasValue = false;
      source2.subscribe(createOperatorSubscriber2(subscriber, function(value) {
        hasValue = true;
        subscriber.next(value);
      }, function() {
        return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
      }));
    });
  }
  function defaultErrorFactory() {
    return new EmptyError();
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/operators/first.js
  function first(predicate, defaultValue2) {
    var hasDefaultValue = arguments.length >= 2;
    return function(source2) {
      return source2.pipe(predicate ? filter(function(v2, i2) {
        return predicate(v2, i2, source2);
      }) : identity3, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue2) : throwIfEmpty(function() {
        return new EmptyError();
      }));
    };
  }

  // node_modules/cookies-ds/node_modules/rxjs/dist/esm5/internal/operators/tap.js
  function tap2(observerOrNext, error, complete) {
    var tapObserver = isFunction2(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
    return tapObserver ? operate2(function(source2, subscriber) {
      var _a;
      (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
      var isUnsub = true;
      source2.subscribe(createOperatorSubscriber2(subscriber, function(value) {
        var _a2;
        (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value);
        subscriber.next(value);
      }, function() {
        var _a2;
        isUnsub = false;
        (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
        subscriber.complete();
      }, function(err) {
        var _a2;
        isUnsub = false;
        (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
        subscriber.error(err);
      }, function() {
        var _a2, _b;
        if (isUnsub) {
          (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
        }
        (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
      }));
    }) : identity3;
  }

  // node_modules/cookies-ds/dist/components/padlock/img/padlock-body.js
  var padlock_body_default = "data:image/png;base64,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dyNygUOpVIIdO3bA6dOn4c0334RGowHtdhuee+45eO211yJroGthZjKwbt06OH36dCyS0Gw2IxBQUQvgnMqePXtg06ZNEIYhHDx4EN58800IwxA+8pGPwDvf+U5WUR955BH429/+FvOBzWIul8tw6aWXxnZ8qvBU2fF5E7prNpux+oJBtQTjuhH5WAEYFCqVChw/fjxyeUqlErzvfe/ramJigKbT6XQlO5mORub7UCugd0nrV9Cb3HnnnbB161YAADh+/Di89tprEIYhXHPNNfCe97yn6/pGowH33nsvvPjii+yuuW3bNti1a1eUd8+Z7Fg5jPLX6/WofZfpDEyVf5A9AV0uhwQM5rPncjmYmZmBIAigWq1Cq9WCw4cPw8zMTOTj4+eYMCfmSMxrGWB5//vfD3/+8591USoAnB255557YPPmzZBKpaBer8OBAweg0+nAzp074frrr++6fnFxEe666y44fPhw17lCoQA7d+6E8847T1R6bsev1WqwsLAAtVqtq0Eot2sPCgBcoOBLOBaLRSgUCrC0tASdTgeOHDkS9Qmgr2ney3RIMucMAARBoCCgLsDZkXvvvRfK5TLkcjkAANi/fz+cOnUKpqen4XOf+1xXkk+lUoE777wT5ubmunbysbEx2L17d9RJl9th6f1Go5GoK/Bjjz3W1/970003eQEHBi5qCVCrAD9uNptw5MiRqOnozp07Ydu2bZELgK0Hk4iELSfDHxhrQWsHlARcUTEls51OB1577TWoVCqQyWTYDL9arQZ79uyB+fn5rtcpl8uwc+dOSKfTMcWRAKDVakXxdZcP/vjjjw/s//3pT38a3b/55putpr8J7RnfHe/W0ufNZrOwfft2OHr0KFSrVXjppZcgCIKYRWTEAKVxB8x7cSSiiloAA5e9e/fC1q1bIQxDqFQqsH//fuh0OnD99dfD7t27Y9e22224++67I24A36amprpyAzilN+z94uJiLIxGTftf/OIX5+T7uOWWW7qsARNKNA0+pJ2fS28+fvx4VCG4a9cu2LRpU8wCMPdxExUAiAGAWgEKACvq92cyGWi1WlGa7yWXXAI33nhj7NpOpwP3338/HDx4sEv5x8fHYdeuXRGZJfnQJhZ+6tSpmHuAlf+JJ55YFd/NrbfeyrYFB4CImPStVJyfn4f5+XkIwxCuvPJKmJyc7AKAdrsN1WqV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";

  // node_modules/cookies-ds/dist/components/padlock/img/padlock-shackle.js
  var padlock_shackle_default = "data:image/png;base64,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";

  // node_modules/cookies-ds/dist/utils/get-shadow-root.js
  function getShadowRoot(element2) {
    if (!element2.shadowRoot) {
      throw new Error("There is no shadow root on the element !");
    }
    return element2.shadowRoot;
  }

  // node_modules/cookies-ds/dist/utils/get-element.js
  function getElement(shadowRoot, selector) {
    const element2 = shadowRoot.querySelector(selector);
    if (!element2) {
      throw new Error("Failed to find element ${ selector } !");
    }
    return element2;
  }

  // node_modules/cookies-ds/dist/components/padlock/index.js
  var templateNode = document.createElement("template");
  templateNode.innerHTML = template_default;
  var Padlock = class extends HTMLElement {
    constructor() {
      super(...arguments);
      this.hoverPart1 = false;
      this.hoverPart2 = false;
      this.hoverPart3 = false;
      this.shackleClickSubscription = null;
      this.enter1Subscription = null;
      this.enter2Subscription = null;
      this.enter3Subscription = null;
      this.out1Subscription = null;
      this.out2Subscription = null;
      this.out3Subscription = null;
    }
    static get observedAttributes() {
      return ["locked", "lockable"];
    }
    get shackleHover() {
      return this.hoverPart1 || this.hoverPart2 || this.hoverPart3;
    }
    connectedCallback() {
      this.attachShadow({ mode: "open" });
      const shadowRoot = getShadowRoot(this);
      shadowRoot.appendChild(templateNode.content.cloneNode(true));
      const padlockBody = getElement(shadowRoot, "#padlock-body");
      padlockBody.style["background-image"] = `url("${padlock_body_default}")`;
      const shackle = getElement(shadowRoot, "#shackle");
      shackle.style["background-image"] = `url("${padlock_shackle_default}")`;
      const shacklePart1 = getElement(shadowRoot, "#shackle-part-1");
      const shacklePart2 = getElement(shadowRoot, "#shackle-part-2");
      const shacklePart3 = getElement(shadowRoot, "#shackle-part-3");
      this.shackleClickSubscription = observeShackleClicks(this).subscribe(() => {
        const event = new CustomEvent("shackle-click");
        this.dispatchEvent(event);
      });
      this.enter1Subscription = fromEvent(shacklePart1, "mouseenter").subscribe(() => {
        this.hoverPart1 = true;
        this.render();
      });
      this.enter2Subscription = fromEvent(shacklePart2, "mouseenter").subscribe(() => {
        this.hoverPart2 = true;
        this.render();
      });
      this.enter3Subscription = fromEvent(shacklePart3, "mouseenter").subscribe(() => {
        this.hoverPart3 = true;
        this.render();
      });
      this.out1Subscription = fromEvent(shacklePart1, "mouseout").subscribe(() => {
        this.hoverPart1 = false;
        this.render();
      });
      this.out2Subscription = fromEvent(shacklePart2, "mouseout").subscribe(() => {
        this.hoverPart2 = false;
        this.render();
      });
      this.out3Subscription = fromEvent(shacklePart3, "mouseout").subscribe(() => {
        this.hoverPart3 = false;
        this.render();
      });
      this.render();
    }
    render() {
      const shadowRoot = getShadowRoot(this);
      const shackle = getElement(shadowRoot, "#shackle");
      const locked = this.getAttribute("locked");
      const lockable = this.getAttribute("lockable");
      const shacklePart1 = getElement(shadowRoot, "#shackle-part-1");
      const shacklePart2 = getElement(shadowRoot, "#shackle-part-2");
      const shacklePart3 = getElement(shadowRoot, "#shackle-part-3");
      shacklePart1.style.cursor = lockable === null ? "initial" : "pointer";
      shacklePart2.style.cursor = lockable === null ? "initial" : "pointer";
      shacklePart3.style.cursor = lockable === null ? "initial" : "pointer";
      if (locked === null) {
        shackle.style.top = "0.1%";
        if (this.shackleHover && lockable !== null) {
          shackle.style.top = "2%";
        }
      } else {
        shackle.style.top = "7.1%";
      }
    }
    attributeChangedCallback() {
      if (this.shadowRoot) {
        this.render();
      }
    }
    disconnectedCallback() {
      var _a, _b, _c, _d, _e, _f, _g;
      (_a = this.shackleClickSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
      (_b = this.enter1Subscription) === null || _b === void 0 ? void 0 : _b.unsubscribe();
      (_c = this.enter2Subscription) === null || _c === void 0 ? void 0 : _c.unsubscribe();
      (_d = this.enter3Subscription) === null || _d === void 0 ? void 0 : _d.unsubscribe();
      (_e = this.out1Subscription) === null || _e === void 0 ? void 0 : _e.unsubscribe();
      (_f = this.out2Subscription) === null || _f === void 0 ? void 0 : _f.unsubscribe();
      (_g = this.out3Subscription) === null || _g === void 0 ? void 0 : _g.unsubscribe();
    }
  };
  function observeShackleClicks(padlock) {
    const shadowRoot = getShadowRoot(padlock);
    const shacklePart1 = getElement(shadowRoot, "#shackle-part-1");
    const shacklePart2 = getElement(shadowRoot, "#shackle-part-2");
    const shacklePart3 = getElement(shadowRoot, "#shackle-part-3");
    return merge2(fromEvent(shacklePart1, "click"), fromEvent(shacklePart2, "click"), fromEvent(shacklePart3, "click")).pipe(map2(() => void 0));
  }

  // node_modules/cookies-ds/dist/components/smart-padlock/template.js
  var template_default2 = '<style>\n	:host {\n		display: block;\n		width: 20rem;\n		height: 20rem;\n	}\n\n	#smart-padlock {\n		display: grid;\n		grid-template-columns: 1fr;\n		grid-template-rows: 1fr;\n		grid-column-gap: 0px;\n		grid-row-gap: 0px;\n		height: 100%;\n	}\n\n	#padlock {\n		grid-area: 1 / 1 / 2 / 2;\n	}\n	\n	#scroll-wheels {\n		grid-area: 1 / 1 / 2 / 2;\n		display: grid;\n		grid-template-columns: 3.17fr 1fr 0.8fr;\n		grid-template-rows: 6.7fr repeat(5, 1fr) 1.5fr;\n		grid-column-gap: 0px;\n		grid-row-gap: 0px;\n	} \n\n	#scroll-wheel-1 { grid-area: 2 / 2 / 3 / 3; }\n	#scroll-wheel-2 { grid-area: 3 / 2 / 4 / 3; }\n	#scroll-wheel-3 { grid-area: 4 / 2 / 5 / 3; }\n	#scroll-wheel-4 { grid-area: 5 / 2 / 6 / 3; }\n	#scroll-wheel-5 { grid-area: 6 / 2 / 7 / 3; }\n\n	#wheels-click-zone {\n		grid-area: 2 / 2 / 7 / 3;\n		z-index: 2;\n	}\n\n	#lcd-screens-zone {\n		grid-area: 1 / 1 / 2 / 2;\n		display: grid;\n		grid-template-columns: 3fr 1fr 1fr 1fr 1fr 1fr 5fr;\n		grid-template-rows: 5fr 1.7fr 1fr 1fr 1fr;\n		grid-column-gap: 0px;\n		grid-row-gap: 0px; \n	}\n\n	#lcd-date { grid-area: 2 / 2 / 3 / 7; }\n	#lcd-days { grid-area: 4 / 2 / 5 / 3; }\n	#lcd-hours { grid-area: 4 / 4 / 5 / 5; }\n	#lcd-size { grid-area: 4 / 6 / 5 / 7; } \n</style>\n\n<div id="smart-padlock">\n	<cookies-padlock id="padlock"></cookies-padlock>\n	<div id="scroll-wheels">\n		<cookies-wheel id="scroll-wheel-1"></cookies-wheel>\n		<cookies-wheel id="scroll-wheel-2"></cookies-wheel>\n		<cookies-wheel id="scroll-wheel-3"></cookies-wheel>\n		<cookies-wheel id="scroll-wheel-4"></cookies-wheel>\n		<cookies-wheel id="scroll-wheel-5"></cookies-wheel>\n		<div id="wheels-click-zone" title="D\xE9verrouiller"></div>\n	</div>\n	<div id="lcd-screens-zone">\n		<div id="lcd-date">\n			<cookies-padlock-screen id="padlock-screen" style="width: 100%; height: 100%"></cookies-padlock-screen>\n		</div>\n	</div>\n</div>\n';

  // node_modules/cookies-ds/dist/components/smart-padlock/index.js
  var templateNode2 = document.createElement("template");
  templateNode2.innerHTML = template_default2;
  var SmartPadlock = class extends HTMLElement {
    constructor() {
      super(...arguments);
      this.hoverWheels = false;
      this.shackleClickSubscription = null;
      this.hoverWheelsSubscription = null;
    }
    static get observedAttributes() {
      return ["locked", "lockable", "code", "unlockable", "release-timestamp"];
    }
    connectedCallback() {
      this.attachShadow({ mode: "open" });
      const shadowRoot = getShadowRoot(this);
      shadowRoot.appendChild(templateNode2.content.cloneNode(true));
      const padlock = getElement(shadowRoot, "#padlock");
      this.hoverWheelsSubscription = observeHoverElement(this, "#wheels-click-zone").subscribe((hover) => {
        this.hoverWheels = hover;
        this.render();
      });
      this.shackleClickSubscription = fromEvent(padlock, "shackle-click").subscribe(() => {
        const event = new CustomEvent("shackle-click");
        this.dispatchEvent(event);
      });
      this.render();
    }
    render() {
      const shadowRoot = getShadowRoot(this);
      applyOwnAttributeToElement(this, "#padlock", "locked");
      applyOwnAttributeToElement(this, "#padlock", "lockable");
      const wheels = [
        getElement(shadowRoot, "#scroll-wheel-1"),
        getElement(shadowRoot, "#scroll-wheel-2"),
        getElement(shadowRoot, "#scroll-wheel-3"),
        getElement(shadowRoot, "#scroll-wheel-4"),
        getElement(shadowRoot, "#scroll-wheel-5")
      ];
      for (let i2 = 0; i2 < wheels.length; i2++) {
        const num = getNumberFromCode(this, i2, 5);
        if (num === null) {
          wheels[i2].removeAttribute("number");
        } else {
          wheels[i2].setAttribute("number", num);
        }
      }
      const unlockable = this.getAttribute("unlockable");
      const wheelsClickZone = getElement(shadowRoot, "#wheels-click-zone");
      wheelsClickZone.style.cursor = unlockable === null ? "initial" : "pointer";
      for (let i2 = 0; i2 < wheels.length; i2++) {
        if (unlockable !== null && this.hoverWheels) {
          wheels[i2].setAttribute("unlockable", "");
        } else {
          wheels[i2].removeAttribute("unlockable");
        }
      }
      applyOwnAttributeToElement(this, "#padlock-screen", "release-timestamp");
    }
    attributeChangedCallback() {
      if (this.shadowRoot) {
        this.render();
      }
    }
    disconnectedCallback() {
      var _a, _b;
      (_a = this.shackleClickSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
      (_b = this.hoverWheelsSubscription) === null || _b === void 0 ? void 0 : _b.unsubscribe();
    }
  };
  function getNumberFromCode(smartPadlock, position, codeSize) {
    const codeAttr = smartPadlock.getAttribute("code");
    if (codeAttr === null) {
      return null;
    }
    const code = Number.parseInt(codeAttr);
    if (Number.isInteger(code)) {
      const codeAsString = code.toString().padStart(codeSize, "0");
      return codeAsString.charAt(position);
    } else {
      switch (codeAttr) {
        case "":
          return null;
        case "?":
          return "?";
        default:
          throw new Error("Unknown code attribute !");
      }
    }
  }
  function applyOwnAttributeToElement(smartPadLock, selector, attribute) {
    const shadowRoot = getShadowRoot(smartPadLock);
    const element2 = getElement(shadowRoot, selector);
    const value = smartPadLock.getAttribute(attribute);
    if (value === null) {
      element2.removeAttribute(attribute);
    } else {
      element2.setAttribute(attribute, value);
    }
  }
  function observeHoverElement(padlock, selector) {
    const shadowRoot = getShadowRoot(padlock);
    const element2 = getElement(shadowRoot, selector);
    return merge2(fromEvent(element2, "mouseenter").pipe(map2(() => true)), fromEvent(element2, "mouseout").pipe(map2(() => false)));
  }

  // node_modules/cookies-ds/dist/components/wheel/template.js
  var template_default3 = `<style>
	:host {
		display: block;
	}

	#wheel {
		height: 100%;
		min-height: 0.5rem;
		/*background-image: url('img/wheel.png');*/
		background-size: 100% 100%;
		transition: filter 0.3s cubic-bezier(.08,.82,.17,1);
		display: grid;
		grid-template-columns: 0.55fr 0.5fr 0.6fr 0.5fr 0.4fr 0.4fr 0.2fr;
		grid-template-rows: 0.4fr 1fr 0.5fr;
		grid-column-gap: 0px;
		grid-row-gap: 0px; 
	}

	#number-1 {
		grid-area: 2 / 2 / 3 / 3;
		background-size: 100% 100%;
		opacity: 0.5;
	}

	#number-2 {
		grid-area: 2 / 4 / 3 / 5;
		background-size: 100% 100%;
	}

	#number-3 {
		grid-area: 2 / 6 / 3 / 7;
		background-size: 100% 100%;
		opacity: 0.5;
	}
</style>

<div id="wheel">
	<div id="number-1"></div>
	<div id="number-2"></div>
	<div id="number-3"></div>
</div>
`;

  // node_modules/cookies-ds/dist/components/wheel/img/wheel-number-0.js
  var wheel_number_0_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAbCAYAAAB836/YAAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AcxV9TRdGKgh1EOmSoThZERRy1CkWoEGqFVh1MLv2CJg1Jiouj4Fpw8GOx6uDirKuDqyAIfoA4OjkpukiJ/0sKLWI8OO7Hu3uPu3eAUC8zzeoYBzTdNlOJuJjJropdr+iFgAFEEJOZZcxJUhK+4+seAb7exXiW/7k/R5+asxgQEIlnmWHaxBvE05u2wXmfOMyKskp8Tjxm0gWJH7muePzGueCywDPDZjo1TxwmFgttrLQxK5oa8RRxVNV0yhcyHquctzhr5Spr3pO/MJTTV5a5TjOCBBaxBAkiFFRRQhk2YrTqpFhI0X7cxz/s+iVyKeQqgZFjARVokF0/+B/87tbKT054SaE40PniOB8jQNcu0Kg5zvex4zROgOAzcKW3/JU6MPNJeq2lRY+A/m3g4rqlKXvA5Q4w9GTIpuxKQZpCPg+8n9E3ZYHBW6BnzeutuY/TByBNXSVvgINDYLRA2es+7+5u7+3fM83+fgBt13KlEntTTQAAAAZiS0dEAP8AAADDMUrv+QAAAAlwSFlzAAAuIwAALiMBeKU/dgAAAAd0SU1FB+YLAhEUKNfvHU0AAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAABRUlEQVRIx9WVu0pDQRCGPw6CirGysNEIYiNptBFtFLEQ7CXoK/gAYiv2gdTikygIWtkoaBDEKggqiBe8Bq/NifwcZs9O0mVgYQ77/98yu3tmoZNjGtgGLoBX4B44BjaBoVZACVABfoDfwHgElr3ASg5IxyewGIPNZUz7wCzQBwwAq8CVzF+nc8E4EPEu0GVohoE70a2HYEURfQNjOQuvifbUI9qLbE0BaIh+VE+0GZOSx4AvwJF8T1jAcclrjttQs7wKHJS87gDWLW+S2RctCUfZzei3gL2SNxzAD8urwHfJux3AHsubBEooOICqebaAt5lLHoui5VXgueQlB7BkeRV4IvmCo9ypgPc/Rtr8l8/yVj5so9ts5AHnI/1wJdMPbzw3ours2F/AkvdNqUbelCeg3OqrNwPsAJfAG/CQnuZWuo8dGn8aBHillPG1IAAAAABJRU5ErkJggg==";

  // node_modules/cookies-ds/dist/components/wheel/img/wheel-number-1.js
  var wheel_number_1_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAbCAYAAAB836/YAAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AcxV9TRdGKgh1EOmSoThZERRy1CkWoEGqFVh1MLv2CJg1Jiouj4Fpw8GOx6uDirKuDqyAIfoA4OjkpukiJ/0sKLWI8OO7Hu3uPu3eAUC8zzeoYBzTdNlOJuJjJropdr+iFgAFEEJOZZcxJUhK+4+seAb7exXiW/7k/R5+asxgQEIlnmWHaxBvE05u2wXmfOMyKskp8Tjxm0gWJH7muePzGueCywDPDZjo1TxwmFgttrLQxK5oa8RRxVNV0yhcyHquctzhr5Spr3pO/MJTTV5a5TjOCBBaxBAkiFFRRQhk2YrTqpFhI0X7cxz/s+iVyKeQqgZFjARVokF0/+B/87tbKT054SaE40PniOB8jQNcu0Kg5zvex4zROgOAzcKW3/JU6MPNJeq2lRY+A/m3g4rqlKXvA5Q4w9GTIpuxKQZpCPg+8n9E3ZYHBW6BnzeutuY/TByBNXSVvgINDYLRA2es+7+5u7+3fM83+fgBt13KlEntTTQAAAAZiS0dEAP8AAADDMUrv+QAAAAlwSFlzAAAuIwAALiMBeKU/dgAAAAd0SU1FB+YLAhEVAYxGtGAAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAb0lEQVRIx2NgGOyAEY3PwcDAoM3AwKDPwMBgAKX1GRgY+KHyDxkYGBRIsWAGAwPDfzz4ASEDmKjtZRY0/ncGBoZzDAwMFxgYGC5C8U8GBobj1LRUY0C9PGrgqIGjBo4aSB8D8ZV9xOI7Q9vLgw8AABSMIJDaGYKJAAAAAElFTkSuQmCC";

  // node_modules/cookies-ds/dist/components/wheel/img/wheel-number-2.js
  var wheel_number_2_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAbCAYAAAB836/YAAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AcxV9TRdGKgh1EOmSoThZERRy1CkWoEGqFVh1MLv2CJg1Jiouj4Fpw8GOx6uDirKuDqyAIfoA4OjkpukiJ/0sKLWI8OO7Hu3uPu3eAUC8zzeoYBzTdNlOJuJjJropdr+iFgAFEEJOZZcxJUhK+4+seAb7exXiW/7k/R5+asxgQEIlnmWHaxBvE05u2wXmfOMyKskp8Tjxm0gWJH7muePzGueCywDPDZjo1TxwmFgttrLQxK5oa8RRxVNV0yhcyHquctzhr5Spr3pO/MJTTV5a5TjOCBBaxBAkiFFRRQhk2YrTqpFhI0X7cxz/s+iVyKeQqgZFjARVokF0/+B/87tbKT054SaE40PniOB8jQNcu0Kg5zvex4zROgOAzcKW3/JU6MPNJeq2lRY+A/m3g4rqlKXvA5Q4w9GTIpuxKQZpCPg+8n9E3ZYHBW6BnzeutuY/TByBNXSVvgINDYLRA2es+7+5u7+3fM83+fgBt13KlEntTTQAAAAZiS0dEAP8AAADDMUrv+QAAAAlwSFlzAAAuIwAALiMBeKU/dgAAAAd0SU1FB+YLAhEVCYKdPFIAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAABBElEQVRIx83VPyuFURwH8A8Tde8bQAbp1l0MdEPuoGxmr8EiJZTNKzDaKYuFV8DIZmdVFqEUiuKxnFunJ3/v7xnur06d4fTpfH/nec6h16svmw9iEjOYRhMjqOEVt7jAMY7w9hu+i+KP4wqtr5D+LpM1cIqpn8AXnGEHS2nxaGpFHW0cZuvr2Cu1ravaKsWfreIgLzNwJdrDAuel6OFDqWXzm2jkAdynnX5gKApuZ/07iGLt9NcUuMNwBGskpMA7FiPYGK6zqMsRbLyErUawZvosOthaBJtIV1YHW49gLTxk2EYEm8NjVdg8njJsM4It4LkqDE7+8QTkY7+K2+bbqhzs/foEHfVYbBIV0xoAAAAASUVORK5CYII=";

  // node_modules/cookies-ds/dist/components/wheel/img/wheel-number-3.js
  var wheel_number_3_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAbCAYAAAB836/YAAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AcxV9TRdGKgh1EOmSoThZERRy1CkWoEGqFVh1MLv2CJg1Jiouj4Fpw8GOx6uDirKuDqyAIfoA4OjkpukiJ/0sKLWI8OO7Hu3uPu3eAUC8zzeoYBzTdNlOJuJjJropdr+iFgAFEEJOZZcxJUhK+4+seAb7exXiW/7k/R5+asxgQEIlnmWHaxBvE05u2wXmfOMyKskp8Tjxm0gWJH7muePzGueCywDPDZjo1TxwmFgttrLQxK5oa8RRxVNV0yhcyHquctzhr5Spr3pO/MJTTV5a5TjOCBBaxBAkiFFRRQhk2YrTqpFhI0X7cxz/s+iVyKeQqgZFjARVokF0/+B/87tbKT054SaE40PniOB8jQNcu0Kg5zvex4zROgOAzcKW3/JU6MPNJeq2lRY+A/m3g4rqlKXvA5Q4w9GTIpuxKQZpCPg+8n9E3ZYHBW6BnzeutuY/TByBNXSVvgINDYLRA2es+7+5u7+3fM83+fgBt13KlEntTTQAAAAZiS0dEAP8AAADDMUrv+QAAAAlwSFlzAAAuIwAALiMBeKU/dgAAAAd0SU1FB+YLAhEVEZHxpAQAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAABPUlEQVRIx9XVSytFURjG8Z/7tUwkl+Q2MFAGJoiMfQQ+gDKSmYnPICkywMjEZyDFXJkcI0lEBhK5FAmTdWq1cznO3gPeemut9t7/td9nvetZ/PUoScxbMRJyAM1oQg1ucYRdrOOykAUe8F5APmEmS2A+534C5rCGKQyjG7WoRi9mcRUBX9CTVve2BHQ+flhaBPACK9G8Ly0QjqNxTRbAjmh8klbDRpxFGg4VA6lAV9j90wi2+BvIzjf9d1dIDxYKvMEkKrMC5vO8WP2Ek9KJCewlTspYFi61EEEPswBWBjvLQ9vTNvZL0DAfLWn/sC5hdakcpwwbEewqrrQ8enE5WNM2DnAd8j54YidGMY3+6LtVvH228uYv3fo9tFBVFm7ziiWM4/mrW68+3HZjGAzlN6EBj6H8HPaxldjlfxQfP6V7AKpQHcIAAAAASUVORK5CYII=";

  // node_modules/cookies-ds/dist/components/wheel/img/wheel-number-4.js
  var wheel_number_4_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAbCAYAAAB836/YAAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AcxV9TRdGKgh1EOmSoThZERRy1CkWoEGqFVh1MLv2CJg1Jiouj4Fpw8GOx6uDirKuDqyAIfoA4OjkpukiJ/0sKLWI8OO7Hu3uPu3eAUC8zzeoYBzTdNlOJuJjJropdr+iFgAFEEJOZZcxJUhK+4+seAb7exXiW/7k/R5+asxgQEIlnmWHaxBvE05u2wXmfOMyKskp8Tjxm0gWJH7muePzGueCywDPDZjo1TxwmFgttrLQxK5oa8RRxVNV0yhcyHquctzhr5Spr3pO/MJTTV5a5TjOCBBaxBAkiFFRRQhk2YrTqpFhI0X7cxz/s+iVyKeQqgZFjARVokF0/+B/87tbKT054SaE40PniOB8jQNcu0Kg5zvex4zROgOAzcKW3/JU6MPNJeq2lRY+A/m3g4rqlKXvA5Q4w9GTIpuxKQZpCPg+8n9E3ZYHBW6BnzeutuY/TByBNXSVvgINDYLRA2es+7+5u7+3fM83+fgBt13KlEntTTQAAAAZiS0dEAP8AAADDMUrv+QAAAAlwSFlzAAAuIwAALiMBeKU/dgAAAAd0SU1FB+YLAhEVGOgtHKAAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAA5UlEQVRIx93UMWpCQRQF0INYCRKtUmUPFmmyg28RsBCygqSwsEqZLm0aJRjIMlK4Aq1SZBE2qWyEFEHU5gXkQ8L/fySCFwaGmXmXe98dHqeEW2z31iyF7BzLIoS1goQjtPF9CKvdULTBY6rCBiaxf8U8Vd1TqPlEC1lKKB2so/gmzioT1vAehdO986xqD4e4xBcGqX27wCpU3OfuKll+i4IP1MsS5i33cR1/7i5CUbb5PzjDOPbPEUoSXsLKAs1f3hTu4VXY3KL3x7vChA+5SVJ2rctOm0qhHAWZAw3Y41k+vVD+Hzsq6VN/QGdjHwAAAABJRU5ErkJggg==";

  // node_modules/cookies-ds/dist/components/wheel/img/wheel-number-5.js
  var wheel_number_5_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAbCAYAAAB836/YAAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AcxV9TRdGKgh1EOmSoThZERRy1CkWoEGqFVh1MLv2CJg1Jiouj4Fpw8GOx6uDirKuDqyAIfoA4OjkpukiJ/0sKLWI8OO7Hu3uPu3eAUC8zzeoYBzTdNlOJuJjJropdr+iFgAFEEJOZZcxJUhK+4+seAb7exXiW/7k/R5+asxgQEIlnmWHaxBvE05u2wXmfOMyKskp8Tjxm0gWJH7muePzGueCywDPDZjo1TxwmFgttrLQxK5oa8RRxVNV0yhcyHquctzhr5Spr3pO/MJTTV5a5TjOCBBaxBAkiFFRRQhk2YrTqpFhI0X7cxz/s+iVyKeQqgZFjARVokF0/+B/87tbKT054SaE40PniOB8jQNcu0Kg5zvex4zROgOAzcKW3/JU6MPNJeq2lRY+A/m3g4rqlKXvA5Q4w9GTIpuxKQZpCPg+8n9E3ZYHBW6BnzeutuY/TByBNXSVvgINDYLRA2es+7+5u7+3fM83+fgBt13KlEntTTQAAAAZiS0dEAP8AAADDMUrv+QAAAAlwSFlzAAAuIwAALiMBeKU/dgAAAAd0SU1FB+YLAhEVH3ZJiQMAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAA+0lEQVRIx+3VvyvFYRTH8RfdGCRl+JasjMqiRJJRGQwS5X8wymoz3f12/wCKLMwGmfwBbmE0kdItSfmxPMPjG27XPaVbTj116pzePef5nE8P3RZ7eG/jrJUBvdE3CgdWfqiN4/rPb/gP/BQ7uMQTmrhJe7reQsxfLfYVpiJHHsMZ5loB71HDKiZRoA8jWMJh1tuPAwx2+u4reMnG34oQczcDnkcAJzLgQwRwOAO+Rqg8muWPEcCNLG90Ou5ySeXt7xqrOMYmZtLyDiWbFVjEfskxd6nny6i3+Z88YyHKeo1ku9NyoSfLBzCLeUwnJYtkrSZucYEjnOBNV8YHMwFQ+22eDWsAAAAASUVORK5CYII=";

  // node_modules/cookies-ds/dist/components/wheel/img/wheel-number-6.js
  var wheel_number_6_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAbCAYAAAB836/YAAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AcxV9TRdGKgh1EOmSoThZERRy1CkWoEGqFVh1MLv2CJg1Jiouj4Fpw8GOx6uDirKuDqyAIfoA4OjkpukiJ/0sKLWI8OO7Hu3uPu3eAUC8zzeoYBzTdNlOJuJjJropdr+iFgAFEEJOZZcxJUhK+4+seAb7exXiW/7k/R5+asxgQEIlnmWHaxBvE05u2wXmfOMyKskp8Tjxm0gWJH7muePzGueCywDPDZjo1TxwmFgttrLQxK5oa8RRxVNV0yhcyHquctzhr5Spr3pO/MJTTV5a5TjOCBBaxBAkiFFRRQhk2YrTqpFhI0X7cxz/s+iVyKeQqgZFjARVokF0/+B/87tbKT054SaE40PniOB8jQNcu0Kg5zvex4zROgOAzcKW3/JU6MPNJeq2lRY+A/m3g4rqlKXvA5Q4w9GTIpuxKQZpCPg+8n9E3ZYHBW6BnzeutuY/TByBNXSVvgINDYLRA2es+7+5u7+3fM83+fgBt13KlEntTTQAAAAZiS0dEAP8AAADDMUrv+QAAAAlwSFlzAAAuIwAALiMBeKU/dgAAAAd0SU1FB+YLAhEVKbnzHJoAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAABgUlEQVRIx83UP0iVYRTH8Y+FBZUVtEgIN6jNyCUIGoKchHJxEy70h3CTJifBySW3ZgeFoDFoKMSG/mDiINVUQ0MRQhERGOa/1NvyXDhc7vvneoc68PL+4P293+c5zznP4X+PjoLvFVRxDWdwCj+wggU8xmvsFi10EBPYQK3guV4G9rAEqDRwquGHjxhJKR9CF/pwFy8wkAe7iJ0Am8ORdor0KMC+4Fg7sG78CcDb7bbQcICt4+h+IAeCvhT0S/xuF3g26OX0Po9ZfMIWvuMVxlOT58ZCSLmKWwmS1X+rGMoDvgvme9gr0dS7GMwCLgVjvdpP0Y8TqanPYQy/gvdbVgGfNaw+nZPNhVS0uvdGM9ODYNhMu8qL+8E/06zK74P+kA49LxaDPt0M+CboWouztNYM+DwdNvTiZAHwctArWabpFoqyHrzDWcaeBuMTXMVxdKbbNJbOt+75jMN5qdxsYVpv4UqZO34HawWwr2n3paOCSbzFT2ynWzGP0f2Ot38ffwHxL5ymalIE8gAAAABJRU5ErkJggg==";

  // node_modules/cookies-ds/dist/components/wheel/img/wheel-number-7.js
  var wheel_number_7_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAbCAYAAAB836/YAAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AcxV9TRdGKgh1EOmSoThZERRy1CkWoEGqFVh1MLv2CJg1Jiouj4Fpw8GOx6uDirKuDqyAIfoA4OjkpukiJ/0sKLWI8OO7Hu3uPu3eAUC8zzeoYBzTdNlOJuJjJropdr+iFgAFEEJOZZcxJUhK+4+seAb7exXiW/7k/R5+asxgQEIlnmWHaxBvE05u2wXmfOMyKskp8Tjxm0gWJH7muePzGueCywDPDZjo1TxwmFgttrLQxK5oa8RRxVNV0yhcyHquctzhr5Spr3pO/MJTTV5a5TjOCBBaxBAkiFFRRQhk2YrTqpFhI0X7cxz/s+iVyKeQqgZFjARVokF0/+B/87tbKT054SaE40PniOB8jQNcu0Kg5zvex4zROgOAzcKW3/JU6MPNJeq2lRY+A/m3g4rqlKXvA5Q4w9GTIpuxKQZpCPg+8n9E3ZYHBW6BnzeutuY/TByBNXSVvgINDYLRA2es+7+5u7+3fM83+fgBt13KlEntTTQAAAAZiS0dEAP8AAADDMUrv+QAAAAlwSFlzAAAuIwAALiMBeKU/dgAAAAd0SU1FB+YLAhEVMN2YtFoAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAA3klEQVRIx92UsQpBYRiGHxaxYjEpNyBlMJpcgUExyAUwuCCTUmYT5QrU2WxyAURJSI7lV++g5P/+hbdOnTqn53xP7/cf+KUMgdjzyr0gyQCDnIFTSOAUuFghK9GtW2FlgW2AhD70Ue7J/ciBvZMC9g7yAIpW3ZboLkLs6lyAbSus6DRj4Ahk3r30TSldaXTiFto7SWArujWrbkNg609f9tk9U7LurMbAHShYgX3RnYXYvUiATSusKrCdO3pYStEyxsDVMl0aOMiEFatuR2BRiDKWAhxYYSX5EdyAPH+TJ0JkSwOkmN8PAAAAAElFTkSuQmCC";

  // node_modules/cookies-ds/dist/components/wheel/img/wheel-number-8.js
  var wheel_number_8_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAbCAYAAAB836/YAAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AcxV9TRdGKgh1EOmSoThZERRy1CkWoEGqFVh1MLv2CJg1Jiouj4Fpw8GOx6uDirKuDqyAIfoA4OjkpukiJ/0sKLWI8OO7Hu3uPu3eAUC8zzeoYBzTdNlOJuJjJropdr+iFgAFEEJOZZcxJUhK+4+seAb7exXiW/7k/R5+asxgQEIlnmWHaxBvE05u2wXmfOMyKskp8Tjxm0gWJH7muePzGueCywDPDZjo1TxwmFgttrLQxK5oa8RRxVNV0yhcyHquctzhr5Spr3pO/MJTTV5a5TjOCBBaxBAkiFFRRQhk2YrTqpFhI0X7cxz/s+iVyKeQqgZFjARVokF0/+B/87tbKT054SaE40PniOB8jQNcu0Kg5zvex4zROgOAzcKW3/JU6MPNJeq2lRY+A/m3g4rqlKXvA5Q4w9GTIpuxKQZpCPg+8n9E3ZYHBW6BnzeutuY/TByBNXSVvgINDYLRA2es+7+5u7+3fM83+fgBt13KlEntTTQAAAAZiS0dEAP8AAADDMUrv+QAAAAlwSFlzAAAuIwAALiMBeKU/dgAAAAd0SU1FB+YLAhEVNjT7EW8AAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAABiElEQVRIx9XVO2sXQRSH4UfFC8RrvDaKIEIUDBFiZ9KaJliIpa0WIrESP4IGEfEDaJUU6dKms1MsJII2SQwGQiLYiH+jUTA2s3BYZnfHMgMHDuxv3jNzLjts13UY9zGHNWyih0+YwQ3sKoWN4Qu2OuwNznbBRtJptgptKd2mcc0H8QYmMYj9OIFRzNagj5pgF2rCsZbAz4NuuUl0PYjedaTmVC34nurDziDaHfyVDuA6/uT2RuBC8M8UnLCCrOFHTrQDH8M1rhXm8Elb5KupgasqP8alVOXjmSp/wKGuXrxSO2nO/ibwkdJpGcCrFuBTHC0B9WGqcEo2MdEG24u3YcNn3MPFFOgYhvEsVbXSTTYBJ4LoPQ62BL+MnyGfAzlRzNnNgvS8CPqHucY+HfylAuBibm8E9oJ/rgB4Pvjfc4LpcIV5HGiBDeNX0N/KicZrbbGMuynhfanvqipvBN039DdFnv2Pv3Vlt9vysg8vC0E93CkdvaE0Xq/xFb9T362ml/ABTm7PB/0fj8+rIXtqPdcAAAAASUVORK5CYII=";

  // node_modules/cookies-ds/dist/components/wheel/img/wheel-number-9.js
  var wheel_number_9_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAbCAYAAAB836/YAAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AcxV9TRdGKgh1EOmSoThZERRy1CkWoEGqFVh1MLv2CJg1Jiouj4Fpw8GOx6uDirKuDqyAIfoA4OjkpukiJ/0sKLWI8OO7Hu3uPu3eAUC8zzeoYBzTdNlOJuJjJropdr+iFgAFEEJOZZcxJUhK+4+seAb7exXiW/7k/R5+asxgQEIlnmWHaxBvE05u2wXmfOMyKskp8Tjxm0gWJH7muePzGueCywDPDZjo1TxwmFgttrLQxK5oa8RRxVNV0yhcyHquctzhr5Spr3pO/MJTTV5a5TjOCBBaxBAkiFFRRQhk2YrTqpFhI0X7cxz/s+iVyKeQqgZFjARVokF0/+B/87tbKT054SaE40PniOB8jQNcu0Kg5zvex4zROgOAzcKW3/JU6MPNJeq2lRY+A/m3g4rqlKXvA5Q4w9GTIpuxKQZpCPg+8n9E3ZYHBW6BnzeutuY/TByBNXSVvgINDYLRA2es+7+5u7+3fM83+fgBt13KlEntTTQAAAAZiS0dEAP8AAADDMUrv+QAAAAlwSFlzAAAuIwAALiMBeKU/dgAAAAd0SU1FB+YLAhEWA0llho8AAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAABhElEQVRIx9XVMUtVYRjA8V+alKBIJuXSKAUN2mijQ0sYUYNIUzRoNrmHgyBoHyCaygan6iO0iEg0CakoutltKCcF5RrX2/IKD6d77rl1Jh84nPNy/u//nPc5z/sczmvcwBy+YB9VVPAZz9H5L7LpJKg3ObZxpxXZywJRPH5ioJlsEKdhwhbG0Y+OdH6CncCsNBMuBvAbunO4HmwG9kGe8HuARgtS8yiwHxsB7agF6GqB8Hpgj3Dp7EZbgC6E63qBMLKduJkV1vArQHcLhMOZ8e1G0IewjDV05ci600eLJTTdCBzJQJsYwzVcTHkbT+VUx+/AzuQt5W2LRV3BUhjPN/ooMIHXBfnbw/301mdxWLQFh5J4Awc4TimYRV9i1sIbTpXtRpdxEoT3ygpHg+wUV8oKPwXh17Ky4UxXelZGNoAfQbab7d7tmQkLeBrKqZrK4xZe4D16w35/nKS58abFwq6lB/8Vbf+x7D08xLu8PhhjORVsNbWojnSuYBWvMIn1c/s/9wf/UI5dTsRnMgAAAABJRU5ErkJggg==";

  // node_modules/cookies-ds/dist/components/wheel/img/wheel-number-unknown.js
  var wheel_number_unknown_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAbCAYAAAB836/YAAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AcxV9TRdGKgh1EOmSoThZERRy1CkWoEGqFVh1MLv2CJg1Jiouj4Fpw8GOx6uDirKuDqyAIfoA4OjkpukiJ/0sKLWI8OO7Hu3uPu3eAUC8zzeoYBzTdNlOJuJjJropdr+iFgAFEEJOZZcxJUhK+4+seAb7exXiW/7k/R5+asxgQEIlnmWHaxBvE05u2wXmfOMyKskp8Tjxm0gWJH7muePzGueCywDPDZjo1TxwmFgttrLQxK5oa8RRxVNV0yhcyHquctzhr5Spr3pO/MJTTV5a5TjOCBBaxBAkiFFRRQhk2YrTqpFhI0X7cxz/s+iVyKeQqgZFjARVokF0/+B/87tbKT054SaE40PniOB8jQNcu0Kg5zvex4zROgOAzcKW3/JU6MPNJeq2lRY+A/m3g4rqlKXvA5Q4w9GTIpuxKQZpCPg+8n9E3ZYHBW6BnzeutuY/TByBNXSVvgINDYLRA2es+7+5u7+3fM83+fgBt13KlEntTTQAAAAZiS0dEAP8AAADDMUrv+QAAAAlwSFlzAAAuIwAALiMBeKU/dgAAAAd0SU1FB+YLAhEWD0DTyqQAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAA0ElEQVRIx+XSPw5BQRDH8W9IaBUqlSOIRIRConABR9AS0ToBV3haR1FwAUqv0fkTIRGFeJotfoW8Z7ObeGKSyTa7n8zODPxitIAA2AAX4A6EwBxo2EAVYAlEMfkEpp+CqwRMc2ADLoAeUAby5hwCJwH3QDYJDEz/4nqrVVZ9DGwrYOfdhYwlqN/cuVbXlerWrlgNOMvqtF2wpmARMHLB6sBVsLELVgKOgvVd+zYTbOJj50IZQsEHeDPgweZR3GLnzPnwBf5ZFGVlvtvD9IPpjxcg5EfzJr8b/QAAAABJRU5ErkJggg==";

  // node_modules/cookies-ds/dist/components/wheel/img/wheel.js
  var wheel_default = "data:image/png;base64,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";

  // node_modules/cookies-ds/dist/components/wheel/index.js
  var templateNode3 = document.createElement("template");
  templateNode3.innerHTML = template_default3;
  var Wheel = class extends HTMLElement {
    static get observedAttributes() {
      return ["unlockable", "number"];
    }
    connectedCallback() {
      this.attachShadow({ mode: "open" });
      const shadowRoot = getShadowRoot(this);
      shadowRoot.appendChild(templateNode3.content.cloneNode(true));
      this.render();
    }
    render() {
      const shadowRoot = getShadowRoot(this);
      const wheel = getElement(shadowRoot, "#wheel");
      wheel.style.backgroundImage = `url('${wheel_default}')`;
      const unlockable = this.getAttribute("unlockable");
      const number1 = getElement(shadowRoot, "#number-1");
      const number2 = getElement(shadowRoot, "#number-2");
      const number3 = getElement(shadowRoot, "#number-3");
      const [n1, n2, n3] = parseNumbers(this);
      number1.style.backgroundImage = getNumberImage(n1);
      number2.style.backgroundImage = getNumberImage(n2);
      number3.style.backgroundImage = getNumberImage(n3);
      if (unlockable !== null) {
        wheel.style.filter = "contrast(1.5)";
      } else {
        wheel.style.filter = "none";
      }
    }
    attributeChangedCallback() {
      if (this.shadowRoot) {
        this.render();
      }
    }
  };
  function parseNumbers(wheel) {
    const numberAttr = wheel.getAttribute("number");
    switch (numberAttr) {
      case null:
        return ["", "", ""];
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
      case "0":
        return [
          String((9 + Number(numberAttr)) % 10),
          numberAttr,
          String((11 + Number(numberAttr)) % 10)
        ];
      case "?":
        return ["?", "?", "?"];
      default:
        throw new Error("unknwown number attribute !");
    }
  }
  function getNumberImage(numberTxt) {
    switch (numberTxt) {
      case "1":
        return `url('${wheel_number_1_default}')`;
      case "2":
        return `url('${wheel_number_2_default}')`;
      case "3":
        return `url('${wheel_number_3_default}')`;
      case "4":
        return `url('${wheel_number_4_default}')`;
      case "5":
        return `url('${wheel_number_5_default}')`;
      case "6":
        return `url('${wheel_number_6_default}')`;
      case "7":
        return `url('${wheel_number_7_default}')`;
      case "8":
        return `url('${wheel_number_8_default}')`;
      case "9":
        return `url('${wheel_number_9_default}')`;
      case "0":
        return `url('${wheel_number_0_default}')`;
      case "?":
        return `url('${wheel_number_unknown_default}')`;
      case "":
        return "unset";
      default:
        throw new Error("Unknown wheel number !");
    }
  }

  // node_modules/cookies-ds/dist/components/lcd-screen/template.js
  var template_default4 = '<style>\n	:host {\n		display: block;\n	}\n\n	div {\n		height: 100%;\n	}\n\n	#lcd-screen {\n		background: rgb(198,215,188);\n		background: linear-gradient(166deg, rgb(164, 204, 140) 0%, rgb(57, 98, 34) 100%);\n		border: 0.3rem inset #4a4a4a;\n	}\n\n	#backlight {\n		opacity: 0.8;\n		background: rgb(0,213,255);\n		background: linear-gradient(0deg, rgba(0,213,255,1) 0%, rgba(16,130,254,1) 100%);\n		\n	}\n\n	#backlight-halo-left {\n		background: rgb(101,101,101);\n		background: linear-gradient(90deg, rgba(101,101,101,1) 0%, rgba(0,213,255,1) 3%, rgba(16,130,254,0) 15%);\n	}\n\n	#backlight-halo-right {\n		background: rgb(0,213,255);\n		background: linear-gradient(270deg, rgba(101,101,101,1) 0%, rgba(0,213,255,1) 3%, rgba(16,130,254,0) 15%);\n	}\n\n	#backlight-halo-up {\n		background: rgb(0,213,255);\n		background: linear-gradient(180deg, rgba(101,101,101,1) 0%, rgba(0,213,255,1) 3%, rgba(16,130,254,0) 15%);\n	}\n\n	#backlight-halo-down {\n		background: rgb(0,213,255);\n		background: linear-gradient(0deg, rgba(101,101,101,1) 0%, rgba(0,213,255,1) 3%, rgba(16,130,254,0) 15%);\n	}\n</style>\n\n<div id="lcd-screen">\n	<div id="backlight">\n		<div id="backlight-halo-left">\n			<div id="backlight-halo-right">\n				<div id="backlight-halo-up">\n					<div id="backlight-halo-down">\n					</div>\n				</div>\n			</div>\n		</div>\n	</div>\n</div>\n';

  // node_modules/cookies-ds/dist/components/lcd-screen/index.js
  var templateNode4 = document.createElement("template");
  templateNode4.innerHTML = template_default4;
  var LcdScreen = class extends HTMLElement {
    connectedCallback() {
      this.attachShadow({ mode: "open" });
      const shadowRoot = getShadowRoot(this);
      shadowRoot.appendChild(templateNode4.content.cloneNode(true));
    }
  };

  // node_modules/cookies-ds/dist/components/padlock-screen/template.js
  var template_default5 = '<style>\n	:host {\n		display: block;\n	}\n\n	#padlock-screen {\n		height: 100%;\n		display: grid;\n		grid-template-columns: 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr;\n		grid-template-rows:  1fr 1fr 1fr 1fr 1fr;\n		grid-column-gap: 0px;\n		grid-row-gap: 0px; \n	}\n\n	#lcd-screen {\n		 grid-area: 1 / 1 / 6 / 10;\n	}\n\n	#release-date {\n		grid-area: 1 / 1 / 6 / 10;\n		background-size: 100% 100%;\n		z-index: 1;\n	}\n\n	#days { grid-area: 4 / 2 / 5 / 3; }\n	#hours { grid-area: 4 / 4 / 5 / 5; }\n	#minutes { grid-area: 4 / 6 / 5 / 7; }\n	#wheels { grid-area: 4 / 8 / 5 / 9; } \n</style>\n\n<div id="padlock-screen">\n	<cookies-lcd-screen id="lcd-screen"></cookies-lcd-screen>\n	<div id="release-date"></div>\n</div>\n';

  // node_modules/cookies-ds/dist/components/padlock-screen/fonts/digital.js
  var digital_default = "data:font/ttf;base64,AAEAAAASAQAABAAgTFRTSPCmpr8AAAO0AAAAb09TLzJoUe8xAAABqAAAAGBQQ0xUzZbuTAAAhiwAAAA2VkRNWGvec3UAAAQkAAAF4GNtYXCQW9VlAAAUHAAAAlBjdnQgEnUMPQAAKowAAABmZnBnbTREFoUAABZsAAATO2dhc3AAFwAJAACGHAAAABBnbHlmLJLqGQAAKvQAAFLAaGRteGyfoAQAAAoEAAAKGGhlYWQgIut1AAABLAAAADZoaGVhBY4BmAAAAWQAAAAkaG10eND8G+wAAAIIAAABrGxvY2FPbGZQAAB9tAAAANhtYXhwAw4T0QAAAYgAAAAgbmFtZcjFstEAAH6MAAAGjXBvc3RdSWIxAACFHAAAAP1wcmVwVvJmgAAAKagAAADhAAEAAAABAQYWpdZ/Xw889QAQBEwAAAAA34VS4gAAAADfhVNxAAD/iAH0A0gAAAALAAIAAAAAAAAAAQAAA5j/OAAAAfQAAAAAAfQAAQAAAAAAAAAAAAAAAAAAAGsAAQAAAGsAVAAOAAAAAAACAAgAQACMAAACABM7AAAAAAADAfQBkAAFAAACvAKKAAAAjwK8AooAAAHFAHgBkAAAAgAAAAAAAAAAAIAAAAEAAAAAAAAAAAAAAABBTFRTAEAAICAwA5j/OAAAA5gAyAAAAAEAAAAAArwC0AAAACAAAAH0AAAB9AAAAfQAAAH0AAAB9ADSAfQAjAH0AB4B9AAoAfQAAAH0ACgB9ADcAfQAKAH0AL4B9ABVAfQAUAH0ANIB9ABQAfQA0gH0ACgB9AAoAfQBfAH0ACgB9AAoAfQAKAH0ACgB9AAoAfQAKAH0ACgB9AAoAfQA0gH0ANIB9ABkAfQAUAH0AGQB9AAoAfQAKAH0ACgB9AAoAfQAKAH0ACgB9AAoAfQAKAH0ACgB9AAoAfQAyAH0ACgB9AAoAfQAKAH0ACgB9AAoAfQAKAH0ACgB9AAoAfQAKAH0ACgB9AApAfQAKAH0ACgB9AAoAfQAKAH0ACgB9AAoAfQAKAH0ACkB9AD6AfQAKAH0ACgB9ACgAfQAKAH0ACgB9AAoAfQAKAH0ACgB9AAoAfQAKAH0ACgB9ADIAfQAKAH0ACgB9AAoAfQAKAH0ACgB9AAoAfQAKAH0ACgB9AAoAfQAKAH0ACkB9AAoAfQAKAH0ACgB9AAoAfQAKAH0ACgB9AAeAfQAKAH0AFAB9AAeAfQAAAH0ANwB9ADcAfQAjAH0AIwB9ABkAfQAHgH0AAoB9AAAAAAAa0sBAQFLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLAAAAAAEAAQEBAQEADAD4CP8ACAAH//4ACQAI//4ACgAJ//4ACwAK//4ADAAL//0ADQAL//0ADgAM//0ADwAN//0AEAAO//0AEQAP//wAEgAQ//wAEwAQ//wAFAAR//wAFQAS//wAFgAT//wAFwAU//sAGAAV//sAGQAV//sAGgAW//sAGwAX//sAHAAY//oAHQAZ//oAHgAa//oAHwAa//oAIAAb//oAIQAc//oAIgAd//kAIwAe//kAJAAf//kAJQAf//kAJgAg//kAJwAh//gAKAAi//gAKQAj//gAKgAk//gAKwAk//gALAAl//gALQAm//cALgAn//cALwAo//cAMAAp//cAMQAp//cAMgAq//YAMwAr//YANAAs//YANQAt//YANgAu//YANwAu//YAOAAv//UAOQAw//UAOgAx//UAOwAy//UAPAAz//UAPQA0//QAPgA0//QAPwA1//QAQAA2//QAQQA3//QAQgA4//QAQwA5//MARAA5//MARQA6//MARgA7//MARwA8//MASAA9//IASQA+//IASgA+//IASwA///IATABA//IATQBB//IATgBC//EATwBD//EAUABD//EAUQBE//EAUgBF//EAUwBG//AAVABH//AAVQBI//AAVgBI//AAVwBJ//AAWABK//AAWQBL/+8AWgBM/+8AWwBN/+8AXABN/+8AXQBO/+8AXgBP/+4AXwBQ/+4AYABR/+4AYQBS/+4AYgBS/+4AYwBT/+4AZABU/+0AZQBV/+0AZgBW/+0AZwBX/+0AaABX/+0AaQBY/+wAagBZ/+wAawBa/+wAbABb/+wAbQBc/+wAbgBc/+wAbwBd/+sAcABe/+sAcQBf/+sAcgBg/+sAcwBh/+sAdABi/+oAdQBi/+oAdgBj/+oAdwBk/+oAeABl/+oAeQBm/+oAegBn/+kAewBn/+kAfABo/+kAfQBp/+kAfgBq/+kAfwBr/+gAgABs/+gAgQBs/+gAggBt/+gAgwBu/+gAhABv/+gAhQBw/+cAhgBx/+cAhwBx/+cAiABy/+cAiQBz/+cAigB0/+YAiwB1/+YAjAB2/+YAjQB2/+YAjgB3/+YAjwB4/+YAkAB5/+UAkQB6/+UAkgB7/+UAkwB7/+UAlAB8/+UAlQB9/+QAlgB+/+QAlwB//+QAmACA/+QAmQCA/+QAmgCB/+QAmwCC/+MAnACD/+MAnQCE/+MAngCF/+MAnwCF/+MAoACG/+IAoQCH/+IAogCI/+IAowCJ/+IApACK/+IApQCK/+IApgCL/+EApwCM/+EAqACN/+EAqQCO/+EAqgCP/+EAqwCQ/+AArACQ/+AArQCR/+AArgCS/+AArwCT/+AAsACU/+AAsQCV/98AsgCV/98AswCW/98AtACX/98AtQCY/98AtgCZ/94AtwCa/94AuACa/94AuQCb/94AugCc/94AuwCd/94AvACe/90AvQCf/90AvgCf/90AvwCg/90AwACh/90AwQCi/9wAwgCj/9wAwwCk/9wAxACk/9wAxQCl/9wAxgCm/9wAxwCn/9sAyACo/9sAyQCp/9sAygCp/9sAywCq/9sAzACr/9oAzQCs/9oAzgCt/9oAzwCu/9oA0ACu/9oA0QCv/9oA0gCw/9kA0wCx/9kA1ACy/9kA1QCz/9kA1gCz/9kA1wC0/9gA2AC1/9gA2QC2/9gA2gC3/9gA2wC4/9gA3AC4/9gA3QC5/9cA3gC6/9cA3wC7/9cA4AC8/9cA4QC9/9cA4gC+/9YA4wC+/9YA5AC//9YA5QDA/9YA5gDB/9YA5wDC/9YA6ADD/9UA6QDD/9UA6gDE/9UA6wDF/9UA7ADG/9UA7QDH/9QA7gDI/9QA7wDI/9QA8ADJ/9QA8QDK/9QA8gDL/9QA8wDM/9MA9ADN/9MA9QDN/9MA9gDO/9MA9wDP/9MA+ADQ/9IA+QDR/9IA+gDS/9IA+wDS/9IA/ADT/9IA/QDU/9IA/gDV/9EA/wDW/9EAAAAXAAAAcAkEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAKBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFAAAACwUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQAAAAwFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUAAAANBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGAAAADwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAABAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAARCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAAEwkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAABUKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoAAAAYCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLAAAAGwwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAB0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0AAAAgDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PAAAAIQ8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDwAAACUREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREAAAAqExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTAAAALhUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFQAAADIXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcAAAA2GRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZAAAAOhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGgAAAEMeHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4AAABLIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiAAAAAAAAAwAAAAMAAAIAAAEAAAAAABwAAwABAAABsAAGAZQAAAAgAMUAAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAEgATABQAFQAWABcAGAAZABoAGwAcAB0AHgAfACAAIQAiACMAJAAlACYAJwAoACkAKgArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AD4APwBAAEEAQgBDAEQARQBGAEcASABJAEoASwBMAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQBeAF8AYABhAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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ACuzDQtGACuzDgFGACuzEA9GACuzEQ9GACuzEgtGACuzEwtGACuzFAFGACuzFQFGACuzFg9GACuzFwFGACuzGAFGACuzGQtGACtFaERFaERFaERFaERFaEQAAAACuwGDAEsCRgIGAAADUQHO/5ABnQIwAAACFQAOATn/jP9F/6cAtgBxAdUBUP9rAQQA7gCMAEsASwCeAIMArACCABwASwBhAA4AMwBKABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAAAAEAAAAAAHgAtAABQALAA8AFwCPuABkK7gAGC+4ABMvuAAQ3LoAAAATABAREjm4ABgQuAAN0LgADS+4AATcuAAH0LgABy+4AA0QuAAI0LgACC+6AAsAEwAQERI5uAAEELgAD9C4ABAQuAAZ3AC6ABMAAABnK7oACwAUAGcruAATELgABNC4ABQQuAAH0LoADQAAABMREjm6AA4AFAALERI5MDEpASYnNyERISc2NyEBBxEXAQYHJxE3FhcBmv6YKApQASz+1VAKKAFn/rZQUAGQCigeHigKCigeAjAeKAr9lB4CRB79xigKUAIwUAooAAADANIAAAEiAtAABAALAA8AQ7gAZCu6AAIAAwBnK7gAAxC4AAXQuAACELgACdC4AAIQuAAM0LgAAxC4AA3QALgABy+6AA8ADABnK7gADxC4AAPcMDEBFxUjPQI3FhcRBxMjNTMBDhRQHigKFBRQUAFeFKqCjNJQCij+6BT+jlAAAAIAjAIIAX0C0QAEAAkAO7gAZCu4AAovuAAHL7gAChC4AALQuAACL7gAANy4AAcQuAAF3LgAC9wAuAADL7gACC+4AAEvuAAGLzAxEwcnNTMXByc1M9woKFChKChQAjAoKKCfKCigAAAADAAeAHcB1gJYAAUACwARABcAHQAjACkALwA1ADsAQQBHAOe4AGQruABIL7gAEi+4AEgQuAAM0LgADC+4AA7cuAASELgAFNy4AAwQuAAY0LgADhC4ABrQuAASELgAHtC4ABQQuAAg0LgAEhC4ACTQuAAUELgAJtC4AAwQuAAq0LgADhC4ACzQALgAGS+4AB8vuAAoL7gALi+6ADYAOABnK7oAQgBEAGcruABCELgAANC4AAAvuABEELgAAtC4AAIvuAA2ELgABtC4AAYvuAA4ELgACNC4AAgvuAA2ELgAMNC4ADAvuAA4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AA4AAhESOboAEAAOAAIREjm6ABQADgACERI5MDETNTcXFTcXDwEfAQcnFQcnNQcnPwEvATfSKChGNw9FRQ83RigoRjcPRUUPNwGuUCgoUCgPNygoNw8oUCgoUCgPNygoNw8AAAABAFAAvgGkAhIADwA/uABkK7oABAAAAGcruAAEELgACNC4AAAQuAAL0AC4AAovuAACL7oABQAHAGcruAAFELgAANC4AAcQuAAM0DAxEzU3FxUzFwcjFQcnNSMnN9IoKFooKFooKFooKAGQWigoWigoWigoWigoAAABANL/iAEiAFAABAAXuABkK7oAAAACAGcrALgAAS+4AAMvMDEFByc1MwEiKChQUCgooAAAAQBQAUABpAGQAAUAD7gAZCsAugAAAAIAZyswMQEXByEnNwF8KCj+/CgoAZAoKCgoAAAAAAEA0gAAASIAUAADABe4AGQrugAAAAEAZysAugADAAAAZyswMSEjNTMBIlBQUAAAAAIAKAAAAcwC0AAFAAsAD7gAZCsAuAABL7gABy8wMQE3MhcDIw8BIicTMwEFdzwUmi0WdzwUmi0B3vIo/sqA8igBNgAABgAoAAABzALQAAYADAARABcAHAAjAK+4AGQruAAkL7gABS+4AALcugAHAAUAAhESObgAJBC4AA3QuAANL7gAC9y4ABDQuAALELgAE9C4ABMvuAANELgAFNC4ABQvugAXAAUAAhESObgACxC4ABjQuAANELgAG9C4AAUQuAAd0LgAAhC4ACHQuAACELgAJdwAugAFAAcAZyu6ABcAHgBnK7gABRC4AAvQugANAAcABRESObgAHhC4ABPQugAcAB4AFxESOTAxARcRBgcnNRMhJic3MwURNxcVEyMnNjchBRUHJxEFNTcWFxEHAbgUCigeCv7UKApQ8P7AFDzw71AKKAEr/vI8FAFUHigKFAFeFP7oKApQ0v7eCigeCgEEFDy+AhweKApkvjwUAQTc0lAKKP7oFAACAXwAAAHMAtAABgANAC+4AForugACAAUAXSu4AAUQuAAH0LgAAhC4AAvQuAACELgAD9wAuAAEL7gACS8wMQEXEQYHJz0CNxYXEQcBuBQKKB4eKAoUAV4U/ugoClDSjNJQCij+6BQAAAUAKAAAAcwC0AAFAAsAEAAWAB0ApbgAZCu4AB4vuAAAL7gAAtC4AB4QuAAM0LgADC+4AArcuAAD0LgAChC4AAXQuAAAELgAHNy6AAYAAAAcERI5uAAKELgAD9C4AAoQuAAS0LgAEi+4AAwQuAAT0LgAEy+6ABYAAAAcERI5uAAAELgAF9C4ABwQuAAf3AC6AAsABgBnK7oAFgAYAGcrugAAAAIAZyu6AAwABgALERI5uAAYELgAEtAwMQEXByEnNwEhJic3IQURNxcVEyMnNjchAzU3FhcRBwF8KCj+/CgoASz+tigKUAEO/qIUPPDvUAooASsKHigKFAGQKCgoKP5wCigeCgEEFDy+AhweKAr+3tJQCij+6BQAAAAABQAoAAABzALQAAUADAASABgAHwBruABaK7oAHgAAAF0ruAAeELgAB9C4AAAQuAAL0LoADQAAAB4REjm6ABgAAAAeERI5uAAAELgAGdC4AB4QuAAh3AC6AAsADQBdK7oAGAAaAF0rugAAAAIAXSu4AAsQuAAR0LgAGhC4ABTQMDEBFwchJzcFFxEGByc1EyEmJzczESMnNjchAzU3FhcRBwF8KCj+/CgoAUAUCigeCv7UKApQ8O9QCigBKwoeKAoUAZAoKCgoMhT+6CgKUNL+3gooHgIwHigK/t7SUAoo/ugUAAAABAAoAAABzALQAAUADAARABgAbbgAZCu4ABkvuAAAL7gAAtC4ABkQuAAQ0LgAEC+4AAXcuAAD0LgAABC4ABfcuAAH0LgAABC4AAvQuAAFELgADdC4AAAQuAAS0LgAFxC4ABrcALgAFC+4AAovugAAAAIAZyu6ABEACgAUERI5MDEBFwchJzcFFxEGByc1ARUHJxEFNTcWFxEHAXwoKP78KCgBQBQKKB7+/DwUAVQeKAoUAZAoKCgoMhT+6CgKUNIBaNw8FAEi+tJQCij+6BQAAAUAKAAAAcwC0AAFAAwAEgAYAB0ArbgAZCu4AB4vuAACL7gAANC4AB4QuAAQ0LgAEC+4ABHcuAAD0LgAERC4AAXQuAACELgAB9y4AAIQuAAL0LoADQACAAcREjm4ABEQuAAU0LgAFC+4ABAQuAAV0LgAFS+6ABgAAgAHERI5uAARELgAGdC4ABAQuAAc0LgABxC4AB/cALoACwANAGcrugAYABMAZyu6AAAAAgBnK7gACxC4ABHQugAdABMAGBESOTAxARcHISc3BRcRBgcnNRMhJic3MxMhJzY3IQUVBycRAXwoKP78KCgBQBQKKB4K/tQoClDwHv7zUAooAUn+1DwUAZAoKCgoMhT+6CgKUNL+3gooHgIwHigKZL48FAEEAAYAKAAAAcwC0AAFAAwAEgAXAB0AIgC/uABkK7gAIy+4AAIvuAAA0LgAIxC4ABPQuAATL7gAEdy4AAPQuAARELgABdC4AAIQuAAH3LgAAhC4AAvQugANAAIABxESObgAERC4ABbQuAARELgAGdC4ABkvuAATELgAGtC4ABovugAdAAIABxESObgAERC4AB7QuAATELgAIdC4AAcQuAAk3AC6AAsADQBnK7oAHQAYAGcrugAAAAIAZyu4AAsQuAAR0LoAEwANAAsREjm6ACIAGAAdERI5MDEBFwchJzcFFxEGByc1EyEmJzczBRE3FxUBISc2NyEFFQcnEQF8KCj+/CgoAUAUCigeCv7UKApQ8P7AFDwBDv7zUAooAUn+1DwUAZAoKCgoMhT+6CgKUNL+3gooHgoBBBQ8vgIcHigKZL48FAEEAAQAKAAAAcwC0AAGAAwAEQAYAHe4AForuAAZL7gABS+4AALcuAAZELgAENC4ABAvuAAO3LgACNC4AAgvuAAQELgACdC4AAkvugAMAAUAAhESObgABRC4ABLQuAACELgAFtC4AAIQuAAa3AC4AAQvugAMABMAXSu4ABMQuAAI0LoAEQATAAwREjkwMQEXEQYHJzUDIyc2NyEFFQcnEQU1NxYXEQcBuBQKKB4U71AKKAEr/vI8FAFUHigKFAFeFP7oKApQ0gFeHigKZL48FAEE3NJQCij+6BQAAAcAKAAAAcwC0AAFAAwAEgAXAB0AIgApANO4AForuAAqL7gAAC+4AALQuAAqELgAE9C4ABMvuAAR3LgAA9C4ABEQuAAF0LgAABC4ACjcuAAH0LgAABC4AAvQugANAAAAKBESObgAERC4ABbQuAARELgAGdC4ABkvuAATELgAGtC4ABovugAdAAAAKBESObgAERC4AB7QuAATELgAIdC4AAAQuAAj0LgAKBC4ACvcALoACwANAF0rugAdACQAXSu6AAAAAgBdK7gACxC4ABHQugATAA0ACxESObgAJBC4ABnQugAiACQAHRESOTAxARcHISc3BRcRBgcnNRMhJic3MwURNxcVEyMnNjchBRUHJxEFNTcWFxEHAXwoKP78KCgBQBQKKB4K/tQoClDw/sAUPPDvUAooASv+8jwUAVQeKAoUAZAoKCgoMhT+6CgKUNL+3gooHgoBBBQ8vgIcHigKZL48FAEE3NJQCij+6BQAAAAABgAoAAABzALQAAUADAASABgAHQAkAMG4AForuAAlL7gAAC+4AALQuAAlELgAENC4ABAvuAAR3LgAA9C4ABEQuAAF0LgAABC4ACPcuAAH0LgAABC4AAvQugANAAAAIxESObgAERC4ABTQuAAUL7gAEBC4ABXQuAAVL7oAGAAAACMREjm4ABEQuAAZ0LgAEBC4ABzQuAAAELgAHtC4ACMQuAAm3AC6AAsADQBdK7oAGAAfAF0rugAAAAIAXSu4AAsQuAAR0LgAHxC4ABTQugAdAB8AGBESOTAxARcHISc3BRcRBgcnNRMhJic3MxEjJzY3IQUVBycRBTU3FhcRBwF8KCj+/CgoAUAUCigeCv7UKApQ8O9QCigBK/7yPBQBVB4oChQBkCgoKCgyFP7oKApQ0v7eCigeAjAeKApkvjwUAQTc0lAKKP7oFAAAAAACANIAoAEiAjAAAwAHAC+4AIIrugAAAAEAhSu4AAAQuAAE0LgAARC4AAXQALoAAwAAAIUrugAHAAQAhSswMSUjNTM1IzUzASJQUFBQoFDwUAAAAAACANL/iAEiAjAAAwAIACu4AGQrugAAAAEAZyu4AAAQuAAE0LgAARC4AAbQALgABS+6AAMAAABnKzAxASM1MxEHJzUzASJQUCgoUAHgUP2AKCigAAACAGQAlgFyAjoABAAJACO4AGQrALgAAi+4AAYvugABAAYAAhESOboACAAGAAIREjkwMRMjNzMXEQcjJzPSbsgoHh4oyG4Bcsgn/qonyAAAAAIAUADvAaQB4AAFAAsAF7gAZCsAugAGAAgAZyu6AAAAAgBnKzAxARcHISc3BRcHISc3AXwoKP78KCgBBCgo/vwoKAHgKCgoKKEoKCgoAAAAAgBkAJYBcgI6AAQACQAjuABkKwC4AAEvuAAHL7oAAwAHAAEREjm6AAYABwABERI5MDETNzMXIxUzByMnZB4oyG5uyCgeAhMnyBTIJwAAAAAFACgAAAHMAtAABQAKABAAFwAbAJm4AGQruAAcL7gAAC+4AALQuAAcELgABtC4AAYvuAAK3LgAA9C4AAoQuAAF0LgAChC4AAzQuAAML7gABhC4AA3QuAANL7gAABC4ABbcugAQAAAAFhESObgAABC4ABHQuAAKELgAGNC4AAYQuAAZ0LgAFhC4AB3cALoAGwAYAGcrugAQABIAZyu6AAAAAgBnK7gAEhC4AAzQMDEBFwchJzcHNTcXFRMjJzY3IQM1NxYXEQcBIzUzAXwoKP78KChQFDzw71AKKAErCh4oChT+wFBQAZAoKCgo8KoUPIIB4B4oCv7e0lAKKP7oFP6OUAAAAAoAKAAAAcwC0AAGAAwAEQAXABwAIwApAC4AMwA5AM24AGQrugALAA0AZyu6ACkAKgBnK7oAAgAFAGcrugAHAAUAAhESObgACxC4ABDQugAXAAUAAhESObgACxC4ABjQuAANELgAG9C4AAUQuAAd0LgAAhC4ACHQuAAqELgAMtC6ADMADQACERI5uAApELgANNC4AAIQuAA73AC6AAwABwBnK7oAFwAeAGcrugAoACUAZyu6ADkANABnK7oADQAHAAwREjm4AB4QuAAT0LoAHAAeABcREjm6ACoAJQAoERI5ugAzADQAORESOTAxARcVBgcnNRMhJic3MwURNxcVEyMnNjchBRUHJxEFNTcWFxEPAiYnNzMHNTcXFTUVByc1FyMnNjcXAbgUCigeCv7UKApQ8P7AFDzw71AKKAEr/vI8FAFUHigKFDKMKApQUKAUPDwUoFBQCihuAV4UeCgKUDL+3gooHgoBBBQ8vgIcHigKZL48FAEE3NJQCij+6BTSAQooHwpkFDweyB48FGQKHygKAQAABgAoAAABzALQAAUADAASABcAHgAlAK+4AGQruAAmL7gAAC+4AALQuAAmELgAFtC4ABYvuAAF3LgAA9C4AAAQuAAd3LgAB9C4AAAQuAAL0LgABRC4AA7QuAAOL7gAFhC4AA/QuAAPL7oAEgAAAB0REjm4AAUQuAAT0LgAABC4ABjQuAAFELgAH9C4ABYQuAAj0LgAHRC4ACfcALgACi+4ACEvugASABkAZyu6AAAAAgBnK7gAGRC4AA7QugAXABkAEhESOTAxARcHISc3BRcRBgcnNQMjJzY3IQUVBycRBTU3FhcRBwUVByYnETcBfCgo/vwoKAFAFAooHhTvUAooASv+8jwUAVQeKAoU/sAeKAoUAZAoKCgoMhT+6CgKUNIBXh4oCmS+PBQBBNzSUAoo/ugUUNJQCigBGBQAAAcAKAAAAcwC0AAFAAoAEAAVABsAIQAnAK+4AGQruAAoL7gAAC+4AALQuAAoELgABtC4AAYvuAAm3LgAA9C4ACYQuAAF0LgAJhC4AAnQuAAmELgADNC4AAYQuAAN0LgAJhC4ABHQuAAGELgAFNC4AAAQuAAW0LgAABC4ABrcuAAd0LgAABC4ACDQuAAGELgAJNC4ABoQuAAp3AC6ACcAIwBnK7oADwALAGcrugAAAAIAZyu6AAYAIwAnERI5ugAVAAsADxESOTAxARcHISc3AxE3FxUTIyc1IRcFFQcnEQU1NxcVBxUXFQcnNRcHITU3MwF8KCj+/CgoUBQ88PBQAUAo/ug8FAFUHjIUFDIeEyj+wVDvAZAoKCgo/rYBBBQ8vgIcHjIoPL48FAEE3NIeMuYUFBTmMh7S+igyHgAEACgAAAGkAtAABQAKABAAFQBLuABkK7oABAAGAGcruAAEELgACdC4AAQQuAAR0LgABhC4ABTQALoABQAAAGcrugAQAAsAZyu6AAYAAAAFERI5ugAVAAsAEBESOTAxKQEmJzchBRE3FxUBISc2NyEFFQcnEQGk/rYoClABDv6iFDwBDv7zUAooAUn+1DwUCigeCgEEFDy+AhweKApkvjwUAQQAAAYAKAAAAcwC0AAEAAoADwAVABsAIQCLuABkK7gAIi+4ABAvuAAiELgAANC4AAAvuAAg3LgAA9C4ACAQuAAG0LgAABC4AAfQuAAgELgAC9C4AAAQuAAO0LgAEBC4ABTcuAAX0LgAEBC4ABrQuAAAELgAHtC4ABQQuAAj3AC6ACEAHQBnK7oACQAFAGcrugAAAB0AIRESOboADwAFAAkREjkwMTcRNxcVEyMnNSEXBRUHJxEFNTcXFQcVFxUHJzUXByE1NzMoFDzw8FABQCj+6DwUAVQeMhQUMh4TKP7BUO9GAQQUPL4CHB4yKDy+PBQBBNzSHjLmFBQU5jIe0vooMh4AAAAABQAoAAABpALQAAUACwAQABYAGwBTuABkK7oACgAMAGcruAAKELgAD9C4AAoQuAAX0LgADBC4ABrQALoACwAGAGcrugAWABEAZyu6AAAAAgBnK7oADAAGAAsREjm6ABsAEQAWERI5MDEBFwchJzcBISYnNyEFETcXFQEhJzY3IQUVBycRAXwoKP78KCgBLP62KApQAQ7+ohQ8AQ7+81AKKAFJ/tQ8FAGQKCgoKP5wCigeCgEEFDy+AhweKApkvjwUAQQAAAQAKAAAAaQC0AAFAAsAEAAXAEW4AGQrugAFAA8AZyu4AAUQuAAM0LgABRC4ABHQuAAPELgAFdAAuAATL7oACwAGAGcrugAAAAIAZyu6ABAABgALERI5MDEBFwchJzclISc2NyEFFQcnERMVByYnETcBfCgo/vwoKAEO/vNQCigBSf7UPBRQHigKFAGQKCgoKPAeKApkvjwUAQT+mNJQCigBGBQABgAoAAABzALQAAUADAASABcAHQAiAK+4AGQruAAjL7gAAi+4AADQuAACELgAB9y4AAIQuAAL0LoADQACAAcREjm4ACMQuAAT0LgAEy+4ABHcuAAW0LgAERC4ABnQuAAZL7gAExC4ABrQuAAaL7oAHQACAAcREjm4ABEQuAAe0LgAExC4ACHQuAAHELgAJNwAugALAA0AZyu6AB0AGABnK7oAAAACAGcruAALELgAEdC6ABMADQALERI5ugAiABgAHRESOTAxARcHIyc3HwERBgcnNRMhJic3MwURNxcVASEnNjchBRUHJxEBfCgoWigolhQKKB4K/tQoClDw/sAUPAEO/vNQCigBSf7UPBQBkCgoKCgyFP7oKApQ0v7eCigeCgEEFDy+AhweKApkvjwUAQQAAAAFACgAAAHMAtAABQAMABMAGgAhAHe4AGQruAAiL7gAAC+4AALQuAAiELgAGNC4ABgvuAAV3LgAA9C4ABUQuAAF0LgAABC4ABLcuAAH0LgAABC4AAvQuAAAELgADdC4ABgQuAAc0LgAFRC4ACDQuAASELgAI9wAuAAKL7gAFi+4AA8vugAAAAIAZyswMQEXByEnNwUXEQYHJz0CNxYXEQcFFQcmJxE3NScRNjcXFQF8KCj+/CgoAUAUCigeHigKFP7AHigKFBQKKB4BkCgoKCgyFP7oKApQ0ozSUAoo/ugUUNJQCigBGBQKFAEYKApQ0gACAMgACgEYAtAABgANACe4AHgrugAFAAAAeyu4AAUQuAAI0LgAABC4AAzQALgAAi+4AAsvMDETNTcWFxEHFRcRBgcnNcgeKAoUFAooHgGu0lAKKP7oFAoU/ugoClDSAAAEACgAAAHMAtAABgAMABEAGABnuABkK7gAGS+4AAUvuAAC3LoABwAFAAIREjm4ABkQuAAN0LgADS+4AAvcuAAQ0LgABRC4ABLQuAACELgAFtC4AAIQuAAa3AC4ABQvugAFAAcAZyu4AAUQuAAL0LoADQAHAAUREjkwMQEXEQYHJzUTISYnNzMFETcXFQE1NxYXEQcBuBQKKB4K/tQoClDw/sAUPAEEHigKFAFeFP7oKApQ0v7eCigeCgEEFDy+AUrSUAoo/ugUAAUAKAAAAcwC0AAFAAwAEgAZACAAf7gAZCu4ACEvuAACL7gAANC4ACEQuAAX0LgAFy+4ABTcuAAD0LgAFBC4AAXQuAACELgAB9y4AAIQuAAL0LgAAhC4AA7QuAAHELgAENC4ABcQuAAb0LgAFBC4AB/QuAAHELgAItwAuAAOL7gAHi+4AAovuAAVL7oAAAACAGcrMDEBFwchJzcFFxEGByc1JzcyFwEjBxUHJicRNzUnETY3FxUBfCgo/vwoKAFAFAooHvDwPBT+/DwUHigKFBQKKB4BkCgoKCgyFP7oKApQ0r7wKP78gtJQCigBGBQUFAEYKApQ0gAAAwAoAAABzALQAAYADAATAD24AGQrugABAAQAZyu6AAwABAABERI5uAAEELgADtC4AAEQuAAS0AC4ABEvugABAAwAZyu4AAEQuAAI0DAxExUHJicRNxMzFwYHIQMnETY3FxV4HigKFFDwUAoo/tQyFAooHgEi0lAKKAEYFP7yHigKAXIUARgoClDSAAAGACgAAAHMAtAABAALABEAFgAdACQAu7gAZCu4ACUvuAAV0LgAFS+4AALcQQMAYAACAAFdQQMAwAACAAFduAAA3LgAAhC4AArcQQMAwAAKAAFdQQMAYAAKAAFduAAH3LgAFRC4ABPcuAAN0LgADS+4ABUQuAAO0LgADi+6ABEACgAHERI5uAAKELgAF9C4AAcQuAAb0LgAExC4AB7QuAAVELgAItC4AAcQuAAm3AC4AAkvuAAgL7oAEQAYAGcruAAYELgADdC6ABYAGAARERI5MDEBByc1MxMXEQYHJzUDIyc2NyEFFQcnEQU1NxYXEQcFFQcmJxE3ASIoKFCWFAooHhTvUAooASv+8jwUAVQeKAoU/sAeKAoUAYYoKOb+8hT+6CgKUNIBXh4oCmS+PBQBBNzSUAoo/ugUUNJQCigBGBQAAAAFACgAAAHMAsYABgAMABMAGgAhAF+4AGQruAAiL7gAEi+4ACIQuAAE0LgABC+4AAHcuAASELgAD9y4ABIQuAAU0LgADxC4ABjQuAAEELgAHNC4AAEQuAAg0LgADxC4ACPcALgAAi+4ABEvuAAWL7gAHy8wMRMVByYnETclIyc1Mx8CEQYHJz0CNxYXEQchJxE2NxcVeB4oChQBLEaWPKBQFAooHh4oChT+hBQKKB4BItJQCigBGBRGljygeBT+6CgKUNKC0lAKKP7oFBQBGCgKUNIAAAYAKAAAAcwC0AAFAAsAEQAXAB0AIwBTuABkK7gAJC+4AAYvuAAK3LgADdC4AAYQuAAQ0LgAJBC4ABPQuAATL7gAF9y4AB7QuAATELgAIdC4AAoQuAAl3AC6AB0AGQBnK7oABAAAAGcrMDEBIyc3MxcHNTcXFQcVFxUHJzUlJzU3FxUBByMnNzMnFQcnNTcBaNwoKNwoFB4yFBQyHv7AFDIeARgo3Cgo3PAeMhQCgCgoKPrSHjLmFBQU5jIe0lAU5jIe0v56KCgo0tIeMuYUAAAFACgAAAHMAtAABQALABAAFgAdAIW4AGQruAAeL7gAAC+4AALQuAAeELgAENC4ABAvuAAH3LgAA9C4AAcQuAAF0LgAEBC4AAnQuAAHELgADdC4AAAQuAAR0LgAABC4ABXcuAAHELgAF9C4ABAQuAAb0LgAFRC4AB/cALgAGS+6AAoABgBnK7oAAAACAGcrugAQAAYAChESOTAxARcHISc/ASMnNSEXBRUHJxEFNTcXFQcFFQcmJxE3AXwoKP78KCjw8FABQCj+6DwUAVQeMhT+wB4oChQBkCgoKCjwHjIoPL48FAEE3NIeMuYUUNJQCigBGBQABwAo//YB1gLQAAQACgAPABUAGgAhACcAq7gAZCu4ACgvuAADL7gAAty4ACgQuAAL0LgACy+6AAUACwACERI5uAAJ3LgADtC4AAkQuAAR0LgAES+4AAsQuAAS0LgAEi+6ABUAAwACERI5uAAJELgAFtC4AAsQuAAZ0LgAAxC4ABvQuAACELgAH9C4AAIQuAAp3AC4ACUvugAKAAUAZyu6ABUAHABnK7oACwAFAAoREjm4ABwQuAAR0LoAGgAcABUREjkwMQEXFSc1AyEmJzczBxE3FxUTIyc2NyEFFQcnEQU1NxYXEQ8BMxcVIycBuBRQCv7oKApQqvoUPPDvUAooASv+8jwUAVQeKAoUoDyCPIIBXhTwUHj+3gooHgoBBBQ8vgIcHigKZL48FAEE3NJQCij+6BS+gjyCAAAAAAYAKAAAAcwC0AAFAAsAEgAYAB8AJACvuABkK7gAJS+4AAAvuAAC0LgAJRC4ABDQuAAQL7gADdy4AAPQuAANELgABdC4AAAQuAAe3LgACNC4AAAQuAAK0LgADRC4ABTQuAAUL7gAEBC4ABXQuAAVL7oAGAAAAB4REjm4AAAQuAAZ0LgADRC4ACDQuAAQELgAI9C4AB4QuAAm3AC4AAovuAAOL7oAGAAaAGcrugAAAAIAZyu4ABoQuAAU0LoAJAAaABgREjkwMQEXByEnNxczAQYjLwEVByYnETcBIyc2NyEDNTcWFxEHJRUHJxEBfCgo/vwoKBQ8AQQUPPAUHigKFAEs71AKKAErCh4oChT+wDwUAZAoKCgoZP78KPAy0lAKKAEYFAEiHigK/t7SUAoo/ugU+r48FAEEAAUAKAAAAcwC0AAFAAwAEgAXAB8As7gAZCu4ACAvuAACL7gAANC4ACAQuAAQ0LgAEC+4ABHcuAAD0LgAERC4AAXQuAACELgAB9y4AAIQuAAL0LoADQACAAcREjm4ABEQuAAT0LgAEBC4ABbQuAARELgAGNC4ABgvuAAQELgAGdC4ABkvuAAHELgAHtC4AAIQuAAf0LgABxC4ACHcALoACwANAGcrugAbABgAZyu6AAAAAgBnK7gACxC4ABHQugAXABgAGxESOTAxARcHISc3BRcRBgcnNRMhJic3MwMVBycRFyc2NyEWFwcBfCgo/vwoKAFAFAooHgr+1CgKUPDwPBRRUAooAT8oClABkCgoKCgyFP7oKApQ0v7eCigeAhy+PBQBBAoeKAoKKB4AAAMAKQAAAcwC0AAGAAsAEwAruABkK7oAAgAFAGcruAAFELgAB9C4AAIQuAAJ0AC4AAQvugAPAAwAZyswMRMXEQYHJz0CMxUHAyc2NyEWFwf6KAooHlAogVAKKAE/KApQAV4o/vwoClDmZNLSKAEOHigKCigeAAAAAAUAKAAAAcwC0AAGAAwAEQAYAB8Ad7gAZCu4ACAvuAAFL7gAAty6AAcABQACERI5uAAgELgADdC4AA0vuAAL3LgAENC4AAUQuAAS0LgAAhC4ABbQuAANELgAGtC4AAsQuAAe0LgAAhC4ACHcALgAFC+6AAUABwBnK7gABRC4AAvQugANAAcABRESOTAxARcRBgcnNRMhJic3MwURNxcVATU3FhcRBwUnETY3FxUBuBQKKB4K/tQoClDw/sAUPAEEHigKFP6EFAooHgFeFP7oKApQ0v7eCigeCgEEFDy+AUrSUAoo/ugUChQBGCgKUNIAAAQAKAAAAcwCxgAGAA0AEwAZAHO4AGQruAAaL7gABy+4ABoQuAAB0LgAAS+4AAbcuAAHELgADNy6AA8AAQAMERI5uAABELgAENC4AAYQuAAT0LgABxC4ABTQuAAMELgAFtC6ABgAAQAMERI5uAAMELgAG9wAuAAEL7gACS+4AA8vuAAYLzAxEycRNjcXFSE1NxYXEQ8BFQM1NxchNxcVAzU8FAooHgEEHigKFMjIFDwBBDwUyAFoFAEYKApQ0tJQCij+6BTweAEEPBQ8PBQ8/vx4AAAABgAoAAABzALQAAQACwARABYAHQAkALu4AGQruAAlL7gAEtC4ABIvuAAB3EEDAGAAAQABXUEDAMAAAQABXbgAANy4AAEQuAAF3EEDAMAABQABXUEDAGAABQABXbgACty6AAwABQAKERI5uAASELgAD9C4AA8vuAASELgAFty4ABDQuAAQL7gAChC4ABjQuAAFELgAHNC4ABIQuAAf0LgAFhC4ACPQuAAKELgAJtwAuAAHL7gAIi+6ABwADABnK7gAHBC4ABDQugASAAwAHBESOTAxJSM1Nxc3NTcWFxEHAyEmJzczBRE3FxUlFxEGByc1JScRNjcXFQEiUCgoWh4oChQy/tUoClDv/sAUPAFAFAooHv7AFAooHmTmKChk0lAKKP7oFP6OCigeCgEEFDy++hT+6CgKUNJQFAEYKApQ0gAEACgAAAHMAtAABQALABEAFwA3uABkK7oACwARAGcruAALELgAANC4AAAvuAARELgAEtC4ABIvALgABC+4AA0vuAAHL7gAFi8wMQEzEwYjJz8BMhcDIw8BIicTMzcjAzYzFwEELZoUPHcBdzwUmi0WdzwUmi0BLZoUPHcBXv7KKPLs8ij+yoDyKAE2FAE2KPMAAAAABQAoAAABzALQAAUADAASABcAHgCJuABkK7gAHy+4AAAvuAAC0LgAHxC4ABDQuAAQL7gAEdy4AAPQuAARELgABdC4AAAQuAAd3LgAB9C4AAAQuAAL0LoADQAAAB0REjm4ABEQuAAT0LgAEBC4ABbQuAAAELgAGNC4AB0QuAAg3AC4ABovugALAA0AZyu6AAAAAgBnK7gACxC4ABHQMDEBFwchJzcFFxEGByc1EyEmJzczAxUHJxEFNTcWFxEHAXwoKP78KCgBQBQKKB4K/tQoClDw8DwUAVQeKAoUAZAoKCgoMhT+6CgKUNL+3gooHgI63DwUASL60lAKKP7oFAAAAAQAKAAAAcwC0AADAAkADwAVACe4AGQrALoAAwAAAGcrugAJAAQAZyu4AAkQuAAL0LgAABC4ABHQMDEpATczAyMnNjchAxMyFwMjFwMiJxMzAaT+6CjSRsdQCigBDW6CPBSWPAqMPBSgPFACMB4oCv7eASIo/spQ/t4oATYAAAAABAAoAAAA+gLQAAQACwAQABcAQ7gAZCu6AAQAAABnK7gABBC4AAzQuAAAELgAD9AAugAXABIAZyu6AAoABQBnK7oAAAASABcREjm6ABAABQAKERI5MDE3ETcXFRMjJzY3MxcHFQcnERMHIyYnNzMoFDxGRVAKKIsUgjwU0hSLKApQRUYBBBQ8vgIcHigKFFC+PBQBBP2KFAooHgAAAgApAAABywLQAAUACwAPuABkKwC4AAQvuAAKLzAxATMTBiMvASMDNjMXAQQtmhQ8dxQtmhQ8dwFe/soo8oABNijzAAAEAPoAAAHMAtAABgALABIAFwBLuABkK7oAAgAFAGcrugALAAUAAhESObgABRC4AAzQuAACELgAENC6ABMABQACERI5uAACELgAGdwAuAAKL7gADi+4AAQvuAATLzAxARcRBgcnNQMjJzczAzU3FhcRBwMjJzczAbgUCigeFDI8FHgKHigKFDJ4FDwyAV4U/ugoClDSAV48FP7e0lAKKP7oFP6OFDwAAAACACgBwgHLAtAABAAJABe4AGQrALgABC+4AAUvuAABL7gACC8wMQE1FxUHISc1NwcBA8gn/qsnyAECYm7IKB4eKMhuAAEAKAAAAcsAUAAHAA+4AGQrALoAAAADAGcrMDElFwYHISYnNwF7UAoo/sEoClBQHigKCigeAAAAAQCgAjABVALkAAUAD7gAZCsAuAACL7gABC8wMQEVByc3MwFUKIwKKAJiKAqMKAAABgAoAAABzALQAAUADAASABcAHgAlAK+4AGQruAAmL7gAAC+4AALQuAAmELgAFtC4ABYvuAAF3LgAA9C4AAAQuAAd3LgAB9C4AAAQuAAL0LgABRC4AA7QuAAOL7gAFhC4AA/QuAAPL7oAEgAAAB0REjm4AAUQuAAT0LgAABC4ABjQuAAFELgAH9C4ABYQuAAj0LgAHRC4ACfcALgACi+4ACEvugASABkAZyu6AAAAAgBnK7gAGRC4AA7QugAXABkAEhESOTAxARcHISc3BRcRBgcnNQMjJzY3IQUVBycRBTU3FhcRBwUVByYnETcBfCgo/vwoKAFAFAooHhTvUAooASv+8jwUAVQeKAoU/sAeKAoUAZAoKCgoMhT+6CgKUNIBXh4oCmS+PBQBBNzSUAoo/ugUUNJQCigBGBQAAAcAKAAAAcwC0AAFAAoAEAAVABsAIQAnAK+4AGQruAAoL7gAAC+4AALQuAAoELgABtC4AAYvuAAm3LgAA9C4ACYQuAAF0LgAJhC4AAnQuAAmELgADNC4AAYQuAAN0LgAJhC4ABHQuAAGELgAFNC4AAAQuAAW0LgAABC4ABrcuAAd0LgAABC4ACDQuAAGELgAJNC4ABoQuAAp3AC6ACcAIwBnK7oADwALAGcrugAAAAIAZyu6AAYAIwAnERI5ugAVAAsADxESOTAxARcHISc3AxE3FxUTIyc1IRcFFQcnEQU1NxcVBxUXFQcnNRcHITU3MwF8KCj+/CgoUBQ88PBQAUAo/ug8FAFUHjIUFDIeEyj+wVDvAZAoKCgo/rYBBBQ8vgIcHjIoPL48FAEE3NIeMuYUFBTmMh7S+igyHgAEACgAAAGkAtAABQAKABAAFQBLuABkK7oABAAGAGcruAAEELgACdC4AAQQuAAR0LgABhC4ABTQALoABQAAAGcrugAQAAsAZyu6AAYAAAAFERI5ugAVAAsAEBESOTAxKQEmJzchBRE3FxUBISc2NyEFFQcnEQGk/rYoClABDv6iFDwBDv7zUAooAUn+1DwUCigeCgEEFDy+AhweKApkvjwUAQQAAAYAKAAAAcwC0AAEAAoADwAVABsAIQCLuABkK7gAIi+4ABAvuAAiELgAANC4AAAvuAAg3LgAA9C4ACAQuAAG0LgAABC4AAfQuAAgELgAC9C4AAAQuAAO0LgAEBC4ABTcuAAX0LgAEBC4ABrQuAAAELgAHtC4ABQQuAAj3AC6ACEAHQBnK7oACQAFAGcrugAAAB0AIRESOboADwAFAAkREjkwMTcRNxcVEyMnNSEXBRUHJxEFNTcXFQcVFxUHJzUXByE1NzMoFDzw8FABQCj+6DwUAVQeMhQUMh4TKP7BUO9GAQQUPL4CHB4yKDy+PBQBBNzSHjLmFBQU5jIe0vooMh4AAAAABQAoAAABpALQAAUACwAQABYAGwBTuABkK7oACgAMAGcruAAKELgAD9C4AAoQuAAX0LgADBC4ABrQALoACwAGAGcrugAWABEAZyu6AAAAAgBnK7oADAAGAAsREjm6ABsAEQAWERI5MDEBFwchJzcBISYnNyEFETcXFQEhJzY3IQUVBycRAXwoKP78KCgBLP62KApQAQ7+ohQ8AQ7+81AKKAFJ/tQ8FAGQKCgoKP5wCigeCgEEFDy+AhweKApkvjwUAQQAAAQAKAAAAaQC0AAFAAsAEAAXAEW4AGQrugAFAA8AZyu4AAUQuAAM0LgABRC4ABHQuAAPELgAFdAAuAATL7oACwAGAGcrugAAAAIAZyu6ABAABgALERI5MDEBFwchJzclISc2NyEFFQcnERMVByYnETcBfCgo/vwoKAEO/vNQCigBSf7UPBRQHigKFAGQKCgoKPAeKApkvjwUAQT+mNJQCigBGBQABgAoAAABzALQAAUADAASABcAHQAiAK+4AGQruAAjL7gAAi+4AADQuAACELgAB9y4AAIQuAAL0LoADQACAAcREjm4ACMQuAAT0LgAEy+4ABHcuAAW0LgAERC4ABnQuAAZL7gAExC4ABrQuAAaL7oAHQACAAcREjm4ABEQuAAe0LgAExC4ACHQuAAHELgAJNwAugALAA0AZyu6AB0AGABnK7oAAAACAGcruAALELgAEdC6ABMADQALERI5ugAiABgAHRESOTAxARcHIyc3HwERBgcnNRMhJic3MwURNxcVASEnNjchBRUHJxEBfCgoWigolhQKKB4K/tQoClDw/sAUPAEO/vNQCigBSf7UPBQBkCgoKCgyFP7oKApQ0v7eCigeCgEEFDy+AhweKApkvjwUAQQAAAAFACgAAAHMAtAABQAMABMAGgAhAHe4AGQruAAiL7gAAC+4AALQuAAiELgAGNC4ABgvuAAV3LgAA9C4ABUQuAAF0LgAABC4ABLcuAAH0LgAABC4AAvQuAAAELgADdC4ABgQuAAc0LgAFRC4ACDQuAASELgAI9wAuAAKL7gAFi+4AA8vugAAAAIAZyswMQEXByEnNwUXEQYHJz0CNxYXEQcFFQcmJxE3NScRNjcXFQF8KCj+/CgoAUAUCigeHigKFP7AHigKFBQKKB4BkCgoKCgyFP7oKApQ0ozSUAoo/ugUUNJQCigBGBQKFAEYKApQ0gACAMgACgEYAtAABgANACe4AHgrugAFAAAAeyu4AAUQuAAI0LgAABC4AAzQALgAAi+4AAsvMDETNTcWFxEHFRcRBgcnNcgeKAoUFAooHgGu0lAKKP7oFAoU/ugoClDSAAAEACgAAAHMAtAABgAMABEAGABnuABkK7gAGS+4AAUvuAAC3LoABwAFAAIREjm4ABkQuAAN0LgADS+4AAvcuAAQ0LgABRC4ABLQuAACELgAFtC4AAIQuAAa3AC4ABQvugAFAAcAZyu4AAUQuAAL0LoADQAHAAUREjkwMQEXEQYHJzUTISYnNzMFETcXFQE1NxYXEQcBuBQKKB4K/tQoClDw/sAUPAEEHigKFAFeFP7oKApQ0v7eCigeCgEEFDy+AUrSUAoo/ugUAAUAKAAAAcwC0AAFAAwAEgAZACAAf7gAZCu4ACEvuAACL7gAANC4ACEQuAAX0LgAFy+4ABTcuAAD0LgAFBC4AAXQuAACELgAB9y4AAIQuAAL0LgAAhC4AA7QuAAHELgAENC4ABcQuAAb0LgAFBC4AB/QuAAHELgAItwAuAAOL7gAHi+4AAovuAAVL7oAAAACAGcrMDEBFwchJzcFFxEGByc1JzcyFwEjBxUHJicRNzUnETY3FxUBfCgo/vwoKAFAFAooHvDwPBT+/DwUHigKFBQKKB4BkCgoKCgyFP7oKApQ0r7wKP78gtJQCigBGBQUFAEYKApQ0gAAAwAoAAABzALQAAYADAATAD24AGQrugABAAQAZyu6AAwABAABERI5uAAEELgADtC4AAEQuAAS0AC4ABEvugABAAwAZyu4AAEQuAAI0DAxExUHJicRNxMzFwYHIQMnETY3FxV4HigKFFDwUAoo/tQyFAooHgEi0lAKKAEYFP7yHigKAXIUARgoClDSAAAGACgAAAHMAtAABAALABEAFgAdACQAu7gAZCu4ACUvuAAV0LgAFS+4AALcQQMAYAACAAFdQQMAwAACAAFduAAA3LgAAhC4AArcQQMAwAAKAAFdQQMAYAAKAAFduAAH3LgAFRC4ABPcuAAN0LgADS+4ABUQuAAO0LgADi+6ABEACgAHERI5uAAKELgAF9C4AAcQuAAb0LgAExC4AB7QuAAVELgAItC4AAcQuAAm3AC4AAkvuAAgL7oAEQAYAGcruAAYELgADdC6ABYAGAARERI5MDEBByc1MxMXEQYHJzUDIyc2NyEFFQcnEQU1NxYXEQcFFQcmJxE3ASIoKFCWFAooHhTvUAooASv+8jwUAVQeKAoU/sAeKAoUAYYoKOb+8hT+6CgKUNIBXh4oCmS+PBQBBNzSUAoo/ugUUNJQCigBGBQAAAAFACgAAAHMAsYABgAMABMAGgAhAF+4AGQruAAiL7gAEi+4ACIQuAAE0LgABC+4AAHcuAASELgAD9y4ABIQuAAU0LgADxC4ABjQuAAEELgAHNC4AAEQuAAg0LgADxC4ACPcALgAAi+4ABEvuAAWL7gAHy8wMRMVByYnETclIyc1Mx8CEQYHJz0CNxYXEQchJxE2NxcVeB4oChQBLEaWPKBQFAooHh4oChT+hBQKKB4BItJQCigBGBRGljygeBT+6CgKUNKC0lAKKP7oFBQBGCgKUNIAAAYAKAAAAcwC0AAFAAsAEQAXAB0AIwBTuABkK7gAJC+4AAYvuAAK3LgADdC4AAYQuAAQ0LgAJBC4ABPQuAATL7gAF9y4AB7QuAATELgAIdC4AAoQuAAl3AC6AB0AGQBnK7oABAAAAGcrMDEBIyc3MxcHNTcXFQcVFxUHJzUlJzU3FxUBByMnNzMnFQcnNTcBaNwoKNwoFB4yFBQyHv7AFDIeARgo3Cgo3PAeMhQCgCgoKPrSHjLmFBQU5jIe0lAU5jIe0v56KCgo0tIeMuYUAAAFACgAAAHMAtAABQALABAAFgAdAIW4AGQruAAeL7gAAC+4AALQuAAeELgAENC4ABAvuAAH3LgAA9C4AAcQuAAF0LgAEBC4AAnQuAAHELgADdC4AAAQuAAR0LgAABC4ABXcuAAHELgAF9C4ABAQuAAb0LgAFRC4AB/cALgAGS+6AAoABgBnK7oAAAACAGcrugAQAAYAChESOTAxARcHISc/ASMnNSEXBRUHJxEFNTcXFQcFFQcmJxE3AXwoKP78KCjw8FABQCj+6DwUAVQeMhT+wB4oChQBkCgoKCjwHjIoPL48FAEE3NIeMuYUUNJQCigBGBQABwAo//YB1gLQAAQACgAPABUAGgAhACcAq7gAZCu4ACgvuAADL7gAAty4ACgQuAAL0LgACy+6AAUACwACERI5uAAJ3LgADtC4AAkQuAAR0LgAES+4AAsQuAAS0LgAEi+6ABUAAwACERI5uAAJELgAFtC4AAsQuAAZ0LgAAxC4ABvQuAACELgAH9C4AAIQuAAp3AC4ACUvugAKAAUAZyu6ABUAHABnK7oACwAFAAoREjm4ABwQuAAR0LoAGgAcABUREjkwMQEXFSc1AyEmJzczBxE3FxUTIyc2NyEFFQcnEQU1NxYXEQ8BMxcVIycBuBRQCv7oKApQqvoUPPDvUAooASv+8jwUAVQeKAoUoDyCPIIBXhTwUHj+3gooHgoBBBQ8vgIcHigKZL48FAEE3NJQCij+6BS+gjyCAAAAAAYAKAAAAcwC0AAFAAsAEgAYAB8AJACvuABkK7gAJS+4AAAvuAAC0LgAJRC4ABDQuAAQL7gADdy4AAPQuAANELgABdC4AAAQuAAe3LgACNC4AAAQuAAK0LgADRC4ABTQuAAUL7gAEBC4ABXQuAAVL7oAGAAAAB4REjm4AAAQuAAZ0LgADRC4ACDQuAAQELgAI9C4AB4QuAAm3AC4AAovuAAOL7oAGAAaAGcrugAAAAIAZyu4ABoQuAAU0LoAJAAaABgREjkwMQEXByEnNxczAQYjLwEVByYnETcBIyc2NyEDNTcWFxEHJRUHJxEBfCgo/vwoKBQ8AQQUPPAUHigKFAEs71AKKAErCh4oChT+wDwUAZAoKCgoZP78KPAy0lAKKAEYFAEiHigK/t7SUAoo/ugU+r48FAEEAAUAKAAAAcwC0AAFAAwAEgAXAB8As7gAZCu4ACAvuAACL7gAANC4ACAQuAAQ0LgAEC+4ABHcuAAD0LgAERC4AAXQuAACELgAB9y4AAIQuAAL0LoADQACAAcREjm4ABEQuAAT0LgAEBC4ABbQuAARELgAGNC4ABgvuAAQELgAGdC4ABkvuAAHELgAHtC4AAIQuAAf0LgABxC4ACHcALoACwANAGcrugAbABgAZyu6AAAAAgBnK7gACxC4ABHQugAXABgAGxESOTAxARcHISc3BRcRBgcnNRMhJic3MwMVBycRFyc2NyEWFwcBfCgo/vwoKAFAFAooHgr+1CgKUPDwPBRRUAooAT8oClABkCgoKCgyFP7oKApQ0v7eCigeAhy+PBQBBAoeKAoKKB4AAAMAKQAAAcwC0AAGAAsAEwAruABkK7oAAgAFAGcruAAFELgAB9C4AAIQuAAJ0AC4AAQvugAPAAwAZyswMRMXEQYHJz0CMxUHAyc2NyEWFwf6KAooHlAogVAKKAE/KApQAV4o/vwoClDmZNLSKAEOHigKCigeAAAAAAUAKAAAAcwC0AAGAAwAEQAYAB8Ad7gAZCu4ACAvuAAFL7gAAty6AAcABQACERI5uAAgELgADdC4AA0vuAAL3LgAENC4AAUQuAAS0LgAAhC4ABbQuAANELgAGtC4AAsQuAAe0LgAAhC4ACHcALgAFC+6AAUABwBnK7gABRC4AAvQugANAAcABRESOTAxARcRBgcnNRMhJic3MwURNxcVATU3FhcRBwUnETY3FxUBuBQKKB4K/tQoClDw/sAUPAEEHigKFP6EFAooHgFeFP7oKApQ0v7eCigeCgEEFDy+AUrSUAoo/ugUChQBGCgKUNIAAAQAKAAAAcwCxgAGAA0AEwAZAHO4AGQruAAaL7gABy+4ABoQuAAB0LgAAS+4AAbcuAAHELgADNy6AA8AAQAMERI5uAABELgAENC4AAYQuAAT0LgABxC4ABTQuAAMELgAFtC6ABgAAQAMERI5uAAMELgAG9wAuAAEL7gACS+4AA8vuAAYLzAxEycRNjcXFSE1NxYXEQ8BFQM1NxchNxcVAzU8FAooHgEEHigKFMjIFDwBBDwUyAFoFAEYKApQ0tJQCij+6BTweAEEPBQ8PBQ8/vx4AAAABgAoAAABzALQAAQACwARABYAHQAkALu4AGQruAAlL7gAEtC4ABIvuAAB3EEDAGAAAQABXUEDAMAAAQABXbgAANy4AAEQuAAF3EEDAMAABQABXUEDAGAABQABXbgACty6AAwABQAKERI5uAASELgAD9C4AA8vuAASELgAFty4ABDQuAAQL7gAChC4ABjQuAAFELgAHNC4ABIQuAAf0LgAFhC4ACPQuAAKELgAJtwAuAAHL7gAIi+6ABwADABnK7gAHBC4ABDQugASAAwAHBESOTAxJSM1Nxc3NTcWFxEHAyEmJzczBRE3FxUlFxEGByc1JScRNjcXFQEiUCgoWh4oChQy/tUoClDv/sAUPAFAFAooHv7AFAooHmTmKChk0lAKKP7oFP6OCigeCgEEFDy++hT+6CgKUNJQFAEYKApQ0gAEACgAAAHMAtAABQALABEAFwA3uABkK7oACwARAGcruAALELgAANC4AAAvuAARELgAEtC4ABIvALgABC+4AA0vuAAHL7gAFi8wMQEzEwYjJz8BMhcDIw8BIicTMzcjAzYzFwEELZoUPHcBdzwUmi0WdzwUmi0BLZoUPHcBXv7KKPLs8ij+yoDyKAE2FAE2KPMAAAAABQAoAAABzALQAAUADAASABcAHgCJuABkK7gAHy+4AAAvuAAC0LgAHxC4ABDQuAAQL7gAEdy4AAPQuAARELgABdC4AAAQuAAd3LgAB9C4AAAQuAAL0LoADQAAAB0REjm4ABEQuAAT0LgAEBC4ABbQuAAAELgAGNC4AB0QuAAg3AC4ABovugALAA0AZyu6AAAAAgBnK7gACxC4ABHQMDEBFwchJzcFFxEGByc1EyEmJzczAxUHJxEFNTcWFxEHAXwoKP78KCgBQBQKKB4K/tQoClDw8DwUAVQeKAoUAZAoKCgoMhT+6CgKUNL+3gooHgI63DwUASL60lAKKP7oFAAAAAQAKAAAAcwC0AADAAkADwAVACe4AGQrALoAAwAAAGcrugAJAAQAZyu4AAkQuAAL0LgAABC4ABHQMDEpATczAyMnNjchAxMyFwMjFwMiJxMzAaT+6CjSRsdQCigBDW6CPBSWPAqMPBSgPFACMB4oCv7eASIo/spQ/t4oATYAAAAABQAeAAABaALQAAQACwAQABcAHQBLuABkK7oABAAAAGcruAAEELgADNC4AAAQuAAP0AC6ABcAEgBnK7oACgAFAGcrugAYABoAZyu6AAAAEgAXERI5ugAQAAUAChESOTAxNzU3FxUTIyc2NzMXBxUHJzUTByMmJzczAxcHIyc3ljwURkVQCiiLFIIUPNIUiygKUEWgKChGKChG3DwU5gIcHigKFFDmFDzc/YoUCigeAUAoKCgoAAAAAAEAKAAAAHgC0AAHABe4AGQrugAAAAMAZysAuAACL7gABS8wMTcGBycRNxYXeAooHh4oCjIoClACMFAKKAAAAAAFAFAAAAGaAtAABAALABAAFwAdAEu4AGQrugAEAAAAZyu4AAQQuAAM0LgAABC4AA/QALoAEgAVAGcrugAHAAoAZyu6ABgAGgBnK7oABAAVABIREjm6AAwACgAHERI5MDE3NTcXFQM3MxYXByM3FQcnNQMzFwYHIycBFwcjJzfSFDzSFIsoClBFljwURkVQCiiLFAEiKChGKChk5hQ83AJ2FAooHgrcPBTm/eQeKAoUAXwoKCgoAAAABQAeAUoB1gIcAAUACwARABcAHQA/uABkKwC4ABovuAASL7oAAAACAGcruAAAELgABtC4AAYvuAACELgACNC4AAgvuAAAELgADNC4AAIQuAAO0DAxARcHIyc3BxcHIyc3JRcHIyc3JxcHIyc3HwEHIyc3AQ4oKCgoKHgoKCgoKAFoKCgoKCjIKCgoKCjIKCgoKCgB4CgoKCgBKCgoKAEoKCgoPCgoKCiCKCgoKAAAAAAOAAD//wHqAtAABQALABEAFwAdACMAKQAvADUAOwBBAEcATQBTASm4AGQrugAcAAgAZyu6ACwAKABnK7oACwAIABwREjm4AAgQuAAQ0LoAFwAIABwREjm6ACMAKAAsERI5ugAvACgALBESObgALBC4ADTQugBKAAgAHBESObgASi+4ADrcugBBAAgAHBESObgAShC4AEbQugBHAAgAHBESOboATQBKADoREjm4ACwQuABV3AC4AAovuAAaL7gAJi+4AC4vuABAL7gARC+4AEAQuAA43LgAAdC6ABEAQAAKERI5ugAXAEAAChESOboAHQBAAAoREjm4ADgQuAAi0LoAIwBAAAoREjm6ACkAQAA4ERI5uABAELgAL9C4AC8vugA1AEAAOBESOboAOwBAADgREjm6AEcAQAA4ERI5uAA4ELgATNC6AE0AQAAKERI5MDETBwY/ATMnIyc2NzMHFQcmJzUXMxcGByM3NTcWFxUTIyc2NzMHFQcmJzUXMxcGByM3NTcWFxUlNTcWFxUnMxcGByM3FQcmJzUXIyc2NzMTNzYPASfloDwBvR6LClAKKEYoHigKZApQCihGKB4oCsgKUAooRiceKApjClAKKEYoHigK/soeKApaClAKKEYKHigKWgpQCihGMqA8Ab0eAY+fATy+lx4oCmQ8UAooeFoeKApkPFAKKHj+eh4oCmQ8UAooeFoeKApkPFAKKHgePFAKKHgJHigKjTxQCih4Ch4oCgEjnwE8vwEAAQDcAggBLALQAAQAF7gAZCu6AAAAAQBnKwC4AAAvuAADLzAxASM1NxcBLFAoKAIIoCgoAAEA3AIIASwC0AAEABe4AGQrugAAAAIAZysAuAABL7gAAy8wMQEHJzUzASwoKFACMCgooAACAIwCCAF8AtEABAAJADu4AGQruAAKL7gABi+4AAoQuAAB0LgAAS+4AADcuAAGELgABdy4AAvcALgAAy+4AAgvuAAAL7gABS8wMRMjNTcfASM1NxfcUCgooFAoKAIJoCgooaAoKAAAAAIAjAIIAX0C0QAEAAkAO7gAZCu4AAovuAAHL7gAChC4AALQuAACL7gAANy4AAcQuAAF3LgAC9wAuAADL7gACC+4AAEvuAAGLzAxEwcnNTMXByc1M9woKFChKChQAjAoKKCfKCigAAAAAQBkANwBhgH+AAsAD7gAZCsAuAAGL7gAAC8wMTciJjU0NjMyFhUUBvU8VVU8PFVV3FU8PFVVPDxVAAAAAQAeAUAB1gGQAAUAD7gAZCsAugAAAAIAZyswMQEXByEnNwGuKCj+mCgoAZAoKCgoAAAAAAEACgFAAeoBkAAFAA+4AGQrALoAAAACAGcrMDEBFwchJzcBwigo/nAoKAGQKCgoKAAAAAAHAAAAAAHgAtAABQALAA8AFwAdACMAKQCluABuK7oABAANAHErugAZACMAcSu6ABAAEwBxK7oAAAATABAREjm6AAsAEwAQERI5uAAEELgAD9C6AB0ADQAQERI5uAAZELgAH9C6ACkAIwAZERI5uAAQELgAK9wAugATAAAAcSu6AAsAFABxK7oAHQAYAHEruAATELgABNC4ABQQuAAH0LoADQAAABMREjm6AA4AFAALERI5ugAjABgAHRESOTAxKQEmJzchESEnNjchAQcRFwEGBycRNxYXByMnNjczBxUHJicRFzMXBgcjAZr+mCgKUAEs/tVQCigBZ/62UFABkAooHh4oCpaCUAoovqAeKApkPFAKKHgKKB4CMB4oCv2UHgJEHv3GKApQAjBQCii+HigKZNxQCigBGPoeKAoAAAB4AHgAeAB4ALgA7AHaApIDagQUBC4EcgS6BRYFUgVsBYYFngXABloGjgccB44H9giGCSgJlApMCvILHAtGC24Llgu+DEANCg2oDkYOmA8aD3wPzhBoEOAREBF0EfASNhLYE0ITqhQkFMIVXhX0FjAWqBcSF7IX/Bh8GLwZChksGYAZohm+GdYadBsSG2Qb5hxIHJodNB2sHdweQB68HwIfpCAOIHYg8CGOIioiwCL8I3Qj3iR+JMglSCWIJeQmBCZgJrgn1CfuKAgoPChwKI4oqCjCKWAAAAAgAYYAAAAAAAAAAACEAAAAAAAAAAAAAQASAIQAAAAAAAAAAgAIAJYAAAAAAAAAAwASAJ4AAAAAAAAABAASALAAAAAAAAAABQA2AMIAAAAAAAAADAAyAPgAAAAAAAAAEwAUASoAAQAAAAAAAABcAT4AAQAAAAAAAQAOAZoAAQAAAAAAAgAEAagAAQAAAAAAAwAOAawAAQAAAAAABAAOAboAAQAAAAAABQAZAcgAAQAAAAAABgANAeEAAQAAAAAACAAeAe4AAQAAAAAACQARAgwAAQAAAAAADAAZAh0AAQAAAAAADQBBAjYAAQAAAAAAEwAKAncAAwABBAkAAAC4AoEAAwABBAkAAQAcAzkAAwABBAkAAgAIA1UAAwABBAkAAwAcA10AAwABBAkABAAcA3kAAwABBAkABQAyA5UAAwABBAkABgAaA8cAAwABBAkACAA8A+EAAwABBAkACQAiBB0AAwABBAkADAAyBD8AAwABBAkADQCCBHEAAwABBAkAEwAUBPMAQwByAGUAYQB0AGUAZAAgAGIAeQAgAFMAaQB6AGUAbgBrAG8AIABBAGwAZQB4AGEAbgBkAGUAcgAuACAAqQAgADIAMAAwADgAIABTAHQAeQBsAGUALQA3AC4AIABBAGwAbAAgAHIAaQBnAGgAdABzACAAcgBlAHMAZQByAHYAZQBkAC4ARABpAGcAaQB0AGEAbAAtADcATQBvAG4AbwBEAGkAZwBpAHQAYQBsAC0ANwBEAGkAZwBpAHQAYQBsAC0ANwBWACAAMQAuADAAMAAgAE8AYwB0ACAAMAAyACAAMQAzADoAMgA0ADoAMAAwACAAMgAwADAAOABoAHQAdABwADoALwAvAHcAdwB3AC4AcwB0AHkAbABlAHMAZQB2AGUAbgAuAGMAbwBtADAAMQAyADMANAA1ADYANwA4ADlDcmVhdGVkIGJ5IFNpemVua28gQWxleGFuZGVyLiCpIDIwMDggU3R5bGUtNy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gaHR0cDovL3d3dy5zdHlsZXNldmVuLmNvbURpZ2l0YWwtNyBNb25vTW9ub0RpZ2l0YWwtNyBNb25vRGlnaXRhbC03IE1vbm8xLjAyIEFwciAwNyAxMjoxNTowMCAyMDExRGlnaXRhbC03TW9ub0NyZWF0ZWQgYnkgU2l6ZW5rbyBBbGV4YW5kZXIuIFNpemVua28gQWxleGFuZGVyaHR0cDovL3d3dy5zdHlsZXNldmVuLmNvbUZyZWV3YXJlIGZvciBwZXJzb25hbCB1c2UuDQpGb3IgY29tbWVyY2lhbCB1c2UgcGxlYXNlIGNvbnR1Y3QgdXMuMDEyMzQ1Njc4OQBDAHIAZQBhAHQAZQBkACAAYgB5ACAAUwBpAHoAZQBuAGsAbwAgAEEAbABlAHgAYQBuAGQAZQByAC4AIACpACAAMgAwADAAOAAgAFMAdAB5AGwAZQAtADcALgAgAEEAbABsACAAcgBpAGcAaAB0AHMAIAByAGUAcwBlAHIAdgBlAGQALgAgAGgAdAB0AHAAOgAvAC8AdwB3AHcALgBzAHQAeQBsAGUAcwBlAHYAZQBuAC4AYwBvAG0ARABpAGcAaQB0AGEAbAAtADcAIABNAG8AbgBvAE0AbwBuAG8ARABpAGcAaQB0AGEAbAAtADcAIABNAG8AbgBvAEQAaQBnAGkAdABhAGwALQA3ACAATQBvAG4AbwAxAC4AMAAyACAAQQBwAHIAIAAwADcAIAAxADIAOgAxADUAOgAwADAAIAAyADAAMQAxAEQAaQBnAGkAdABhAGwALQA3AE0AbwBuAG8AQwByAGUAYQB0AGUAZAAgAGIAeQAgAFMAaQB6AGUAbgBrAG8AIABBAGwAZQB4AGEAbgBkAGUAcgAuACAAUwBpAHoAZQBuAGsAbwAgAEEAbABlAHgAYQBuAGQAZQByAGgAdAB0AHAAOgAvAC8AdwB3AHcALgBzAHQAeQBsAGUAcwBlAHYAZQBuAC4AYwBvAG0ARgByAGUAZQB3AGEAcgBlACAAZgBvAHIAIABwAGUAcgBzAG8AbgBhAGwAIAB1AHMAZQAuAA0ACgBGAG8AcgAgAGMAbwBtAG0AZQByAGMAaQBhAGwAIAB1AHMAZQAgAHAAbABlAGEAcwBlACAAYwBvAG4AdAB1AGMAdAAgAHUAcwAuADAAMQAyADMANAA1ADYANwA4ADkAAAAAAgAAAAAAAP+IAEYAAAAAAAAAAAAAAAAAAAAAAAAAAABrAAABAgACAAMABAAFAAYABwAIAAkACgALAAwADQAOAA8AEAARABIAEwAUABUAFgAXABgAGQAaABsAHAAdAB4AHwAgACEAIgAjACQAJQAmACcAKAApACoAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAOgA7ADwAPQA+AD8AQABBAEIAQwBEAEUARgBHAEgASQBKAEsATABNAE4ATwBQAFEAUgBTAFQAVQBWAFcAWABZAFoAWwBcAF0AXgBfAGAAYQDGALYAtwC0ALUAhwCyALMAiwROVUxMAAAAAAAAAwAIAAIAEAAB//8AAwABAAAAAAAAAQQCvAAAbxwCvAE1RGlnaXRhbC03ICAgICAgIAAAAAAAAAAARGlnaXRhAAABAAAA";

  // node_modules/cookies-ds/dist/components/padlock-screen/index.js
  var __awaiter3 = function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var templateNode5 = document.createElement("template");
  templateNode5.innerHTML = template_default5;
  var PadlockScreen = class extends HTMLElement {
    static get observedAttributes() {
      return ["release-timestamp"];
    }
    connectedCallback() {
      return __awaiter3(this, void 0, void 0, function* () {
        const font = new FontFace("digital", `url('${digital_default}')`);
        yield font.load();
        document.fonts.add(font);
        this.attachShadow({ mode: "open" });
        const shadowRoot = getShadowRoot(this);
        shadowRoot.appendChild(templateNode5.content.cloneNode(true));
        this.render();
      });
    }
    render() {
      const [canvas, canvasContext] = createCanvasAndContext();
      canvasContext.font = "44px digital";
      const [releaseDateLabel, releaseHoursLabel] = getReleaseDateLabels(this);
      canvasContext.fillText(releaseDateLabel, 48, 78);
      canvasContext.fillText(releaseHoursLabel, 68, 132);
      const shadowRoot = getShadowRoot(this);
      const releaseDate = getElement(shadowRoot, "#release-date");
      const dataUrl = canvas.toDataURL();
      releaseDate.style.backgroundImage = `url("${dataUrl}")`;
    }
    attributeChangedCallback() {
      if (this.shadowRoot) {
        this.render();
      }
    }
  };
  function getReleaseDateLabels(padlockScreen) {
    const releaseTimestampString = padlockScreen.getAttribute("release-timestamp");
    if (releaseTimestampString === null) {
      throw new Error("release-timestamp attribute is required !");
    }
    const releaseTimestamp = Number(releaseTimestampString);
    if (Number.isInteger(releaseTimestamp) === false) {
      throw new Error("release-timestamp attribute is not an integer !");
    }
    const releaseDate = new Date(releaseTimestamp);
    const [date, hours] = releaseDate.toLocaleString("fr-FR", { dateStyle: "short", timeStyle: "medium" }).split(" ");
    return [date, hours];
  }
  function createCanvasAndContext() {
    const canvas = document.createElement("canvas");
    const canvasContext = canvas.getContext("2d");
    if (canvasContext === null) {
      throw new Error("Failed to get canvas context");
    }
    return [canvas, canvasContext];
  }

  // node_modules/cookies-ds/dist/components/background/template.js
  var template_default6 = '<style>\n	:host {\n		display: block;\n	}\n\n	#background {\n		width: 100%;\n		height: 100%;\n		display: block;\n		opacity: 0;\n		transition: opacity 1s cubic-bezier(.08,.82,.17,1);\n		transition-delay: .2s;\n	}\n</style>\n\n<canvas id="background"></canvas>\n';

  // node_modules/cookies-ds/dist/components/background/img/cookie.js
  var cookie_default = "data:image/png;base64,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";

  // node_modules/cookies-ds/node_modules/async-mutex/index.mjs
  var E_TIMEOUT = new Error("timeout while waiting for mutex to become available");
  var E_ALREADY_LOCKED = new Error("mutex already locked");
  var E_CANCELED = new Error("request for lock canceled");
  var __awaiter$2 = function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var Semaphore = class {
    constructor(_value, _cancelError = E_CANCELED) {
      this._value = _value;
      this._cancelError = _cancelError;
      this._weightedQueues = [];
      this._weightedWaiters = [];
    }
    acquire(weight = 1) {
      if (weight <= 0)
        throw new Error(`invalid weight ${weight}: must be positive`);
      return new Promise((resolve, reject) => {
        if (!this._weightedQueues[weight - 1])
          this._weightedQueues[weight - 1] = [];
        this._weightedQueues[weight - 1].push({ resolve, reject });
        this._dispatch();
      });
    }
    runExclusive(callback, weight = 1) {
      return __awaiter$2(this, void 0, void 0, function* () {
        const [value, release] = yield this.acquire(weight);
        try {
          return yield callback(value);
        } finally {
          release();
        }
      });
    }
    waitForUnlock(weight = 1) {
      if (weight <= 0)
        throw new Error(`invalid weight ${weight}: must be positive`);
      return new Promise((resolve) => {
        if (!this._weightedWaiters[weight - 1])
          this._weightedWaiters[weight - 1] = [];
        this._weightedWaiters[weight - 1].push(resolve);
        this._dispatch();
      });
    }
    isLocked() {
      return this._value <= 0;
    }
    getValue() {
      return this._value;
    }
    setValue(value) {
      this._value = value;
      this._dispatch();
    }
    release(weight = 1) {
      if (weight <= 0)
        throw new Error(`invalid weight ${weight}: must be positive`);
      this._value += weight;
      this._dispatch();
    }
    cancel() {
      this._weightedQueues.forEach((queue) => queue.forEach((entry) => entry.reject(this._cancelError)));
      this._weightedQueues = [];
    }
    _dispatch() {
      var _a;
      for (let weight = this._value; weight > 0; weight--) {
        const queueEntry = (_a = this._weightedQueues[weight - 1]) === null || _a === void 0 ? void 0 : _a.shift();
        if (!queueEntry)
          continue;
        const previousValue = this._value;
        const previousWeight = weight;
        this._value -= weight;
        weight = this._value + 1;
        queueEntry.resolve([previousValue, this._newReleaser(previousWeight)]);
      }
      this._drainUnlockWaiters();
    }
    _newReleaser(weight) {
      let called = false;
      return () => {
        if (called)
          return;
        called = true;
        this.release(weight);
      };
    }
    _drainUnlockWaiters() {
      for (let weight = this._value; weight > 0; weight--) {
        if (!this._weightedWaiters[weight - 1])
          continue;
        this._weightedWaiters[weight - 1].forEach((waiter) => waiter());
        this._weightedWaiters[weight - 1] = [];
      }
    }
  };
  var __awaiter$1 = function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var Mutex = class {
    constructor(cancelError) {
      this._semaphore = new Semaphore(1, cancelError);
    }
    acquire() {
      return __awaiter$1(this, void 0, void 0, function* () {
        const [, releaser] = yield this._semaphore.acquire();
        return releaser;
      });
    }
    runExclusive(callback) {
      return this._semaphore.runExclusive(() => callback());
    }
    isLocked() {
      return this._semaphore.isLocked();
    }
    waitForUnlock() {
      return this._semaphore.waitForUnlock();
    }
    release() {
      if (this._semaphore.isLocked())
        this._semaphore.release();
    }
    cancel() {
      return this._semaphore.cancel();
    }
  };

  // node_modules/cookies-ds/dist/utils/animation-lock.js
  var __awaiter4 = function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var animationLock = new Mutex();
  function acquireAnimationLock() {
    return __awaiter4(this, void 0, void 0, function* () {
      const release = yield animationLock.acquire();
      return function releaseAnimationLock() {
        release();
      };
    });
  }

  // node_modules/cookies-ds/dist/colors.js
  var primary = { "600": "#0084ff", "900": "#1e3eb9" };
  var complementary = { "900": "#ff7b00" };
  var analogousA = { "200": "#00dee6" };
  var analogousB = { "700": "#0004ff" };
  var triadicA = { "500": "#7b00ff", "800": "#4700ec" };
  var triadicB = { "400": "#ff0084" };
  var primaryColor = primary["600"];
  var secondaryColor = complementary["900"];
  var tertiaryColor = analogousA["200"];
  var quaternaryColor = analogousB["700"];
  var quinaryColor = triadicA["500"];
  var senaryColor = triadicB["400"];
  var primaryDarker = primary["900"];
  var quinaryDarker = triadicA["800"];
  var linkColor = primaryDarker;
  var linkVisitedColor = quinaryDarker;

  // node_modules/cookies-ds/dist/components/background/index.js
  var __awaiter5 = function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var templateNode6 = document.createElement("template");
  templateNode6.innerHTML = template_default6;
  var Background = class extends HTMLElement {
    constructor() {
      super(...arguments);
      this.waitCookieImage = initCookieImage();
      this.cookies = [];
      this.canvasSizeSubscription = null;
      this.cookiesSubscription = null;
    }
    connectedCallback() {
      return __awaiter5(this, void 0, void 0, function* () {
        this.attachShadow({ mode: "open" });
        const shadowRoot = getShadowRoot(this);
        const release = yield acquireAnimationLock();
        shadowRoot.appendChild(templateNode6.content.cloneNode(true));
        setTimeout(() => {
          const canvas = getBackgroundCanvas(this);
          canvas.style.opacity = "1";
          setTimeout(release, 800);
        }, 1);
        this.canvasSizeSubscription = observeCanvasSize(this).subscribe(() => {
          const canvas = getBackgroundCanvas(this);
          const { width, height } = canvas.getBoundingClientRect();
          canvas.setAttribute("width", `${width}`);
          canvas.setAttribute("height", `${height - 10}`);
        });
        this.cookiesSubscription = observeCookies(this).subscribe((cookies) => {
          this.cookies = cookies;
          this.render().catch(console.error);
        });
        yield this.render();
      });
    }
    render() {
      return __awaiter5(this, void 0, void 0, function* () {
        const cookieImage = yield this.waitCookieImage;
        const canvas = getBackgroundCanvas(this);
        const ctx = getCanvasContext(this);
        ctx.fillStyle = primaryColor;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        for (const cookie of this.cookies) {
          ctx.save();
          ctx.translate(cookie.x, cookie.y);
          ctx.rotate(cookie.rotation * Math.PI / 180);
          ctx.drawImage(cookieImage, 0, 0);
          ctx.restore();
        }
      });
    }
    attributeChangedCallback() {
      if (this.shadowRoot) {
        this.render().catch(console.error);
      }
    }
    disconnectedCallback() {
      var _a, _b;
      (_a = this.canvasSizeSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
      (_b = this.cookiesSubscription) === null || _b === void 0 ? void 0 : _b.unsubscribe();
    }
  };
  function observeCanvasSize(background) {
    return new Observable5(function(subscriber) {
      const backgroundCanvas = getBackgroundCanvas(background);
      new ResizeObserver(function() {
        const canvas = getBackgroundCanvas(background);
        const { width, height } = canvas.getBoundingClientRect();
        subscriber.next([width, height]);
      }).observe(backgroundCanvas);
    });
  }
  function createCookie(width, height) {
    return {
      x: Math.floor(Math.random() * width),
      y: Math.floor(Math.random() * height),
      rotation: Math.floor(Math.random() * 360),
      clockwiseRotation: Math.random() > 0.5
    };
  }
  function ajustCookiesQuantiy(cookiesInitial, width, height) {
    let cookies = [...cookiesInitial];
    const numberOfCookies = Math.ceil(width * height / (500 * 500));
    while (cookies.length < numberOfCookies) {
      cookies = [...cookies, createCookie(width, height)];
    }
    cookies = cookies.splice(0, numberOfCookies);
    return cookies;
  }
  function observeCookies(background) {
    let cookies = [];
    return combineLatest2(observeCanvasSize(background).pipe(tap2(function([width, height]) {
      cookies = ajustCookiesQuantiy(cookies, width, height);
    })), interval(200)).pipe(map2(function() {
      return cookies = cookies.map(function(cookie) {
        const rotation = cookie.rotation + (cookie.clockwiseRotation ? 0.01 : -0.01);
        const newCookie = Object.assign(Object.assign({}, cookie), { rotation });
        return newCookie;
      });
    }));
  }
  function initCookieImage() {
    return new Promise(function(resolve, reject) {
      const image = new Image();
      const timeout = setTimeout(reject, 1e4, new Error("Timed out while to load image !"));
      image.addEventListener("load", function() {
        resolve(image);
        clearTimeout(timeout);
      });
      image.src = cookie_default;
    });
  }
  function getBackgroundCanvas(background) {
    const shadowRoot = getShadowRoot(background);
    const canvas = shadowRoot.querySelector("#background");
    if (canvas === null) {
      throw new Error("Background not found !");
    }
    if (canvas.tagName !== "CANVAS") {
      throw new Error("Element is not a canvas !");
    }
    return canvas;
  }
  function getCanvasContext(background) {
    const canvas = getBackgroundCanvas(background);
    const ctx = canvas.getContext("2d");
    if (ctx === null) {
      throw new Error("Failed to get context !");
    }
    return ctx;
  }

  // node_modules/cookies-ds/dist/components/panel/template.js
  var template_default7 = '<style>\n	:host {\n		display: block;\n	}\n\n	#panel-container {\n		display: grid;\n		grid-column-gap: 0px;\n		grid-row-gap: 0px;\n		transition: grid-template-columns .5s cubic-bezier(.12,1.03,.11,.99), grid-template-rows .5s cubic-bezier(.12,1.03,.11,.99);\n		height: 100%;\n	}\n\n	#panel {\n		border-radius: 0.3rem;\n		padding: 1.7rem;\n		grid-area: 2 / 2 / 3 / 3;\n		background-color: #ffffff00;\n		box-shadow: 0px 0px 9px 5px rgba(28, 44, 83, 0.04);\n		transition: background-color .5s cubic-bezier(.12,1.03,.11,.99);\n		color: black;\n		overflow: auto;\n		position: relative;\n	}\n\n	#panel-title-container {\n		grid-area: 2 / 2 / 3 / 3;\n		z-index: 0;\n	}\n\n	#panel-content {\n		visibility: collapse;\n		transition: opacity 1s cubic-bezier(.12,1.03,.11,.99);\n		overflow: hidden;\n		z-index: 1;\n		position: relative;\n	}\n\n	#panel-loading-container {\n		grid-area: 2 / 2 / 3 / 3;\n		overflow: hidden;\n		backdrop-filter: blur(0.3rem);\n	}\n\n	#panel-title {\n		background: linear-gradient(0deg, rgba(255, 255, 255, 0.46) 0%, rgba(255, 255, 255, 0.44) 100%);\n		display: inline-block;\n		border-radius: 0.3rem;\n		padding-left: 1rem;\n		padding-right: 1rem;\n		opacity: 0;\n		transition-duration: 0.2s;\n		transition-timing-function: cubic-bezier(.12,1.03,.11,.99);\n		transition-delay: 0.4s;\n		transition-property: opacity;\n	}\n\n	#panel-loading {\n		border-radius: 0.3rem;\n		width: 75%;\n		height: 100%;\n		background-color: #ffffff55;\n		box-shadow: 0px 0px 9px 5px rgba(28, 44, 83, 0.04);\n\n		transition-duration: 1s;\n		transition-timing-function: cubic-bezier(.17,.84,.44,1);\n		transition-delay: 0s;\n		transition-property: width, background-color;\n\n		color: black;\n		overflow: auto;\n\n		position: relative;\n	}\n\n	* {\n		scrollbar-width: auto;\n		scrollbar-color: #ffffff90 #ffffff00;\n	}\n\n	*::-webkit-scrollbar {\n		width: 8px;\n	}\n\n	*::-webkit-scrollbar-track {\n		background: #ffffff00;\n	}\n\n	*::-webkit-scrollbar-thumb {\n		background-color: #ffffff90;\n		border-radius: 10px;\n		border: 3px solid #ffffff00;\n	}\n</style>\n\n<div id="panel-container" style="grid-template-columns: 20% 1fr 20%; grid-template-rows: 1rem 1fr 40%;">\n	<div id="panel-loading-container">\n		<div id="panel-loading"></div>\n	</div>\n\n	<div id="panel">\n		<div id="panel-content" style="opacity: 0;">\n			<slot></slot>\n		</div>\n	</div>\n\n	<div id="panel-title-container">\n		<div id="panel-title">\n			<cookies-p style="line-height: 0;">\n				<b id="panel-title-content"> </b>\n			</cookies-p>\n		</div>\n	</div>\n</div>\n';

  // node_modules/cookies-ds/dist/utils/app-ready.js
  var __awaiter6 = function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function isWindowVisible() {
    return !document.hidden;
  }
  function visibleAndFocusedObservable() {
    const visibilityChange$ = fromEvent(document, "visibilitychange");
    const focus$ = fromEvent(window, "focus").pipe(mapTo(true));
    const blur$ = fromEvent(window, "blur").pipe(mapTo(false));
    const focused$ = merge2(focus$, blur$);
    return combineLatest2(visibilityChange$, focused$).pipe(map2(([, focused]) => isWindowVisible() && focused), filter((visible) => visible), first());
  }
  var mouseOverDocument$ = fromEvent(document, "mouseover");
  function waitVisible() {
    return __awaiter6(this, void 0, void 0, function* () {
      if (isWindowVisible()) {
        return;
      }
      yield Promise.race([
        visibleAndFocusedObservable().toPromise(),
        mouseOverDocument$.toPromise()
      ]);
    });
  }
  function waitAppReady() {
    return __awaiter6(this, void 0, void 0, function* () {
      yield new Promise((r2) => setTimeout(r2, 400));
      yield waitVisible();
      yield new Promise((r2) => setTimeout(r2, 400));
    });
  }
  var appReady = waitAppReady();

  // node_modules/cookies-ds/dist/components/panel/index.js
  var __awaiter7 = function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var templateNode7 = document.createElement("template");
  templateNode7.innerHTML = template_default7;
  var Panel = class extends HTMLElement {
    constructor() {
      super(...arguments);
      this.contentTimeoutElapsed = false;
      this.contentLoaded = false;
      this.connected = false;
      this.loading = "100";
      this.scrolled = false;
      this.scrolledSubscription = null;
    }
    static get observedAttributes() {
      return ["loading", "panel-title"];
    }
    connectedCallback() {
      return __awaiter7(this, void 0, void 0, function* () {
        this.attachShadow({ mode: "open" });
        yield appReady;
        const release = yield acquireAnimationLock();
        const shadowRoot = getShadowRoot(this);
        shadowRoot.appendChild(templateNode7.content.cloneNode(true));
        const loading = this.getAttribute("loading");
        if (loading !== null && isLoadingValid(loading)) {
          this.loading = loading;
        }
        setTimeout(() => {
          const panelContainer = getElement(shadowRoot, "#panel-container");
          panelContainer.style.gridTemplateColumns = "1rem 1fr 1rem";
          panelContainer.style.gridTemplateRows = "1rem 1fr 1rem";
          const panel = getElement(shadowRoot, "#panel");
          panel.style.backgroundColor = "#ffffff40";
          this.scrolledSubscription = fromEvent(panel, "scroll").pipe(
            map2((e2) => e2.target.scrollTop),
            // startWith(0),
            map2((scrollTop) => scrollTop !== 0)
            // distinctUntilChanged()
          ).subscribe((value) => {
            this.scrolled = value;
            this.render();
          });
          this.render();
        }, 10);
        setTimeout(() => {
          this.contentTimeoutElapsed = true;
          this.render();
        }, 400);
        setTimeout(release, 600);
        this.connected = true;
        this.render();
      });
    }
    render() {
      const shadowRoot = getShadowRoot(this);
      const panelContent = getElement(shadowRoot, "#panel-content");
      const panelLoading = getElement(shadowRoot, "#panel-loading");
      const panel = getElement(shadowRoot, "#panel");
      const panelTitleContent = getElement(shadowRoot, "#panel-title-content");
      if (this.contentTimeoutElapsed && isLoaded(this.loading)) {
        panelContent.style.visibility = "visible";
        panelContent.style.opacity = "1";
        panel.style.overflow = "auto";
      } else {
        panelContent.style.visibility = "collapse";
        panelContent.style.opacity = "0";
        panel.style.overflow = "hidden";
      }
      panelLoading.style.width = `${this.loading}%`;
      const panelTitle = getElement(shadowRoot, "#panel-title");
      if (this.loading === "100" && this.getAttribute("panel-title") && !this.scrolled) {
        setTimeout(() => {
          panelTitle.style.opacity = "1";
          panelTitleContent.innerHTML = this.getAttribute("panel-title") || "";
          panelContent.style.paddingTop = "2.5rem";
        }, 10);
      } else {
        panelContent.style.paddingTop = "inherit";
        panelTitle.style.opacity = "0";
      }
    }
    attributeChangedCallback() {
      if (this.shadowRoot && this.connected) {
        const loading = this.getAttribute("loading");
        if (loading !== null && isLoadingValid(loading)) {
          this.loading = loading;
        } else if (loading === null) {
          this.loading = "100";
        }
        this.render();
      }
    }
    disconnectedCallback() {
      var _a;
      (_a = this.scrolledSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
    }
  };
  function isLoadingValid(loading) {
    const loadingAsNumber = Number(loading);
    const rounded = Math.floor(loadingAsNumber);
    return rounded == loadingAsNumber && Number.isInteger(rounded) && Number.isFinite(rounded) && rounded <= 100 && rounded >= 0;
  }
  function isLoaded(loading) {
    return loading === null || loading === "100";
  }

  // node_modules/cookies-ds/dist/components/p/template.js
  var template_default8 = "<style>\n	:host {\n		display: block;\n	}\n\n	p {\n		font-family: ds-notes-sans;\n		font-size: 1rem;\n		color: black;\n	}\n\n	@media screen and (min-width: 800px) {\n		p {\n			font-size: 1.4rem;\n		}\n	}\n</style>\n\n<p>\n	<slot></slot>\n</p>\n";

  // node_modules/cookies-ds/dist/fonts/notes-sans.js
  var notes_sans_default = "data:font/otf;base64,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dGVDY2lyY3VtZmxleGNjaXJjdW1mbGV4Q2RvdGFjY2VudGNkb3RhY2NlbnRDY2Fyb25jY2Fyb25EY2Fyb25kY2Fyb25EY3JvYXRkY3JvYXRFbWFjcm9uZW1hY3JvbkVicmV2ZWVicmV2ZUVkb3RhY2NlbnRlZG90YWNjZW50RW9nb25la2VvZ29uZWtTY2lyY3VtZmxleHNjaXJjdW1mbGV4VGNhcm9udGNhcm9uVGJhcnRiYXJVdGlsZGV1dGlsZGVVbWFjcm9udW1hY3JvblVicmV2ZXVicmV2ZVVyaW5ndXJpbmdVaHVuZ2FydW1sYXV0dWh1bmdhcnVtbGF1dFVvZ29uZWt1b2dvbmVrV2NpcmN1bWZsZXh3Y2lyY3VtZmxleFljaXJjdW1mbGV4eWNpcmN1bWZsZXhaYWN1dGV6YWN1dGVaZG90YWNjZW50emRvdGFjY2VudHVuaTAxOEZ1bmkwMUM3dW5pMDFDRHVuaTAxQ0V1bmkwMUNGdW5pMDFEMHVuaTAxRDF1bmkwMUQydW5pMDFEM3VuaTAxRDR1bmkwMUUydW5pMDFFM0djYXJvbmdjYXJvbnVuaTAxRTh1bmkwMUU5dW5pMDFGMHVuaTAxRjR1bmkwMUY1QUVhY3V0ZWFlYWN1dGV1bmkwMjE4dW5pMDIxOXVuaTAyMUF1bmkwMjFCdW5pMDIxRXVuaTAyMUZ1bmkwMjI2dW5pMDIyN3VuaTAyMjh1bmkwMjI5dW5pMDIzMnVuaTAyMzN1bmkwMjM3dW5pMDI1OXVuaTAyQzh1bmkwMkM5dW5pMDJDQXVuaTAyQ0JncmF2ZWNvbWJhY3V0ZWNvbWJ1bmkwMzAydGlsZGVjb21idW5pMDMwNHVuaTAzMDZ1bmkwMzA3dW5pMDMwOHVuaTAzMEF1bmkwMzBCdW5pMDMwQ3VuaTAzMER1bmkwMzE1dW5pMDMyNnVuaTAzMjd1bmkwMzI4dW5pMDNBOXVuaTAzQkNwaUV1cm91bmkyMEJBdW5pMjBCRHVuaTIxMTNlc3RpbWF0ZWRwYXJ0aWFsZGlmZkRlbHRhcHJvZHVjdHN1bW1hdGlvbnVuaTIyMTV1bmkyMjE5cmFkaWNhbGluZmluaXR5aW50ZWdyYWxhcHByb3hlcXVhbG5vdGVxdWFsbGVzc2VxdWFsZ3JlYXRlcmVxdWFsbG96ZW5nZXVuaUZCMDB1bmlGQjAxdW5pRkIwMnVuaUZCMDN1bmlGQjA0YS5zYWx0Zy5zYWx0eS5zYWx0YS5zczAxdi5zczAxeS5zczAyQS5zczAySC5zczAySi5zczAySy5zczAyTC5zczAyTS5zczAyTi5zczAyUS5zczAyUi5zczAyWi5zczAyYy5zczAxZS5zczAxZi5zczAxdC5zczAxY190c190Y19oY19reS5zczAxYi5zczAxSi5zczAxdC5zYWx0cy5zczAxci5zczAxMi4wQ29weXJpZ2h0IChjKSAyMDIxLiBLbGVmb250LiAKQWxsIFJpZ2h0cyBSZXNlcnZlZE5vdGVzIFNhbnNOb3RlcyBTYW5zAAAAAAEAAgADAAQABQAGAAcAaAAJAAoACwAMAA0ADgAPABAAEQASABMAFAAVABYAFwAYABkAGgAbABwAHQAeAB8AIAAhACIAIwAkACUAJgAnACgAKQAqACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5ADoAOwA8AD0APgA/AEAAfABCAEMARABFAEYARwBIAEkASgBLAEwATQBOAE8AUABRAFIAUwBUAFUAVgBXAFgAWQBaAFsAXABdAF4AXwBgAGEAYgBnAGQAoABmAIMAqgCLAGoAlwGHAKUAgAChAJwBiAGJAH0AmABzAHIAhQGKAI8AeACeAJsAowB7AKgAjQDEAMEAwgDDAMUAnQCVAMsAyADJAM0AygDMAJAAzgDSAM8A0ADRANYA0wDUANUApwDXANsA2ADZANwA2gCfAJMA4gCiAOMBiwGMAY0BjgGPAZABkQGSAZMBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgDAAN0BpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AbgBuQG6AMYBuwG8Ab0BvgDHAOQBvwBlAcABwQHCAcMBxAHFAcYBxwHIAckBygHLAcwBzQHOAc8B0AHRAdIB0wHUAdUB1gHXAdgB2QHaAdsB3AHdAd4B3wHgAeEAfgCIAeIB4wHkAeUAgQCCAIQAhwB/AIYB5gHnAegB6QHqAesB7AHtAe4B7wHwAfEB8gHzAfQB9QH2AfcB+ABvAIkAQQAIAHUAaQB3AHYAcABxAHQAeQB6AGsAbABjAfkB+gH7AfwAmQH9Af4B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AA0AowCjAA0ApACkABMApQClAAEApgCmABMApwCnAAEAqACoABMAqQCpAAEAqwCrAAIArQCtAAIArwCvAAIAsQCxAAIAtwC3AAMAuQC5AAMAuwC7AAMAvQC9AAMAvwC/AAoAwgDCABAAxADEABAAxwDHAAsAyQDJAAsAywDLAAsAzQDNAAsAzwDPAAsA0QDRAAsA0gDSABUA0wDTAAwA1ADUABYA1QDVAA0A1gDWABYA4QDhAAEA5ADkABcA5QDlAAgA8gDyAAEA9AD0AAoA/QD9ABYA/gD+AA0BJAEkAA4BJwEnAA4BRQFHABIBSwFLAAQBTAFMAA0AAQA0ABAAIgAsAC0AMQA0ADUANwA4ADoARABHAEgAUABSAFMAVACFAI8AmgCbAJwAnQCeAKQApgCoAKsArQCvALEAvgC/AMAAwQDCANIA1ADWAOAA5QDrAPAA8wD0APUA/QFFAU0BWgFbAV0AAAABAAAAANXtRbgAAAAA21lSRgAAAADdxAxUAfQAAADcAAAA0QA7AR0AIAKFADICRAA+Ao4ALwKFAD4AgwAiASQAMQEkACEBQAAoAf8AKQCYAAoBTwAqAKkAIwH0AAoCSgAyATkAMgIMADICCwAtAh8AHgIeADICKQAyAfEAIwH6ADICGAA8ALcAKwDdACoCDwAgAe4ANwIPACAB7QA3AwsAMgIqABQCUABBAk4ANwKGAEsCQgBGAgwARgJvADwCiABLAP4AUAGvAAoCOABQAfwAUAMjAFACngBQAokANwIlAEYCkQA3Ak8ARgIeADcCIgAKAl0ARgI8ABkDBgAeAlEAFAIWABkCIwAoAUAARgHdAAoBSgAeAaAAKgG3ADAA+AAxAiUALQIKAEYB4wAtAjMALQHKAC0BowAZAgoALQIZAEYA8QBBAQn/gwHyAEYBFQBGAvcAQQIaAEEB9wAtAgsAQQIQAC0BhgA8AaUAMgF9ABkCLgBBAfkALQLFAEEB7AAeAgcAQQHWACMBfwAoALsAPAF/AB4BtQApAMoAOAHsADcCBQA4Ah4AKAIbADEAtwA5AgcARgEhABoC/gBAAXUAHgGuACgCFAAUAXMARgIwACsBcwAtASUAIQIAACsBOwAsAToAJgD4ADECFgA8AeUAIgC0ACgAtgAPAOkALQGoADMBrgAjAkYAMgJfADICYAAyAe4ASAHbACgCjQA3Al0ARgJdAEYCXQBGAl0ARgIWABkCOwBLAjYASwIlAC0CJQAtAiUALQIlAC0CJQAtAiUALQLxAC0BuwAoAcoALQHKAC0BygAtAcoALQC6//EAugA3ALr/6wC6/+8B7AAyAhoAQQH3AC0B9wAtAfcALQH3AC0B9wAtAgYAKAHyADICBwBBAfwALQIHAEECKgAUAiUALQIqABQCJQAtAiAAFAIdAC0CTgA3AeMALQJOADcB4wAtAk4ANwHjAC0CTgA3AeMALQKGAEsCKQAtAoYALQIcAC0CQgBGAcoALQJCAEYBygAtAkIARgHKAC0CHgA5AcUAMAIeADcBpQAyAh4ANwGlADICIgAKAXMAGQI2ABQBcwAUAl0ARgIuAEECXQBGAi4AQQJdAEYCLgBBAl0ARgIuAEECXQBGAi4AQQJdAEYCHwA8AwYAHgLFAEECFgAZAgcAQQIWABkCIwAoAdYAIwIjACgB1gAjAiMAKAHWACMCOwAtAgj/8QK5ADwCKgAUAiUALQD+AAwAuv/wAokANwH3AC0CXQBGAi4AQQMjAA8C8QAtAm8APAIKAC0COABQAfL//QEl/5sCbwA8AgoALQMjAA8C8QAtAh4ANwGlADICIgAKAX0AGQKIAEsCGQAIAioAFAIlAC0CQgBGAcoALQIWABkCBwBBASX/mwHMAC0BNwAiAUoALQCpADUBPwAlAPoALwD6AC8BSAAtALsALQEAACgA9QAuAUUALQFMAC0AAP+tAAD/sgAA/4YAAP+LAAD/hgAA/4kAAP/QAAD/hQAA/6gAAP+HAAD/iAAA/+EAAP/gAAD/wwAA/7cAAP+0AngAMgIWADwB8QAjAhUAMgPMAC0AqAAUAKcAFACmABQBPgAUAU4AFAFDABQBnwAKAZ8ACgDTACMB/gAoA5QALwEjACgBIwAoAdwACgJyACgCGgAjAhIAKAHfAB4C6QAKAjEANwHYAC0B9AAPAmwANwIxAB4B5wAgAdgAFADgAC4CVAAZAvcALQGXAAoCJwAtAhcAMgILACMCCwAjAfkAHgLsAAoCLQAKAmwACgNxABQDmQAKAd8ALQH2ACgB2gAOAiUALQHzABkB2f8fAhr+uAJgAFABqv78AjAAUAEkADIC+ABOApn+wAKWADwCHQA8AfYACgHPAC0ByAAtAXr/xAFzAB4DKwAtAw0ALQPYAC0DoAAtAdEALQH2AAABr/9lAUIAFAGbAC4BbQA1";

  // node_modules/cookies-ds/dist/fonts/poetsen-one.js
  var poetsen_one_default = "data:font/ttf;base64,AAEAAAAQAQAABAAAR1BPU2sKEWcAAAEMAAB1OEdTVUK5u71lAAB2RAAAAgBPUy8yjOdwngAAeEQAAABgY21hcD++S+IAAHikAAALkmN2dCAD0QyoAAKXfAAAAC5mcGdt5C4ChAACl6wAAAliZ2FzcAAAABAAApd0AAAACGdseWYBRdDCAACEOAAB7whoZWFk/LYE/wACc0AAAAA2aGhlYQfqBSEAAnN4AAAAJGhtdHjSrjEkAAJznAAAByxsb2NhAep+4AACesgAAAOYbWF4cAMICisAAn5gAAAAIG5hbWWssr/vAAJ+gAAADQpwb3N0UU8AJwACi4wAAAvlcHJlcK3BwW0AAqEQAAAAlQABAAAACgAeACwAAWxhdG4ACAAEAAAAAP//AAEAAAABa2VybgAIAAAAAQAAAAEABAACAAAABAAONghUAmBMAAFrdgAEAAABXALCAtwC+gMoA04DeAOiA8AD2gPoBAoEIAQ2BFQEagSYBRIFMAVSBYAFngXEBeYGBAYuBlgGhgaQBsoG8AcGBxAHLgd4B5oHvAgCCCgIMgg8CFoIgAiiCMAI4glUCXoJnAmuCcAKBgpMCn4KqAsSCzwLSgt0C3oLiAuWC5wLogusC74LyAvaC/QMFgw4DEIMXAyGDLAM2g0wDXINgA2ODbgN5g4IDjIOVA6mDrQOxg7wDw4PLA9SD3QPig+sD7IPwA/GD9QP/hAgEEIQbBCCEJgQthDgEPYRGBFCEXwRmhHEEe4SBBIiEkgSahKIErIS7BMCEyATShNgE4ITrBPmFAQULhRMFHYUjBSqFMwU6hUUFU4VeBXCFeAWBhYoFkYWXBZ+FqQWshbUFvYXGBc6F3gXlhfQF/oYGBhGGGwYfhicGK4YzBjyGRwZRhlYGW4ZkBmuGcQaQhpsGo4arBrWGvgbMhtUG44b5BwCHCAcThygHL4c6Bz+HSQdRh2AHdYd8B4GHhweOh5kHoYeqB7iHwwfLh9QH4IfnB/CIBAgYiBwIJYgxCDmITAhdiG8IgIiSCKOItQjGiNgI6YjxCPiJAAkHiQ8JF4kgCSiJMQk4iUAJR4lPCVaJXglliW0JdIl8CYOJiAmMiZEJlYmYCZqJngmhiaUJp4mqCayJrwmxibQJtom5CcGJywneifEKA4oWChiKGwodiiAKIoorCjOKPApEik0KVYpeCmaKbwp4ioIKi4qVCpmKngqiiqcKq4qwCsyK6QsFiyILPotHC0+LWAtgi2kLcYt6C4KLiwuTi5wLqIu1C8GLzgvYi+ML7Yv4DACMDAwXjCIMKIwvDDGMNAw+jEkMUIxcDGKMagx1jHwMhoyRDJKMpgyvjLkMw4zODNSM3QzijOoM8IzzDPeM+g0UjS8NSY1kAAGABv/6QA1/+YAbv/vAQD/9gGu//ABtP/JAAcANf/oADr/+gBY/+sAWf/yAGT/6wC8/9MBtf/yAAsAG//3AB3/9wA1/+EAOv/0AFD/8QBY/+IAWf/iAGT/4QC8/8UBtf/qAbj/9gAJABv/+gA1/+QAOv/6AFD/9QBY/+gAWf/wAGT/5wC8/8wBtf/vAAoAG//2AB3/9gA1/+AAOv/zAFD/8QBY/+IAWf/hAGT/4AC8/8cBtf/tAAoAA//sAB3/+wA1//YAOv/OAFj/7gBZ/+oAYf/6AGT/7gBu//sAvP/fAAcAvP/eAOAAGgDjABsA5AAOAO0ALAD4AAkA+wAeAAYAG//7ADX/+QBZ//YAvP/QAO0ACwGB//UAAwA1//oAbv/4ALz/3QAIABUANwA1/+gAOv/5AFj/9gBk//YAvP/TAPsANwG1//IABQAVAFgANf/oADr/+gC8/9QBtf/zAAUAFQA9ADX/6AA6//oAvP/TAbX/8gAHALz/3gDgABoA4wAbAOQADgDtACwA+AAJAPsAHgAFALz/3QDgAAsA4wATAO0AIgD7ABYACwAb//cAHf/3ADX/4QA6//QAUP/xAFj/4gBZ/+IAZP/hALz/xQG1/+oBuP/2AB4AA//nAAkAAQAVAB4ANQA+ADoAKQBOAAkAUAAuAFgAMgBZABcAYf/vAGQAMgBlAAwAbv/ZAH0APADX//wA4ABsAOEAAQDjAHYA5ABpAOwAAQDtAIgA+ABUAPsAeQEgAAEBfwAoAYz/9gG1ADQBtgAcAbcAFQG4ACIABwC8/94A4AAaAOMAGwDkAA4A7QAsAPgACQD7AB4ACAAVAEcAvP/eAOAADwDjABAA5AAOAO0AIQD4AAkA+wBHAAsAG//4ADX/4ABQ//YAWP/pAFn/8wBh//wAZP/pAG7/9QC8/8gBtf/pAbj/+AAHADX/8gA6//cAWP/sAFn/7ABk/+sAvP/UAbX/9wAJABv/+gA1/+QAOv/6AFD/9QBY/+gAWf/wAGT/5wC8/8wBtf/vAAgAHf/8ADX/7wA6//QAWP/sAFn/7QBk/+sAvP/TAbX/9gAHABv/+gA1/+sAWP/rAFn/7QBk/+sAvP/SAbX/8gAKAAP/7QAd//oANf/1ADr/1wBY/+4AWf/qAGH/9wBk/+4Abv/1ALz/3gAKAAP/7gAd//sANf/2ADr/3ABY/+8AWf/rAGH/+gBk/+8Abv/5ALz/3wALAAX//AAb//kANf/oADr/9wBY/+oAYf/6AGT/6wBu//MAvP/RANf//AG1//EAAgC8/9sA7QASAA4AA//vABv/+AA1/+YAUP/uAFj/4QBZ/+0AZP/hAH3/8gC8/8MBf//zAbX/5AG2//MBt//1Abj/8AAJABv/+gA1/+QAOv/6AFD/9QBY/+gAWf/wAGT/5wC8/8wBtf/vAAUANf/3AFj/9ABk//QAbv/5ALz/3wACALz/2wDtABIABwAb//QAvP/ZAOAAFADjABgA5AAKAO0AJwD7ABwAEgAD/+YABf/5ABv/0AA1/9QAO//sAEH/7ABQ/+kAWP/iAFn/9ABk/+IAff/PALz/rgF//+sBgf/jAbX/zQG2/84Bt//PAbj/zwAIABv/+gA1//cAOv/5AFj/8gBZ/+4AZP/xALz/3ADtAAkACAAb//sAHf/5ADX/9wA6//AAWP/wAFn/7ABk//AAvP/XABEAA//sAAn/8QAd//UAOwAHAGH/5ABi//sAbv/rALz/5wDX//MA4AA5AOMAPQDkAC8A7QBNAPgAKQD7AEEBAQAUAX7/9AAJABv/+QBi//UAbv/1ALz/2QDX//sA4wAHAOQABwDtACMA+wALAAIAvP/bAO0AEgACALz/2wDtABIABwAD/+sAOv/tAFn/9gBh//kAbv/7ALz/4gDtAB0ACQAb//oANf/4ADr/+ABY//IAWf/yAGT/8gBu//kAvP/WAbX/+AAIAB3/+gBZ//YAYf/6ALz/3gDX//sA4wAMAO0AHAD7AA8ABwAbAAUAOv/7AGL/+wBu//oAvP/gAO0AJgD7AAcACAAb//sAHf/5ADX/9wA6//AAWP/wAFn/7ABk//AAvP/XABwAA//lAAn/2QAb/9wAHf/WADsADgBh/8EAYv/zAG7/wAB9AAgAvP/pANb/3gDX/+oA4AA/AOH/9wDjAEQA5AA0AOz/zADtAFMA+AAuAPsARwEBABoBdP/eAXb/3gF4/94Bfv/rAYz/4wG8//QBvf/0AAkAFQAkABv/+wAd//kANf/3ADr/8ABY//AAWf/sAGT/8AC8/9cACAAd//oAWf/2AGH/+wC8/94A1//7AOMADADtABoA+wAOAAQAG//7ADX/+gC8/9oA7QAYAAQAG//7ADX/+wC8/9sA7QAbABEAA//qAAn/9QAd//oAOv/7AGH/6QBi//YAbv/kALz/5ADX//IA4AAlAOMAMQDkACIA7QBAAPgACwD7ADQBAQAKAX7/8wARAAP/5gAF//gAG//qADX/6AA7//EAUP/vAFj/6gBk/+oAff/nALz/uwFg/9kBf//zAbT/+gG1/98Btv/oAbf/6gG4/+YADAAd//oAOv/6AGH/8ABi//oAbv/wALz/4wDX//UA4AAcAOMAJgDkABkA7QA5APsAKgAKABv/9QBu//kAvP/eANf/+wDgAB4A4wAjAOQAFADtADIA+AAOAPsAJgAaAAP/5QAJ/+kAHf/0ADz/9QA+//UAQP/2AEH/9gBh/9IAYv/rAG7/yQC8/+AA1//pAOAALgDh//UA4wA4AOQAKQDtAEgA+AAXAPsAPAEBAA4Bfv/nAYz/6AG0//kBu//0Abz/9AG9//QACgBh//kAYv/zAG7/7QC8/98A1//4AOAACADjABAA5AANAO0ALwD7ABQAAwBY//EAWf/tAGT/8QAKADUAFQA6AAYAOwAIAE3/7QF8//IBfv/uAYH/4QG+//UBv//mAcL/7gABAFn/9AADAFj/8gBZ/+0AZP/xAAMAWP/1AFn/7wBk//UAAQBZ//QAAQBZ//EAAgGB//QBv//xAAQAG//hADX/2AA7/+cAQf/vAAIANf/zAWD/7wAEABUASgA1//MA+wBKAWD/7wAGABUAVQAb/+EANf/YADv/5wBB/+8A+wBVAAgAHf/8ADX/7wA6//QAWP/sAFn/7QBk/+sAvP/TAbX/9gAIAB3//AA1/+8AOv/0AFj/7ABZ/+0AZP/rALz/0wG1//YAAgAVAFMA+wBTAAYABf/uABUAbQAb/+gANf/eAG7/7gD7AG0ACgAb//MAHf/rADX/6QA6//EAO//kAD3/5QA///YAQ//2AET/8gFg/+AACgAb//MAHf/rADX/6QA6//EAO//kAD3/5QA///YAQ//2AET/8gFg/+AACgAb//MAHf/rADX/6QA6//EAO//kAD3/5QA///YAQ//2AET/8gFg/+AAFQAVAHkAHf/1ADUACgA8/+0APv/tAED/9ABB//YAV//2AGH/6gBi//IAY//tAG7/5gDX//MA4AAzAOIABwDjADgA5AApAO0ARwD4ACQA+wB5AQEACgAQABUAXgA1ABYAOgAFADz/9gA+//YAYf/wAGP/7QBu/+oA4ABAAOMARADkADYA7QBUAPgALQD7AF4BAQAXAWAAAQADAFj/9QBZ//YAZP/1AAMAFQA8ALz/2wDtABIACgAVAEwAG//6ADX/5AA6//oAUP/1AFj/6ABZ//AAZP/nALz/zAG1/+8ACwAb//cAHf/3ADX/4QA6//QAUP/xAFj/4gBZ/+IAZP/hALz/xQG1/+oBuP/2AAgAHf/6ADX/9wA6/+sAWP/sAFn/6QBk/+sBYP/6AbX/9wAKABv/9gAd//YANf/gADr/8wBQ//EAWP/iAFn/4QBk/+AAvP/HAbX/7QAIABv/+wAd//kANf/3ADr/8ABY//AAWf/sAGT/8AC8/9cAFAAVAHkAHf/2ADUACgA8/+wAPv/tAED/9ABB//UAV//2AGH/6gBi//EAY//sAG7/5gDX//MA4AAzAOMAOADkACkA7QBHAPgAJAD7AHkBAQAKAAMAWP/tAFn/7gBk/+wABAAVAFIA4wAJAO0AGwD7AFIACgAb//MAHf/rADX/6QA6//EAO//kAD3/5QA///YAQ//2AET/8gFg/+AABwAb//sAHf/5AOAAHADjACUA5AAXAO0ANgD7ACgABwA1//IAOv/3AFj/7ABZ/+wAZP/rALz/1AG1//cACQAb//oANf/kADr/+gBQ//UAWP/oAFn/8ABk/+cAvP/MAbX/7wAIAB3//AA1/+8AOv/0AFj/7ABZ/+0AZP/rALz/0wG1//YABQA1//cAWP/0AGT/9ABu//kAvP/fAAgAFQA3ADX/6AA6//kAWP/2AGT/9gC8/9MA+wA3AbX/8gABAWD/8gADAB3/9gA1/+0BYP/pAAEBYP/yAAMAHf/2ADX/7QFg/+kACgAbAB0Abv/sAOAADgDjABMA5AAcAO0AOAD7ABYBAQAdATIADwFgAAEACAAd//oAWf/2AGH/+wC8/94A1//7AOMADADtABoA+wAOAAgAFQBIALz/3gDgAA8A4wAQAOQADgDtACEA+AAJAPsAEwAKABv/9QBu//kAvP/eANf/+wDgAB4A4wAjAOQAFADtADIA+AAOAPsAJgAFADX/9wBY//QAZP/0AG7/+QC8/98ABQA1//cAWP/0AGT/9ABu//kAvP/fAAcANf/oADr/+gBY/+sAWf/yAGT/6wC8/9MBtf/yAAoAG//2AB3/9gA1/+AAOv/zAFD/8QBY/+IAWf/hAGT/4AC8/8cBtf/tAAUAFQA9ADX/6AA6//oAvP/TAbX/8gAIAB3//AA1/+8AOv/0AFj/7ABZ/+0AZP/rALz/0wG1//YACgAD/+4AHf/7ADX/9gA6/9wAWP/vAFn/6wBh//oAZP/vAG7/+QC8/98ADgAD/+8AG//4ADX/5gBQ/+4AWP/hAFn/7QBk/+EAff/yALz/wwF///MBtf/kAbb/8wG3//UBuP/wAAcANf/oADr/+gBY/+sAWf/yAGT/6wC8/9MBtf/yAAoAG//2AB3/9gA1/+AAOv/zAFD/8QBY/+IAWf/hAGT/4AC8/8cBtf/tAAoAA//sAB3/+wA1//YAOv/OAFj/7gBZ/+oAYf/6AGT/7gBu//sAvP/fAAUAFQA9ADX/6AA6//oAvP/TAbX/8gAHADX/8gA6//cAWP/sAFn/7ABk/+sAvP/UAbX/9wAJABv/+gA1/+QAOv/6AFD/9QBY/+gAWf/wAGT/5wC8/8wBtf/vAAgAHf/8ADX/7wA6//QAWP/sAFn/7QBk/+sAvP/TAbX/9gAHABv/+gA1/+sAWP/rAFn/7QBk/+sAvP/SAbX/8gAKAAP/7gAd//sANf/2ADr/3ABY/+8AWf/rAGH/+gBk/+8Abv/5ALz/3wAOAAP/7wAb//gANf/mAFD/7gBY/+EAWf/tAGT/4QB9//IAvP/DAX//8wG1/+QBtv/zAbf/9QG4//AABQA1//cAWP/0AGT/9ABu//kAvP/fAAcANf/oADr/+gBY/+sAWf/yAGT/6wC8/9MBtf/yAAoAG//2AB3/9gA1/+AAOv/zAFD/8QBY/+IAWf/hAGT/4AC8/8cBtf/tAAUAFQA9ADX/6AA6//oAvP/TAbX/8gAIAB3//AA1/+8AOv/0AFj/7ABZ/+0AZP/rALz/0wG1//YACgAD/+4AHf/7ADX/9gA6/9wAWP/vAFn/6wBh//oAZP/vAG7/+QC8/98ADgAD/+8AG//4ADX/5gBQ/+4AWP/hAFn/7QBk/+EAff/yALz/wwF///MBtf/kAbb/8wG3//UBuP/wAAcANf/oADr/+gBY/+sAWf/yAGT/6wC8/9MBtf/yAAoAG//2AB3/9gA1/+AAOv/zAFD/8QBY/+kAWf/hAGT/6QC8/8cBtf/tAAcANf/oADr/+gBY/+sAWf/yAGT/6wC8/9MBtf/yAAoAG//2AB3/9gA1/+AAOv/zAFD/8QBY/+IAWf/hAGT/4AC8/8cBtf/tAAUAFQA9ADX/6AA6//oAvP/TAbX/8gAHADX/8gA6//cAWP/sAFn/7ABk/+sAvP/UAbX/9wAIAB3//AA1/+8AOv/0AFj/7ABZ/+0AZP/rALz/0wG1//YABwAb//oANf/rAFj/6wBZ/+0AZP/rALz/0gG1//IACgAD/+4AHf/7ADX/9gA6/9wAWP/vAFn/6wBh//oAZP/vAG7/+QC8/98ADgAD/+8AG//4ADX/5gBQ/+4AWP/hAFn/7QBk/+EAff/yALz/wwF///MBtf/kAbb/8wG3//UBuP/wAAoAA//sAB3/+wA1//YAOv/OAFj/7gBZ/+oAYf/6AGT/7gBu//sAvP/fABIAA//kAAUAHAAVACwAGwAmAB0ACgBOABIAUAAyAFgAOgBZAB4AZAA6AGUAEwBu/+kAfQBBAX8AMgG1AD8BtgAhAbcAHgG4ACQABwA1//IAOv/3AFj/7ABZ/+wAZP/rALz/1AG1//cACQAb//oANf/kADr/+gBQ//UAWP/oAFn/8ABk/+cAvP/MAbX/7wAIAB3//AA1/+8AOv/0AFj/7ABZ/+0AZP/rALz/0wG1//YABwAb//oANf/rAFj/6wBZ/+0AZP/rALz/0gG1//IABQA1//cAWP/0AGT/9ABu//kAvP/fAAgAFQA3ADX/6AA6//kAWP/2AGT/9gC8/9MA+wA3AbX/8gAJABv/+gA1/+QAOv/6AFD/9QBY/+gAWf/wAGT/5wC8/8wBtf/vAAMABf/fABv/5wAd/94ACAAVACoANf/yADr/9wBY/+wAWf/sAGT/6wC8/9QBtf/3AAgAFQAPABv/+gA1/+sAWP/rAFn/7QBk/+sAvP/SAbX/8gAIABUAIgA1/+gAOv/6AFj/6wBZ//IAZP/rALz/0wG1//IACAAd//wANf/vADr/9ABY/+wAWf/tAGT/6wC8/9MBtf/2AA8AA//vABUAYwAb//gANf/mAFD/7gBY/+cAWf/tAGT/5wB9//IAvP/DAX//8wG1/+QBtv/zAbf/9QG4//AABwA1/+gAOv/6AFj/6wBZ//IAZP/rALz/0wG1//IADgAD/+8AG//4ADX/5gBQ/+4AWP/hAFn/7QBk/+EAff/yALz/wwF///MBtf/kAbb/8wG3//UBuP/wAAoAA//sAB3/+wA1//YAOv/OAFj/7gBZ/+oAYf/6AGT/7gBu//sAvP/fAAcAFQBKABv/+wA1//kAWf/2ALz/0ADtAAsBgf/1AAsAG//4ADX/4ABQ//YAWP/pAFn/8wBh//wAZP/pAG7/9QC8/8gBtf/pAbj/+AAJABv/+gA1/+QAOv/6AFD/9QBY/+gAWf/wAGT/5wC8/8wBtf/vAAQAFQBgADX/+gBu//gAvP/dAAcAG//6ADX/6wBY/+sAWf/tAGT/6wC8/9IBtf/yAAQAFQAcADX/+gBu//gAvP/dAAcANf/oADr/+gBY/+sAWf/yAGT/6wC8/9MBtf/yAAkAG//6ADX/5AA6//oAUP/1AFj/6ABZ//AAZP/nALz/zAG1/+8ACgAb//YAHf/2ADX/4AA6//MAUP/xAFj/4gBZ/+EAZP/gALz/xwG1/+0ACgAD/+wAHf/7ADX/9gA6/84AWP/uAFn/6gBh//oAZP/uAG7/+wC8/98ABAAVACkANf/6AG7/+AC8/90ABQC8/90A4AALAOMAEwDtACIA+wAWAAgAHf/8ADX/7wA6//QAWP/sAFn/7QBk/+sAvP/TAbX/9gAHABv/+gA1/+sAWP/rAFn/7QBk/+sAvP/SAbX/8gAFADX/9wBY//QAZP/0AG7/+QC8/98AHwAD/+cACQABAA8AAQAVAB4ANQA+ADoAKQBOAAkAUAAuAFgAMgBZABcAYf/vAGQAMgBlAAwAbv/ZAH0APADX//wA4ABsAOEAAQDjAHYA5ABpAOwAAQDtAIgA+ABUAPsAeQEgAAEBfwAoAYz/9gG1ADQBtgAcAbcAFQG4ACIACgAb/+kANf/rAFj/8QBZ/+8AZP/wAH3/8AG1//IBtv/vAbf/7gG4//AACAAb//kAvP/eAOAAGgDjABsA5AAOAO0AMgD4AAkA+wAeAAcANf/oADr/+gBY/+sAWf/yAGT/6wC8/9MBtf/yAAoAG//2AB3/9gA1/+AAOv/zAFD/8QBY/+IAWf/hAGT/4AC8/8cBtf/tAAgAHf/8ADX/7wA6//QAWP/sAFn/7QBk/+sAvP/TAbX/9gAOAAP/7wAb//gANf/mAFD/7gBY/+EAWf/tAGT/4QB9//IAvP/DAX//8wG1/+QBtv/zAbf/9QG4//AACAAd//wANf/vADr/9ABY/+wAWf/tAGT/6wC8/9MBtf/2AA4AA//vABv/+AA1/+YAUP/uAFj/4QBZ/+0AZP/hAH3/8gC8/8MBf//zAbX/5AG2//MBt//1Abj/8AAVAAUAIQAVADAATgAWAFAAIgBYAD0AWQAbAGQAPQBlABgAfQA4ALz/3gDgABoA4wAbAOQADgDtACwA+AAJAPsAHgF/ADABtQBAAbYAFwG3ABYBuAASAAcAvP/eAOAAGgDjABsA5AAOAO0ALAD4AAkA+wAeAAcAvP/eAOAAGgDjABsA5AAOAO0ALAD4AAkA+wAeAAsAWAALAGQACwB9ABMAvP/eAOAAGgDjABsA5AAOAO0ALAD4AAkA+wAeAbUADwAUAAUAEAAVACAAUAAYAFgALQBZAAwAZAAtAGUABwB9ADEAvP/eAOAAGgDjABsA5AAOAO0ALAD4AAkA+wAeAX8AIQG1ADABtgAOAbcADAG4AAgABwA1/+gAOv/6AFj/6wBZ//IAZP/rALz/0wG1//IACgAb//YAHf/2ADX/4AA6//MAUP/xAFj/4gBZ/+EAZP/gALz/xwG1/+0ABQAVAD0ANf/oADr/+gC8/9MBtf/yAAkAG//6ADX/5AA6//oAUP/1AFj/6ABZ//AAZP/nALz/zAG1/+8ACAAd//wANf/vADr/9ABY//cAWf/tAGT/9wC8/9MBtf//AA4AA//vABv/+AA1/+YAUP/uAFj/4QBZ/+0AZP/hAH3/8gC8/8MBf//zAbX/5AG2//MBt//1Abj/8AAVAAUANQAVADwATgAoAFAAJgBYAEkAWQAkAGQASQBlACUAfQA+ALz/3gDgABoA4wAbAOQADgDtACwA+AAJAPsAHgF/ADoBtQBLAbYAHAG3ABwBuAASAAYAG//7ADX/+QBZ//YAvP/QAO0ACwGB//UABQA1//cAWP/0AGT/9ABu//kAvP/fAAUANf/3AFj/9ABk//QAbv/5ALz/3wAHADX/6AA6//oAWP/rAFn/8gBk/+sAvP/TAbX/8gAKABv/9gAd//YANf/gADr/8wBQ//EAWP/iAFn/4QBk/+AAvP/HAbX/7QAIABUANwA1/+gAOv/5AFj/9gBk//YAvP/TAPsANwG1//IACAAd//wANf/vADr/9ABY/+wAWf/tAGT/6wC8/9MBtf/2AA4AA//vABv/+AA1/+YAUP/uAFj/4QBZ/+0AZP/hAH3/8gC8/8MBf//zAbX/5AG2//MBt//1Abj/8AAKAFgADwBkAA8AvP/eAOAAGgDjABsA5AAOAO0ALAD4AAkA+wAeAbUAFgAIABUAJgC8/94A4AAaAOMAGwDkAA4A7QAsAPgACQD7AB4ACAAVAEUAvP/eAOAAGgDjABsA5AAOAO0ALAD4AAkA+wAeAAwAFQBHAFgACABkAAgAfQAQALz/3gDgABoA4wAbAOQADgDtACwA+AAJAPsAHgG1AAwABgAb//sANf/5AFn/9gC8/9AA7QALAYH/9QAJABv/+gA1/+QAOv/6AFD/9QBY/+gAWf/wAGT/5wC8/8wBtf/vABMAA//mAAUAFwAVACYAGwAhAB0ABQBOAAwAUAAsAFgANABZABcAZAA0AGUADQBu/9sAfQA7ANf/+wF/ACwBtQA4AbYAGgG3ABcBuAAdABQAA//mAAUAGQAVACcAGwAiAB0ABQBOAA0AUAAtAFgANgBZABoAZAA2AGUADwBu/9kAfQA8ANf/+wDhAAUBfwAuAbUAOwG2AB0BtwAaAbgAIAADADX/+gBu//gAvP/dAAkAG//6ADX/5AA6//oAUP/1AFj/6ABZ//AAZP/nALz/zAG1/+8ACwBQAA0AWAARAGQAEQB9ABsAvP/dAOAACwDjABMA7QAiAPsAFgF/AAkBtQAWAAgAFQA3ADX/6AA6//kAWP/2AGT/9gC8/9MA+wA3AbX/8gASAAP/5gAF//gAFQBcABv/6gA1/+gAO//xAFD/7wBY/+oAZP/qAH3/5wC8/7sBYP/ZAX//8wG0//oBtf/fAbb/6AG3/+oBuP/mABEAA//mAAX/+AAb/+oANf/oADv/8QBQ/+8AWP/qAGT/6gB9/+cAvP+7AWD/2QF///MBtP/6AbX/3wG2/+gBt//qAbj/5gARAAP/5gAF//gAG//qADX/6AA7//EAUP/vAFj/6gBk/+oAff/nALz/uwFg/9kBf//zAbT/+gG1/98Btv/oAbf/6gG4/+YAEQAD/+YABf/4ABv/6gA1/+gAO//xAFD/7wBY/+oAZP/qAH3/5wC8/7sBYP/ZAX//8wG0//oBtf/fAbb/6AG3/+oBuP/mABEAA//mAAX/+AAb/+oANf/oADv/8QBQ/+8AWP/qAGT/6gB9/+cAvP+7AWD/2QF///MBtP/6AbX/3wG2/+gBt//qAbj/5gARAAP/5gAF//gAG//qADX/6AA7//EAUP/vAFj/6gBk/+oAff/nALz/uwFg/9kBf//zAbT/+gG1/98Btv/oAbf/6gG4/+YAEQAD/+YABf/4ABv/6gA1/+gAO//xAFD/7wBY/+oAZP/qAH3/5wC8/7sBYP/ZAX//8wG0//oBtf/fAbb/6AG3/+oBuP/mABEAA//mAAX/+AAb/+oANf/oADv/8QBQ/+8AWP/qAGT/6gB9/+cAvP+7AWD/2QF///MBtP/6AbX/3wG2/+gBt//qAbj/5gARAAP/5gAF//gAG//qADX/6AA7//EAUP/vAFj/6gBk/+oAff/nALz/uwFg/9kBf//zAbT/+gG1/98Btv/oAbf/6gG4/+YAEQAD/+YABf/4ABv/6gA1/+gAO//xAFD/7wBY/+oAZP/qAH3/5wC8/7sBYP/ZAX//8wG0//oBtf/fAbb/6AG3/+oBuP/mAAcAGwAFADr/+wBi//sAbv/6ALz/4ADtACYA+wAHAAcAGwAFADr/+wBi//sAbv/6ALz/4ADtACYA+wAHAAcAGwAFADr/+wBi//sAbv/6ALz/4ADtACYA+wAHAAcAGwAFADr/+wBi//sAbv/6ALz/4ADtACYA+wAHAAcAGwAFADr/+wBi//sAbv/6ALz/4ADtACYA+wAHAAgAG//7AB3/+QA1//cAOv/wAFj/8ABZ/+wAZP/wALz/1wAIABv/+wAd//kANf/3ADr/8ABY//AAWf/sAGT/8AC8/9cACAAb//sAHf/5ADX/9wA6//AAWP/wAFn/7ABk//AAvP/XAAgAG//7AB3/+QA1//cAOv/wAFj/8ABZ/+wAZP/wALz/1wAHABv/9AC8/9kA4AAUAOMAGADkAAoA7QAnAPsAHAAHABv/9AC8/9kA4AAUAOMAGADkAAoA7QAnAPsAHAAHABv/9AC8/9kA4AAUAOMAGADkAAoA7QAnAPsAHAAHABv/9AC8/9kA4AAUAOMAGADkAAoA7QAnAPsAHAAHABv/9AC8/9kA4AAUAOMAGADkAAoA7QAnAPsAHAAHABv/9AC8/9kA4AAUAOMAGADkAAoA7QAnAPsAHAAHABv/9AC8/9kA4AAUAOMAGADkAAoA7QAnAPsAHAAHABv/9AC8/9kA4AAUAOMAGADkAAoA7QAnAPsAHAAHABv/9AC8/9kA4AAUAOMAGADkAAoA7QAnAPsAHAAHABv/9AC8/9kA4AAUAOMAGADkAAoA7QAnAPsAHAAHABv/9AC8/9kA4AAUAOMAGADkAAoA7QAnAPsAHAAEABv/+wA1//oAvP/aAO0AGAAEABv/+wA1//oAvP/aAO0AGAAEABv/+wA1//oAvP/aAO0AGAAEABv/+wA1//oAvP/aAO0AGAACALz/2wDtABIAAgC8/9sA7QASAAMAvP/bAO0AEgEy//oAAwAVADsAvP/bAO0AEgADABUAHAC8/9sA7QASAAIAvP/bAO0AEgACALz/2wDtABIAAgC8/9sA7QASAAIAvP/bAO0AEgACALz/2wDtABIAAgC8/9sA7QASAAIAvP/bAO0AEgACALz/2wDtABIACAAd//oAWf/2AGH/+wC8/94A1//7AOMADADtABoA+wAOAAkAG//5AGL/9QBu//UAvP/ZANf/+wDjAAcA5AAHAO0AIwD7AAsAEwAD/+YABf/5ABUADQAb/9AANf/UADv/7ABB/+wAUP/pAFj/4gBZ//QAZP/iAH3/zwC8/64Bf//rAYH/4wG1/80Btv/OAbf/zwG4/88AEgAD/+YABf/5ABv/0AA1/9QAO//sAEH/7ABQ/+kAWP/iAFn/9ABk/+IAff/PALz/rgF//+sBgf/jAbX/zQG2/84Bt//PAbj/zwASAAP/5gAF//kAG//QADX/1AA7/+wAQf/sAFD/6QBY/+IAWf/0AGT/4gB9/88AvP+uAX//6wGB/+MBtf/NAbb/zgG3/88BuP/PABIAA//mAAX/+QAb/9AANf/UADv/7ABB/+wAUP/pAFj/4gBZ//QAZP/iAH3/zwC8/64Bf//rAYH/4wG1/80Btv/OAbf/zwG4/88AAgC8/9sA7QASAAIAvP/bAO0AEgACALz/2wDtABIAAgC8/9sA7QASAAIAvP/bAO0AEgAIABv/+wAd//kANf/3ADr/8ABY//AAWf/sAGT/8AC8/9cACAAb//sAHf/5ADX/9wA6//AAWP/wAFn/7ABk//AAvP/XAAgAG//7AB3/+QA1//cAOv/wAFj/8ABZ/+wAZP/wALz/1wAIABv/+wAd//kANf/3ADr/8ABY//AAWf/sAGT/8AC8/9cACAAb//sAHf/5ADX/9wA6//AAWP/wAFn/7ABk//AAvP/XAAgAG//7AB3/+QA1//cAOv/wAFj/8ABZ/+wAZP/wALz/1wAIABv/+wAd//kANf/3ADr/8ABY//AAWf/sAGT/8AC8/9cACAAb//sAHf/5ADX/9wA6//AAWP/wAFn/7ABk//AAvP/XAAgAG//7AB3/+QA1//cAOv/wAFj/8ABZ/+wAZP/wALz/1wAJABv/+gA1//gAOv/4AFj/8gBZ//IAZP/yAG7/+QC8/9YBtf/4AAkAG//6ADX/+AA6//gAWP/yAFn/8gBk//IAbv/5ALz/1gG1//gACQAb//oANf/4ADr/+ABY//IAWf/yAGT/8gBu//kAvP/WAbX/+AAJABv/+gA1//gAOv/4AFj/8gBZ//IAZP/yAG7/+QC8/9YBtf/4AAQAG//7ADX/+wC8/9sA7QAbAAQAG//7ADX/+wC8/9sA7QAbAAQAG//7ADX/+wC8/9sA7QAbAAQAG//7ADX/+wC8/9sA7QAbAAQAG//7ADX/+wC8/9sA7QAbAAQAG//7ADX/+wC8/9sA7QAbABwAA//lAAn/2QAb/9wAHf/WADsADgBh/8EAYv/zAG7/wAB9AAgAvP/pANb/3gDX/+oA4AA/AOH/9wDjAEQA5AA0AOz/zADtAFMA+AAuAPsARwEBABoBdP/eAXb/3gF4/94Bfv/rAYz/4wG8//QBvf/0ABwAA//lAAn/2QAb/9wAHf/WADsADgBh/8EAYv/zAG7/wAB9AAgAvP/pANb/3gDX/+oA4AA/AOH/9wDjAEQA5AA0AOz/zADtAFMA+AAuAPsARwEBABoBdP/eAXb/3gF4/94Bfv/rAYz/4wG8//QBvf/0ABwAA//lAAn/2QAb/9wAHf/WADsADgBh/8EAYv/zAG7/wAB9AAgAvP/pANb/3gDX/+oA4AA/AOH/9wDjAEQA5AA0AOz/zADtAFMA+AAuAPsARwEBABoBdP/eAXb/3gF4/94Bfv/rAYz/4wG8//QBvf/0ABwAA//lAAn/2QAb/9wAHf/WADsADgBh/8EAYv/zAG7/wAB9AAgAvP/pANb/3gDX/+oA4AA/AOH/9wDjAEQA5AA0AOz/zADtAFMA+AAuAPsARwEBABoBdP/eAXb/3gF4/94Bfv/rAYz/4wG8//QBvf/0ABwAA//lAAn/2QAb/+8AHf/lADsADgBh/8EAYv/zAG7/zgB9AAEAvP/pANb/7gDX//AA4AA/AOH/9wDjAEQA5AA0AOz/zADtAFMA+AAuAPsARwEBABoBdP/uAXb/7gF4/+4Bfv/rAYz/4wG8//oBvf/6AAgAHf/6AFn/9gBh//oAvP/eANf/+wDjAAwA7QAcAPsADwAIAB3/+gBZ//YAYf/6ALz/3gDX//sA4wAMAO0AHAD7AA8ACAAd//oAWf/2AGH/+gC8/94A1//7AOMADADtABwA+wAPAAgAHf/6AFn/9gBh//oAvP/eANf/+wDjAAwA7QAcAPsADwAIAB3/+gBZ//YAYf/6ALz/3gDX//sA4wAMAO0AHAD7AA8ACAAd//oAWf/2AGH/+gC8/94A1//7AOMADADtABwA+wAPAAgAHf/6AFn/9gBh//oAvP/eANf/+wDjAAwA7QAcAPsADwAIAB3/+gBZ//YAYf/6ALz/3gDX//sA4wAMAO0AHAD7AA8ACAAd//oAWf/2AGH/+gC8/94A1//7AOMADADtABwA+wAPAAgAHf/6AFn/9gBh//oAvP/eANf/+wDjAAwA7QAcAPsADwAIAB3/+gBZ//YAYf/6ALz/3gDX//sA4wAMAO0AHAD7AA8ADAAd//oAOv/6AGH/8ABi//oAbv/wALz/4wDX//UA4AAcAOMAJgDkABkA7QA5APsAKgAMAB3/+gA6//oAYf/wAGL/+gBu//AAvP/jANf/9QDgABwA4wAmAOQAGQDtADkA+wAqAAwAHf/6ADr/+gBh//AAYv/6AG7/8AC8/+MA1//1AOAAHADjACYA5AAZAO0AOQD7ACoADAAd//oAOv/6AGH/8ABi//oAbv/wALz/4wDX//UA4AAcAOMAJgDkABkA7QA5APsAKgAKABv/9QBu//kAvP/eANf/+wDgAB4A4wAjAOQAFADtADIA+AAOAPsAJgAKABv/9QBu//kAvP/eANf/+wDgAB4A4wAjAOQAFADtADIA+AAOAPsAJgAKABv/9QBu//kAvP/eANf/+wDgAB4A4wAjAOQAFADtADIA+AAOAPsAJgAKABv/9QBu//kAvP/eANf/+wDgAB4A4wAjAOQAFADtADIA+AAOAPsAJgAIABv/+QC8/94A4AAaAOMAGwDkAA4A7QAyAPgACQD7AB4ACwAb//cAHf/3ADX/4QA6//QAUP/xAFj/4gBZ/+IAZP/hALz/xQG1/+oBuP/2AAsAG//3AB3/9wA1/+EAOv/0AFD/8QBY/+IAWf/iAGT/4QC8/8UBtf/qAbj/9gAKABv/9QBu//kAvP/eANf/+wDgAB4A4wAjAOQAFADtADIA+AAOAPsAJgAGABv/+wA1//kAWf/2ALz/0ADtAAsBgf/1AAYA4AAjAOMAKgDkABoA7QA5APgADAD7AC0AAgA1//EAO//1AAIAO//mAD3/6QAKAAP/8gBu/+oA4AAeAOMAIQDkABIA7QAwAPgADgD7ACQBfv/sAYz/8AAKAAP/8gBu/+oA4AAeAOMAIQDkABIA7QAwAPgADgD7ACQBfv/sAYz/8AAHAG7/6wDgAB4A4wAHAOQACQDtACsA+AASAPsACgALAAP/8ABh//UAbv/lAOAAJQDjACwA5AAcAO0AOwD4ABEA+wAvAX7/6gGM/+sABgAVAEcAG//hADX/2AA7/+cAQf/vAPsARwAHAG7/6wDgAB4A4wAHAOQACQDtACsA+AASAPsACgALAAP/8ABh//UAbv/lAOAAJQDjACwA5AAcAO0AOwD4ABEA+wAvAX7/6gGM/+sABgAVAEcAG//hADX/2AA7/+cAQf/vAPsARwAKAAP/9QAb/+YANf/vAFj/8QBk//EAff/zAbX/8gG2//QBt//zAbj/8AAKAAP/9QAb/+YANf/vAFj/8QBk//EAff/zAbX/8gG2//QBt//zAbj/8AABAX3/6wATAAP/5gAF//kAG//QADX/1AA7/+wAQf/sAFD/6QBY/+IAWf/0AGT/4gB9/88AvP+uAWD/1wF//+sBgf/jAbX/zQG2/84Bt//PAbj/zwAJABv/+wAd//kANf/3ADr/8ABY//AAWf/sAGT/8AC8/9cBYP/7AAkAG//7AB3/+QA1//cAOv/wAFj/8ABZ/+wAZP/wALz/1wFg//sACgAb//YAHf/2ADX/4AA6//MAUP/xAFj/4gBZ/+EAZP/gALz/xwG1/+0ACgAb//YAHf/2ADX/4AA6//MAUP/xAFj/4gBZ/+EAZP/gALz/xwG1/+0ABgAb//sANf/5AFn/9gC8/9AA7QALAYH/9QAIAAP/0AAbAAUANf/5AFn/9gB9AAYAvP/QAO0ACwGB//UABQBu//UA4AALAOMAEgDtACEA+wAVAAcAG//0ALz/2QDgABQA4wAYAOQACgDtACcA+wAcAAYAOv/zAR8AFwEgAAkBYP/6Aa4AHAG0AAoAAgA7//YAPf/1AAQAO//lAD3/4ABD/+0ARP/sAAIAO//xAD3/9QAaAAP/5QAJ/+kAHf/0ADz/9QA+//UAQP/2AEH/9gBh/9IAYv/rAG7/yQC8/+AA1//pAOAALgDh//UA4wA4AOQAKQDtAEgA+AAXAPsAPAEBAA4Bfv/nAYz/6AG0//kBu//0Abz/9AG9//QAGgAD/+UACf/pAB3/9AA8//UAPv/1AED/9gBB//YAYf/SAGL/6wBu/8kAvP/gANf/6QDgAC4A4f/1AOMAOADkACkA7QBIAPgAFwD7ADwBAQAOAX7/5wGM/+gBtP/5Abv/9AG8//QBvf/0ABoAA//lAAn/6QAd//QAPP/1AD7/9QBA//YAQf/2AGH/0gBi/+sAbv/JALz/4ADX/+kA4AAuAOH/9QDjADgA5AApAO0ASAD4ABcA+wA8AQEADgF+/+cBjP/oAbT/+QG7//QBvP/0Ab3/9AAaAAP/5QAJ/+kAHf/0ADz/9QA+//UAQP/2AEH/9gBh/9IAYv/rAG7/yQC8/+AA1//pAOAALgDh//UA4wA4AOQAKQDtAEgA+AAXAPsAPAEBAA4Bfv/nAYz/6AG0//kBu//0Abz/9AG9//QAGgAD/+UACf/pAB3/9AA8//UAPv/1AED/9gBB//YAYf/SAGL/6wBu/8kAvP/gANf/6QDgAC4A4f/1AOMAOADkACkA7QBIAPgAFwD7ADwBAQAOAX7/5wGM/+gBtP/5Abv/9AG8//QBvf/0AAE2agAEAAAAGgA+AOQBbgQcBzoHtAo2CvwNhg+YD7IQWBByEKAQuhDUEP4RMBMeFWAXqhhkGqYbDBxSHcwAKQAc/+sAMP/mADL/5gA2/+sAN//nADn/4ACQ/+sAm//rAKP/6wCw/+sBDv/rAQ//6wEQ/+sBEf/rARL/6wET/+sBFP/rARX/6wEW/+sBF//rAT3/5gFc/+YBXf/mAV7/5gFf/+YBYP/mAWz/5wFt/+cBbv/nAW//5wGD//IBhP/yAYb/8gGJ//IBjf/nAY7/5wHG/+ABx//gAcj/4AHJ/+AByv/gACIALf/6ADD/0QA3/+UAOP/6ADn/1AFc/9EBXf/RAV7/0QFf/9EBYP/RAWH/+gFi//oBY//6AWT/+gFl//oBZv/6AWf/+gFo//oBaf/6AWr/+gFr//oBbP/lAW3/5QFu/+UBb//lAXD/+gFx//oBcv/6AXP/+gHG/9QBx//UAcj/1AHJ/9QByv/UAKsAB//4AAz/+QAN//kAEP/5ABf/+AAZ//gAGv/7AB7/+gAf//cAIf/4ACL/+gAj//oAJP/6ACX/+gAm//oAJ//6ACj/+gAp//oAKv/6ACv/+gAs//oAMP/MADL/1gA2/+oAN//1ADj/5wA5/+IARf/kAEn/5ABK//cAS//4AFL/9ABT//QAVP/0AF3/+gBg//oAaP/0AG//+ABx//gAcv/4AHP/+QB///oAg//5AIr/5ACN//gAj//4AJH/9wCU//gAl//4AJn/+ACa//sAnP/3AJ3/+ACg//gAov/4AKT/9wCn//gAq//4AK3/+ACu//gAr//7ALH/9wC0//gAtv/4ALf/+wC4//gAuf/5AL3/+AC+//sAwf/4AML/9wDF//cAy//7AM//+ADS//kA0//4ANT/+wDV//gA2//4ANz/+ADd//cA3v/3AN//9wDo//gA6//4AOz/9wDx//kA9P/4APX/+QD2//gA9//3AP7/+QEC//kBA//5AQ7/6gEP/+oBEP/qARH/6gES/+oBE//qART/6gEV/+oBFv/qARf/6gEd//oBHv/6AR//+gEg//oBIf/6ASL/+gEj//oBJP/6ASX/+gEm//oBJ//6ASj/+gEp//oBKv/6ASv/+gEw//oBMf/6ATL/+gEz//oBNP/6ATX/+gE2//oBN//6ATj/+gE5//oBOv/6ATv/+gE8//oBPf/WAT7/+gE///oBQP/6AUH/+gFD//oBRP/6AUX/+gFG//oBR//6AVL/+gFT//oBVP/6AVX/+gFc/8wBXf/MAV7/zAFf/8wBYP/MAWz/9QFt//UBbv/1AW//9QFw/+cBcf/nAXL/5wFz/+cBh//kAYr/5AGN/+gBjv/oAa7/+gGx//gBsv/4Acb/4gHH/+IByP/iAcn/4gHK/+IAxwAH//QADP/0AA3/9QAO//oAEP/1ABL//AAX//QAGf/0ABz/+wAe//sAH//8ACL/+wAj//sAJP/7ACX/+wAm//sAJ//7ACj/+wAp//sAKv/7ACv/+wAs//sALf/1AC7/9gAv//YAMP/JADH/9gAz//cANP/6ADf/5AA5/9EASv/8AEv/9ABS/+sAU//rAFT/6wBd//sAYP/7AGj/6wBv//QAcf/0AHP/9AB5//UAe//1AH//+wCD//UAjf/0AI7/+gCP//QAkP/7AJH//ACU//QAlv/6AJf/9ACZ//QAm//7AJz//ACg//QAof/6AKL/9ACj//sApP/8AKf/9ACr//QArP/6AK3/9ACu//QAsP/7ALH//AC0//QAtv/0ALn/9AC9//QAwf/0AML//ADF//wAz//0ANL/9QDT//QA1v/8ANj//ADb//QA3P/0AN3//ADe//wA3//8AOj/9ADp//oA6//0AOz//ADv//wA8f/1APT/9AD1//QA9v/0APf//AD+//UBAv/1AQP/9AEY//YBGf/2ARr/9gEb//YBHP/2AR3/+wEe//sBH//7ASD/+wEh//sBIv/7ASP/+wEk//sBJf/7ASb/+wEn//sBKP/7ASn/+wEq//sBK//7ASz/9wEt//cBLv/3AS//9wEw//sBMf/7ATL/+wEz//sBNP/7ATX/+wE2//sBN//7ATj/+wE5//sBOv/7ATv/+wE8//sBPv/7AT//+wFA//sBQf/7AUP/+wFE//sBRf/7AUb/+wFH//sBSP/2AUr/9gFL//YBTP/2AU3/9gFO//YBT//2AVD/9gFR//YBUv/7AVP/+wFU//sBVf/7AVb/+gFX//oBWP/6AVn/+gFa//oBW//6AVz/yQFd/8kBXv/JAV//yQFg/8kBYf/1AWL/9QFj//UBZP/1AWX/9QFm//UBZ//1AWj/9QFp//UBav/1AWv/9QFs/+QBbf/kAW7/5AFv/+QBdP/8AXX//AF2//wBeP/8Aa7/+wGv//YBsP/2AbH/9AGy//QBuv/2Acb/0QHH/9EByP/RAcn/0QHK/9EAHgAS//sAHP/7ADD/9gA3//kAOf/uAJD/+wCb//sAo//7ALD/+wDW//sA2P/7AO//+wFc//YBXf/2AV7/9gFf//YBYP/2AWz/+QFt//kBbv/5AW//+QF0//sBdf/7AXb/+wF4//sBxv/uAcf/7gHI/+4Byf/uAcr/7gCgAAT/8wAH/+sACP/yAAz/7QAN/+wADv/0ABD/7AAR//IAEv/5ABf/6wAY//IAGf/rABr/7AAf/+MAIP/yACH/5wAu//oAL//6ADH/+gAy/8IAM//6ADb/4ABF/8sAR//2AEj/9gBJ/8sASv/jAEv/6wBS//EAU//xAFT/8QBe//IAaP/xAG//6wBw//IAcf/rAHL/5wBz/+0Ag//sAIr/ywCM//MAjf/rAI7/9ACP/+sAkf/jAJP/8wCU/+sAlf/yAJb/9ACX/+sAmP/yAJn/6wCa/+wAnP/jAJ3/5wCf//MAoP/rAKH/9ACi/+sApP/jAKb/8wCn/+sAqv/zAKv/6wCs//QArf/rAK7/6wCv/+wAsf/jALL/8gC0/+sAtf/yALb/6wC3/+wAuP/nALn/7QC9/+sAvv/sAL//8wDB/+sAwv/jAMT/8wDF/+MAxv/yAMn/8gDL/+wAzf/zAM//6wDQ//IA0v/sANP/6wDU/+wA1f/nANb/+QDY//kA2v/zANv/6wDc/+sA3f/jAN7/4wDf/+MA5//zAOj/6wDp//QA6v/yAOv/6wDs/+MA7//5APH/7ADz//MA9P/rAPX/7QD2/+sA9//jAP3/8gD+/+wBAv/sAQP/7QEO/+ABD//gARD/4AER/+ABEv/gARP/4AEU/+ABFf/gARb/4AEX/+ABGP/6ARn/+gEa//oBG//6ARz/+gEs//oBLf/6AS7/+gEv//oBPf/CAUj/+gFK//oBS//6AUz/+gFN//oBTv/6AU//+gFQ//oBUf/6AXT/+QF1//kBdv/5AXj/+QGH/8sBiv/LAY3/1gGO/9YBr//6AbD/+gGx/+sBsv/rAbr/+gAxAB//+gAh//oAMv/OADb/7gA4//cAOf/1AEX/zwBJ/88ASv/6AHL/+gCK/88Akf/6AJz/+gCd//oApP/6ALH/+gC4//oAwv/6AMX/+gDV//oA3f/6AN7/+gDf//oA7P/6APf/+gEO/+4BD//uARD/7gER/+4BEv/uARP/7gEU/+4BFf/uARb/7gEX/+4BPf/OAXD/9wFx//cBcv/3AXP/9wGH/88Biv/PAY3/5QGO/+UBxv/1Acf/9QHI//UByf/1Acr/9QCiAAT/9gAH/+YACP/2AAz/6QAN/+gADv/2ABD/6AAR//YAEv/3ABf/5gAY//YAGf/mABr/7AAf/+cAIP/2ACH/7wAu//kAL//5ADH/+QAy/9IAM//5ADb/5gBF/9sAR//2AEj/9gBJ/9sASv/nAEv/5gBS/+sAU//rAFT/6wBe//YAaP/rAG//5gBw//YAcf/mAHL/7wBz/+kAef/zAHv/8wCD/+gAiv/bAIz/9gCN/+YAjv/2AI//5gCR/+cAk//2AJT/5gCV//YAlv/2AJf/5gCY//YAmf/mAJr/7ACc/+cAnf/vAJ//9gCg/+YAof/2AKL/5gCk/+cApv/2AKf/5gCq//YAq//mAKz/9gCt/+YArv/mAK//7ACx/+cAsv/2ALT/5gC1//YAtv/mALf/7AC4/+8Auf/pAL3/5gC+/+wAv//2AMH/5gDC/+cAxP/2AMX/5wDG//YAyf/2AMv/7ADN//YAz//mAND/9gDS/+gA0//mANT/7ADV/+8A1v/3ANj/9wDa//YA2//mANz/5gDd/+cA3v/nAN//5wDn//YA6P/mAOn/9gDq//YA6//mAOz/5wDv//cA8f/oAPP/9gD0/+YA9f/pAPb/5gD3/+cA/f/2AP7/6AEC/+gBA//pAQ7/5gEP/+YBEP/mARH/5gES/+YBE//mART/5gEV/+YBFv/mARf/5gEY//kBGf/5ARr/+QEb//kBHP/5ASz/+QEt//kBLv/5AS//+QE9/9IBSP/5AUr/+QFL//kBTP/5AU3/+QFO//kBT//5AVD/+QFR//kBdP/3AXX/9wF2//cBeP/3AYf/2wGK/9sBjf/gAY7/4AGv//kBsP/5AbH/5gGy/+YBuv/5AIQABP/4AAf/5gAL//oADP/hAA3/5wAO//MAEP/nABL/8AAX/+YAGf/mAB//+wAu/+8AL//vADH/7wAz//EANP/6ADn/+wBK//sAS//mAFL/3wBT/98AVP/fAGj/3wBv/+YAcf/mAHP/4QB5//AAe//wAIP/5wCM//gAjf/mAI7/8wCP/+YAkf/7AJP/+ACU/+YAlv/zAJf/5gCZ/+YAnP/7AJ//+ACg/+YAof/zAKL/5gCk//sApv/4AKf/5gCq//gAq//mAKz/8wCt/+YArv/mALH/+wC0/+YAtv/mALn/4QC9/+YAv//4AMH/5gDC//sAxP/4AMX/+wDK//oAzP/6AM3/+ADP/+YA0f/6ANL/5wDT/+YA1v/wANj/8ADa//gA2//mANz/5gDd//sA3v/7AN//+wDn//gA6P/mAOn/8wDr/+YA7P/7AO//8ADx/+cA8//4APT/5gD1/+EA9v/mAPf/+wD+/+cA///6AQD/+gEC/+cBA//hARj/7wEZ/+8BGv/vARv/7wEc/+8BLP/xAS3/8QEu//EBL//xAUj/7wFK/+8BS//vAUz/7wFN/+8BTv/vAU//7wFQ/+8BUf/vAVb/+gFX//oBWP/6AVn/+gFa//oBW//6AXT/8AF1//ABdv/wAXj/8AGv/+8BsP/vAbH/5gGy/+YBuv/vAcb/+wHH//sByP/7Acn/+wHK//sABgA5//QBxv/0Acf/9AHI//QByf/0Acr/9AApADAACQAy/9cANv/pADcADQA5ABoARf/IAEn/yABS/90AU//dAFT/3QBo/90Aiv/IAQ7/6QEP/+kBEP/pARH/6QES/+kBE//pART/6QEV/+kBFv/pARf/6QE9/9cBXAAJAV0ACQFeAAkBXwAJAWAACQFsAA0BbQANAW4ADQFvAA0Bh//IAYr/yAGN/+IBjv/iAcYAGgHHABoByAAaAckAGgHKABoABgA5//UBxv/1Acf/9QHI//UByf/1Acr/9QALADn/9ABF//QASf/0AIr/9AGH//QBiv/0Acb/9AHH//QByP/0Acn/9AHK//QABgA5//UBxv/1Acf/9QHI//UByf/1Acr/9QAGADn/9gHG//YBx//2Acj/9gHJ//YByv/2AAoAOf/2AFL/8ABT//AAVP/wAGj/8AHG//YBx//2Acj/9gHJ//YByv/2AAwAMP/0ADn/8AFc//QBXf/0AV7/9AFf//QBYP/0Acb/8AHH//AByP/wAcn/8AHK//AAewAE//IAB//tAAv/8AAN/+4AEP/uABL/8QAX/+0AGf/tABz/6QAt/+4ALv/sAC//7AAw/9gAMf/sADP/7gA3/90AOf/RAEv/7QBv/+0Acf/tAIP/7gCM//IAjf/tAI//7QCQ/+kAk//yAJT/7QCX/+0Amf/tAJv/6QCf//IAoP/tAKL/7QCj/+kApv/yAKf/7QCq//IAq//tAK3/7QCu/+0AsP/pALT/7QC2/+0Avf/tAL//8gDB/+0AxP/yAMr/8ADM//AAzf/yAM//7QDR//AA0v/uANP/7QDW//EA2P/xANr/8gDb/+0A3P/tAOf/8gDo/+0A6//tAO//8QDx/+4A8//yAPT/7QD2/+0A/v/uAP//8AEA//ABAv/uARj/7AEZ/+wBGv/sARv/7AEc/+wBLP/uAS3/7gEu/+4BL//uAUj/7AFK/+wBS//sAUz/7AFN/+wBTv/sAU//7AFQ/+wBUf/sAVz/2AFd/9gBXv/YAV//2AFg/9gBYf/uAWL/7gFj/+4BZP/uAWX/7gFm/+4BZ//uAWj/7gFp/+4Bav/uAWv/7gFs/90Bbf/dAW7/3QFv/90BdP/xAXX/8QF2//EBeP/xAa//7AGw/+wBsf/tAbL/7QG6/+wBxv/RAcf/0QHI/9EByf/RAcr/0QCQAAT/7gAH/+QACP/wAA3/5AAQ/+QAEf/wABL/8wAX/+QAGP/wABn/5AAa/+wAH//qACD/8AAh/+4ALv/sAC//7AAx/+wAMv/fADP/7QA2/+UAOQAQAEr/6gBL/+QAXv/wAG//5ABw//AAcf/kAHL/7gCD/+QAjP/uAI3/5ACP/+QAkf/qAJP/7gCU/+QAlf/wAJf/5ACY//AAmf/kAJr/7ACc/+oAnf/uAJ//7gCg/+QAov/kAKT/6gCm/+4Ap//kAKr/7gCr/+QArf/kAK7/5ACv/+wAsf/qALL/8AC0/+QAtf/wALb/5AC3/+wAuP/uAL3/5AC+/+wAv//uAMH/5ADC/+oAxP/uAMX/6gDG//AAyf/wAMv/7ADN/+4Az//kAND/8ADS/+QA0//kANT/7ADV/+4A1v/zANj/8wDa/+4A2//kANz/5ADd/+oA3v/qAN//6gDn/+4A6P/kAOr/8ADr/+QA7P/qAO//8wDx/+QA8//uAPT/5AD2/+QA9//qAP3/8AD+/+QBAv/kAQ7/5QEP/+UBEP/lARH/5QES/+UBE//lART/5QEV/+UBFv/lARf/5QEY/+wBGf/sARr/7AEb/+wBHP/sASz/7QEt/+0BLv/tAS//7QE9/98BSP/sAUr/7AFL/+wBTP/sAU3/7AFO/+wBT//sAVD/7AFR/+wBdP/zAXX/8wF2//MBeP/zAY3/4wGO/+MBr//sAbD/7AGx/+QBsv/kAbr/7AHGABABxwAQAcgAEAHJABABygAQAJIABP/1AAf/6QAI//YADP/2AA3/6gAQ/+oAEf/2ABf/6QAY//YAGf/pABr/8gAf/+8AIP/2AC7/8wAv//MAMAAIADH/8wAy/+AAM//zADb/6gA3AA8AOQAbAEr/7wBL/+kAXv/2AG//6QBw//YAcf/pAHP/9gCD/+oAjP/1AI3/6QCP/+kAkf/vAJP/9QCU/+kAlf/2AJf/6QCY//YAmf/pAJr/8gCc/+8An//1AKD/6QCi/+kApP/vAKb/9QCn/+kAqv/1AKv/6QCt/+kArv/pAK//8gCx/+8Asv/2ALT/6QC1//YAtv/pALf/8gC5//YAvf/pAL7/8gC///UAwf/pAML/7wDE//UAxf/vAMb/9gDJ//YAy//yAM3/9QDP/+kA0P/2ANL/6gDT/+kA1P/yANr/9QDb/+kA3P/pAN3/7wDe/+8A3//vAOf/9QDo/+kA6v/2AOv/6QDs/+8A8f/qAPP/9QD0/+kA9f/2APb/6QD3/+8A/f/2AP7/6gEC/+oBA//2AQ7/6gEP/+oBEP/qARH/6gES/+oBE//qART/6gEV/+oBFv/qARf/6gEY//MBGf/zARr/8wEb//MBHP/zASz/8wEt//MBLv/zAS//8wE9/+ABSP/zAUr/8wFL//MBTP/zAU3/8wFO//MBT//zAVD/8wFR//MBXAAIAV0ACAFeAAgBXwAIAWwADwFtAA8BbgAPAW8ADwGN/+oBjv/qAa//8wGw//MBsf/pAbL/6QG6//MBxgAbAccAGwHIABsByQAbAcoAGwAuACH/+wAw//AAMv/zADb/+AA3//cAOP/xADn/5wBF/+0ASf/tAHL/+wCK/+0Anf/7ALj/+wDV//sBDv/4AQ//+AEQ//gBEf/4ARL/+AET//gBFP/4ARX/+AEW//gBF//4AT3/8wFc//ABXf/wAV7/8AFf//ABbP/3AW3/9wFu//cBb//3AXD/8QFx//EBcv/xAXP/8QGH/+0Biv/tAY3/9wGO//cBxv/nAcf/5wHI/+cByf/nAcr/5wCQAAT/7wAH/+QACP/wAA3/5AAQ/+QAEf/wABL/9AAX/+QAGP/wABn/5AAa/+wAH//qACD/8AAh/+8ALv/rAC//6wAx/+sAMv/fADP/7AA2/+UAOQAQAEr/6gBL/+QAXv/wAG//5ABw//AAcf/kAHL/7wCD/+QAjP/vAI3/5ACP/+QAkf/qAJP/7wCU/+QAlf/wAJf/5ACY//AAmf/kAJr/7ACc/+oAnf/vAJ//7wCg/+QAov/kAKT/6gCm/+8Ap//kAKr/7wCr/+QArf/kAK7/5ACv/+wAsf/qALL/8AC0/+QAtf/wALb/5AC3/+wAuP/vAL3/5AC+/+wAv//vAMH/5ADC/+oAxP/vAMX/6gDG//AAyf/wAMv/7ADN/+8Az//kAND/8ADS/+QA0//kANT/7ADV/+8A1v/0ANj/9ADa/+8A2//kANz/5ADd/+oA3v/qAN//6gDn/+8A6P/kAOr/8ADr/+QA7P/qAO//9ADx/+QA8//vAPT/5AD2/+QA9//qAP3/8AD+/+QBAv/kAQ7/5QEP/+UBEP/lARH/5QES/+UBE//lART/5QEV/+UBFv/lARf/5QEY/+sBGf/rARr/6wEb/+sBHP/rASz/7AEt/+wBLv/sAS//7AE9/98BSP/rAUr/6wFL/+sBTP/rAU3/6wFO/+sBT//rAVD/6wFR/+sBdP/0AXX/9AF2//QBeP/0AY3/5AGO/+QBr//rAbD/6wGx/+QBsv/kAbr/6wHGABABxwAQAcgAEAHJABABygAQABkAIf/5ADL/+wA2//kAOP/3AHL/+QCd//kAuP/5ANX/+QEO//kBD//5ARD/+QER//kBEv/5ARP/+QEU//kBFf/5ARb/+QEX//kBPf/7AXD/9wFx//cBcv/3AXP/9wGN//sBjv/7AFEAB//zAAz/9wAN//EAEP/xABf/8wAZ//MAHAAXAB//+AAwAAwAMv/CADb/6QBK//gAS//zAG//8wBx//MAc//3AIP/8QCN//MAj//zAJAAFwCR//gAlP/zAJf/8wCZ//MAmwAXAJz/+ACg//MAov/zAKMAFwCk//gAp//zAKv/8wCt//MArv/zALAAFwCx//gAtP/zALb/8wC5//cAvf/zAMH/8wDC//gAxf/4AM//8wDS//EA0//zANv/8wDc//MA3f/4AN7/+ADf//gA6P/zAOv/8wDs//gA8f/xAPT/8wD1//cA9v/zAPf/+AD+//EBAv/xAQP/9wEO/+kBD//pARD/6QER/+kBEv/pARP/6QEU/+kBFf/pARb/6QEX/+kBPf/CAVwADAFdAAwBXgAMAV8ADAGN/+ABjv/gAbH/8wGy//MAXgAGABkAB//sAAkAIQAKABoADP/xAA3/8AAPACEAEP/wABQAIQAWABkAF//sABn/7AAcACIARf/4AEf/9ABI//QASf/4AEv/7ABS/90AU//dAFT/3QBfABkAaP/dAG//7ABx/+wAc//xAHn/5wB7/+cAgAAhAIP/8ACK//gAjf/sAI//7ACQACIAlP/sAJf/7ACZ/+wAmwAiAKD/7ACi/+wAowAiAKf/7ACr/+wArf/sAK7/7ACwACIAswAaALT/7AC2/+wAuf/xALoAGQC9/+wAwf/sAMcAGgDIABkAzgAZAM//7ADS//AA0//sANv/7ADc/+wA4AAhAOEAIQDiACEA4wAhAOQAIQDo/+wA6//sAO0AIQDx//AA9P/sAPX/8QD2/+wA+AAhAPkAIQD6ACEA+wAhAPwAGgD+//ABAQAZAQL/8AED//EBgwAjAYQAIwGFACIBhgAnAYf/+AGIACIBiQAnAYr/+AGx/+wBsv/sAbMAGgG0ABoACwAM/8QADv/XAHP/xACO/9cAlv/XAKH/1wCs/9cAuf/EAOn/1wD1/8QBA//EAAEYqAAEAAAADQAkAkoDJAOSBAAEbgZ0CG4K9AsyC4gLugv4AIkABP/WAAb/3QAH/8AACP/XAAn/3wAK/94AC//YAA3/vgAP/98AEP++ABH/1wAS/88AFP/fABX/3wAW/90AF//AABj/1wAZ/8AAGv/IABz/5QAf/8cAIP/XACH/zwBK/8cAS//AAF7/1wBf/90Ab//AAHD/1wBx/8AAcv/PAID/3wCD/74AjP/WAI3/wACP/8AAkP/lAJH/xwCT/9YAlP/AAJX/1wCX/8AAmP/XAJn/wACa/8gAm//lAJz/xwCd/88An//WAKD/wACi/8AAo//lAKT/xwCm/9YAp//AAKr/1gCr/8AArf/AAK7/wACv/8gAsP/lALH/xwCy/9cAs//eALT/wAC1/9cAtv/AALf/yAC4/88Auv/dAL3/wAC+/8gAv//WAMH/wADC/8cAxP/WAMX/xwDG/9cAx//eAMj/3QDJ/9cAyv/YAMv/yADM/9gAzf/WAM7/3QDP/8AA0P/XANH/2ADS/74A0//AANT/yADV/88A1v/PANj/zwDa/9YA2//AANz/wADd/8cA3v/HAN//xwDg/98A4f/fAOL/3wDj/98A5P/fAOf/1gDo/8AA6v/XAOv/wADs/8cA7f/fAO//zwDx/74A8//WAPT/wAD2/8AA9//HAPj/3wD5/98A+v/fAPv/3wD8/94A/f/XAP7/vgD//9gBAP/YAQH/3QEC/74BdP/PAXX/zwF2/88BeP/PAbH/wAGy/8ABs//eAbT/3gA2AAv/9wAS//gAHP/uAC3/+gAw/+UAN//nADn/5ACQ/+4Am//uAKP/7gCw/+4Ayv/3AMz/9wDR//cA1v/4ANj/+ADv//gA///3AQD/9wFc/+UBXf/lAV7/5QFf/+UBYP/lAWH/+gFi//oBY//6AWT/+gFl//oBZv/6AWf/+gFo//oBaf/6AWr/+gFr//oBbP/nAW3/5wFu/+cBb//nAXT/+AF1//gBdv/4AXj/+AGD//ABhP/wAYX/8AGG/+8BiP/wAYn/7wHG/+QBx//kAcj/5AHJ/+QByv/kABsABgAdAAkAJQAKAB4ADwAlABQAJQAWAB0AXwAdAIAAJQCzAB4AugAdAMcAHgDIAB0AzgAdAOEAJQDiACUA+QAlAPoAJQD8AB4BAQAdAYMAJwGEACcBhQAUAYYAJwGIABQBiQAnAbMAHgG0AB4AGwAGAA0ACQAVAAoADgAPABUAFAAVABYADQBfAA0AgAAVALMADgC6AA0AxwAOAMgADQDOAA0A4QAVAOIAFQD5ABUA+gAVAPwADgEBAA0BgwAXAYQAFwGFAAsBhgAYAYgACwGJABgBswAOAbQADgAbAAYAMAAJADEACgAxAA8AMQAUADEAFgAwAF8AMACAADEAswAxALoAMADHADEAyAAwAM4AMADhADEA4gAxAPkAMQD6ADEA/AAxAQEAMAGDADoBhAA6AYUAGQGGADEBiAAZAYkAMQGzADEBtAAxAIEABgATAAf/3AAJABoACgATAAz/5AAN/+EADwAaABD/4QAS//QAFAAaABYAEwAX/9wAGf/cABr/7AAcABkAH//qACH/+wBF/+YAR//qAEj/6gBJ/+YASv/qAEv/3ABS/+AAU//gAFT/4ABfABMAaP/gAG//3ABx/9wAcv/7AHP/5AB5/+cAev/0AHv/5wB8//QAgAAaAIP/4QCK/+YAjf/cAI//3ACQABkAkf/qAJT/3ACX/9wAmf/cAJr/7ACbABkAnP/qAJ3/+wCg/9wAov/cAKMAGQCk/+oAp//cAKv/3ACt/9wArv/cAK//7ACwABkAsf/qALMAEwC0/9wAtv/cALf/7AC4//sAuf/kALoAEwC9/9wAvv/sAMH/3ADC/+oAxf/qAMcAEwDIABMAy//sAM4AEwDP/9wA0v/hANP/3ADU/+wA1f/7ANb/9ADY//QA2//cANz/3ADd/+oA3v/qAN//6gDgABoA4QAaAOIAGgDjABoA5AAaAOj/3ADr/9wA7P/qAO0AGgDv//QA8f/hAPT/3AD1/+QA9v/cAPf/6gD4ABoA+QAaAPoAGgD7ABoA/AATAP7/4QEBABMBAv/hAQP/5AF0//QBdf/0AXb/9AF4//QBgwAcAYQAHAGFABsBhgAgAYf/5gGIABsBiQAgAYr/5gGx/9wBsv/cAbMAEwG0ABMAfgAGABUAB//dAAkAHAAKABYADP/lAA3/4wAPABwAEP/jABL/+AAUABwAFgAVABf/3QAZ/90AGv/xABwAGwAf/+4AIf/7AEX/5QBH/+8ASP/vAEn/5QBK/+4AS//dAFL/0ABT/9AAVP/QAF8AFQBo/9AAb//dAHH/3QBy//sAc//lAHn/4gB7/+IAgAAcAIP/4wCK/+UAjf/dAI//3QCQABsAkf/uAJT/3QCX/90Amf/dAJr/8QCbABsAnP/uAJ3/+wCg/90Aov/dAKMAGwCk/+4Ap//dAKv/3QCt/90Arv/dAK//8QCwABsAsf/uALMAFgC0/90Atv/dALf/8QC4//sAuf/lALoAFQC9/90Avv/xAMH/3QDC/+4Axf/uAMcAFgDIABUAy//xAM4AFQDP/90A0v/jANP/3QDU//EA1f/7ANb/+ADY//gA2//dANz/3QDd/+4A3v/uAN//7gDgABwA4gAcAOMAHADkABwA6P/dAOv/3QDs/+4A7QAcAO//+ADx/+MA9P/dAPX/5QD2/90A9//uAPgAHAD5ABwA+gAcAPsAHAD8ABYA/v/jAQEAFQEC/+MBA//lAXT/+AF1//gBdv/4AXj/+AGDAB8BhAAfAYUAHgGGACMBh//lAYgAHgGJACMBiv/lAbH/3QGy/90BswAWAbQAFgChAAT/5AAH/9cACP/nAAv/9gAM/9oADf/YAA7/4wAQ/9gAEf/nABL/9AAX/9cAGP/nABn/1wAa/9oAHP/vAB//1wAg/+cAIf/dAC7/9QAv//UAMf/1ADP/9gA2/9kAR//sAEj/7ABK/9cAS//XAFL/1gBT/9YAVP/WAF7/5wBo/9YAb//XAHD/5wBx/9cAcv/dAHP/2gB5/+UAev/vAHv/5QB8/+8Ag//YAIz/5ACN/9cAjv/jAI//1wCQ/+8Akf/XAJP/5ACU/9cAlf/nAJb/4wCX/9cAmP/nAJn/1wCa/9oAm//vAJz/1wCd/90An//kAKD/1wCh/+MAov/XAKP/7wCk/9cApv/kAKf/1wCq/+QAq//XAKz/4wCt/9cArv/XAK//2gCw/+8Asf/XALL/5wC0/9cAtf/nALb/1wC3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AeUAHQH1AA8CWwAQAfwAHQJrACkCFAAcAgEAAgJfACEAvQAAAL0AEACEAAoAygAKAOYACgFnACEBaAAfApMAIQKbAB8B0AA1ArIAFQL+ADMCNwAqBJcAMwSHADMEXwAeA6IAMwLJADMCSwApBIoAMwPOADMDigApAtMAFgGCAAACWAAsAlYAHQJiACACFAAcA0cAEAIzAAsBAQAKAlgALAJWAB0B3wAqAmIAIAH8AB0CawApAhQAHAHWAAoDRwAQAjMACwIBAAIA0wAKAlgALAJWAB0CYgAgAhQAHANHABACMwALAgIACgJYACwCVgAdAWkACgFpAAoCWAAsAlYAHQJiACAB/AAdAhQAHAHWAAoDRwAQAjMACwHfACoBYgApAfwAHQJrACkCFAAcAdYACgIBAAICXwAhAmAAKACqAAoBxQCnAf0AHgHXAAsCWAAsAlgAHgIVABwCMwALAMsACgJYACwCMwALAd8AKgEuACkCGwAoAmsAKQGQABoB1gAKAY8AGgJYACwCYAAoAlYAHQHfACUBjwAaAmAAHgIUABwB1gAKAgEAAgLzABoCegAnAkEAGgF9AAoCWAAsAlYAHQIUABwCMwALAzsACwIzAAsBGf/tARkAKgEZAA0BGf/mARn/9gHJABQBwgAKAlgALAJWAB0CYgAgAmsAKQIUABwCMwALARn/1wJcAC0CZgAaBIcAMwRfAB4BXQAKAlgALAJWAB0CXwAhAhQAHAIzAAsBGf/+ARn/6wEZABMBF/9rAakAKQJrACkCrAAeAeQAGgGUAA4CYAAKAmAAHgJfACEBggAAAQMAAADeAAACBQAAAa4AAAFJAAAAtwAAAWkAAAFpAAABaQAAAmsABgJrAAYCawAGAmsABgJrAAYCawAGAmsABgJrAAYCawAGAmsABgJqACgCaQAnAmkAJwJpACcCaQAnApoAMwKaADMCn//+AqAACgH1ADMB9QAzAfUAMwH1ADMB9QAzAfUAMwH1ADMB9QAzAfUAMwH1ADMB9QAzAoAAKQKAACkCgAApAoAAKQKiADMCogAzAq0AHwE6ACoBOgACAToAMwE6//MBOgAzATr//wE6/90BOgAgAToADgE6//4B3//5Am8AMwHAADMBwAAzAcAAFgHDADMCsAAzArAAMwKwADMCsAAzArAAMwLHACgCyAAoAscAKALHACgCxwAoAscAKALHACgCxwAoAscAKALHACgCaQAzAmkAMwJpADMCaQAzAh0AHwIdAB8CHQAfAh0AHwIdAB8CHgAgAiAAHgIgAB4CIAAeAiAAHgI3ACsCkwA5ApQAOQKTADkCkwA5ApMAOQKTADkCkwA5ApMAOQKTADkCkwA5ApMAOQOyACADsgAgA7IAIAOyACACKgAHAioABwIqAAcCKgAHA3AAGgOhABoE0AAaBJcAMwOVABoChgAXAhAAGAKSADQB/wAZAIf/UgFJABABSQA5AisADwEEACcBBAAnAaAAPQDdAD0A9QA1APcANgD3AAcBzwA1AdEANgHRAAcCoAAlAx8AHQMz/+8DM//vAVoAKADWACMBPgAkASkAGwFHAB0BNQAhAUUAKQD+ACkBOgAkAUUAJgFcAA0A1gAIAT4ACAEqAAABRwACATUABQFFAA0A/wAOATwACQFFAAoDDQArBHQALAK2ADECrwAxAr4AMQKsADEC7wApAt0AJQLYACQC4gAmApYALwHQ//gCxwAoAscAKAJWAB0CVgAdAS4AKQGQAAoDAgBIAt8AOgGKAC0BigAxAXwAMgOZACcCpwAZAyMAJgMjACYB4QAaAiAAOQIBAA8B8QAcAeMAFwGtABwBrwAmAbP/6AJhABMCYQATAmEAEwJhABMCYQATAAAASABIAEgASADEASoBoAHsAmgCoALkA2gEFgSmBSoFegYcBs4HWgeEB+YIYAjkCWAJ1gpECsQLGguiDCYMhg0CDbQOBg48DpAOyg9SD8oQFhCUESIRjBH6EpIS8hNWE6YT6hRKFKAVOBW8FgoWYhbuF0QXqBguGHwYzBkYGa4aRhq+GyQbqhwuHIwctBy0HPodXh2eHrIfdCAeIG4gyiE2IboiJiJWIoYitiLmI0QjviQWJJAlKiXEJk4m1idqJ/YobCjgKVAp2ipkKq4rJCtiK5Ir9iwkLMotQC3YLqwvQi/mMIYxBDHqMgIyGjJAMmoywjMOM1oz4jRqNQw1rjZCNwI4Ejk4OkQ69jusPII9TD4uPyg/hD/AQGZA7kG2QmhDKEPqRBxEyEU8RehGlkckR8pIYkkSScRKakrmSxZLvkwwTNpNbk4cTr5PFk/oUIJQyFEOUcxSVFMUU7ZUYFUkVehWoFdeV/xYvFl+Wiha7Ft6XGxdHl1GXYZeZl9KX+BgRGDMYWBhsmKIY15kJmSmZXBmLGcYZ+hovGlSadxqPGrUa3JsLmyybU5ttm6qb2BwDHA2cNZxQHHMcmZztnSSdQB1YnXAdjR2inbQdxp34HhqeSx57Hqae1R7ynwWfNh+aH/AgBSA+IGggsaDooSOhRiFkIYGhpKG6oeSiIiJZIoGipqLWoxUjHqMoIzGjQiNQI1qjZqNuo30jiyOno8Yj5SQEJCokTqRsJI8ksCTqJRqlOKVbJYOlrCXQpf8mJKZGpmCme6aVprQm0ibvpxQnNCdQp3SnmKfTp/+oMahoKIWorSjLqN4o8qkFKRwpMylJKWYpfqmTqbAp1SoFqiOqO6pZqm0qlyq7KuSrBKsuq0grYyuAq52ruivfrAMsIiw9rGCsjazGrPgtLq1WLYGtsy3krhmuVa5sLpGusq7SruuvCS8or0mvay+Lr7Uv3LAAMCWwRbBtMJmwxjDxsSOxPrFZMXgxnLHasfyyKzKDssqy8zMTszozWjNos3czhDOlM7Azt7POs9wz7DP8NAk0IrQ8NFI0jbTINOk1EzUktTW1SrVutYO1rLXUteQ1/zYotjo2SzZftoO2mDbBtum2+LcTtz43cbezN+y4LbhjuJk46rlEOZu58TolOkC6YzqPOrG63rr5Oxo7PLtlO4C7kjukO987/bwuvG28ijyTPLS8z7zwPQa9HT0pvUw9dL2XPbi94QAAQAAAcsAjwAHAAAAAAACACoAOABqAAAAoQliAAAAAAAAAB8BegABAAAAAAAAAJcAAAABAAAAAAABAAsAlwABAAAAAAACAAcAogABAAAAAAADADMAqQABAAAAAAAEAAsA3AABAAAAAAAFAEEA5wABAAAAAAAGABIBKAABAAAAAAAHAD4BOgABAAAAAAAIACMBeAABAAAAAAAJACMBmwABAAAAAAAKATgBvgABAAAAAAALABEC9gABAAAAAAAMACYDBwABAAAAAAANAJADLQABAAAAAAAOABoDvQABAAAAAAASAAsD1wADAAEECQAAAS4D4gADAAEECQABABYFEAADAAEECQACAA4FJgADAAEECQADAGYFNAADAAEECQAEABYFmgADAAEECQAFAIIFsAADAAEECQAGACQGMgADAAEECQAHAHwGVgADAAEECQAIAEYG0gADAAEECQAJAEYHGAADAAEECQAKAnAHXgADAAEECQALACIJzgADAAEECQAMAEwJ8AADAAEECQANASAKPAADAAEECQAOADQLXENvcHlyaWdodCAoYykgMjAxMiwgUGFibG8gSW1wYWxsYXJpICh3d3cuaW1wYWxsYXJpLmNvbXxpbXBhbGxhcmlAZ21haWwuY29tKSwgUm9kcmlnbyBGdWVuemFsaWRhICh3d3cucmZ1ZW56YWxpZGEuY29tKSwgd2l0aCBSZXNlcnZlZCBGb250IE5hbWUgUG9ldHNlbi5Qb2V0c2VuIE9uZVJlZ3VsYXJQYWJsb0ltcGFsbGFyaSxSb2RyaWdvRnVlbnphbGlkYTogUG9ldHNlbiBPbmU6IDIwMTJQb2V0c2VuIE9uZVZlcnNpb24gMS4wMDE7IHR0ZmF1dG9oaW50ICh2MC45MykgLWwgOCAtciA1MCAtRyAyMDAgLXggMTQgLXcgIkciUG9ldHNlbk9uZS1SZWd1bGFyUG9ldHNlbiBpcyBhIHRyYWRlbWFyayBvZiBQYWJsbyBJbXBhbGxhcmksIFJvZHJpZ28gRnVlbnphbGlkYS5QYWJsbyBJbXBhbGxhcmksIFJvZHJpZ28gRnVlbnphbGlkYVBhYmxvIEltcGFsbGFyaSwgUm9kcmlnbyBGdWVuemFsaWRhSW5zcGlyZWQgYnkgdGhlIGhhbmQgcGFpbnRlZCBzaWducyBpbiBzdXBlcm1hcmtldHMsIGFuZCB0aGUgcm9tYW4gc3RydWN0dXJlcyBvZiB0aGUgY2xhc3NpY2FsIGFscGhhYmV0cy4gUG9ldHNlbiBpcyBhIGRpc3BsYXkgZm9udCwgYnV0IGl0J3Mgbm90IGp1c3QgaW50ZW5kZWQgdG8gYmUgdXNlZCBvbiBiaWcgJ3N0cmFpZ2h0IHRvIHRoZSBleWUnIHRpdGxlcy4gU2luY2UgaXQgaGFzIGEgbGFyZ2UgeCBoZWlnaHQsIGl0IGNhbiBiZSB1c2VkIG9uIHNob3J0IHBhcmFncmFwaHMgaW4gcmVsYXRpdmVseSBzbWFsbCBib2RpZXMgb2YgdGV4dCB0b28ud3d3LmltcGFsbGFyaS5jb213d3cuaW1wYWxsYXJpLmNvbSwgd3d3LnJmdWVuemFsaWRhLmNvbVRoaXMgRm9udCBTb2Z0d2FyZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgU0lMIE9wZW4gRm9udCBMaWNlbnNlLCBWZXJzaW9uIDEuMS4gVGhpcyBsaWNlbnNlIGlzIGF2YWlsYWJsZSB3aXRoIGEgRkFRIGF0OiBodHRwOi8vc2NyaXB0cy5zaWwub3JnL09GTGh0dHA6Ly9zY3JpcHRzLnNpbC5vcmcvT0ZMUG9ldHNlbiBPbmUAQwBvAHAAeQByAGkAZwBoAHQAIAAoAGMAKQAgADIAMAAxADIALAAgAFAAYQBiAGwAbwAgAEkAbQBwAGEAbABsAGEAcgBpACAAKAB3AHcAdwAuAGkAbQBwAGEAbABsAGEAcgBpAC4AYwBvAG0AfABpAG0AcABhAGwAbABhAHIAaQBAAGcAbQBhAGkAbAAuAGMAbwBtACkALAAgAFIAbwBkAHIAaQBnAG8AIABGAHUAZQBuAHoAYQBsAGkAZABhACAAKAB3AHcAdwAuAHIAZgB1AGUAbgB6AGEAbABpAGQAYQAuAGMAbwBtACkALAAgAHcAaQB0AGgAIABSAGUAcwBlAHIAdgBlAGQAIABGAG8AbgB0ACAATgBhAG0AZQAgAFAAbwBlAHQAcwBlAG4ALgBQAG8AZQB0AHMAZQBuACAATwBuAGUAUgBlAGcAdQBsAGEAcgBQAGEAYgBsAG8ASQBtAHAAYQBsAGwAYQByAGkALABSAG8AZAByAGkAZwBvAEYAdQBlAG4AegBhAGwAaQBkAGEAOgAgAFAAbwBlAHQAcwBlAG4AIABPAG4AZQA6ACAAMgAwADEAMgBQAG8AZQB0AHMAZQBuACAATwBuAGUAVgBlAHIAcwBpAG8AbgAgADEALgAwADAAMQA7ACAAdAB0AGYAYQB1AHQAbwBoAGkAbgB0ACAAKAB2ADAALgA5ADMAKQAgAC0AbAAgADgAIAAtAHIAIAA1ADAAIAAtAEcAIAAyADAAMAAgAC0AeAAgADEANAAgAC0AdwAgACIARwAiAFAAbwBlAHQAcwBlAG4ATwBuAGUALQBSAGUAZwB1AGwAYQByAFAAbwBlAHQAcwBlAG4AIABpAHMAIABhACAAdAByAGEAZABlAG0AYQByAGsAIABvAGYAIABQAGEAYgBsAG8AIABJAG0AcABhAGwAbABhAHIAaQAsACAAUgBvAGQAcgBpAGcAbwAgAEYAdQBlAG4AegBhAGwAaQBkAGEALgBQAGEAYgBsAG8AIABJAG0AcABhAGwAbABhAHIAaQAsACAAUgBvAGQAcgBpAGcAbwAgAEYAdQBlAG4AegBhAGwAaQBkAGEAUABhAGIAbABvACAASQBtAHAAYQBsAGwAYQByAGkALAAgAFIAbwBkAHIAaQBnAG8AIABGAHUAZQBuAHoAYQBsAGkAZABhAEkAbgBzAHAAaQByAGUAZAAgAGIAeQAgAHQAaABlACAAaABhAG4AZAAgAHAAYQBpAG4AdABlAGQAIABzAGkAZwBuAHMAIABpAG4AIABzAHUAcABlAHIAbQBhAHIAawBlAHQAcwAsACAAYQBuAGQAIAB0AGgAZQAgAHIAbwBtAGEAbgAgAHMAdAByAHUAYwB0AHUAcgBlAHMAIABvAGYAIAB0AGgAZQAgAGMAbABhAHMAcwBpAGMAYQBsACAAYQBsAHAAaABhAGIAZQB0AHMALgAgAFAAbwBlAHQAcwBlAG4AIABpAHMAIABhACAAZABpAHMAcABsAGEAeQAgAGYAbwBuAHQALAAgAGIAdQB0ACAAaQB0ACcAcwAgAG4AbwB0ACAAagB1AHMAdAAgAGkAbgB0AGUAbgBkAGUAZAAgAHQAbwAgAGIAZQAgAHUAcwBlAGQAIABvAG4AIABiAGkAZwAgACcAcwB0AHIAYQBpAGcAaAB0ACAAdABvACAAdABoAGUAIABlAHkAZQAnACAAdABpAHQAbABlAHMALgAgAFMAaQBuAGMAZQAgAGkAdAAgAGgAYQBzACAAYQAgAGwAYQByAGcAZQAgAHgAIABoAGUAaQBnAGgAdAAsACAAaQB0ACAAYwBhAG4AIABiAGUAIAB1AHMAZQBkACAAbwBuACAAcwBoAG8AcgB0ACAAcABhAHIAYQBnAHIAYQBwAGgAcwAgAGkAbgAgAHIAZQBsAGEAdABpAHYAZQBsAHkAIABzAG0AYQBsAGwAIABiAG8AZABpAGUAcwAgAG8AZgAgAHQAZQB4AHQAIAB0AG8AbwAuAHcAdwB3AC4AaQBtAHAAYQBsAGwAYQByAGkALgBjAG8AbQB3AHcAdwAuAGkAbQBwAGEAbABsAGEAcgBpAC4AYwBvAG0ALAAgAHcAdwB3AC4AcgBmAHUAZQBuAHoAYQBsAGkAZABhAC4AYwBvAG0AVABoAGkAcwAgAEYAbwBuAHQAIABTAG8AZgB0AHcAYQByAGUAIABpAHMAIABsAGkAYwBlAG4AcwBlAGQAIAB1AG4AZABlAHIAIAB0AGgAZQAgAFMASQBMACAATwBwAGUAbgAgAEYAbwBuAHQAIABMAGkAYwBlAG4AcwBlACwAIABWAGUAcgBzAGkAbwBuACAAMQAuADEALgAgAFQAaABpAHMAIABsAGkAYwBlAG4AcwBlACAAaQBzACAAYQB2AGEAaQBsAGEAYgBsAGUAIAB3AGkAdABoACAAYQAgAEYAQQBRACAAYQB0ADoAIABoAHQAdABwADoALwAvAHMAYwByAGkAcAB0AHMALgBzAGkAbAAuAG8AcgBnAC8ATwBGAEwAaAB0AHQAcAA6AC8ALwBzAGMAcgBpAHAAdABzAC4AcwBpAGwALgBvAHIAZwAvAE8ARgBMAAAAAgAAAAAAAP+1ADIAAAAAAAAAAAAAAAAAAAAAAAAAAAHLAAABAgACAAMAWABFAEsAUgBVANcATwBXAEoAVABcAQMARwBTAEkA3ABMAE0ATgBGAFEASABWAFkAWgBbACsARABQAF0ALAAoAC8AJQAnACkALgAwADEAMwA1ADgAJgAyADcANAAtACoANgA5ACQAOgA9ADwAOwAUABMAGgAZABwAGwAXABgAFgAVABEBBAAdAB4ADwCgALEAhgAgAAQAowAiAKIAEACyALMAQgA+AAsAQAAMAJcBBQEGAQcBCADuAO0BCQEKAF4AYABfAOgApAELAIgAhwCmAIIAwgDqAQwBDQEOAQ8BEAERARIBEwDgAN4AvgC/AKkAqgANAAYBFAEVARYBFwEYARkBGgEbARwBHQEeAKsAjgCBAHwAugBzAR8AbACNAH4AeQEgAOwA/gEhAHABIgEjAGkBJABDAH8AegElAHEBJgBqAN8BJwEoANgA4QCAAHsBKQEqAHIBKwEsAGsBLQEuAQABLwEwAOUA5wExATIBMwE0AG8BNQE2ATcBOAE5AN0BOgBuATsBPAE9AT4BPwFAAUEBQgFDAUQBRQFGAUcBSAFJAUoBSwCJAUwBTQFOAU8BUAFRAVIBUwB3AHQAdQB2AVQAQQDZAVUAfQFWAHgBVwBtAVgAYQFZAVoBWwDbAVwBXQD5AV4BXwFgAWEBYgFjAWQBZQFmAWcBaAFpAWoBawFsAW0BbgFvAXABcQFyAXMBdAF1AXYArQDJAGIArgDHAXcAYwF4AXkAZAF6AP0BewD/AXwBfQF+AOkBfwGAAYEAygBlAMsBggGDAYQAyAGFAYYBhwD4AYgBiQGKAYsBjAGNAY4AzgDMAM8BjwGQAZEAzQGSAZMBlAGVAZYBlwGYAZkBmgGbAGYBnAGdAGcA0ADTAZ4ArwGfAaAA0QGhAaIBowGkAaUBpgGnAOQBqAGpAaoBqwGsAa0BrgGvAbAAaADUANYBsQGyAbMBtAG1ANUBtgG3AbgBuQG6AbsBvADmAb0BvgG/AcABwQHCAAcAlgCEALwAEgA/AIUBwwHEAAUACgC2ALcAxAC0ALUAxQC9ACMAkAHFAcYA8QDyAPMBxwHIAckBygHLAcwBzQHOAc8B0AHRAdIB0wHUAdUB1gAIAMYA9AHXAPUB2AHZAPYB2gHbAdwA4gCRAd0AoQHeAd8A4wCMAeAAnQCeAIMAsAAJAIsAigAOAO8AkwDwALgAHwAhAeEA6wHiALsB4wHkBE5VTEwIZG90bGVzc2oHdW5pMDBBMAd1bmkwM0JDDGtncmVlbmxhbmRpYwNFbmcDZW5nBXNjaHdhBVNjaHdhB3VuaTAwQUQKY2RvdGFjY2VudApuZG90YWNjZW50CmVkb3RhY2NlbnQKemRvdGFjY2VudApnZG90YWNjZW50DWRvdGFjY2VudC5jYXAIZG90YmVsb3cLY29tbWFhY2NlbnQCSUoCaWoHdW5pMDFGMQd1bmkwMUYyB3VuaTAxRjMHdW5pMDFDNwd1bmkwMUM4B3VuaTAxQzkHdW5pMDFDQQd1bmkwMUNCB3VuaTAxQ0MJd2RpZXJlc2lzBnJhY3V0ZQZuYWN1dGUGc2FjdXRlBndhY3V0ZQZ6YWN1dGUGeWdyYXZlBndncmF2ZQ11aHVuZ2FydW1sYXV0DW9odW5nYXJ1bWxhdXQLeWNpcmN1bWZsZXgLY2NpcmN1bWZsZXgLc2NpcmN1bWZsZXgLd2NpcmN1bWZsZXgGcmNhcm9uBmxjYXJvbgZuY2Fyb24GZWNhcm9uC2djaXJjdW1mbGV4C2hjaXJjdW1mbGV4CWNhcm9uLmFsdAphcG9zdHJvcGhlB3VuaTAxNUYHdW9nb25lawdvb2dvbmVrB2VvZ29uZWsHYW9nb25lawV1cmluZwxyY29tbWFhY2NlbnQMbGNvbW1hYWNjZW50DGtjb21tYWFjY2VudAxuY29tbWFhY2NlbnQHdW5pMDE2Mwd1bmkwMjE5B3VuaTAyMUIJdWRvdGJlbG93CWhkb3RiZWxvdwlvZG90YmVsb3cJcmRvdGJlbG93CXRkb3RiZWxvdwlkZG90YmVsb3cJZWRvdGJlbG93CXNkb3RiZWxvdwl6ZG90YmVsb3cDZl9mA2ZfaQZtYWNyb24HdW1hY3JvbgdvbWFjcm9uB2VtYWNyb24HYW1hY3JvbgdhZWFjdXRlCmFyaW5nYWN1dGUHaW1hY3JvbgZ1dGlsZGUGeXRpbGRlBmV0aWxkZQZpdGlsZGUDZl9sB3VuaTAxQzUHdW5pMDFDNgZ1YnJldmUGb2JyZXZlBmVicmV2ZQZhYnJldmUGaWJyZXZlB2lvZ29uZWsJaWRvdGJlbG93C2pjaXJjdW1mbGV4BGxkb3QLbmFwb3N0cm9waGUGZGNhcm9uBnRjYXJvbgR0YmFyBGhiYXIGZGNyb2F0DGdjb21tYWFjY2VudAxkaWVyZXNpcy5jYXAJYWN1dGUuY2FwCWdyYXZlLmNhcBBodW5nYXJ1bWxhdXQuY2FwCXRpbGRlLmNhcAlicmV2ZS5jYXAIcmluZy5jYXAKbWFjcm9uLmNhcA5jaXJjdW1mbGV4LmNhcAljYXJvbi5jYXAHQW9nb25lawdBbWFjcm9uBkFicmV2ZQpBcmluZ2FjdXRlCkNkb3RhY2NlbnQLQ2NpcmN1bWZsZXgJRGRvdGJlbG93BkRjYXJvbgZEY3JvYXQJRWRvdGJlbG93B0VvZ29uZWsKRWRvdGFjY2VudAZFdGlsZGUGRWJyZXZlB0VtYWNyb24GRWNhcm9uDEdjb21tYWFjY2VudApHZG90YWNjZW50C0djaXJjdW1mbGV4CUhkb3RiZWxvdwtIY2lyY3VtZmxleARIYmFyCUlkb3RiZWxvdwdJb2dvbmVrCklkb3RhY2NlbnQGSXRpbGRlBklicmV2ZQdJbWFjcm9uC0pjaXJjdW1mbGV4DEtjb21tYWFjY2VudAxMY29tbWFhY2NlbnQGTGFjdXRlBkxjYXJvbgRMZG90DE5jb21tYWFjY2VudAZOYWN1dGUGTmNhcm9uCk5kb3RhY2NlbnQJT2RvdGJlbG93B09vZ29uZWsNT2h1bmdhcnVtbGF1dAZPYnJldmUHT21hY3JvbglSZG90YmVsb3cMUmNvbW1hYWNjZW50BlJhY3V0ZQZSY2Fyb24JU2RvdGJlbG93BlNhY3V0ZQtTY2lyY3VtZmxleAd1bmkwMjE4B3VuaTAxNUUJVGRvdGJlbG93B3VuaTAxNjIHdW5pMDIxQQZUY2Fyb24EVGJhcglVZG90YmVsb3cHVW9nb25law1VaHVuZ2FydW1sYXV0BlV0aWxkZQZVYnJldmUFVXJpbmcHVW1hY3JvbglXZGllcmVzaXMGV2FjdXRlBldncmF2ZQtXY2lyY3VtZmxleAlaZG90YmVsb3cKWmRvdGFjY2VudAZaYWN1dGUFZl9mX2kDZl9iBWZfZl9iB3VuaTAxQzQFZl9mX2wERXVybw5wZXJpb2RjZW50ZXJlZAd1bmkyMjE5B0FFYWN1dGUMemVyb3N1cGVyaW9yDGZvdXJzdXBlcmlvcgxmaXZlc3VwZXJpb3ILc2l4c3VwZXJpb3INc2V2ZW5zdXBlcmlvcg1laWdodHN1cGVyaW9yDG5pbmVzdXBlcmlvcgx6ZXJvaW5mZXJpb3ILb25laW5mZXJpb3ILdHdvaW5mZXJpb3INdGhyZWVpbmZlcmlvcgxmb3VyaW5mZXJpb3IMZml2ZWluZmVyaW9yC3NpeGluZmVyaW9yDXNldmVuaW5mZXJpb3INZWlnaHRpbmZlcmlvcgxuaW5laW5mZXJpb3IIb25ldGhpcmQJb25lZWlnaHRoCXR3b3RoaXJkcwx0aHJlZWVpZ2h0aHMLZml2ZWVpZ2h0aHMMc2V2ZW5laWdodGhzC09zbGFzaGFjdXRlC29zbGFzaGFjdXRlBmxhY3V0ZQtzZXJ2aWNlbWFyawd1bmkyMjE1C1ljaXJjdW1mbGV4BllncmF2ZQZZdGlsZGUAAAAAAQAB//8ADwAAAAAAAAAAAAAAAAAAAKoAhQCqAIUCxgAAAuQCJgAA/z0C0P/2AuQCMP/2/z0AALAALLAgYGYtsAEsIGQgsMBQsAQmWrAERVtYISMhG4pYILBQUFghsEBZGyCwOFBYIbA4WVkgsApFYWSwKFBYIbAKRSCwMFBYIbAwWRsgsMBQWCBmIIqKYSCwClBYYBsgsCBQWCGwCmAbILA2UFghsDZgG2BZWVkbsAArWVkjsABQWGVZWS2wAiwgRSCwBCVhZCCwBUNQWLAFI0KwBiNCGyEhWbABYC2wAywjISMhIGSxBWJCILAGI0KyCgECKiEgsAZDIIogirAA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";

  // node_modules/cookies-ds/dist/fonts/index.js
  var __awaiter8 = function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function loadNotesSans() {
    return __awaiter8(this, void 0, void 0, function* () {
      const font = new FontFace("ds-notes-sans", `url('${notes_sans_default}')`);
      yield font.load();
      document.fonts.add(font);
    });
  }
  function loadPoetsenOne() {
    return __awaiter8(this, void 0, void 0, function* () {
      const font = new FontFace("ds-poetsen-one", `url('${poetsen_one_default}')`);
      yield font.load();
      document.fonts.add(font);
    });
  }
  var notesSansLoaded = loadNotesSans();
  var poetsenOneLoaded = loadPoetsenOne();

  // node_modules/cookies-ds/dist/components/p/index.js
  var __awaiter9 = function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var templateNode8 = document.createElement("template");
  templateNode8.innerHTML = template_default8;
  var P = class extends HTMLElement {
    connectedCallback() {
      return __awaiter9(this, void 0, void 0, function* () {
        yield notesSansLoaded;
        this.attachShadow({ mode: "open" });
        const shadowRoot = getShadowRoot(this);
        shadowRoot.appendChild(templateNode8.content.cloneNode(true));
      });
    }
  };

  // node_modules/cookies-ds/dist/components/h1/template.js
  var template_default9 = "<style>\n	:host {\n		display: block;\n	}\n\n	p {\n		font-family: ds-notes-sans;\n		font-size: 1.3rem;\n		font-weight: 900;\n		color: black;\n	}\n\n	@media screen and (min-width: 800px) {\n		p {\n			font-size: 2rem;\n		}\n	}\n</style>\n\n<p>\n	<slot></slot>\n</p>\n";

  // node_modules/cookies-ds/dist/components/h1/index.js
  var __awaiter10 = function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var templateNode9 = document.createElement("template");
  templateNode9.innerHTML = template_default9;
  var H1 = class extends HTMLElement {
    connectedCallback() {
      return __awaiter10(this, void 0, void 0, function* () {
        yield notesSansLoaded;
        this.attachShadow({ mode: "open" });
        const shadowRoot = getShadowRoot(this);
        shadowRoot.appendChild(templateNode9.content.cloneNode(true));
      });
    }
  };

  // node_modules/cookies-ds/dist/components/info/template.js
  var template_default10 = `<style>
	:host {
		display: block;
		width: 1.85rem;
		height: 1.85rem;
	}

	#info {
		width: 100%;
		height: 100%;
		user-select: none;
		cursor: pointer;
	}

	#info > svg {
		transition: opacity 0.3s cubic-bezier(.08,.82,.17,1);
	}
</style>

<div id="info">
	<svg
		width="100%"
		height="100%"
		viewBox="0 0 13.475812 13.361457"
	>
		<g
			transform="translate(-107.50063,-121.54137)"
			id="layer1">
			<g
				transform="translate(-0.20045214,-0.15033911)"
				id="g4559">
				<g
					aria-label="i"
					style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:10.58333302px;line-height:1.25;font-family:'Notes Sans';-inkscape-font-specification:'Notes Sans, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-feature-settings:normal;text-align:start;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;stroke-width:0.26458332"
					id="text16">
					<path
						d="m 114.69351,127.5986 c 0,-0.32809 -0.21167,-0.48684 -0.52917,-0.48684 -0.16933,0 -0.254,0.23284 -0.28575,0.59267 -0.0741,0.85725 -0.0741,1.28058 -0.0741,2.12725 0,1.25942 0.3175,2.4765 0.81492,2.4765 0.22225,0 0.41275,-0.13758 0.41275,-0.3175 0,-0.14817 -0.40217,-0.55033 -0.40217,-2.06375 0,-0.4445 0,-0.9525 0.0318,-1.4605 0.0212,-0.37042 0.0318,-0.6985 0.0318,-0.86783 z m -0.889,-2.0955 c 0,0.21166 0.16933,0.43391 0.46567,0.43391 0.381,0 0.60325,-0.23283 0.60325,-0.49741 0,-0.20109 -0.127,-0.45509 -0.41275,-0.45509 -0.33867,0 -0.65617,0.22225 -0.65617,0.51859 z"
						style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:10.58333302px;font-family:'Notes Sans';-inkscape-font-specification:'Notes Sans, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-feature-settings:normal;text-align:start;writing-mode:lr-tb;text-anchor:start;stroke-width:0.26458332"
						id="path4532">
					</path>
				</g>
				<path
					style="fill:none;stroke:#000000;stroke-width:0.90247035;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
					d="m 120.52521,128.38432 a 6.067265,6.067265 0 0 1 -6.06726,6.06727 6.067265,6.067265 0 0 1 -6.06727,-6.06727 6.067265,6.067265 0 0 1 6.06727,-6.06726 6.067265,6.067265 0 0 1 6.06726,6.06726 z"
					id="path18">
				</path>
			</g>
		</g>
	</svg>
</div>
`;

  // node_modules/cookies-ds/dist/utils/copy-attribute.js
  function copyAttribute(attrName, source2, target) {
    const value = source2.getAttribute(attrName);
    if (value === null) {
      if (target.hasAttribute(attrName)) {
        target.removeAttribute(attrName);
      }
    } else {
      target.setAttribute(attrName, value);
    }
  }

  // node_modules/cookies-ds/dist/components/info/index.js
  var __awaiter11 = function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var templateNode10 = document.createElement("template");
  templateNode10.innerHTML = template_default10;
  var Info = class extends HTMLElement {
    static get observedAttributes() {
      return ["visited"];
    }
    connectedCallback() {
      return __awaiter11(this, void 0, void 0, function* () {
        this.attachShadow({ mode: "open" });
        const shadowRoot = getShadowRoot(this);
        shadowRoot.appendChild(templateNode10.content.cloneNode(true));
        const svg = getElement(shadowRoot, "svg");
        copyAttribute("title", this, svg);
        this.render();
      });
    }
    render() {
      const shadowRoot = getShadowRoot(this);
      const svg = getElement(shadowRoot, "svg");
      const visited = this.getAttribute("visited");
      svg.style.opacity = visited === null ? "initial" : "0.25";
    }
    attributeChangedCallback() {
      if (this.shadowRoot) {
        this.render();
      }
    }
  };

  // node_modules/cookies-ds/dist/components/datetime-picker/template.js
  var template_default11 = '<style>\n	:host {\n		display: block;\n	}\n\n	input {\n		font-family: ds-notes-sans;\n		font-size: 1rem;\n		background-color: transparent;\n		padding: 0.4rem;\n\n	    border-radius: 10px;\n	    border-color: transparent;\n\n		padding: 10px 25px;\n		box-shadow: inset 2px 2px 6px 0px rgba(0, 0, 0, 0.29), inset -2px -2px 3px #ffffffa8, 2px 2px 1px 0px #ffffff1c, -2px -2px 1px rgba(0, 0, 0, 0.02);\n  		border-width: 0;\n  		margin: 0.1rem;\n	}\n\n	@media screen and (min-width: 800px) {\n		input {\n			font-size: 1.4rem;\n		}\n	}\n\n	input:focus, input:focus-visible {\n		outline: none;\n	}\n</style>\n\n<input type="datetime-local">\n';

  // node_modules/cookies-ds/dist/components/datetime-picker/index.js
  var __awaiter12 = function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var templateNode11 = document.createElement("template");
  templateNode11.innerHTML = template_default11;
  var DatetimePicker = class extends HTMLElement {
    constructor() {
      super(...arguments);
      this.inputChangeSubscription = null;
    }
    connectedCallback() {
      return __awaiter12(this, void 0, void 0, function* () {
        yield notesSansLoaded;
        this.attachShadow({ mode: "open" });
        const shadowRoot = getShadowRoot(this);
        shadowRoot.appendChild(templateNode11.content.cloneNode(true));
        const datetimePicker = getElement(shadowRoot, "input");
        this.inputChangeSubscription = fromEvent(datetimePicker, "change").subscribe((event) => {
          const target = getEventTarget(event);
          const detail = target.valueAsNumber;
          const dispatched = new CustomEvent("change", { detail });
          this.dispatchEvent(dispatched);
        });
      });
    }
    disconnectedCallback() {
      var _a;
      (_a = this.inputChangeSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
    }
  };
  function getEventTarget(event) {
    var _a;
    if (((_a = event === null || event === void 0 ? void 0 : event.target) === null || _a === void 0 ? void 0 : _a.tagName) !== "INPUT") {
      throw new Error("Event target is not an input !");
    }
    return event.target;
  }

  // node_modules/cookies-ds/dist/components/breadcrumbs/template.js
  var template_default12 = `<style>
	:host {
		display: block;
	}

	#breadcrumbs {
		font-family: ds-notes-sans;
		font-size: 1rem;
		display: flex;
		color: black;
	}

	@media screen and (min-width: 800px) {
		#breadcrumbs {
			font-size: 1.4rem;
		}
	}

	::slotted(*)::before {
	    content: '\u203A';
		margin-right: 0.9rem;
		margin-left: 0.9rem;
		font-weight: 900;
		display:inline-block;
		text-decoration: none;
		cursor: initial;
	}

	::slotted(*:first-child)::before {
	    content: none;
	}

	::slotted(*) {
	    opacity: 0.5;
	}

	::slotted(*:hover) {
	    text-decoration: underline;
	    cursor: pointer;
	}

	::slotted(*:last-child) {
		opacity: 1;
	    font-weight: 900;
	}

	::slotted(*:hover:last-child) {
	    text-decoration: none;
	   	cursor: initial;
	}
</style>

<div id="breadcrumbs">
	<slot></slot>
</div>
`;

  // node_modules/cookies-ds/dist/components/breadcrumbs/index.js
  var __awaiter13 = function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var templateNode12 = document.createElement("template");
  templateNode12.innerHTML = template_default12;
  var Breadcrumbs = class extends HTMLElement {
    connectedCallback() {
      return __awaiter13(this, void 0, void 0, function* () {
        yield notesSansLoaded;
        this.attachShadow({ mode: "open" });
        const shadowRoot = getShadowRoot(this);
        shadowRoot.appendChild(templateNode12.content.cloneNode(true));
      });
    }
  };

  // node_modules/cookies-ds/dist/components/snackbar-dock/template.js
  var template_default13 = '<style>\n	:host {\n		display: block;\n	}\n\n	p {\n		font-family: ds-poetsen-one;\n		text-transform: uppercase;\n		font-size: 1.6rem;\n		color: black;\n		user-select: none;\n	}\n\n	#snackbar-container {\n		position: absolute;\n		left: 0;\n		top: -8rem;\n		transition: .15s top cubic-bezier(.22,.61,.36,1);\n		cursor: pointer;\n	}\n\n	#snackbar-container.down {\n		top: 0;\n	}\n\n	#snackbar-container.down:hover {\n		top: -0.3rem;\n	}\n\n	#snackbar-content {\n		display: grid;\n		grid-template-columns: 1fr;\n		grid-template-rows: 1fr;\n		grid-column-gap: 0px;\n		grid-row-gap: 0px;\n		height: 7.5rem;\n		width: 100vw;\n	}\n\n	#snackbar-content > div {\n		grid-area: 1 / 1 / 2 / 2;\n		background-color: transparent;\n	}\n</style>\n\n<div id="snackbar-container">\n	<div id="snackbar-content">\n		<div>\n			<svg width="100vw" height="7.5rem" viewBox="50 40 50 30" preserveAspectRatio="none">\n				<path d="m 50,40 h 50 V 70 C 90,60 60,60 50,70 Z" style="fill:#ffd920;"></path>\n			</svg>\n		</div>\n		<div style="padding: 0.1rem; text-align: center;">\n			<p id="snackbar-text"> </p>\n		</div>\n	</div>	\n</div>\n';

  // node_modules/cookies-ds/dist/components/snackbar-dock/index.js
  var __awaiter14 = function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var closeCurrentSnackbar$ = new Subject2();
  var enqueueSnackbar$ = new Subject2();
  var currentSnackbar$ = new Observable5(function(subscriber) {
    const snackbarStore = [];
    let currentSnackbar = null;
    const enqueueSnackbarSubscription = enqueueSnackbar$.subscribe({
      next(snackbar) {
        if (currentSnackbar === null) {
          currentSnackbar = snackbar;
          subscriber.next(currentSnackbar);
        } else {
          snackbarStore.push(snackbar);
        }
      },
      complete() {
        enqueueSnackbarSubscription.unsubscribe();
      }
    });
    const closeCurrentSnackbarSubscription = closeCurrentSnackbar$.subscribe({
      next() {
        currentSnackbar = snackbarStore.shift() || null;
        subscriber.next(currentSnackbar);
      },
      complete() {
        closeCurrentSnackbarSubscription.unsubscribe();
      }
    });
  });
  var templateNode13 = document.createElement("template");
  templateNode13.innerHTML = template_default13;
  var SnackbarDock = class extends HTMLElement {
    constructor() {
      super(...arguments);
      this.currentSnackbar = null;
      this.currentSnackbarSubscription = null;
      this.clickSubscription = null;
    }
    connectedCallback() {
      return __awaiter14(this, void 0, void 0, function* () {
        yield poetsenOneLoaded;
        this.attachShadow({ mode: "open" });
        const shadowRoot = getShadowRoot(this);
        shadowRoot.appendChild(templateNode13.content.cloneNode(true));
        const snackbarContainer = getElement(shadowRoot, "#snackbar-container");
        this.clickSubscription = fromEvent(snackbarContainer, "click").subscribe(() => {
          closeCurrentSnackbar$.next(null);
        });
        this.currentSnackbarSubscription = currentSnackbar$.subscribe((snackbar) => {
          this.currentSnackbar = snackbar;
          this.render();
        });
        this.render();
      });
    }
    render() {
      var _a;
      const shadowRoot = getShadowRoot(this);
      const p2 = getElement(shadowRoot, "p");
      const snackbarContainer = getElement(shadowRoot, "#snackbar-container");
      p2.innerHTML = ((_a = this.currentSnackbar) === null || _a === void 0 ? void 0 : _a.message) || "";
      setTimeout(() => {
        if (this.currentSnackbar) {
          snackbarContainer.classList.add("down");
        } else {
          snackbarContainer.classList.remove("down");
        }
      }, 10);
    }
    disconnectedCallback() {
      var _a, _b;
      return __awaiter14(this, void 0, void 0, function* () {
        (_a = this.currentSnackbarSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
        (_b = this.clickSubscription) === null || _b === void 0 ? void 0 : _b.unsubscribe();
      });
    }
  };

  // node_modules/cookies-ds/dist/components/a/template.js
  var template_default14 = "<style>\n	:host {\n		display: inline;\n	}\n\n	a {\n		font-family: ds-notes-sans;\n		font-size: 1rem;\n		color: black;\n	}\n\n	@media screen and (min-width: 800px) {\n		a {\n			font-size: 1.4rem;\n		}\n	}\n</style>\n\n<a>\n	<slot></slot>\n</a>\n";

  // node_modules/cookies-ds/dist/components/a/index.js
  var __awaiter15 = function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var templateNode14 = document.createElement("template");
  templateNode14.innerHTML = template_default14;
  function addCssRuleToShadowRoot(shadowRoot, cssRule) {
    const styleElement = document.createElement("style");
    styleElement.textContent = cssRule;
    shadowRoot.appendChild(styleElement);
  }
  var A = class extends HTMLElement {
    connectedCallback() {
      return __awaiter15(this, void 0, void 0, function* () {
        yield notesSansLoaded;
        this.attachShadow({ mode: "open" });
        const shadowRoot = getShadowRoot(this);
        shadowRoot.appendChild(templateNode14.content.cloneNode(true));
        const a2 = getElement(shadowRoot, "a");
        copyAttribute("href", this, a2);
        addCssRuleToShadowRoot(shadowRoot, `a { color: ${linkColor}; }`);
        addCssRuleToShadowRoot(shadowRoot, `a:visited { color: ${linkVisitedColor}; }`);
      });
    }
  };

  // node_modules/cookies-ds/dist/components/button/template.js
  var template_default15 = '<style>\n	:host {\n		display: inline-block;\n	}\n\n	@media screen and (min-width: 800px) {\n		.custom-btn {\n			font-size: 1.4rem;\n		}\n	}\n\n	/* \u2764\uFE0F https://codepen.io/yuhomyan/pen/OJMejWJ */\n\n	.custom-btn {\n	  font-family: ds-notes-sans;\n	  font-size: 1rem;\n	  display: grid;\n	  place-content: center;\n	  border-radius: 5px;\n	  padding: 10px 25px;\n	  font-weight: 500;\n	  background: transparent;\n	  cursor: pointer;\n	  transition: all 0.3s ease;\n	  position: relative;\n	   box-shadow:inset 2px 2px 2px 0px rgba(255,255,255,.5),\n	   7px 7px 20px 0px rgba(0,0,0,.1),\n	   4px 4px 5px 0px rgba(0,0,0,.1);\n	  outline: none;\n	  grid-area: 2 / 2 / 3 / 3;\n	}\n\n	.btn-16 {\n	  border: none;\n	  color: #000;\n	}\n	.btn-16:after {\n	  position: absolute;\n	  content: "";\n	  width: 0;\n	  height: 100%;\n	  top: 0;\n	  left: 0;\n	  direction: rtl;\n	  z-index: -1;\n	  box-shadow: -1px -1px 5px 0px #fff0, -1px -1px 5px 0px #fff, 7px 7px 10px 0px #0002, 4px 4px 5px 0px #0001;\n	  transition: all 0.3s ease;\n	  border-radius: 5px;\n	  background-color: #fff3;\n	}\n	.btn-16:hover {\n	  color: #000;\n	}\n	.btn-16:hover:after {\n	  left: auto;\n	  right: 0;\n	  width: 100%;\n	}\n	.btn-16:active {\n	  top: 2px;\n	}\n\n	.button-container {\n		/*padding: 0.4rem;*/\n		display: grid;\n		grid-template-columns: 0.4rem 1fr 0.4rem;\n		grid-template-rows: 0.4rem 1fr 0.4rem; \n	}\n\n\n.progress-container {\n	grid-area: 2 / 2 / 3 / 3;\n}\n\n#progress {\n	background-color: #fff3;\n	height: 100%;\n	width: 0%;\n    border-radius: 5px;\n    transition: width 0.3s ease-in-out;\n}\n\n</style>\n\n\n<div class="button-container">\n	<div class="custom-btn btn-16">\n		<slot></slot>\n	</div>\n	<div class="progress-container">\n		<div id="progress"></div>\n	</div>\n</div>\n';

  // node_modules/cookies-ds/dist/components/button/index.js
  var __awaiter16 = function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var templateNode15 = document.createElement("template");
  templateNode15.innerHTML = template_default15;
  var Button = class extends HTMLElement {
    constructor() {
      super(...arguments);
      this.clickSubscription = null;
      this.progress = "0";
    }
    static get observedAttributes() {
      return ["progress"];
    }
    connectedCallback() {
      return __awaiter16(this, void 0, void 0, function* () {
        yield notesSansLoaded;
        this.attachShadow({ mode: "open" });
        const shadowRoot = getShadowRoot(this);
        shadowRoot.appendChild(templateNode15.content.cloneNode(true));
        this.render();
      });
    }
    attributeChangedCallback() {
      if (this.shadowRoot) {
        const progress = this.getAttribute("progress");
        if (isProgressValid(progress)) {
          this.progress = progress === null ? "0" : progress;
        }
        this.render();
      }
    }
    render() {
      const shadowRoot = getShadowRoot(this);
      const progress = getElement(shadowRoot, "#progress");
      progress.style.width = `${this.progress}%`;
    }
    disconnectedCallback() {
      var _a;
      (_a = this.clickSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
    }
  };
  function isProgressValid(progress) {
    if (progress === null) {
      return true;
    }
    const progressAsNumber = Number(progress);
    const rounded = Math.floor(progressAsNumber);
    return rounded == progressAsNumber && Number.isInteger(rounded) && Number.isFinite(rounded) && rounded <= 100 && rounded >= 0;
  }

  // node_modules/cookies-ds/dist/main.js
  var componentDefinitions = (/* @__PURE__ */ new Map()).set("cookies-smart-padlock", SmartPadlock).set("cookies-padlock", Padlock).set("cookies-wheel", Wheel).set("cookies-lcd-screen", LcdScreen).set("cookies-padlock-screen", PadlockScreen).set("cookies-background", Background).set("cookies-panel", Panel).set("cookies-p", P).set("cookies-h1", H1).set("cookies-info", Info).set("cookies-datetime-picker", DatetimePicker).set("cookies-breadcrumbs", Breadcrumbs).set("cookies-snackbar-dock", SnackbarDock).set("cookies-a", A).set("cookies-button", Button);
  for (const [name, element2] of componentDefinitions) {
    customElements.define(name, element2);
  }

  // src/index.ts
  new playground_svelte_default({ target: document.body });
})();
